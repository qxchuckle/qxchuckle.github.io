[{"title":"Banner随机文章展示","url":"/article/a1bf85bf.html","content":"\n# 前言\nBanner 处的文章推荐总是挂着那几个文章，静态博客要去经常换也麻烦，嗯，就是懒了\n\n改为随机展示文章就解放双手啦\n\n# 实现\n>首先当然得实现一个类似于我首页那样的Banner\n\n**1、**在`themes\\butterfly\\scripts\\helpers\\` 新建一个生成器 `home_random_post.js`\n\n该生成器会将 matter 中 **random** 配置不为 false 的文章的基本信息输出到 **random.json**\n\n```js home_random_post.js\nhexo.extend.generator.register('thePosts', function (locals) {\n  const jsonData = locals.posts\n    .filter(post => post.random !== false)\n    .map(post => {\n      return {\n        title: post.title || \"暂无标题\",\n        abbrlink: post.abbrlink,\n        cover: post.cover,\n        description: post.description || \"暂无简介\"\n      };\n    });\n\n  return {\n    path: 'random.json',\n    data: JSON.stringify(jsonData)\n  };\n});\n\n```\n\n**2、**js 请求该 json ，随机选取若干文章渲染展示到页面上\n\n```js\nfunction getRandomElementsFromArray(arr, num) {\n  const totalElements = arr.length;\n  const selectedElements = new Set();\n  while (selectedElements.size < num) {\n    const randomIndex = Math.floor(Math.random() * totalElements);\n    selectedElements.add(arr[randomIndex]);\n  }\n  return Array.from(selectedElements);\n}\nfunction renderingPosts(data){\n  const randomElements = getRandomElementsFromArray(data, 6);\n  const postsHtml = randomElements.map((i) => `\n    <div class=\"top_post_item\">\n      <div class=\"post_cover\">\n        <a href=\"/article/${i.abbrlink}.html\" title=\"${i.title}\">\n          <img class=\"post_bg entered loaded\" src=\"${i.cover}\" alt=\"${i.title}\" data-no-lazy>\n          <div class=\"post_cover_info\">\n            <p class=\"post_cover_text\">${i.description}</p>\n          </div>\n        </a>\n      </div>\n      <div class=\"post_info\" onclick=\"window.open('/article/${i.abbrlink}.html', '_self')\">\n        <a class=\"article-title\" href=\"/article/${i.abbrlink}.html\" title=\"${i.title}\">${i.title}</a>\n      </div>\n    </div>`).join('');\n  document.querySelector(\"#homeTopGroup>.top_post_group\").innerHTML = postsHtml\n}\nif(!sessionStorage.getItem(\"postsInfo\")){\n  fetch(\"/random.json\")\n  .then(res=>res.json())\n  .then(data=>{\n    console.log(1);\n    sessionStorage.setItem(\"postsInfo\", JSON.stringify(data));\n    renderingPosts(data);\n  })\n}else{\n  renderingPosts(JSON.parse(sessionStorage.getItem(\"postsInfo\")));\n}\n\n```\n\nBanner 的实现各不相同，但适配自己的并不难，postsHtml 内的 hmtl 模板需要修改一下\n\n这里放一下我的 pug 和 css\n\n```pug\n#home_top\n  .home_top_group\n    #homeTopGroup.homeTopGroup\n      .category_group\n          .category_item\n            a.category_button(href=\"/archives/\",style=\"background:linear-gradient(to right,#00868Bdb,#3fc1c9db)\")\n              span.category_button_text 归档\n              i.fas.fa-laptop-code\n          .category_item\n            a.category_button(href=\"/archives/2022/\",style=\"background:linear-gradient(to right, #0A5ABEdb, #2fcbffdb)\")\n              span.category_button_text 2022\n              i.fas.fa-lightbulb\n      .top_post_group\n        //- 这下面是原来固定的写法\n        //- if site.data.slider\n        //-   each i in site.data.slider\n        //-     .top_post_item\n        //-       .post_cover\n        //-         a(href=url_for(i.link) title=i.title)\n        //-           img.post_bg.entered.loaded(src=url_for(i.cover))\n        //-           .post_cover_info\n        //-             p.post_cover_text= i.description\n        //-       .post_info(onclick=`\"window.open(`+url_for(i.link)+`,\"_self\")\"`)\n        //-         a.article-title(href=url_for(i.link) title=i.title)= i.title\n\n```\n\n```css\n:root{\n    --mj-white: #fff;\n    --mj-card-bg: rgba(255,255,255,0.67);\n    --mj-theme: #128adadb;\n    --mj-secondbg: #ededed;\n    --mj-card-border: #e3e8f7;\n    --style-border: 2px solid rgba(0, 255, 255, 0.6);\n    --anchor-border: 1px solid rgba(21, 158, 208, 0.8);\n    --style-hover-border: 2px solid var(--mj-theme);\n}\n[data-theme=dark] {\n    --mj-card-bg: rgba(0,0,0,0.6);\n    --style-border: 2px solid rgba(56,211,203,0.8);\n}\n/* home top */\n#home_top {\n    width: 100%;\n}\n.home_top_group {\n    border-radius: 11px;\n    overflow: auto;\n    width: 100%;\n    margin-bottom: 0;\n}\n.homeTopGroup {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    width: 100%;\n    overflow: auto;\n    overflow-x: score;\n    border-radius: 11px;\n}\n.homeTopGroup::-webkit-scrollbar {\n    display: none;\n}\n\n.homeTopGroup .category_group{\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    min-width: 200px;\n    min-height: 166px;\n}\n.top_post_item>.post_cover>a{\n    display: block;\n}\n.homeTopGroup .category_item {\n    overflow: hidden;\n    transform: scale(1);\n    transition: .3s;\n    height: 48%;\n    border-radius: 12px;\n}\n.homeTopGroup .category_item a.category_button {\n    height: 100%;\n    width: 100%;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    display: inline-block;\n    text-align: left;\n    line-height: 4em;\n    font-weight: 800;\n    font-size: 16px;\n    color: var(--mj-white);\n    transition: all .4s cubic-bezier(.39,.575,.565,1);\n    transform: scale(1);\n    overflow: hidden;\n}\n.category_button_text {\n    padding-left: 25px;\n}\na.category_button i {\n    font-size: 3rem;\n    opacity: .3;\n    position: absolute;\n    right: 15px;\n    top: 10%;\n    transition: .3s;\n    transform: rotate(-10deg);\n    /*width: 100px;\n    text-align: center;*/\n}\na.category_button:hover i {\n    opacity: .8;\n    transition: .8s;\n    transition-delay: .15s;\n    transform: scale(1.1)\n}\na.category_button:hover:after{\n    width: 3rem;\n    transition: .8s;\n}\na.category_button:after {\n    top: 45px;\n    width: 1rem;\n    left: 25px;\n    height: 2.5px;\n    background: var(--mj-white);\n    content: \"\";\n    border-radius: 1px;\n    position: absolute;\n    transition: .8s;\n}\n@media screen and (max-width: 1245px){\n  .homeTopGroup,.home_top_group {\n      border-radius: 0px;\n  }\n}\n@media screen and (max-width: 768px){\n  .homeTopGroup .category_group {\n    min-width: 130px!important;\n  }\n  #home_top {\n    width: calc(100% + 17px);\n  }\n  .home_top_group {\n      overflow: visible;\n  }\n  .homeTopGroup {\n      width: calc(100% + 17px);\n      margin-left: -17px;\n  }\n  .homeTopGroup .category_group{\n      margin-left: 17px;\n  }\n}\n.top_post_group{\n    display: flex;\n    position: relative;\n}\n.top_post_group .top_post_item {\n    display: flex;\n    width: 200px;\n    height: 166px;\n    flex-direction: column;\n    align-items: flex-start;\n    margin-left: 8px;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    overflow: hidden;\n    border: var(--style-border);\n    color: var(--text-highlight-color);\n    transition: 0.3s;\n}\n/* .top_post_group .top_post_item:first-child{\n    right: 0px;\n} */\n.top_post_group .top_post_item:hover {\n    border: var(--style-hover-border);\n    background: #128adadb;\n}\n.top_post_group .top_post_item .post_cover {\n    width: 100%;\n    height: 110px;\n    position: relative;\n}\n.top_post_group .top_post_item .post_cover img {\n    object-fit: cover;\n    width: 100%;\n    height: 110px;\n    background: var(--mj-secondbg);\n}\n.top_post_group .top_post_item .post_cover .post_cover_info {\n    position: absolute;\n    top: 0;\n    width: 101%;\n    height: 100%;\n    opacity: 0;\n    background-color: rgba(0,0,0,0.7) !important;\n    transition: all 0.3s ease;\n    display: flex;\n} \n.top_post_group .top_post_item:hover .post_cover .post_cover_info{\n    opacity: 1;\n}\n.top_post_group .top_post_item .post_cover .post_cover_info .post_cover_text{\n    color: #fff;\n    padding: 13px 14px;\n    font-size: 15px;\n    font-weight: 400;\n    margin: 0;\n    -webkit-line-clamp: 3;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n}\n.top_post_group .top_post_item .post_info a{\n    color: var(--mj-fontcolor) !important;\n    transition: 0;\n}\n.top_post_group .top_post_item:hover .post_info a{\n    color: var(--mj-white) !important;\n}\n.top_post_group .top_post_item .post_info {\n    padding: 6px 9px!important;\n    transition: .3s;\n    width: 100%;\n    height: 100%;\n}\n.top_post_group .top_post_item .post_info .article-title {\n    -webkit-line-clamp: 2;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    line-height: 1.4;\n    justify-content: center;\n    align-items: flex-end;\n    align-content: center;\n    font-weight: 800;\n    font-size: 14px!important;\n    padding: 0!important;\n}\n\n```\n\n# 懒加载的修改\nbtf主题若开启了懒加载，可能会有些bug，文章图片不能正常被懒加载所加载，那干脆就不让懒加载去接管这些图片\n\n修改 `themes\\butterfly\\scripts\\filters\\post_lazyload.js`\n\n```js 对返回值进行了修改\nfunction lazyload (htmlContent) {\n  const bg = hexo.theme.config.lazyload.placeholder ? urlFor(hexo.theme.config.lazyload.placeholder) : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\n  // 修改下面的返回值\n  return htmlContent.replace(/(<img(?![^>]*\\bdata-no-lazy\\b)[^>]*? src=)/ig, `$1 \"${bg}\" data-lazy-src=`);\n}\n```\n\n现在，只要加上了 **data-no-lazy** 属性的 img 标签，都不会被懒加载所接管\n\n# 后记\n期待 [@Heo](https://blog.zhheo.com/) 对他 Banner 的大改\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"ES6查缺补漏","url":"/article/383b041f.html","content":"\n# 前言\n一直没有把ES6标准系统地进行学习，虽然很多新特性已经用上了，但也该系统地学习一下\n\n还是阮一峰讲得全面些：[ECMAScript 6 入门 | 阮一峰](https://es6.ruanyifeng.com/) 很多新特性，多用就记住了\n\n# ES6简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言\n\nES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准\n\n# let和const\nlet 声明变量，const声明常量（内存地址所保存的数据不得改动）\n\n**1、块级作用域**\n\n```js\nvar a = 2;\n{\n  let a = 1;\n  console.log(a); // 1\n}\nconsole.log(a); // 2\n```\n\n**2、同一个块内不允许覆盖、重复声明**\n\n```js\nvar a = 1;\nvar a = 2;\nconsole.log(a); // 2\nlet b = 1;\nlet b = 2; // 'b' has already been declared\n{\n  let b = 2;\n  console.log(b); // 2\n}\n```\n\n**3、没有变量提升**\n\n```js\nconsole.log(a); // undefined\nvar a = 1;\nconsole.log(b); // Cannot access 'b' before initialization\nlet b = 2;\n```\n\n**4、暂时性死区**\n只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部的影响\n\n只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n```js 变量一定要在声明之后使用\nconsole.log(typeof a); // undefined\nconsole.log(typeof b); // undefined\nvar b = 1;\nconsole.log(typeof x); // ReferenceError\nlet x = 2;\n```\n\n**Tip：**\n**1、**循环中的 var 与 let:\n\nvar 会提升进行声明，数组中所有函数访问的都是同一个 i\n\n```js\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n```\n\n变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 都是一个新的变量，但在循环中，JavaScript 引擎会记住每一次 let 的值，下一次创建的时候，直接在这个值上递进\n\n```js\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n\n**2、**const 声明的对象仍然是可写的，可以使用 `Object.freeze()` 冻结对象\n\n当对象嵌套时，需要递归冻结\n\n```js\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, i) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n```\n\n# 解构赋值\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值\n\n## 数组解构\n\n**1、**只要等号两边的模式相同，左边的变量就会被赋予对应的值\n\n```js\nlet [a, b, c, ...d] = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a); // 1\nconsole.log(d); // [ 4, 5, 6, 7, 8 ]\n```\n\n**2、**如果解构不成功，变量的值就等于undefined\n\n```js\nlet [a] = [];\nconsole.log(a); // undefined\nlet [b, c] = [1];\nconsole.log(c); // undefined\n```\n\n**3、**解构赋值允许指定默认值，只有当一个数组成员严格等于undefined，默认值才会生效\n\n```js\nlet [b, c = 2] = [1];\nconsole.log(c); // 2\n```\n\n如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined\n\n```js\nlet [x = 1] = [undefined];\nx // 1\nlet [x = 1] = [null];\nx // null\n```\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值\n\n```js\nfunction f() {\n  console.log('123'); \n}\nlet [a = f()] = [1]; // 不执行f()\nlet [b = f()] = []; // 123\n```\n\n## 对象解构\n**1、**解构提取对象中的属性\n\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n}\nlet { a, b } = obj // 变量名与属性名需相同\nconsole.log(a) // 1\n```\n\n变量名与属性名不一致，需写成下面这样\n\n```js\nconst obj = {\n  a: 1\n}\nlet { a : x } = obj\nconsole.log(x) // 1\n```\n\n**2、**嵌套结构的对象\n\n```js\nconst obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\nlet { p, p: [x, { y }] } = obj;\nconsole.log(x); // Hello\nconsole.log(y); // World\n```\n\n**3、**剩余运算符，将其它属性展开到一个对象中存储\n\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n}\nconst a = {\n  ...obj,\n  b: 3, // 可以覆盖\n  c: 4, // 默认值\n}\nconsole.log(a.a, a.b, a.c); // 1 3 4\n```\n\n**4、**可以取到继承的属性\n\n```js\nconst obj1 = {};\nconst obj2 = { a: 1 };\nObject.setPrototypeOf(obj1, obj2);\nconst { a } = obj1;\nconsole.log(a); // 1\n```\n\n## 函数参数解构\n函数的参数也可以使用解构赋值\n\n```js\nfunction add([x, y]){\n  return x + y;\n}\nadd([1, 2]); // 3\n[[1, 2], [3, 4]].map(([a, b]) => a + b); // [ 3, 7 ]\n```\n\n## 技巧\n**1、**交换变量的值\n\n```js\nlet x = 1;\nlet y = 2;\nlet [x,y] = [y,x];\n```\n\n**2、**函数返回多个值\n\n```js\n// 返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n\n// 返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n```\n\n# 函数的扩展\n**1、带参数默认值的函数**\n\n```js\nfunction f(a, b = 1) { }\nfunction f(a, b = fun()) { }\n```\n\n**2、rest 参数**\n获取函数的多余参数，不需要使用 arguments 对象，rest 参数之后不能再有其他参数\n\n```js\nfunction f(a, ...b) {\n  console.log(a, b); // 1 [2, 3]\n}\nf(1, 2, 3);\n```\n\n**3、name 属性**\n返回函数名\n\n```js\nfunction foo() {}\nfoo.name // \"foo\"\n```\n\n\n\n## 箭头函数\n使用“箭头”（=>）定义函数\n\n```js\nvar f = v => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n多种写法\n\n```js\nvar f = v => v;\nvar f = v => { return v };\nvar f = (a, b) => a + b;\n```\n\n简化回调函数\n\n```js\n[1,2,3].map(function (x) {\n  return x * x;\n});\n[1,2,3].map(x => x * x);\n```\n\n箭头函数的特性：\n1、没有自己的 this\n2、不可以当作构造函数\n3、不可以使用 arguments 对象\n4、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数\n\n# 对象的扩展\n**1、属性简洁表示**\n\n```js\nlet [a, b] = [1, 2];\nconst obj = {\n  a,\n  b,\n  fun(){ } // 简写对象方法\n}\n```\n\n**2、属性名表达式**\n属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串\n属性名表达式与简洁表示法，不能同时使用\n\n```js\nobj['a' + 'bc'] = 123; // obj.abc = 123\nlet propKey = 'foo';\nlet obj = {\n  [propKey]: true,\n  ['a' + 'bc']: 123\n};\n```\n\n## Object方法\n**1、**`is()`\n判断两个值是否相同，解决了 NaN 问题\n\n```js\nObject.is(null,undefined); // false\nObject.is(NaN,NaN); // true\nNaN === NaN // false\n```\n\n**2、**`assign()`\n合并多个对象，并返回第一个参数的引用，冲突属性后面覆盖前面\n\n```js\nlet obj1 = { a: 1 }\nlet obj2 = { a: 2, b: 3 }\nlet obj3 = Object.assign(obj1, obj2); // {a: 2, b: 3}\nconsole.log(obj3 === obj1); // true\n```\n\n**3、**`keys()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键名**\n\n**4、**`values()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键值**\n\n**5、**`entries()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键值对数组**\n\n**6、**`fromEntries()` entries() 的逆操作，用于将一个键值对数组转为对象\n\n**7、**`hasOwn()` 判断某个属性是否为自身的属性\n\n# 数组的扩展\n**1、扩展运算符** `...`\n扩展运算符将一个数组转为用逗号分隔的参数序列\n\n```js\nconsole.log(...[1, 2, 3]) // 1 2 3\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\nfunction add(x, y) { return x + y }\nadd(...[4, 38]) // 42\n```\n\n替代用到 apply() 和 push() 的某些操作\n\n```js\nMath.max.apply(null, [11, 33, 22]) // 33\nMath.max(...[11, 33, 22]) // 33\nlet arr1 = [0, 1, 2]\nlet arr2 = [3, 4, 5]\narr1.push.apply(arr1, arr2)\narr1.push(...arr2)\n```\n\n## Array方法\n**1、**`Array.from()` 将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的 Set 和 Map）\n\n```js\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\nconsole.log([].slice.call(arrayLike)) // [ 'a', 'b', 'c' ]\nconsole.log(Array.from(arrayLike)) // [ 'a', 'b', 'c' ]\n```\n\n接收第二个参数，回调函数，对每个元素进行处理\n\n```js\nlet arrayLike = {\n  '0': 1,\n  '1': 2,\n  length: 2\n};\nconsole.log(Array.from(arrayLike, item => item * 2)) // [ 2, 4 ]\n```\n\n**2、**`Array.of()` 将一组任意类型的值，转换为数组\n\n```js 弥补Array的不足\nArray.of(1, 2) // [1, 2]\nArray(3) // [, , ,]\nArray.of(3) // [3]\n```\n\n## 实例方法\n**1、**`copyWithin(target, start = 0, end = this.length)` 将指定位置的成员**复制**到其他位置（会覆盖），然后返回当前数组\ntarget（必需）：从该位置开始替换数据。如果为负值，表示倒数。\nstart（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\nend（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n```js\n[1,2,3,4,5].copyWithin(0,3) // [4, 5, 3, 4, 5]\n```\n\n**2、**`find()` 找出第一个符合条件的数组成员。传入一个回调函数，没有符合条件的则返回 undefined\n\n```js\n[1, -2, -5, 10].find(n => n < 0) // -2\n[1, -2, -5, 10].find(function(value, index, arr) {\n  return value < 0;\n})\n```\n\n`findIndex()` 返回第一个符合条件的数组成员的位置，没有符合条件的则返回 -1\n`findLast() findLastIndex()` 从数组的最后一个成员开始，依次向前检查\n\n可以接受第二个参数，用来绑定回调函数的this对象\n\n**3、**`fill()` 使用给定值，覆盖填充一个数组\n可以接受第二、三个参数，用于指定填充的起始位置和结束位置\n\n```js\n['a', 'b', 'c'].fill(7) // [7, 7, 7]\nnew Array(3).fill(7) // [7, 7, 7]\n```\n\n若填充对象，数组中填充的是该对象的引用\n\n**4、**`entries() keys() values()` 用于遍历数组，都返回一个**遍历器**对象\nkeys() 是键名的遍历，values() 是键值的遍历，entries() 是键值对的遍历\n\n```js\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index); // 0 // 1\n}\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem); // 'a' // 'b'\n}\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem); // 0 \"a\" // 1 \"b\"\n}\n```\n\n**5、**`includes()` 判断数组中是否包含某个值，可选第二个参数表示搜索的起始位置，默认为0\n\n```js\n[1, 2, 3].includes(2) // true\n[1, 2, NaN].includes(NaN) // true\n```\n\n**6、**`flat()` 将多维数组解构为一维，传入参数表示总共解构多少层，默认 1\n该方法返回一个新数组，对原数据没有影响\n\n如果不管有多少维，都要转成一维数组，可以用 Infinity 作为参数。\n如果原数组有空位，flat()方法会跳过空位\n\n```js\n[1, 2, [3, 4]].flat() // [1, 2, 3, 4]\n[1, 2, [3, 4, [5, 6]]].flat() // [1, 2, 3, 4, [5, 6]]\n[1, 2, [3, 4, [5, 6]]].flat(2) // [1, 2, 3, 4, 5, 6]\n[1, [2, [3]]].flat(Infinity) // [1, 2, 3]\n[1, 2, , 4, 5].flat() // [1, 2, 4, 5]\n```\n\n`flatMap()` 传入一个遍历函数，先执行 `map()` 再 `flat()` 只能展开一层数组。\n可选第二个参数，用来绑定遍历函数里面的this\n\n```js\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n**7、**`at()` 返回指定索引上的值，允许负索引\n该方法不仅可用于数组，也可用于字符串和类型数组\n\n```js\nlet arr = [1, 2, 3]\narr[arr.length - 1] // 3\narr.at(-1) // 3\n```\n\n**8、**`toReversed() toSorted() toSpliced() with()` \n含义和用法完全一样，但不改变原数组，而返回一个原数组的拷贝：\ntoReversed() 对应 reverse()，用来颠倒数组成员的位置。\ntoSorted() 对应 sort()，用来对数组成员排序。\ntoSpliced() 对应 splice()，用来在指定位置，删除指定数量的成员，并插入新成员。\nwith(index, value) 对应 splice(index, 1, value)，用来将指定位置的成员替换为新的值。\n\n**9、**`group((item, index, array) => {})` 数组成员分组\n根据分组函数的运行结果，将数组成员分组，分组函数的返回值应该是字符串（或者可以自动转为字符串），以作为分组后的组名\n\n还未实装的[提案](https://github.com/tc39/proposal-array-grouping)\n\n```js\nlet arr = [1,2,3,4,5];\nlet result = arr.group(item => {\n  return item % 2 === 0 ? 'even': 'odd';\n});\nconsole.log(result);\n```\n\n\n# 运算符的扩展\n**1、指数运算符**`**`\n多个指数运算符连用时，是从最右边开始计算的\n\n```js\n2 ** 2 // 4\n2 ** 3 ** 2 // 相当于 2 ** (3 ** 2)\nlet b = 4;\nb **= 3; // 等同于 b = b * b * b;\n```\n\n**2、链判断运算符**`?.`\n如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在\n\n```js\n// 错误的写法\nconst  firstName = message.body.user.firstName || 'default';\n// 正确的写法\nconst firstName = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n```\n\n使用 `?.` 运算符简化写法\n在链式调用的时候判断左侧的对象是否为 null 或 undefined。如果是，则不再往下运算，直接返回 undefined\n\n```js\nconst firstName = message?.body?.user?.firstName || 'default';\n```\n\n判断对象方法是否存在，如果存在就立即执行：\n\n```js\nobj.fun?.()\n```\n\n**3、NULL 判断运算符**`??`\n使用 `||` 运算符指定默认值时，只要属性的值为 null 或 undefined，默认值就会生效，但是属性的值如果为空字符串或 false 或 0，默认值也会生效\n\nNull 判断运算符 `??` 类似 `||`，但是只有运算符左侧的值为 null 或 undefined 时，才会返回右侧的值\n\n与链判断运算符 `?.` 配合使用，为 null 或 undefined 的值设置默认值。\n\n```js\nconst a = obj?.a ?? 10;\n```\n\n\n# Symbol类型\nSymbol 是新的**基本数据类型**，表示**独一无二**的值\n\n```js\nlet s = Symbol();\nconsole.log(typeof s) // symbol\nconsole.log(Symbol('sss') == Symbol('sss')) //false\n```\n\nSymbol 值通过 `Symbol()` 函数生成，允许接受一个**字符串**作为参数，表示对 Symbol 实例的**描述**。这主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n如果 Symbol 的参数是一个**对象**，就会调用该对象的 `toString()` 方法，将其转为**字符串**，然后再生成一个 Symbol 值\n\n```js\nlet s = Symbol('sss');\nconsole.log(s) // Symbol(sss)\nconsole.log(s.toString()) // Symbol(sss)\n\nconst obj = {\n  toString() {\n    return 'abc';\n  }\n}\ns = Symbol(obj);\nconsole.log(s) // Symbol(abc)\n```\n\nSymbol 值也可以转为**布尔值**(true)，但是不能转为数值\n\n```js\nlet s = Symbol();\nconsole.log(Boolean(s)) // true\nconsole.log(Number(s)) // TypeError\n```\n\n## 作为属性名\n现在，对象的**属性名**可以是字符串或 **Symbol** 值\n\n由于每一个 Symbol 值都是不相等的，这意味着只要 Symbol 值用于对象的属性名，就能保证不会出现同名的属性\n\n```js 两次Symbol('123')返回值并不相同\nlet s = Symbol('123');\nconst obj = { \n  a: 1,\n  [s]: 's'\n}\nobj[Symbol('123')] = 123\nconsole.log(obj) // { a: 1, [Symbol(123)]: 's', [Symbol(123)]: 123 }\nconsole.log(obj[s]) // s\n\n```\n\nSymbol 值作为对象属性名时，用点运算符无法获取该属性\n\n```js\nlet s = Symbol('s');\nconst obj = { \n  [s]: 's',\n  s: 123\n};\nconsole.log(obj.s) // 123\nconsole.log(obj[s]) // s\n```\n\nSymbol 值作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，所以通常可以当做**私有属性**来使用\n\n`Object.getOwnPropertySymbols()` 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值\n`Reflect.ownKeys()` 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名\n\n```js\nconst obj = {\n  a: 1,\n  [Symbol('s')]: 's',\n};\nfor (let key in obj) {\n  console.log(key); // a\n}\nconsole.log(Object.keys(obj)); // [ 'a' ]\n\nconsole.log(Object.getOwnPropertySymbols(obj)); // [ Symbol(s) ]\nconsole.log(Reflect.ownKeys(obj)); // [ 'a', Symbol(s) ]\n\n```\n\n## Symbol方法\n**1、**`Symbol.for()` 将生成的 Symbol 值登记在全局环境中供搜索，若有相同描述的 Symbol 值则复用返回\n\nSymbol() 写法没有登记机制\n\n其登记机制可以用在不同的 iframe 或 service worker 中取到同一个值\n\n```js\nlet s1 = Symbol('s');\nlet s2 = Symbol.for('s');\nlet s3 = Symbol.for('s');\nconsole.log(s1 === s2); // false\nconsole.log(s2 === s3); // true\n```\n\n**2、**`Symbol.keyFor()` 返回一个**已登记**的 Symbol 类型值的参数 key\n\n```js\nlet s1 = Symbol('s');\nlet s2 = Symbol.for('s');\nconsole.log(Symbol.keyFor(s1)) // undefined\nconsole.log(Symbol.keyFor(s2)) // s\n```\n\n\n# Map对象\nMap对象保存键值对，元素会保持其插入时的顺序。\n\nMap的键可以是任意数据类型，包括函数、对象或任意基本类型。\n\n在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效\n\n```js 创建一个Map\nvar m = new Map();\n//或传入一个嵌套数组\nm = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n```\n\nObject与Map增删改查基本操作。\n\n```js\nvar o = {};\nvar m = new Map();\n//添加\no.x = 1;\nm.set('x', 1);\n//修改\no.x = 2;\nm.set('x', 2);\n//递增\no.x++;\nm.set('x', m.get('x')+1);\n//获取\no.x;\nm.get('x');\n//删除\ndelete o.x;\nmap.delete('x');\n\n```\n\nMap的键值对个数可以通过size属性获取\n\n```js\nvar m = new Map();\nm.set('x', 1);\nm.set('y', 2);\nconsole.log(m);//Map(2) {'x' => 1, 'y' => 2}\nconsole.log(m.size);//2\n```\n\n## Map的方法\n**基本方法：**\n1. **`get()`：**获取元素\n2. **`set()`：**设置元素\n3. **`has()`：**检查是否有指定key\n4. **`clear()`：**清空map\n5. **`delete()`：**删除指定元素\n\n**遍历方法：**\n1. **`keys()`：**提取键并返回**键**的迭代器MapIterator对象\n2. **`values()`：**提取值并返回**值**的迭代器MapIterator对象\n3. **`entries()`：**提取键值对并返回取**键值对**的迭代器MapIterator对象\n4. **`forEach()`：**传入回调函数(value, key)=>{}\n\n```js\nvar m = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n\nconsole.log(m.keys());//MapIterator {'x', 'y'}\nconsole.log(m.values());// MapIterator {1, 2}\nconsole.log(m.entries());// MapIterator {'x' => 1, 'y' => 2}\n\n//迭代器可以用for-of遍历\nfor (let [key, value] of m.entries()) {\n    console.log(key, value);//x 1, y 2\n}\n\nm.forEach((value, key) => {\n    console.log(key, value);//x 1, y 2\n})\n\n```\n\n# Set对象\n**Set**是**唯一值**的集合，与map类似，map存放的是键值对，而set只存放唯一值。\n\n**创建set对象：**\n\n```js\nvar s = new Set();\nvar s = new Set([1,2,3]);\n```\n\nset对象与数组也很像，可以互相转换\n\n```js\nvar arr1 = [1, 2, 3];\nvar s = new Set(arr1);//数组转为set对象，会去重\nvar arr2 = [...s];//set对象转为数组\n```\n\n可利用set值唯一的特性做**数组去重、并集、交集、差集**操作\n\n```js\n//1、去重\nvar s = new Set([1,2,3,3,2,1]);\nvar arr = [...s];//[1,2,3]\n\n//2、并集\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s = new Set([...arr1, ...arr2]); // {1, 2, 3, 4}\nvar arr = [...s];// [1,2,3,4]\n\n//3、交集，arr1和arr2共有的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => s2.has(x));//[2, 3]\n\n//4、差集,arr1去除arr2中的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => !s2.has(x));//[1]\n\n```\n\nSet值个数可以通过size属性获取\n\n```js\nvar s = new Set([1,2,3]);\nconsole.log(s);//Set(3) {1, 2, 3}\nconsole.log(s.size);//3\n```\n\n## Set的方法\n1. **`add()`：**添加新元素\n2. **`delete()`：**删除指定元素\n3. **`clear()`：**清空所有元素\n4. **`has()`：**判断是否存在某值\n5. **`forEach()`：**遍历每个元素，传入回调函数\n6. **`keys()`：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n7. **`values()`：**同keys()\n8. **`entries()`：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n**add()、delete()、clear()、has() ：**\n\n```js\nvar s = new Set([1,2,3]);\ns.add(4);\nconsole.log(s);//Set(4) {1, 2, 3, 4}\ns.delete(2);\ns.has(2);//false\ns.clear();\nconsole.log(s.size);// 0\n\n```\n\n**keys()、values() ：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.values();\nconsole.log(setIter);//SetIterator {1, 2, 3}\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // 2\nconsole.log(setIter.next().value); // 3\n```\n\n**entries() ：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.entries();\nconsole.log(setIter);//SetIterator {1 => 1, 2 => 2, 3 => 3}\nconsole.log(setIter.next().value); // [1, 1]\nconsole.log(setIter.next().value); // [2, 2]\nconsole.log(setIter.next().value); // [3, 3]\n```\n\n**forEach() ：**遍历每个元素，传入回调函数，参数：回调函数、thisArg执行回调函数时可以当作this来使用。\n回调函数参数：值（key）、值（value）、set对象\n\n```js\nvar s = new Set([1,2,3]);\ns.forEach((key,value,set)=>{\n    console.log(key,value);//1 1, 2 2, 3 3\n});\n```\n\n# 迭代/遍历器Iterator\nES6之后，表示“集合”的数据结构，在原先 Array 和 Object 基础上，又增加了 Map 和 Set\n\n遍历器 Iterator 用于规范统一地对集合进行遍历操作，是一个能访问数据的接口\n\n**Iterator 的遍历过程：**\n（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构的当前成员的信息（一个包含 value、done 属性的对象）\nvalue：当前成员的值\ndone：布尔值，表示遍历是否结束\n\n总之，遍历器使得不同的数据结构都可以被 for-of 遍历，只要实现了 Symbol.iterator\n\n## Symbol.iterator\nSymbol.iterator 是一个预定义好的、类型为 Symbol 的特殊值，是 Iterator 接口\n\n一个数据结构只要具有 Symbol.iterator 属性，就是可遍历的，也就是可以用 for-of 进行遍历\n\nSymbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器\n\n```js\nconst obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n```\n\n原生具备 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象\n\n```js 获取数组的迭代器\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n// for-of 遍历\nlet arr = ['a', 'b', 'c'];\nfor(let item in arr) {\n  console.log(item);\n}\n```\n\n\n# 生成器Generator\n生成器是一种函数，function关键字与函数名之间有一个星号 *，函数体内部使用yield表达式\n\n调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是一个遍历器对象\n\nyield 关键字会暂停函数的执行，调用遍历器对象的 next 方法，能让函数执行到下一个 yield 暂停处（或是return）\n\n总之 Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\n```js\nfunction* fun() {\n  console.log(1);\n  yield 'qx';\n  console.log(2);\n  yield 'chuckle';\n  console.log(3);\n}\nconst f = fun();\nconsole.log(f.next())\nconsole.log(f.next())\nconsole.log(f.next())\n// 1\n// { value: 'qx', done: false }\n// 2\n// { value: 'chuckle', done: false }\n// 3\n// { value: undefined, done: true }\n```\n\nnext() 会返回一个包含 value、done 属性的对象，其中 value 值是 yield 后面表达式的值\n\nnext() 可以传入参数，yield 是将其返回后，函数再继续执行到下一个 yield\n\n```js\nfunction* fun() {\n  let x = yield;\n  console.log(x);\n  let y = yield;\n  console.log(x+y);\n}\nconst f = fun();\nconsole.log(f.next(1))\nconsole.log(f.next(2))\nconsole.log(f.next(3))\n// { value: undefined, done: false }\n// 2\n// { value: undefined, done: false }\n// 5\n// { value: undefined, done: true }\n```\n\n使用 Generator 函数能够很方便地实现 Symbol.iterator，其目的也正是如此\n\n```js\nfunction* objectEntries(obj){\n    // 获取对象的所有 key 保存到数组 [name, age]\n    const propKeys = Object.keys(obj);\n    for(const propkey of propKeys){\n        yield [propkey, obj[propkey]]\n    }\n}\nconst obj = {\n    name: 'chuckle',\n    age: 19\n}\n// 把 Generator 生成器函数赋值给对象的Symbol.iterator属性, 为该对象加上遍历器接口\nobj[Symbol.iterator] = objectEntries;\n// objectEntries(obj) 等价于 obj[Symbol.iterator](obj) \nfor(let [key, value] of objectEntries(obj)){ \n    console.log(`${key}: ${value}`);\n}\n// name: chuckle\n// age: 19\n```\n\n## Generator的应用\n**1、异步代码同步化**\n\n```js\nfunction* main(){\n  let res = yield request('https://v1.hitokoto.cn/');\n  console.log('1:'+res);\n  res = yield request('https://v1.hitokoto.cn/');\n  console.log('2:'+res);\n  res = yield request('https://v1.hitokoto.cn/');\n  console.log('3:'+res);\n}\nconst ite = main();\nite.next();\n\nfunction request(url){\n  fetch(url)\n  .then(res=>res.json())\n  .then(data=>{\n    ite.next(data.hitokoto)\n  })\n}\n// 1:自己永远是孤单的，但你可以让其他人变得不孤单。\n// 2:我就是小偷，专门来偷走哥哥的心\n// 3:电脑的处理器总比执行单元小。\n```\n\n**2、正确的执行顺序**\n\n```js\nfunction* main(){\n  fun1();\n  yield fun2();\n  fun3();\n}\nlet ite = main();\nite.next();\n// 1 2 3\n\nfunction fun1(){\n  console.log('1');\n}\nfunction fun2(){\n  setTimeout(()=>{\n    console.log('2');\n    ite.next();\n  },1000)\n}\nfunction fun3(){\n  console.log('3');\n}\n```\n\n# Promise\n**之前已经记过笔记了：**[Promise异步编程](/article/7a1fbbc5.html)\n\n# Class类\n在 ES5 中生成实例对象的传统方法是通过构造函数\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.sayName = function () {\n  console.log(this.name);\n}\nlet p = new Person('chuckle', 18);\np.sayName() // chuckle\n```\n\n构造函数和普通函数容易混淆，现在，可以通过 Class 关键字来声明一个类了，其内置的 `constructor()` 在实例化对象时会立即被调用\n\n用法还是大差不差，并且和之前一样，类方法都在原型上\n\n```js\nclass Person {\n  // 实例化的时候会立即被调用\n  constructor(name, age){\n      this.name = name;\n      this.age = age;\n  }\n  //等同于Person.prototype.sayName = function sayName(){}\n  sayName(){\n    console.log(this.name);\n  }\n}\nlet p = new Person('chuckle', 18);\np.sayName() // chuckle\n```\n\nObject.assign() 方法可以很方便地一次向类添加多个方法\n\n```js\nclass Person {\n  constructor(){}\n}\nObject.assign(Person.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n\n## constructor函数\n`constructor()` 方法是类的默认方法，在创建实例对象时，自动调用\n\n默认返回实例对象（即this），也可以指定返回（return）另外一个对象\n\n```js\nconstructor() {\n  return Object.create(null);\n}\n```\n\n如果一个实例属性不需要接受外部的传参赋值，可以不在 constructor 方法中定义\n\n```js\nclass Person {\n  constructor(name, age){\n      this.name = name;\n      this.age = age;\n  }\n  country = 'china';\n}\nlet p = new Person('chuckle', 18);\nconsole.log(p)\n// Person { country: 'china', name: 'chuckle', age: 18 }\n```\n\n## Class表达式\n可以写成表达式的形式\n\n```js\nconst MyClass = class { \n  name = 'chuckle';\n  SayName() {\n    console.log(this.name);\n  }\n};\nconst myClass = new MyClass();\nmyClass.SayName() // chuckle\n```\n\n可以写出立即执行的 Class\n\n```js\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\nperson.sayName(); // 张三\n```\n\n## Static\n在类成员前，加上static关键字，就表示静态属性或方法\n\n**静态**即不会被实例继承，而是直接通过类来调用\n\n静态方法可以与非静态方法重名\n\n```js\nclass Class{ \n  name = 'chuckle';\n  static name = 'qx';\n  static SayName() {\n    console.log(this.name); // 静态方法的this指类本身，只能访问静态属性\n  }\n};\nClass.SayName() // qx\nnew Class().SayName(); // TypeError: myClass.SayName is not a function\n```\n\n父类的静态成员，可以被子类继承\n\n```js\nclass Foo {\n  static num = 123;\n  static classMethod() {\n    return 'hello';\n  }\n}\nclass Bar extends Foo {\n}\nBar.classMethod() // 'hello'\nBar.num // 123\n```\n\n## 私有方法和属性\n私有，即只能在类的内部访问的方法和属性，外部不能访问，有利于代码的封装\n\n早期并没有途径实现真正的私有，只能通过特殊的命名规则加以区别\n\n```js\nclass Class {\n  foo () {} // 公有\n  _fun() {} // 加上_表示私有\n}\n```\n\n或者借助 Symbol 来让成员不易被获取，但仍然可以被 Reflect.ownKeys() 等方法获取到\n\n```js\nlet s1 = Symbol('name');\nlet s2 = Symbol('fun')\nclass Class {\n  name = 'qx';\n  [s1] = 'chuckle';\n  [s2](){\n    console.log(this.name);\n  };\n}\nconst myClass = new Class()\nconsole.log(myClass) // Class { name: 'qx', [Symbol(name)]: 'chuckle' }\nmyClass[s2]() // qx\nconsole.log(Object.getOwnPropertySymbols(myClass)) // [ Symbol(name) ]\n```\n\nES2022 正式为 class 添加了私有成员，方法是在属性或方法名之前使用 `#` 表示\n\n```js\nclass Class {\n  #count = 0;\n  get value(){\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\nconst myClass = new Class();\nmyClass.increment();\nconsole.log(myClass.value) // 1\nconsole.log(myClass.#count) // SyntaxError: Private field '#count' must be declared in an enclosing class\nconsole.log(myClass.count) // undefined\n```\n\n不管在类的内部或外部，如果读取一个不存在的私有成员，会报错\n\n私有成员前面，也可以加上 static 关键字，表示这是一个静态的私有成员\n\n## 类的继承\nClass 通过 `extends` 关键字实现继承，写法比 ES5 的原型链继承，要清晰和方便很多\n\n\n```js\nclass Animal {\n    constructor(name, age){\n        this.name = name;\n        this.age = age;\n    }\n    sayName(){\n        return this.name;\n    }\n    sayAge(){\n        return this.age;\n    }\n}\n \nclass Dog extends Animal{\n    constructor(name, age, color){\n        // 子类的构造函数必须执行一次 super() 函数\n        super(name, age);  // 等同于 Animal.call(this,name,age); 继承父类的属性\n        this.color = color;\n    }\n    // 子类自己的方法\n    sayColor(){\n        return `${this.name}是${this.age}岁了，它的颜色是${this.color}`;\n    }\n    // 重写父类的方法\n    sayName(){\n        // super 相同于 Animal\n        return this.name + super.sayAge + this.color;\n    }\n}\n \nlet d1 = new Dog('小黄', 28, 'red');\nconsole.log(d1.sayAge());     // 调用继承父类的方法\nconsole.log(d1.sayColor());   // 调用子类自己的方法\nconsole.log(d1.sayName());    // 调用重写父类的方法\n```\n\n## super\nsuper 关键字，既可以当作函数使用，也可以当作对象使用\n\nsuper 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super() 函数\n调用super()的作用是形成子类的this对象，任何对子类 this 的操作都要放在 super() 的后面\n\nsuper() 相当于 A.prototype.constructor.call(this)（在子类的this上运行父类的构造函数）\n\n```js\nclass A {}\nclass B extends A {\n  constructor() {\n    super();\n    this.name = 'qx';\n  }\n}\n```\n\nsuper 作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类\n\n定义在父类实例上的方法或属性，无法通过 super 调用\n\n```js\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n```\n\n# Module模块化\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJS 和 AMD 模块，都是运行时的\n\n```js\n// CommonJS模块\nlet { stat, exists, readfile } = require('fs');\n// ES6模块\nimport { stat, exists, readFile } from 'fs';c\n```\n\nES6 模块主要有两个命令构成：`export` 和 `import`\n\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量\n\n```js\nconst name = '张三';\nconst age = 18;\nconst sayName = function() { console.log(fristName); }\nexport {name, age, sayName}\n\nimport {name, age, sayName} from './modules/index.js';\n```\n\n默认暴露 `export default` 为模块指定默认输出，import命令可以为该匿名函数指定任意名字\n\n```js\nexport default function(){\n  console.log('chuckle');\n}\n\nimport sayName from './modules/index.js'\nsayName(); // chuckle\n```\n\n整体加载：模块暴露的内容都会作为该对象的成员\n\n```js\nimport * as obj from './modules/index.js';\n```\n\n在浏览器环境中，需要给 script 标签加上 `type='module'` 属性\n\n```html\n<script type='module'>\n  import { name } from './modules/index.js';\n</script>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"文本、代码粘贴分享平台项目","url":"/article/544ba770.html","content":"\n# 前言\n网上居然没有个轻量方便的代码粘贴分享的网站，那就自己动手丰衣足食。\n\n**目的：**跨设备、远程进行文本、代码的传输、分享与展示（起初只是为了在qq群里发代码不刷屏）\n\n作为大学牲，之前忙着预习期末，6月份都没写博文，也少写代码，都快忘了Vue3咋写了，这个项目就当康复训练了\n\n# 简介\n一个轻量快捷的文本、代码粘贴分享网站\n\n**演示：**[粘贴分享](https://s.qcqx.cn/)，使用Cloud Mongodb + Vercel部署\n\n**前端：**[paste-share](https://github.com/qxchuckle/paste-share)\n\nVue3 + Vite + Vue Router + Pinia + Naive UI + axios + sass + highlight.js + vue-clipboard3\n\n**后端：**[paste-share-server](https://github.com/qxchuckle/paste-share-server)\n\nNodeJS + Express + MongoDB + Mongoose + shortid + jsonwebtoken\n\n# 功能\n1. 注册、登录、自动登录，区分多用户和游客，Token控制会话\n2. 游客也能粘贴分享内容，注册登录后能查看自己所分享的所有内容\n3. 粘贴内容7天后自动过期销毁\n4. 分享内容可选加密\n5. 代码高亮展示\n\n# 截图\n\n<img src=https://cdn.chuckle.top/images/62-2.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/62-3.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/62-4.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/62-5.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/62-6.webp loading=\"lazy\">\n\n","tags":["NodeJS","Vue"],"categories":["项目"]},{"title":"Express+Vue3前后端分离博客","url":"/article/ebf9360.html","content":"\n# 前言\n花了三天时间搞定，属于是边写边学\n\n<img src=https://cdn.chuckle.top/images/61-2.webp loading=\"lazy\">\n\nBug嘛，肯定没有（没发现就是没有！）\n这不是 Bug ，这是一个特性，它在我的机器上可以很好地运行。\n\n# 简介\n一个简单的前后端分离的博客，拥有完整的接口与后台\n\n**演示：**[轻笑Chuckle|博客](https://blog.qcqx.cn/)，部署使用的cloud Mongodb + Vercel，可能会有亿点慢\n\n后台账号：qx 密码：123456\n\n**前端：**[仓库 blog-vue](https://github.com/qxchuckle/blog-vue)\n\nVue3 + Vite + Vue Router + Pinia + Naive UI + wangEditor + axios + sass\n\n**后端：**[仓库 blog-server](https://github.com/qxchuckle/blog-server)\n\nNodeJS + Express + MongoDB + Mongoose + jsonwebtoken\n\n# 后端\n**接口文档：**[API文档](https://console-docs.apipost.cn/preview/c671abaeb3ac6f29/c22da7ca55753064)\n\n1. 登陆、注册、自动登陆校验\n2. 分类的增删改查\n3. 文章的增删改查\n4. 敏感操作（增删改）校验token\n5. API视情况返回不同的json信息\n\n获取文章时通过携带的query参数不同，可以实现分页查询、查询指定分类的文章、标题和内容关键词搜索等\n\n# 前端\n1. 路由拦截，自动登陆\n2. 完整的管理后台，文章管理、富文本编辑、分类管理\n3. 人性化的交互，加载提示、信息提示\n4. 适配移动端\n5. 表单输入内容的校验\n6. 管理员登陆状态的管理\n7. 对分类等数据进行暂存，除非进行了修改，否则不去请求后端接口\n8. 使用pinia管理状态以及对状态的操作，两个store：UserStore、PostStore\n9. 代码上，对文章列表、富文本编辑等组件的封装，方便复用\n\n# Tip\n因为是个人博客，所以后端没有设计区分多用户的文章、分类管理，注册好管理员就改后端代码把注册接口堵死吧\n\n后端config.js保存了token加密字符串、数据库连接url等配置\n\n输入内容的限制只在前端做了，后端只管关键参数有没有传过来，至于内容的限制，懒了，能跑就行，咕咕咕\n\n是否展示业务逻辑已经写完，但是没有实装（加个判断的事），感觉个人博客没必要是否展示（那我写来干嘛？以后实装），所以现在就算选不展示，也还是会展示滴\n\n# 截图\n\n<img src=https://cdn.chuckle.top/images/61-3.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/61-4.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/61-5.webp loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/61-6.webp loading=\"lazy\">\n","tags":["NodeJS","Vue"],"categories":["项目"]},{"title":"Vite、Pinia、Router","url":"/article/31e8cb77.html","content":"\n# Vite\n[Vite](https://cn.vitejs.dev/) 是一种新型的前端构建工具，它可以在开发过程中提供快速的反应速度。相对于其他传统的打包工具，Vite利用浏览器原生ES模块导入功能代替传统的打包方式，实现了更快的构建和启动速度，在生产环境下打包使用 Rollup\n\n**开始：** `npm create vite@latest`\n\n根据提示完成项目创建\n\n```js\n√ Project name: ... vite-test\n√ Select a framework: » Vue\n√ Select a variant: » JavaScript\n```\n\n**安装依赖：**`npm i`\n\n**运行：**`npm run dev`\n\n项目结构与 vue-cli 差不多\n\n**差别：**\n(1) index.html 现在位于项目根目录\n(2) [vite.config.js](https://cn.vitejs.dev/config/) 是Vite项目的配置文件，用于配置Vite本身和插件的选项\n\n# 路由router\n在 vue2 中学的是 [vue-router](https://router.vuejs.org/zh/)@3，现在该跟上最新版本了\n\n**安装：**`npm i vue-router`\n\n虽然大版本变了，但很多功能和写法也只是稍微变了点样子\n\n**配置路由：**\n\n```js /router/index.js\n// 导入创建路由必要的方法\nimport { createRouter, createWebHashHistory } from \"vue-router\";\n// 路由懒加载\nconst Login = () => import('../components/Login/index.vue')\n\n// 路由配置\nconst routes = [\n  {\n    // 都是熟悉的配置项\n    path: '/login',\n    name: 'Login',\n    component: Login,\n    children:[]\n  }\n];\n\n// 创建路由并暴露其返回值\nexport default createRouter({\n  // 配置路由模式hash和history\n  history: createWebHashHistory(),\n  // 使用路由配置\n  routes\n})\n\n```\n\n在 main.js 导入并使用路由\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n// 导入路由\nimport router from './router'\n// 使用路由\ncreateApp(App).use(router).mount('#app')\n```\n\n## 路由模式\nhash 模式 `createWebHashHistory()` \n\nHTML5 模式 `createWebHistory()`\n\n```js\nimport { createWebHashHistory, createWebHistory } from \"vue-router\";\nexport default createRouter({\n  // history: createWebHashHistory(),\n  history: createWebHistory(),\n  routes\n})\n```\n\n## 路由守卫\n[路由守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)使用也和之前差不多\n\n现在每个路由守卫都接收两个参数，不再有 next()\n(1) **to:** 即将要进入的目标\n(2) **from:** 当前导航正要离开的路由\n\n通过返回值来控制路由：\n(1) **false:** 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n(2) **一个路由地址:** 通过一个路由地址跳转到一个不同的地址，就像调用 router.push() 一样，可以设置诸如 replace: true 或 name: 'home' 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 from 一样。\n(3) **无返回值**或**true:** 继续当前路由\n\n**全局路由守卫：**\n\n```js\nconst router = createRouter({ /* ... */ }）\nlet isAuthenticated = true;\n// 全局前置守卫\nrouter.beforeEach(async (to, from) => {\n  console.log(to,from);\n  if (\n    // 检查用户是否已登录\n    !isAuthenticated &&\n    // ❗️ 避免无限重定向\n    to.name !== 'Login'\n  ) {\n    // 将用户重定向到登录页面\n    return { name: 'Login' }\n  }\n})\n\n```\n\n## 编程式路由\n在 vue3  组合式 API 中不再有 this\n\n使用 `useRouter()`, `useRoute()` 的返回值获取路由器和当前路由对象，route 对象是一个响应式对象\n\n```js\nimport { useRouter, useRoute } from 'vue-router'\nconst router = useRouter()\nconst route = useRoute()\nconsole.log(route);\nfunction pushLogin() {\n  router.push({\n    name: 'Login'\n  })\n}\n\n```\n\n**注意：**在模板中仍然可以访问 $router 和 $route，不需要在 setup 中返回 router 或 route\n\n## 导航流程\n\n1. 导航被触发。\n2. 在失活的组件里调用 beforeRouteLeave 守卫。\n3. 调用全局的 beforeEach 守卫。\n4. 在重用的组件里调用 beforeRouteUpdate 守卫。\n5. 在路由配置里调用 beforeEnter。\n6. 解析异步路由组件。\n7. 在被激活的组件里调用 beforeRouteEnter。\n8. 调用全局的 beforeResolve 守卫。\n9. 导航被确认。\n10. 调用全局的 afterEach 钩子。\n11. 触发 DOM 更新。\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n> 路由这块，多看[文档](https://router.vuejs.org/zh/guide/)吧\n\n# pinia\n[Pinia](https://pinia.web3doc.top/) 是类似 Vuex 的**状态管理**库，具有更好的类型安全性和更简单的API\n\npinia 中只有 state、getter、action，抛弃了 Vuex 中的 Mutation，但和 vuex 一样，有一个 store\n\n**安装：**`npm i pinia`\n\n`createPinia` 创建并使用pinia：\n\n```js\n// 导入并使用pinia\nimport { createPinia } from 'pinia'\napp.use(createPinia())\n```\n\n## 创建store\n使用 `defineStore()` 创建一个 store，并且需要一个唯一名称，作为第一个参数传递。pinia中允许创建多个store\n\n```js /store/mainStore.js\nimport { defineStore } from 'pinia'\n// 创建并暴露一个store\nexport default defineStore('mainStore', {\n  // 类似data，存储状态\n  // 在 Pinia 中，状态被定义为返回初始状态的函数\n  state: () => {\n    return {\n      num: 1,\n      name: 'chuckle'\n    }\n  },\n  // 对状态的操作\n  actions: {\n    add(){\n      this.num++\n    }\n  },\n  // 相当于计算属性，传入一个store的state作为参数\n  getters: {\n    bigNum(state){\n      return state.num*10\n    }\n  }\n});\n\n```\n\n## 使用store操作状态\n在需要使用该 store 的组件中引入\n\n为了从 Store 中提取属性同时保持其响应式，需要使用 `storeToRefs()`\n\n```html\n<script setup>\nimport { storeToRefs } from 'pinia'\nimport { useStore } from './stores/mainStore'\n// store 是一个用reactive 包裹的对象，不能对其进行解构\nconst store = useStore()\n// 为了从 Store 中提取属性同时保持其响应式，需要使用storeToRefs()\nconst { num, name, bigNum } = storeToRefs(store)\n</script>\n<template>\n  <!-- store中的 -->\n  <h3>{{ store.name }}</h3>\n  <h3>{{ store.num }}</h3>\n  <h3>{{ store.bigNum }}</h3>\n  <!-- 提取出来的 -->\n  <h3>{{ name }}</h3>\n  <h3>{{ num }}</h3>\n  <h3>{{ bigNum }}</h3>\n  <button @click=\"store.add()\">增加</button>\n</template>\n\n```\n\n**其它操作：**\n1. `$reset()` 重置 state\n```html\n<button @click=\"store.$reset()\">重置</button>\n```\n2. `$patch()` 批量写入或修改 state\n```js\nfunction bulkChange(){\n  store.$patch((state)=>{\n    state.name = \"qx\";\n    state.num = state.num *10\n  })\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"TypeScript笔记","url":"/article/9d362be7.html","content":"\n# 初识\n[TypeScript](https://www.tslang.cn/index.html) 是由巨硬开发的 **JS 的超集**，通过添加可选的静态类型和基于类的面向对象编程思想，使得代码更易于理解、维护和重构。此外，**TS** 还支持其他高级语言功能，如接口、泛型、命名空间和装饰器等\n\n**规范：**TS 提供了更好的类型检查和代码提示工具，并且可以使用第三方库中的类型声明文件进行代码补全和类型检查\n\n**开发：**TS 为现代Web应用程序和大型项目提供了一个强大的编程环境，可以帮助开发人员减少错误、提高开发效率和代码质量\n\n**运行：**TS 可以转换成 JS 并在任何支持 JS 的环境中运行，包括浏览器、Node.js和移动应用程序等\n\n**安装：**`npm install typescript -g` 会在全局暴露一个 **tsc** 命令\n\n`tsc -init` 初始化，创建 **tsconfig.json**\n\n`tsc -w` 监视所有 TS 文件变化，实时编译成 JS\n\n`npm install ts-node -g` 安装 **ts-node** 更方便地运行 TS\n\n# 配置文件\n**tsconfig.json** 是 TS 的配置文件\n\n可以定义哪些文件需要包含在编译过程中、使用哪个ECMAScript目标版本、生成哪种模块系统、是否开启严格模式等等\n\n**常用配置项：**\n1. **target** 设置编译后的 JavaScript 代码使用的 ECMAScript 版本，默认为 ES3，可设置为 ES5、ES6/ES2015、ES7 等。\n2. **strict** 开启所有严格类型检查选项，包括noImplicitAny，noImplicitThis，alwaysStrict等等。如果希望 TypeScript 给出尽可能多的类型检查错误提示，可以将此选项设置为 true。\n3. **module** 指定生成的模块规范类型，可选值有 commonjs、amd、system 和 es2015。\n4. **lib** 指定编译过程中需要引入的库文件，默认情况下只包含 DOM 和 ES 标准库，可以通过指定其他库来获得更好的类型检查支持。\n5. **moduleResolution** 指定模块解析策略，可选值有 classic、node、和 yarn pnp。\n6. **esModuleInterop** 简化导入cjs模块功能\n7. **outDir** 输出目录，指定编译后的 JavaScript 代码所在的目录。\n8. **rootDir** 项目根目录\n9. **allowJs** 允许编译器编译 .js 文件（通常是为了容易迁移现有的 JavaScript 项目到 TypeScript 项目）\n10. **sourceMap** 生成 sourcemap 文件，方便调试 TypeScript 代码时能够正确地映射回原始的 TypeScript 代码。\n11. **noImplicitAny** 当 TypeScript 无法推导出变量的类型时，给出一个错误提醒\n12. **noImplicitThis** 禁止 this 关键字的隐式 any 类型\n13. **strictNullChecks** 严格模式下对 null 和 undefined 的检查。\n\n# TS检查相关注释\n(1) `// @ts-nocheck` 加到文件首行，当前文件不需要 ts 校验\n(2) `// @ts-check` 加到文件首行，对当前文件进行 ts 校验\n(3) `// @ts-ignore` 忽略下一行代码的 ts 校验\n(4) `// eslint-disable-next-line` 忽略下一行代码的 eslint 校验\n(5) `/* eslint-disable */` eslint忽略\n\n# 类型标注\n通过 `<数据>:<类型>` 对变量、函数返回值、函数参数等数据进行类型的标注、限制\n\n**思想：**定义任何东西的时候要注明类型，调用任何东西的时候要检查类型。\n\n可以标注的类型：\n(1) **基础类型：**Boolean、Number、String、null、undefined 以及 ES6 的 Symbol 和 ES10 的 BigInt。\n(2) **空值**：Void\n(3) **顶级类型：**任意类型 Any 和 不知道的类型 Unknown\n(4) Object、object 和 {} \n(5) **接口和对象类型：**interface定义\n(6) **数组类型**\n(7) **函数类型**\n\n## 基本类型\n**1、字符串类型：string**\n\n```ts\nlet str: string = \"chuckle\";\nstr = `1+1=${1+1}`; // 可以使用模板字符串\nstr = \"1+1=\" + \"2\"; // 可以拼接\n```\n\n**2、数字类型：number**\n\n```ts\nlet num: number = 1\nnum = NaN\nnum = Infinity\nnum = 0xf00d // 十六进制\nnum = 0b1010 // 二进制\n```\n\n**3、布尔类型：boolean**\n\n**注意：**new Boolean() 返回的是一个 Boolean 对象，而不是布尔值\n\n```ts\nlet bool: boolean = true\nbool = Boolean(0) // false\n```\n\n**4、Null 和 undefined 类型**\n\nundefined 和 null 是所有类型的**子类型**，在**非严格模式**下可以赋给其它**任何类型**的变量\n\n**严格模式下：**\n(1) undefined 和 null 不能赋给其它类型的变量，但 undefined 可以赋给 void 类型（一般也用不到）\n(2) null 和 undefined 类型也不能相互赋值\n\n```ts\nlet a: null = null\nlet b: undefined =  undefined\na = b // 严格模式下不允许\nlet str: string = a // 严格模式下不允许\nlet c: void = null // 严格模式下不允许\nc = undefined // 始终允许\n```\n\n## 空值void\nJS 中没有空值的概念，TS 中可以使用 void 表示函数无返回值\n\n**注意：**\n(1) 不能将 void 赋给除 any 外其它类型的变量。\n(2) 使用 any 类型的变量接收函数返回的空值，打印 undefined\n(3) Boolean(void) 值是 false\n\n```ts\nfunction fun(): void{}\nlet a: any = fun();\nconsole.log(a); // undefined\na = Boolean(fun());\nconsole.log(a); // false\nlet b: string = fun() // 不允许\n```\n\n## any和unknown\nany 和 unknown 是 TS 中的顶级类型，可以包含所有类型的数据\n\n如果所有变量都是 any 类型，那就是 AnyScript，写起来和 JS 没什么区别，最好不要这么做\n\n```ts\nlet a: any = 1;\na = \"qx\"\na = true\na = null\n```\n\n**any 与 unknown 的区别：**\nany 可以赋给其它类型，而 unknown 不能赋值给除 any 和 unknown 以外的其它类型\n\n```ts\nlet a: any = 1\nlet b: unknown = 2\nlet num: number = a // any可以赋给其它类型\na = b // unknown可以赋给any\nnum = b // unknown不能赋给其它类型\n```\n\nunknown 类型不能读任何元素、属性，也不能调用任何方法，所以 unknown 比 any 安全\n\n```ts\nlet u: unknown = { a: 1 }\nconsole.log(u); // 可以\nconsole.log(u.a); // 错误\nu =  ()=>{ console.log('@@') }\nu() // 错误\n```\n\n## Object、object和{}\nObject、object 和 {} 虽然能保存的数据类型不同，但都和 **unknown** 类型一样，不能读任何元素、属性，也不能调用任何方法\n\n**1、**Object 类型是所有 Object 类的实例的类型，字面量 {} 代表的也是 Object\n\n由于原型链顶层就是 Object，所有基本数据类型和引用类型最终都指向 Object，所以他也包含所有类型\n\n```ts\nlet obj: Object = 1;\nobj = \"chuckle\"\nconsole.log(obj); // chuckle\nobj = { a: 1 }\nconsole.log(obj.a); // 报错：类型Object上不存在属性a\n```\n\n**2、**object 代表所有**非值类型**的类型（数组、对象、函数）等，常用于泛型约束\n\n```ts\nlet o: object = ()=>{ console.log('@@') }\no() // 此表达式不可调用。类型{}没有调用签名\no = ['1','2']\nconsole.log(o[1]) // 错误\no = { a: 1 }\nconsole.log(o) // 报错：类型object上不存在属性a\n```\n\n## 接口和对象类型\n在 TypeScript 中，使用接口（Interfaces）来定义对象的类型。\n\n即使用 **interface** 来定义一种对对象的约束\n\n接口是一个非常灵活的概念，除了可用于对类的一部分**行为**进行抽象外，也常用于**对象的形状**的描述。\n\n```ts\n// 定义一个对象\ninterface Person{\n  name: String,\n  age: number,\n}\n// 必须按照定义的形状来声明\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20\n}\n\n```\n\n1、重名的接口会合并，共同起作用\n\n```ts\ninterface Person{\n  name: String,\n}\ninterface Person{\n  age: number,\n}\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20\n}\n\n```\n\n2、任意属性 [propName: string] (索引签名)\n\n声明的对象中可以有任意个数所定义的类型（或其子类型）的属性\n\n```ts\ninterface Person{\n  name: String,\n  age: number,\n  [propName: string]: any\n}\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20,\n  // 接下来可以有任意个数any类型的属性\n  a: 1,\n  b: \"qx\",\n  c(){\n    console.log(this.a)\n  }\n}\n\n```\n\n3、readonly 让属性只读\n\n```ts\ninterface Person{\n  readonly name: String,\n  age: number,\n}\n```\n\n4、定义对象中的函数\n\n```ts\ninterface Person{\n  fun: (value:number)=>number\n}\n```\n\n6、接口继承 extends\n\n```ts\ninterface A{\n  name: String,\n}\ninterface B extends A{\n  age: number,\n}\nlet b: B = {\n  name: \"chuckle\",\n  age: 20,\n}\n\n```\n\n## 数组类型\n使用 `:<元素类型>[]` 来定义一个数组\n\n```ts\nlet arr: number[] // 定义数值类型的数组\n```\n\n使用泛型的方式定义\n\n```ts\nlet arr: Array<number>\n```\n\n定义二维数组\n\n```ts\nlet arr: number[][]\nlet arr: Array<Array<number>>\n```\n\n定义包含多种类型的数组\n\n```ts\nlet arr: (number|string)[] = [1, 2, '3', 4]\n```\n\n元组：元素的类型、位置、个数必须一一对应\n\n```ts\nlet arr: [number,string] = [1,'qx']\n```\n\n## 函数类型与定义\n定义一个函数类型变量\n\n```ts\nlet fun: Function\nfun = ()=>{}\n```\n\n定义函数的参数和返回值\n\n```ts\nfunction fun(a:number, b:number):number{\n  return a+b;\n}\nconsole.log(fun(1,1))\n```\n\n使用 interface 定义函数类型（函数也是一种对象）\n\n```ts\ninterface Fn {\n  // 只有一个string类型的参数，返回值是数值类型\n  (name: string): number\n}\nlet fun: Fn = (name)=>{\n  console.log(name)\n  return 1\n}\nfun(\"chuckle\")\n\n```\n\nTS 可以定义函数中的 this 类型，用于增强补全，必须写在函数的第一个参数上，不作为真正的参数定义\n\n```ts\ninterface Obj{\n  name: string\n  // TS可以定义this的类型（一般用于增强补全），必须在第一个参数上定义\n  add: (this:Obj, num:number)=>void\n}\nlet obj:Obj = {\n  name: \"chuckle\",\n  add(num:number){\n    console.log(num);\n    console.log(this.name);\n    // 此时this.就会有补全\n  }\n}\nobj.add(1);\n\n```\n\n# ?可选符\n使用 `?:` 定义函数参数或对象属性作为可选项\n\n```ts\ninterface Person{\n  name: String,\n  age?: number, // 年龄可选\n}\n// 第二个b参数可选\nfunction fun(a:number, b?:number):number{\n  return b ? a+b : a;\n}\n\n```\n\n# 联合类型\n使用 `<类型1>|<类型2>` 标注多个类型\n\n```ts\n// 函数可传入两种参数\nfunction fun(a: number | string) { }\n// 可保存两种类型的变量\nlet a: number | string\n```\n\n# 交叉类型\n`<类型1>&<类型2>` 需同时满足两种类型，通常配合接口使用\n\n```ts\ninterface Student {\n  name: string\n  id: number\n}\ninterface Person {\n  name: string\n  age: number\n}\nlet p: Student & Person = {\n  name: \"chuckle\",\n  id: 1,\n  age: 20\n}\n\n```\n\n# 类型断言\n`值 as 类型`或`<类型>值` 欺骗 TypeScript 编译器，但无法避免运行时的错误\n\n```ts\nfunction fun(a: number | string){\n  // console.log(a.length); // 数值类型没.length方法，会报错\n  console.log((<string>a).length); // 断言a一定是string类型\n}\nfun(123) // undefined\nfun('123') // 3\n```\n\nTS 直接在 window 上添加属性是不允许的，但可以将 window 断言为 any 类型，就可以添加属性了\n\n```ts\nwindow.a = 1; // 不可以\n(<any>window).a = 1; // 断言成any就可以了\nconsole.log((<any>window).a);\n```\n\n# 内置对象\nJS 中有很多内置对象，它们可以直接在 TS 中当做定义好了的类型来使用\n\n**1、ECMAScript 的内置对象：**内置对象名就是类型名\n\n```ts\nlet b: Boolean = new Boolean(1)\nconsole.log(b)\nlet n: Number = new Number(true)\nconsole.log(n)\nlet s: String = new String('chuckle')\nconsole.log(s)\nlet d: Date = new Date()\nconsole.log(d)\nlet r: RegExp = /^123/\nconsole.log(r)\nlet e: Error = new Error(\"error\")\nconsole.log(e)\n\n```\n\n**2、DOM 和 BOM 的内置对象：** \n`HTML<标签名>Element` 某个内置标签的类型，input、span 等\n`HTMLElement` 语义化的标签名，footer、header，以及自定义标签名\n`Element` 任何标签元素的类型\n`NodeList` 任何元素集合的类型\n`NodeListOf<其它类型>` 指定元素集合的类型\n\n由于元素可能获取不到，要加上 null 组成联合类型\n\n```ts\nlet div1: HTMLInputElement | null = document.querySelector('input');\nlet div2: HTMLDivElement | null = document.querySelector('div');\nlet div3: NodeListOf<HTMLElement> | null = document.querySelectorAll('.content');\nlet local: string | null = localStorage.getItem('token')\nlet lct: Location  = location\nlet pms: Promise<number> = new Promise((r)=>r(1))\n```\n\n```ts\n//dom元素的映射表\ninterface HTMLElementTagNameMap {\n  \"a\": HTMLAnchorElement;\n  \"abbr\": HTMLElement;\n  \"address\": HTMLElement;\n  \"applet\": HTMLAppletElement;\n  \"area\": HTMLAreaElement;\n  \"article\": HTMLElement;\n  \"aside\": HTMLElement;\n  \"audio\": HTMLAudioElement;\n  \"b\": HTMLElement;\n  \"base\": HTMLBaseElement;\n  \"bdi\": HTMLElement;\n  \"bdo\": HTMLElement;\n  \"blockquote\": HTMLQuoteElement;\n  \"body\": HTMLBodyElement;\n  \"br\": HTMLBRElement;\n  \"button\": HTMLButtonElement;\n  \"canvas\": HTMLCanvasElement;\n  \"caption\": HTMLTableCaptionElement;\n  \"cite\": HTMLElement;\n  \"code\": HTMLElement;\n  \"col\": HTMLTableColElement;\n  \"colgroup\": HTMLTableColElement;\n  \"data\": HTMLDataElement;\n  \"datalist\": HTMLDataListElement;\n  \"dd\": HTMLElement;\n  \"del\": HTMLModElement;\n  \"details\": HTMLDetailsElement;\n  \"dfn\": HTMLElement;\n  \"dialog\": HTMLDialogElement;\n  \"dir\": HTMLDirectoryElement;\n  \"div\": HTMLDivElement;\n  \"dl\": HTMLDListElement;\n  \"dt\": HTMLElement;\n  \"em\": HTMLElement;\n  \"embed\": HTMLEmbedElement;\n  \"fieldset\": HTMLFieldSetElement;\n  \"figcaption\": HTMLElement;\n  \"figure\": HTMLElement;\n  \"font\": HTMLFontElement;\n  \"footer\": HTMLElement;\n  \"form\": HTMLFormElement;\n  \"frame\": HTMLFrameElement;\n  \"frameset\": HTMLFrameSetElement;\n  \"h1\": HTMLHeadingElement;\n  \"h2\": HTMLHeadingElement;\n  \"h3\": HTMLHeadingElement;\n  \"h4\": HTMLHeadingElement;\n  \"h5\": HTMLHeadingElement;\n  \"h6\": HTMLHeadingElement;\n  \"head\": HTMLHeadElement;\n  \"header\": HTMLElement;\n  \"hgroup\": HTMLElement;\n  \"hr\": HTMLHRElement;\n  \"html\": HTMLHtmlElement;\n  \"i\": HTMLElement;\n  \"iframe\": HTMLIFrameElement;\n  \"img\": HTMLImageElement;\n  \"input\": HTMLInputElement;\n  \"ins\": HTMLModElement;\n  \"kbd\": HTMLElement;\n  \"label\": HTMLLabelElement;\n  \"legend\": HTMLLegendElement;\n  \"li\": HTMLLIElement;\n  \"link\": HTMLLinkElement;\n  \"main\": HTMLElement;\n  \"map\": HTMLMapElement;\n  \"mark\": HTMLElement;\n  \"marquee\": HTMLMarqueeElement;\n  \"menu\": HTMLMenuElement;\n  \"meta\": HTMLMetaElement;\n  \"meter\": HTMLMeterElement;\n  \"nav\": HTMLElement;\n  \"noscript\": HTMLElement;\n  \"object\": HTMLObjectElement;\n  \"ol\": HTMLOListElement;\n  \"optgroup\": HTMLOptGroupElement;\n  \"option\": HTMLOptionElement;\n  \"output\": HTMLOutputElement;\n  \"p\": HTMLParagraphElement;\n  \"param\": HTMLParamElement;\n  \"picture\": HTMLPictureElement;\n  \"pre\": HTMLPreElement;\n  \"progress\": HTMLProgressElement;\n  \"q\": HTMLQuoteElement;\n  \"rp\": HTMLElement;\n  \"rt\": HTMLElement;\n  \"ruby\": HTMLElement;\n  \"s\": HTMLElement;\n  \"samp\": HTMLElement;\n  \"script\": HTMLScriptElement;\n  \"section\": HTMLElement;\n  \"select\": HTMLSelectElement;\n  \"slot\": HTMLSlotElement;\n  \"small\": HTMLElement;\n  \"source\": HTMLSourceElement;\n  \"span\": HTMLSpanElement;\n  \"strong\": HTMLElement;\n  \"style\": HTMLStyleElement;\n  \"sub\": HTMLElement;\n  \"summary\": HTMLElement;\n  \"sup\": HTMLElement;\n  \"table\": HTMLTableElement;\n  \"tbody\": HTMLTableSectionElement;\n  \"td\": HTMLTableDataCellElement;\n  \"template\": HTMLTemplateElement;\n  \"textarea\": HTMLTextAreaElement;\n  \"tfoot\": HTMLTableSectionElement;\n  \"th\": HTMLTableHeaderCellElement;\n  \"thead\": HTMLTableSectionElement;\n  \"time\": HTMLTimeElement;\n  \"title\": HTMLTitleElement;\n  \"tr\": HTMLTableRowElement;\n  \"track\": HTMLTrackElement;\n  \"u\": HTMLElement;\n  \"ul\": HTMLUListElement;\n  \"var\": HTMLElement;\n  \"video\": HTMLVideoElement;\n  \"wbr\": HTMLElement;\n}\n\n```\n\n# Class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","TypeScript"],"categories":["学习笔记"]},{"title":"Vue笔记[六]-Vue3","url":"/article/63b3ee69.html","content":"\n# Vue3\n[Vue3](https://cn.vuejs.org/) 是由**尤雨溪**等[99位贡献者](https://github.com/vuejs/vue-next/graphs/contributors)开发的一款前端框架。于 2020/09/18 正式发布，耗时2年多、[2600+次提交](https://github.com/vuejs/vue-next/graphs/commit-activity)、[30+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)，在这里，框架将授予你「**声明式**」、「**组件化**」的编程模型，导引「**响应式**」之力。你将扮演一位名为「**CV工程师**」的神秘角色在自由的编码中邂逅样式各异、功能独特的组件库们，和他们一起解决问题，完成多样的需求——同时，逐步发掘「**组合式API**」的真相。\n\n**注意：**尽管 Vue3 兼容大部分 Vue2 写法，但组合式 API 写法下，最好不要混用\n\n# Vue-cli创建工程\nVue3 推荐使用 [Vite]() 来创建工程，但刚学完 vue2 还是接着用 Vue-cli 把 Vue3 新的语法学完，再去学习 Vite 和 [pinia](https://pinia.web3doc.top/) 的使用吧\n\n工程结构和 vue2 中的一样，但文件内有些变化：\n\n```js main.js\n// 引入的不再是Vue构造函数\n// 而是createApp工厂函数，无需通过new去调用\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n// 创建应用实例，类似vm，但比vm更轻\nconst app = createApp(App)\n// 挂载\napp.mount('#app')\n\n```\n\n单文件组件模板可以没有根元素\n\n```html\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <HelloWorld msg=\"Welcome to Your Vue.js App\"/>\n</template>\n```\n\n# 初识setup\n**setup** 是 Vue3 中一个新的**配置项**，值为一个**函数**。\n\n组件中所有的数据、方法都要配置在 **setup** 中\n\nsetup函数有两种返回值\n(1) 返回一个**对象**，对象中的所有属性都可以在组件模板中使用\n(2) 返回一个**渲染函数**，会替换掉组件模板（基本用不到）\n\nsetup 执行是在创建实例之前，也就是 **beforeCreate** （之前）执行，所以 setup 函数中的 this 不是组件的实例，而是undefined，setup是**同步**的\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"showName\">点击</button>\n</template>\n<script>\nexport default {\n  name: 'App',\n  // setup配置项\n  setup(){\n    // 定义一些数据和方法\n    let name = 'chuckle';\n    let age = 20;\n    function showName(){\n      alert(name);\n    }\n    // 返回一个对象\n    return {\n      name,\n      age,\n      showName,\n    }\n  }\n}\n</script>\n\n```\n\n# < script setup >\n在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。可以通过构建工具来简化该操作。\n\n给 `<script>` 标签加上 **setup** 属性，里面的代码会被编译成 `setup()` 函数的内容\n\n与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，`<script setup>` 中的代码会在每次组件实例被创建的时候执行\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"showName\">点击</button>\n</template>\n<script setup>\n// 定义一些数据和方法\nlet name = 'chuckle';\nlet age = 20;\nfunction showName() {\n  alert(name);\n}\n</script>\n\n```\n\n**setup带来的改变：**\n1. 解决了vue2的data和methods方法相距太远，无法组件之间复用\n2. 提供了script标签引入共同业务逻辑的代码块，顺序执行\n3. script变成setup函数，默认暴露给模版\n4. 组件直接挂载，无需注册\n5. 自定义的指令也可以在模版中自动获得\n6. this不再是这个活跃实例的引用\n7. 带来的大量全新api，比如defineProps，defineEmits，withDefault，toRef，toRefs\n\n# 响应式\n对比探究 Vue3 中的响应式使用与实现\n\n## ref函数\n`setup()` 返回的数据并没有自带**响应式**的效果，在 Vue3 中要实现响应式，需要使用 `ref()` 对数据进行处理\n\n**作用：**用 `ref()` 定义**响应式**变量，将**传入的值**包装为一个带 **value** 属性的 ref 对象（**引用实现对象**），允许我们创建可以使用**任何值类型**的**响应式**数据\n\nJS 中需要 **.value** 才能获取或修改数据，模板中直接写 ref 对象名\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"change\">改变</button>\n</template>\n<script setup>\n// Vue3 遵循按需引入的理念，所以许多 vue 中的东西需要引入后才能使用\nimport { ref } from 'vue';\n// 定义一些数据和方法\nlet name = ref('chuckle');\nlet age = ref(20);\n// 修改数据，响应式\nfunction change() {\n  name.value = 'qx';\n  age.value = 19;\n}\n</script>\n\n```\n\n`ref()` 传入值为**基本数据类型**时，其响应式本质和 vue2 一样，是通过 `Object.defineProperty()` 的 **getter** 和 **setter** 进行**数据劫持**和**数据代理** 实现的\n\n```js\nRefImpl {__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: 'chuckle', _value: 'chuckle'}\ndep: Set(1) {ReactiveEffect}\n__v_isRef: true\n__v_isShallow: false\n_rawValue: \"chuckle\"\n_value: \"chuckle\"\n// 熟悉的(...)数据代理\nvalue: (...) // \"chuckle\"\n[[Prototype]]: Object\n  constructor: class RefImpl\n  // 熟悉的(...)数据劫持，添加get和set\n  value: (...) //\"chuckle\"\n  // 熟悉的 getter 和 setter\n  get value: ƒ value()\n  set value: ƒ value(newVal)\n  [[Prototype]]: Object\n\n```\n\n`ref()` 传入值为**对象类型**时，会去调用 `reactive()` 处理 **value**，而 `reactive()` 返回一个 **Proxy** 类型的对象\n\n暂时看不懂的东西：\n\n```js\nRefImpl {__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: {…}, _value: Proxy(Object)}\ndep: undefined\n__v_isRef: true\n__v_isShallow: false\n_rawValue: {a: 1, b: 2}\n_value: Proxy(Object)\n  [[Handler]]: Object\n  [[Target]]: Object\n  [[IsRevoked]]: false\nvalue: Proxy(Object)\n  [[Handler]]: Object\n  [[Target]]: Object\n    a: 1\n    b: 2\n  [[Prototype]]: Object\n  [[IsRevoked]]: false\n[[Prototype]]: Object\n\n```\n\n## reactive函数\n`reactive()` 传入一个**对象类型**，返回该对象类型的代理对象（**Proxy**的实例对象，简称**proxy**对象）\n\n`reactive()` 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的**原始类型**无效\n\n**proxy** 对象直接用变量名访问数据，无需 .value\n\n可以直接通过下标**响应式**地修改数组数据，这是通过 **defineProperty** 实现的响应式所做不到的\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"change\">改变</button>\n  <h3>{{ obj.a }}</h3>\n  <h3>{{ obj.b }}</h3>\n  <h3>{{ arr.toString() }}</h3>\n</template>\n\n<script setup>\nimport { ref, reactive } from 'vue';\n// 定义一些数据和方法\nlet name = ref('chuckle');\nlet age = ref(20);\nlet obj = reactive({\n  a: 1,\n  b: 2,\n});\nlet arr = [1,2,3];\n// 修改数据，响应式\nfunction change() {\n  name.value = 'qx';\n  age.value++;\n  // proxy对象无需.value，可以直接访问\n  obj.a = 10;\n  obj.b++;\n  // 可以直接通过下标响应式地修改数组\n  arr[0] = 10;\n}\n</script>\n\n```\n\n在**定义响应式数据**时，通常基本数据类型用 `ref()`，引用数据类型用 `reactive()`\n\n但由于 `ref()` 定义的响应式数据需要 **.value** 才能获取和修改数据值，所以也通常将基本数据类型扔进一个对象中，然后用 `reactive()`，可以省去 **.value**\n\n## Vue2的响应式原理\n依靠 `Object.defineProperty()`\n\n**实现原理：**\n1. **基本数据类型：**通过 **defineProperty** 进行数据劫持与代理\n2. **对象类型：**深度遍历对象，通过 **defineProperty** 进行数据劫持与代理\n3. **数组类型：**通过重写更新数组的一系列方法（push等）\n\n**存在问题：**\n1. 深度遍历对象存在性能与效率问题\n2. 对象新增、删除属性，无法响应式，需用 $set 和 $delete\n3. 直接通过下标修改数组，无法响应式\n\n## Vue3的响应式原理\n依靠 ES6 中新的 API `window.Proxy()` 构造函数，解决了 Vue2 响应式中的问题\n\n`Proxy()` 返回 **proxy** 对象，它可以代理对**源数据**中**任何属性**的**任何操作**\n\n`Proxy()` 传入两个参数，第一个：要代理的源数据，第二个：一个配置对象，其中有 get、set 等方法，用于设置拦截\n如果Proxy的第二个参数（配置对象）没有设置任何拦截，就等同于直接访问原对象\n\n尝试使用 `Proxy()` 实现代理数据操作：\n\n```js\n// 源数据\nlet obj = {\n  name: 'chuckle',\n  age: 20\n}\n// 通过Proxy实例代理对源数据的增删改查操作\nconst agent = new Proxy(obj, {\n  // 对操作的拦截配置\n  // 获取属性值\n  get(target, propName){\n    console.log(`读取了${propName}属性`);\n    // 返回源数据的值\n    return target[propName]\n  },\n  // 修改属性值、新增属性\n  set(target, propName, value){\n    console.log(`修改或新增了${propName}属性，去响应式地更新视图`);\n    // 实际地修改源数据的值\n    target[propName] = value\n  },\n  // 删除属性\n  deleteProperty(target, propName){\n    console.log(`删除了${propName}属性，去响应式地更新视图`);\n    // 实际地删除源数据地属性，返回删除成功与失败地布尔值\n    return delete target[propName]\n  }\n});\n\n```\n\n<img src=\"https://cdn.chuckle.top/images/58-3.webp\" width=\"260px\" loading=\"lazy\">\n\n**注意：**后续在 proxy 对象上添加新属性也是响应式的\n\n虽然上面已经模仿实现了\"响应式\"，但 Vue3 中还用到了 `window.Reflect` 对象\n\n`Proxy()` 用于**代理**（代理对数据的操作），`Reflect` 用于**反射**（实际对数据的操作）\n\n**Reflect 用法：**\n1. `Reflect.get(target, prop)` **获取**某个对象（target）中某个属性（prop）的值\n2. `Reflect.set(target, prop, value)` **修改**某个对象中某个属性的值为value\n3. `Reflect.deleteProperty(target, prop)` **删除**某个对象中的某个属性\n\nReflect 身上还有很多方法，ECMA 也在将原本 Object 中的方法移植到 Reflect 中\n\n```js\n// 源数据\nlet obj = {\n  name: 'chuckle',\n  age: 20\n}\n// 通过Proxy代理对源数据的增删改查操作\nconst agent = new Proxy(obj, {\n  // 对操作的拦截配置\n  // 获取属性值\n  get(target, propName){\n    console.log(`读取了${propName}属性`);\n    // 返回源数据的值\n    return Reflect.get(target, propName)\n  },\n  // 修改属性值、新增属性\n  set(target, propName, value){\n    console.log(`修改或新增了${propName}属性，去响应式地更新视图`);\n    // 实际地修改源数据的值\n    return Reflect.set(target, propName, value)\n  },\n  // 删除属性\n  deleteProperty(target, propName){\n    console.log(`删除了${propName}属性，去响应式地更新视图`);\n    // 实际地删除源数据地属性，返回删除成功与失败地布尔值\n    return Reflect.deleteProperty(target, propName)\n  }\n});\n\n```\n\n**MDN 文档：**[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 与 [Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)\n\n**总结 Vue3 响应式的实现原理:**\n1. **通过Proxy（代理）：**拦截对象中任意属性的变化, 包括增删改查等。\n2. **通过Reflect（反射）：**对源对象的属性进行实际操作。\n\n# props声明\n和 Vue2 一样，一个组件需要显式声明它所接受的 props\n\n`<script setup>` 的单文件组件中，props 可以使用 `defineProps()` 宏来声明\n\n```html\n<script setup>\nimport { defineProps } from 'vue';\nconst props = defineProps(['foo'])\nconsole.log(props.foo)\n</script>\n```\n\n没有使用 `<script setup>` 的组件中，prop 可以使用 props 选项来声明：\n\n```js\nexport default {\n  props: ['foo'], // 声明props\n  setup(props) {\n    // setup() 接收 props 作为第一个参数\n    console.log(props.foo)\n  }\n}\n```\n\nprops 也是一个 proxy 对象，也能实现响应式\n\n**注意：**所有的 props 都遵循着**单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而**不会逆向传递**，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，不应该在子组件中去更改一个 prop。\n\n# context上下文\n**context** 是 `setup(props, context)` 的第二个参数，代表上下文\n\ncontext 中有一些属性和方法\n1. **attrs** 没有接收的 prop 都会出现在里面\n2. `emit()` 触发父组件绑定来的自定义事件\n3. **slots** 没有接收的 slot 都会出现在里面\n\n`<script setup>` 中 useContext() 已经废弃\n\n需要使用独立的 API 获取原本 context 中的属性和方法：\n1. `useAttrs()` 没有接收的 prop 都会出现在里面\n2. `defineEmits()` 接收父组件绑定的自定义事件\n3. `useSlots()`  获取父组件中插槽传递的所有虚拟Dom对象，按插槽名字区分\n\n需要引入后使用：\n\n```js\nimport { useAttrs,defineEmits, useSlots } from 'vue';\n```\n\n**1、**`useAttrs()`\n\n```html\n<!-- 父组件 -->\n<student :a=\"1\" b=\"giggles\"></student>\n\n<!-- 子组件 -->\n<script setup>\n// 接收a\nconst props = defineProps(['a'])\nconsole.log(props)\n// 没接收的b会在里面\nconst attrs = useAttrs();\nconsole.log(attrs) // 一个proxy对象\n</script>\n\n```\n\n**2、**`defineEmits()`\n\n```html\n<!-- 父组件 -->\n<student @emitTest=\"emitTest\"></student>\n<script setup>\nfunction emitTest(value) {\n  console.log(value);\n}\n</script>\n\n<!-- 子组件 -->\n<script setup>\n// 接收自定义事件\nconst emit = defineEmits(['emitTest']);\n// 触发自定义事件\nemit('emitTest', name)\n</script>\n\n```\n\n**3、**`useSlots()`\n\n```html\n<!-- 父组件 -->\n<student>\n  <template #slotTest>\n    <h2>插槽</h2>\n  </template>\n</student>\n\n<!-- 子组件 -->\n<slot name=\"slotTest\"></slot>\n<script setup>\nconst slots = useSlots();\nconsole.log(slots)\n</script>\n\n```\n\n# defineExpose函数\n子组件通过 `defineExpose()` 向父组件暴露数据\n\n当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 { a: number, b: number } (ref 会和在普通实例中一样被自动解包)\n\n```html\n<!-- 父组件 -->\n<student ref=\"stu\"></student>\n<script setup>\n// 接收子组件\nlet stu = ref(null);\nonMounted(() => {\n  console.log(stu.value.name); // chuckle\n  console.log(stu.value.city); // 北京\n})\n</script>\n\n<!-- 子组件 -->\n<script setup>\nlet name = ref(\"chuckle\");\nlet city = ref(\"北京\");\n// 暴露数据\ndefineExpose({\n  name,\n  city\n})\n</script>\n\n```\n\n# computed计算属性\n`computed()` 接受一个 getter 函数，返回一个只读的响应式 **ref** 对象。该 ref 通过 .value 暴露 getter 函数的返回值。也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\n\n```js\nimport { computed } from 'vue';\nlet person = reactive({\n  firstName: '张',\n  lastName: '三'\n})\nlet name = computed(()=>{\n  return person.firstName + person.lastName;\n})\n\n// 可读写的：\nlet refObj = computed({\n  get(){},\n  set(value){}\n})\n\n```\n\n# watch函数\n`watch()` 监视一个或多个**响应式数据源**，并在数据源变化时调用所给的**回调函数**。\n\n返回值是一个用来停止监听的的函数\n\n**基本使用：**\n\n```js\nwatch(refObj, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n}, {\n  // 配置对象\n  deep: true,\n})\n```\n\n1、可以同时监视多个响应式数据，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\n\n```js\nwatch([name, age], ([newName, newAge], [oldName, oldAge]) => {})\n```\n\n2、当监听一个 **reactive** 定义的 **proxy** 响应式对象时，侦听器会强制启用**深层模式**，但回调函数收到的**新值**和**旧值**参数将是同一个对象\n\n```js\nlet person = reactive({\n  firstName: '张',\n  lastName: '三'\n})\nwatch(person, (newValue, oldValue)=>{\n  console.log(newValue,oldValue);\n  // Proxy(Object){firstName: '张一', lastName: '三'} \n  //Proxy(Object){firstName: '张一', lastName: '三'}\n  console.log(newValue===oldValue); // true\n})\n\n```\n\n3、监听 **proxy** 对象中某一个**基本数据类型**的属性，**新值**和**旧值**可以正常获取，但监听对象需写成**函数返回值形式**\n\n```js\nlet person = reactive({\n  a: { b: 1, c: 2 }\n})\nwatch(()=>person.a.b, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n```\n\n4、监听 **proxy** 对象中某一个**对象类型**的属性，**新值**和**旧值**是同一个对象\n\n```js\nlet person = reactive({\n  a: { b: 1, c: 2 }\n})\nwatch(person.a, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n```\n\n5、若监视一个使用 `ref()` 定义的**对象类型**的**响应式数据**，则需要 **deep: true** 开启深度监视，或去监视其 **.value**（此时value是一个proxy对象，会自动开启深度监视）\n\n```js\nlet person = ref({\n  a: { b: 1, c: 2 }\n})\nwatch(person, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n},{\n  deep: true, // 直接监视ref对象需要手动开启深度监视\n})\n// 也可以去监视其.value\nwatch(person.value, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n\n```\n\n# watchEffect函数\n`watchEffect()` **立即运行**一个回调函数，同时响应式地追踪其**依赖**，并在**依赖更改**时**重新执行**回调\n\n返回值是一个用来停止监听的的函数\n\n```js\nconst count = ref(0)\nwatchEffect(() => console.log(count.value)) // 立即执行回调，输出 0\ncount.value++ // 重新执行回调，输出 1\n```\n\n和计算属性有些像，计算属性重在最后的返回值，而watchEffect重在逻辑过程，而返回值确定\n\n# Vue3生命周期\nVue3 [生命周期钩子](https://cn.vuejs.org/api/composition-api-lifecycle.html)名称改为了 on 开头，但作用和 Vue2 中的差不多，但也添加了一些新钩子，有需要在文档中查看用法\n\n**Vue3 生命周期图：**\n\n<img src=\"https://cdn.chuckle.top/images/58-2.webp\" width=\"80%\" loading=\"lazy\">\n\n# 自定义hook\n**hook** 本质是一个函数。\n**自定义hook**，就是将 setup 中使用过的**组合式API**进行封装，写在一个单独的 JS 文件中并暴露出去，实现**代码复用**，命名通常以 use 开头，集中放在 hooks 文件夹中\n\n**作用：**在 Vue3 中通过**组合式函数**实现 JS 代码复用，而**避免**使用 mixin 混入\n\n**组合式函数：**是一个利用 Vue 的组合式 API 来封装和复用**有状态**和**相关逻辑**的**函数**。\n\n**案例：**写一个实时返回鼠标坐标的 hook，让任何组件引入即可使用\n\n```js /hooks/useMouse.js\nimport { reactive, onMounted, onBeforeUnmount } from \"vue\"\n// 暴露出该hook函数\nexport default function (){\n  // 状态\n  let coordinate = reactive({\n    x: 0,\n    y: 0,\n  })\n  // 修改状态\n  function monitorMouse(event){\n    coordinate.x = event.pageX;\n    coordinate.y = event.pageY;\n  }\n  // 组件挂载完开始监听\n  onMounted(()=>{\n    window.addEventListener('mousemove', monitorMouse)\n  })\n  // 组件卸载前结束监听\n  onBeforeUnmount(()=>{\n    window.removeEventListener('mousemove', monitorMouse)\n  })\n  // 将状态返回出去给组件使用\n  return coordinate\n}\n\n```\n\n组件中展示鼠标坐标，非常方便，引入hook并执行，获取状态，然后使用状态\n\n```html\n<template>\n  <!-- 使用hook函数返回的状态 -->\n  <span>X：{{ coordinate.x }} Y：{{ coordinate.y }}</span>\n</template>\n<script setup>\n// 引入hook\nimport useMouse from '@/hooks/useMouse';\n// 执行hook函数获取数据\nlet coordinate = useMouse();\n</script>\n\n```\n\n# toRef与toRefs\n`toRef()` 可以将值、refs 或 getters 规范化为 refs\n也可以基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性**保持同步**：改变源属性的值将更新 ref 的值，反之亦然\n\n```js\nlet refObj = toRef(proxyObj, 'propName');\n```\n\n为什么要用 `toRef()`：\n当直接解构 proxy 响应式对象时，对于属性值是**基本数据类型**的属性，传的是值，而非引用地址，解构后的变量会失去响应式的功能\n\n```html\n<template>\n  <h3>{{ a }}</h3>\n  <h3>{{ b }}</h3>\n</template>\n<script setup>\nlet obj = reactive({\n  a: {\n    b: 1,\n    c: 2,\n  }\n})\n// 解构obj\nlet a = obj.a; // 传的地址，响应式仍在\nconsole.log(a); // Proxy(Object) {b: 1, c: 2}\nlet b = obj.a.b; // 传的数值，响应式丢失\nconsole.log(b); // 1\n</script>\n\n```\n\n使用 `toRef()` 可以不用重新将解构的值通过 `ref()` 创建一个**独立**的 **ref** 对象，而是直接用源对象中的属性，通过引用关系，创建一个对应的 **ref** 对象，与其源属性**保持同步**\n\n```js\nlet obj = reactive({\n  a: { b: 1, c: 2 }\n})\n// 创建一个对应的 ref\nlet b = toRef(person.a, 'b');\nconsole.log(b);\n// ObjectRefImpl {_object: Proxy(Object), _key: 'b', _defaultValue: undefined, __v_isRef: true}\n```\n\n`toRefs()` 功能与 `toRef()` 差不多，但可以批量处理某个 proxy 对象中的所有属性(浅层)，返回一个对象，对象中存着源对象属性对应的 ref 对象\n\n```js\nlet refArr = toRefs(proxyObj);\n```\n\n**总结：**`toRef()`创健一个 ref 对像，其 value 值指向另一个对象中的某个属性\n\n# 其它组合式API\n介绍较不常用的组合式API\n\n## 响应式数据的判断\n1、`isRef()` 检查某个值是否为 ref 对象\n2、`unref()` 如果参数是 ref，则返回其 value 值，否则返回参数本身\n2、`isProxy()` 检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理\n3、`isReactive()` 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理\n\n## 浅层响应式\n`shallowReactive()` reactive() 的浅层作用形式，只对**浅层属性**进行响应式处理\n\n`shallowRef()` ref() 的浅层作用形式，只有浅层的 value 是响应式的\n\n## 只读API\n`readonly()​` 深层的只读，接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理\n\n`shallowReadonly()` 浅层的只读\n\n## toRaw、markRaw\n`toRaw()` 根据一个 Vue 创建的 **proxy** 代理对象返回其**原始对象**的引用地址\n\n`markRaw()` 将一个对象标记为不可被转为 **proxy** 代理。返回该对象本身。可以让某些数据追加到 proxy 对象上后没有响应式功能。\n\n## 自定义ref\n`customRef()` 创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。\n\n接收一个工厂函数作为参数，这个工厂函数接受 **track** 和 **trigger** 两个函数作为参数，并返回一个带有 get 和 set 方法的对象\n\n`track()` 追踪数据变化，`trigger()` 重新解析模板\n\n**作用：**用于防抖、延迟更新视图等需求\n\n```js\nimport { customRef } from 'vue'\nfunction myRef(value){\n  return customRef((track, trigger)=>{\n    return {\n      get() {\n        track() // 追踪数据变化\n        return value\n      },\n      set(newValue) {\n        value = newValue\n        trigger() // 重新解析模板\n      }\n    }\n  })\n}\n\n```\n\n## 依赖注入\n`provide()` 祖先组件提供一个值，可以被后代组件注入。接受两个参数：第一个参数是要注入的 key（名字），第二个参数是要注入的值\n\n`inject()` 注入一个由祖先组件或整个应用 (app.provide()) 提供的值。\n\n通过这两个 API 可以实现祖先与后代组件的通信，非常方便\n\n```js\n// 祖先组件\nimport { provide } from 'vue';\nlet person = reactive({\n  firstName: '张',\n  lastName: '三',\n})\nprovide('person',person)\n\n// 后代组件\nimport { inject } from 'vue';\nlet person = inject('person');\nconsole.log(person); // 获取成功\n\n```\n\n**注意：**`provide()`、`inject()` 必须在组件的 setup() 阶段同步调用\n\nVue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，inject() 将返回 undefined，除非提供了一个默认值。\n\n# Fragment组件\n在 Vue2 中，组件模板必须有一个根标签\n\n在 Vue3 中，若模板中没有根标签，会将模板包含在一个 fragment 虚拟元素中，不会被实际渲染出来\n\n# Teleport组件\n`<teleport to=\"\">` 可以将组件模板、插槽移动到指定的任意元素中（尾插），to 中写 css 选择器\n\n一个简单的弹窗组件：\n\n```html\n<template>\n  <div>\n    <button @click=\"showPopUp\">点击显示弹窗</button>\n    <teleport to='body'>\n      <div class=\"popup-mask\" v-show=\"popup.isShow\">\n        <div class=\"popup\">\n          <h3>弹窗内容</h3>\n          <button @click=\"showPopUp\">关闭弹窗</button>\n        </div>\n      </div>\n    </teleport>\n  </div>\n</template>\n\n<script setup>\nimport { reactive } from 'vue';\nlet popup = reactive({\n  isShow: false,\n})\nfunction showPopUp() {\n  popup.isShow = !popup.isShow;\n}\n</script>\n\n<style lang=\"less\" scoped>\n.popup-mask {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.popup {\n  position: relative;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 200px;\n  height: 300px;\n  background: rgb(60, 60, 60);\n  text-align: center;\n}\n</style>\n\n```\n\n# Suspense组件(实验)\n**作用：**异步地动态加载子组件，父组件加载完就直接显示，不等待异步的子组件\n\n将要异步加载的子组件使用 `<Suspense>` 包裹\n\n`<Suspense>` 提供两个有名插槽，default 最终要加载的子组件，fallback 子组件还未加载出来时展示的模板\n\n```html\n<template>\n  <div class=\"app\">\n    <h3>我是App组件</h3>\n    <Suspense>\n      <!-- default插槽 -->\n      <template v-slot:default>\n        <Child/>\n      </template>\n      <!-- fallback插槽 -->\n      <template v-slot:fallback>\n        <h3>加载中.....</h3>\n      </template>\n    </Suspense>\n  </div>\n</template>\n\n```\n\n除了 `<Suspense>` 还可以使用 `defineAsyncComponent()` 异步引入组件\n\n```js\nimport { defineAsyncComponent } from 'vue'\nconst Child = defineAsyncComponent(()=>import('./components/Child.vue'))\n```\n\n异步引入组件后：\n(1) 该组件的 setup() 就可以是 async 函数，可以用 await，可以返回 promise 对象。\n(2) `<script setup>` 中也可以使用顶层 await。结果代码会被编译成 async setup()\n\n# Vue3的其它变化\n**1、全局 API 的转移：**`Vue.xxx` 调整到应用实例 `app` 上\n\n| 2.x 全局 API（`Vue`） | 3.x 实例 API (`app`)                        |\n| ------------------------- | ------------------------------------------- |\n| Vue.config.xxxx           | app.config.xxxx                             |\n| Vue.config.productionTip  | <strong style=\"color:#DD5145\">移除</strong>，因为不再有生产提示 |\n| Vue.component             | app.component                               |\n| Vue.directive             | app.directive                               |\n| Vue.mixin                 | app.mixin                                   |\n| Vue.use                   | app.use                                     |\n| Vue.prototype             | app.config.globalProperties                 |\n\n**2、Vue动画中过度类名的更改：**\n\n```css Vue2 写法\n.v-enter,\n.v-leave-to {\n  opacity: 0;\n}\n.v-leave,\n.v-enter-to {\n  opacity: 1;\n}\n```\n\n```css Vue3 写法\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n.v-leave-from,\n.v-enter-to {\n  opacity: 1;\n}\n```\n\n**3、**keyCode 不再作为 v-on 的修饰符，同时也不再支持 `config.keyCodes`\n\n**4、**移除 `v-on.native` 修饰符\n\n**5、**移除过滤器 **filter**\n\n**6、**父组件给子组件绑定自定义事件，子组件中需要接收才能使用，\n(1) `defineEmits()` 接收父组件绑定的自定义事件\n(2) 或者选项式中的 emits 配置项\n\n> THE END\n\n\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[五]-路由","url":"/article/ade78509.html","content":"\n# 路由route\n前端路由用于实现 **SPA应用**（单页Web应用）\n\n**SPA应用：**\n(1) 整个应用只有一个完整的页面\n(2) 点击导航区不刷新页面，只做页面的局部更新\n(3) 数据需要通过 ajax 请求获取\n\n每个路由都是**路径**与**组件**的**映射关系**，当浏览器的路径改变时，对应的组件就会显示\n\n# 路由基本使用\n在 Vue 中使用路由需安装 [vue-router](https://router.vuejs.org/) 插件\n\n**安装：** `npm install vue-router` ，最新版本仅支持 Vue3，Vue2 需使用 vue-router@3\n\n**使用步骤：**\n(1) 创建路由器\n(2) 注册路由\n(3) 使用路由\n(4) 编写路由组件\n\n**注意：**\n(1) 不断切换路由时，路由组件在重复地销毁和挂载，即**重复地**经过完整的**生命周期**\n(2) **vue-router** 插件会向 vm 和 vc 身上添加 `$route`（当前路由） 和 `$router`（全局路由器） 两个属性\n\n**1、创建路由器：**\n通常在 src 目录下新建 router/index.js\n\n使用 `new VueRouter()` 创建路由器实例\n\n```js /router/index.js\n// 该文件用于创建路由器\nimport VueRouter from 'vue-router';\nimport About from '@/pages/About.vue';\nimport Home from '@/pages/Home.vue';\n\n// 创建路由器\nexport default new VueRouter({\n  routes: [\n    // 一级路由\n    {\n      // 路由的路径\n      path: '/about',\n      // 路由对应展示的组件\n      component: About\n    },\n    {\n      path: '/home',\n      component: Home,\n    },\n  ]\n});\n\n```\n\n**2、注册路由：**\n在 `new Vue()` 时传入刚刚创建好的路由器实例\n\n因为 **vue-router** 是插件，还要 `Vue.use()` 安装插件\n\n```js main.js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport VueRouter from \"vue-router\";\n// 引入路由器\nimport router from \"@/router\"\n\nVue.config.productionTip = false;\n\nVue.use(VueRouter)\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n    // 使用路由器\n    router,\n})\n\n```\n\n**3、使用路由：**\n**vue-router** 提供了几个特殊标签来使用路由\n\n`<router-link>` 会被解析为 A 标签，点击后切换路由\n`<router-view>` 指定路由组件的呈现位置\n\n```html App.vue\n<template>\n  <div>\n    <!-- 使用router-link标签进行route切换 -->\n    <router-link to=\"/home\" active-class=\"active\">Home</router-link>\n    <router-link to=\"/about\" active-class=\"active\">About</router-link>\n    <!-- 路由组件呈现位置 -->\n    <router-view></router-view>\n  </div>\n</template>\n\n<!-- ....... -->\n\n```\n\n**4、编写路由组件：**\n**一般组件：**直接在另一个组件模板中写组件标签，一般放在 **components** 文件夹\n**路由组件：**配置在路由器中，通过切换路由动态展示和销毁，一般放在 **pages** 文件夹\n\n```html /pages/Home.vue\n<template>\n  <div>\n    <h2>我是Home组件</h2>\n  </div>\n</template>\n<!-- .... -->\n```\n\n```html /pages/About.vue\n<template>\n  <div>\n    <h2>我是About组件</h2>\n  </div>\n</template>\n<!-- .... -->\n```\n\n# 嵌套、多级路由\n**效果：**\n\n<img src=\"https://cdn.chuckle.top/images/57-2.webp\" loading=\"lazy\">\n\n使用 **children** 属性配置子路由\n\n```js /router/index.js\n// 该文件用于创建路由器\nimport VueRouter from 'vue-router';\nimport About from '@/pages/About.vue';\nimport Home from '@/pages/Home.vue';\nimport Message from '@/pages/HomePages/Message.vue';\nimport News from '@/pages/HomePages/News.vue';\n\n// 创建路由器\nexport default new VueRouter({\n  routes: [\n    // 一级路由\n    {\n      path: '/about',\n      component: About\n    },\n    {\n      path: '/home',\n      component: Home,\n      children: [\n        // 二级路由\n        {\n          // 多级路由不用再写斜杠\n          path: 'news',\n          component: News\n        },\n        {\n          path: 'message',\n          component: Message\n        }\n      ],\n    },\n  ]\n});\n\n```\n\n修改 Home.vue 组件加上二级路由切换\n\n```html /pages/Home.vue\n<template>\n  <div>\n    <h2>我是Home组件</h2>\n    <router-link to=\"/home/message\" active-class=\"active\">Message</router-link>\n    <router-link to=\"/home/news\" active-class=\"active\">News</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n<!-- .... -->\n\n```\n\n新建二级路由组件 Message.vue 和 News.vue\n\n```html Message.vue 和 News.vue\n<!-- Message.vue -->\n<template>\n  <div>\n    <h2>Home的二级路由Message</h2>\n  </div>\n</template>\n<!-- .... -->\n\n<!-- News.vue -->\n<template>\n  <div>\n    <h2>Home的二级路由News</h2>\n  </div>\n</template>\n<!-- .... -->\n\n```\n\n# route的属性\n**获取route：**组件中 `this.$route`，路由守卫中的 **to**、**from** 参数\n\n**route上常用属性：**\n1. **fullPath** 该路由的完整路径，带参数\n2. **meta** 一个对象，允许程序员自由地往里面加内容，可以在配置路由时就设置\n3. **name** 路由的名字\n4. **params** params参数\n5. **path** 路由路径\n6. **query** 查询字符串参数\n\n# 路由query传参\n通过 url 的 **query**（查询字符串）参数给子路由组件传参\n\n**使用：**\n\n```html /pages/HomePages/Message.vue\n<!-- 模板字符串写法 -->\n<router-link :to=\"`/home/message/detail?id=${item.id}&title=${item.title}`\">{{ item.title }}</router-link>\n<!-- 对象写法，推荐 -->\n<router-link :to=\"{\n  path: '/home/message/detail',\n  query: {\n    id: item.id,\n    title: item.title\n  }\n}\">\n{{ item.title }}</router-link>\n\n```\n\n子路由组件中通过 `$route.query.<key>` 获取 query 参数\n\n```html /pages/HomePages/MessageDetail.vue\n<h3>{{ $route.query.id }}</h3>\n<h3>{{ $route.query.title }}</h3>\n```\n\n# 命名路由\n给路由起名字，可以简化一些编码工作\n\n```js /router/index.js\n{\n  // 命名路由\n  name: 'Message',\n  path: 'message',\n  component: Message,\n  children: [\n    {\n      name: 'MessageDetail',\n      path: 'detail',\n      component: MessageDetail\n    }\n  ]\n}\n\n```\n\n使用 name 替代 path 配置，也能跳转路径\n\n```html /pages/HomePages/Message.vue\n<router-link :to=\"{\n  name: 'MessageDetail',\n  // path: '/home/message/detail',\n  query: {\n    id: item.id,\n    title: item.title\n  }\n}\">{{ item.title }}</router-link>\n\n```\n\n# 路由params传参\n使用 params 传参需要在路由 path 配置中写上 url 参数（占位符）\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  // 写上占位符\n  path: 'detail/:id/:title',\n  component: MessageDetail\n}\n```\n\n**传参：**使用 params 传参，路径只能用 name 写法，不能写 path\n\n```html /pages/HomePages/Message.vue\n<router-link :to=\"{\n  name: 'MessageDetail',\n  params: { //传params参数\n    id: item.id,\n    title: item.title\n  }\n}\">{{ item.title }}</router-link>\n```\n\n**获取参数：** `$route.params`\n\n```html /pages/HomePages/MessageDetail.vue\n<h3>{{ $route.params.id }}</h3>\n<h3>{{ $route.params.title }}</h3>\n```\n\n# 路由props配置\n在路由配置中加上 `props: true`，该路由组件收到的所有 **params 参数**都会以 **props** 形式呈现\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  path: 'detail/:id/:title',\n  component: MessageDetail,\n  // 写死数据，一般用不到\n  // props: {a:'1', b:'2'}\n  // 设置true，该路由组件收到的所有params参数都会以props形式呈现\n  props: true\n}\n\n```\n\n接收 props\n\n```js /pages/HomePages/MessageDetail.vue\nexport default {\n  name: 'MessageDetail',\n  // 接收props\n  props: ['id', 'title'],\n}\n```\n\n将 `props()` 写成**函数式**，参数是该路由 **$route** ，可以自定义返回值，不再局限于之前只能传 params 参数\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  path: 'detail/:id/:title',\n  component: MessageDetail,\n  // 解构赋值从$route中拿出params和query\n  props({params,query}){\n    return {\n      id: params.id,\n      title: query.title\n    }\n  }\n}\n```\n\n# replace属性\n`<router-link>` 的 **replace** 属性\n\n**作用：**控制路由跳转时，操作浏览器**历史记录**的模式为 **replace**\n\n操作浏览器历史记录有 **push**(默认) 和 **replace** 两种模式\n(1) push 追加历史记录\n(2) replace 替换当前记录，使浏览器不能通过后退返回之前的路径\n\n```html\n<router-link to=\"/home\" active-class=\"active\" replace>Home</router-link>\n<router-link to=\"/about\" active-class=\"active\" replace>About</router-link>\n```\n\n# 编程式路由\n不使用 `<router-link>` 标签，通过调用 `$router` 上的方法，来控制路由的跳转\n\n`$router` 原型上的 `push()` 和 `replace()` 方法分别以**push** 和 **replace** 两种模式跳转路由，都接收一个配置对象，内容和 **to** 属性中的一样\n\n```html /pages/HomePages/Message.vue\n<button @click=\"pushShow(item)\">push跳转</button>\n<button @click=\"replaceShow(item)\">replace跳转</button>\n<!-- ...... -->\n<script>\n// ......\nmethods: {\n  pushShow(item){\n    this.$router.push({\n      name: 'MessageDetail',\n      params: {\n        id: item.id,\n        title: item.title\n      }\n    })\n  },\n  replaceShow(item){\n    this.$router.replace({\n      name: 'MessageDetail',\n      params: {\n        id: item.id,\n        title: item.title\n      }\n    })\n  }\n}\n// ......\n</script>\n\n```\n\n`$router` 的原型上还有其它方法\n(1) `back()` 后退\n(2) `forward()` 前进\n(3) `go()` 前进或后退几个历史记录\n\n在 vue-router 插件的某些版本，使用编程式路由时，相同路径跳转会报错，在路由配置文件中加上这段代码即可\n\n```js /router/index.js\n// 解决相同路径跳转报错的问题\n//先保存一份VueRouter\nlet originPush = VueRouter.prototype.push;\nlet originReplace = VueRouter.prototype.replace;\n//重写push|replace\n//第一个参数：往哪里跳（传递哪些参数）\nVueRouter.prototype.push = function(location,resolve,reject) {\n    if(resolve && reject) {\n        originPush.call(this,location,resolve,reject);\n    } else {\n        originPush.call(this,location,()=>{},()=>{});\n    }\n}\nVueRouter.prototype.replace = function(location,resolve,reject) {\n    if(resolve && reject) {\n        originReplace.call(this,location,resolve,reject);\n    } else {\n        originReplace.call(this,location,()=>{},()=>{});\n    }\n}\n\n```\n\n# 缓存路由组件\n切换路由，旧的路由组件会被销毁，在该组件中的用户输入等操作都会丢失\n\n要想切换路由不销毁旧的组件，可以将 `<router-view>` 放入 `<keep-alive>` 标签中，**include** 属性指定要缓存的组件名（默认全缓存）\n\n**作用：**让不展示的路由组件保持挂载，不被销毁\n\n```html /pages/Home.vue\n<router-link to=\"/home/message\" active-class=\"active\">Message</router-link>\n<router-link to=\"/home/news\" active-class=\"active\">News</router-link>\n<keep-alive include=\"News-\">\n  <router-view></router-view>\n</keep-alive>\n```\n\n# 两个新钩子\n`<keep-alive>` 给**能被其缓存**的**路由组件**添加了两个新的**生命周期钩子**\n\n(1) `activated()` 路由组件被**激活**时\n(2) `deactivated()` 路由组件**失活**时\n\n**作用：**在 `activated()` 中开启定时器、发AJAX请求等，在 `deactivated()` 中关闭定时器等\n\n# 路由守卫\n**作用：**对路由进行权限控制\n\n**分类：**全局守卫，独享守卫，组件内守卫\n\n在前端业务中，经常有需要配合后端校验权限后才能打开的页面，如个人中心、订单记录等等，通过路由守卫就能在切换路由前，对权限进行校验，然后控制切不切换页面（放行），或跳转到某一页面（登陆页）\n\n所有守卫本质都是**函数**，除了**全局后置守卫**没有第三个参数（next）之外，都有三个参数：\n(1) **to** 要切换的路由对象\n(2) **from** 切换前的路由对象\n(3) **next** 一个函数，无参时切换to的路由，有参时切换到指定路由\n\n三种守卫相互配合实现业务\n\n## 全局守卫\n**全局路由守卫：**监测所有路由的切换，只要切换路由，就会经过全局守卫的业务逻辑\n\n**分类：**\n(1) 全局**前置**守卫：在**切换路由前**触发的守卫\n(2) 全局**后置**守卫：在成功**切换路由后**触发的守卫\n\n**配置全局守卫：**在路由配置文件中，通过路由器上的两个方法配置全局守卫\n(1) `beforeEach(() => {})` 全局**前置**守卫\n(2) `afterEach(() => {})` 全局**前置**守卫\n\n```js\n/* ...... */\n// 全局前置守卫\nrouter.beforeEach((to, from, next) => {\n  console.log('切换路由前');\n  console.log(to);\n  console.log(from);\n  next();\n})\n// 全局后置守卫\nrouter.afterEach((to, from) => {\n  console.log('切换路由后');\n  console.log(to);\n  console.log(from);\n  // 动态地切换网页标题\n  if (to.meta.title) {\n    document.title = to.meta.title;\n  }\n})\n\n```\n\n## 独享守卫\n**独享路由守卫：** `beforeEnter()` 只监测某个路由，要切换到该路由，才触发该守卫\n\n**注意：**独享路由守卫没有后置，只在切换到该路由前触发\n\n```js\n// 创建路由器\nconst router = new VueRouter({\n  routes: [\n    {\n      name: 'About',\n      path: '/about',\n      component: About,\n      meta: {\n        title: '关于'\n      },\n      // 独享路由守卫\n      beforeEnter(to, from, next) {\n        console.log('切换到关于路由前');\n        console.log(to);\n        console.log(from);\n        // 做一些业务，这里让一秒后再切换\n        setTimeout(() => {\n          next();\n        }, 1000);\n      },\n    },\n\n    /* ...... */\n\n  ]\n});\n\n```\n\n## 组件内守卫\n**组件内路由守卫：**只在某一路由组件实例中生效的守卫，控制进入和离开该组件\n\n**分类：**\n(1) `beforeRouteEnter()` 通过路由规则 **要进入该组件前** 触发\n(2) `beforeRouteLeave()` 通过路由规则 **要离开该组件前** 触发\n\n```js\nexport default {\n  name: 'Home-',\n  // 通过路由规则 要进入该组件前 触发\n  beforeRouteEnter(to, from, next){\n    console.log('要进入该组件');\n    console.log(to);\n    console.log(from);\n    next();\n  },\n  // 通过路由规则 要离开该组件前 触发\n  beforeRouteLeave(to, from, next){\n    console.log('要进入该组件');\n    console.log(to);\n    console.log(from);\n    next();\n  }\n}\n\n```\n\n# 路由器两种工作模式\n**路由器有两种工作模式：**\n(1) **hash** 模式：url中带 **#** 号，如 localhost:8080/#/home\n(2) **history** 模式：url中不带 **#** 号 如 localhost:8080/home\n\n**1、hash 模式：**\n1. 对于 url 来说，# 号后面的内容都是 **hash 值**，**不会包含在 HTTP 请求的路径中**，# 号后面的路径只是 vue 路由器工作所需\n2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n3. 兼容性较好，无需后端特地去处理路径问题\n\n**2、history 模式：**\n1. url 样子较符合常理，也美观\n2. 项目上线后，需要后端去分辨前端路由和后端路由，返回不同的资源，解决 vue 这种单页应用程序切换路由后，刷新页面服务端404的问题，\n\n**mode** 配置，指定路由器工作模式\n\n```js\nconst router = new VueRouter({\n  // mode: 'hash',\n  mode: 'history',\n  /* ...... */\n})\n```\n\n**NodeJS-Express** 通过中间件 [connect-history-api-fallback](https://www.npmjs.com/package/connect-history-api-fallback) 自动处理路径问题\n\n# Element-UI\n组件化编码催生出了许多优秀的UI组件库，导入即可使用\n\n以 **Element-UI** 为例，vue2 使用 [Element](https://element.eleme.cn/)，vue3 用 [Element Plus](https://element-plus.gitee.io/)\n\n使用组件库更多的是去看其提供的文档\n\n**安装：** `npm i element-ui -S`\n\n**全部引入：**\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 全部引入\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\n\nVue.config.productionTip = false;\n\n// 使用ElementUI插件\nVue.use(ElementUI);\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n})\n\n```\n\n**按需引入：**\n\n安装 [babel-plugin-component](https://github.com/ElementUI/babel-plugin-component)\n\n修改 **babel.config.js**\n\n```js\nmodule.exports = {\n  presets: [\n    '@vue/cli-plugin-babel/preset',\n    [\"@babel/preset-env\", { \"modules\": false }]\n  ],\n  plugins: [\n    [\n      \"component\",\n      {\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      }\n    ]\n  ]\n}\n\n```\n\n然后就可以按需引入了\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 按需引入\nimport { Button,Row,DatePicker } from 'element-ui';\n\nVue.config.productionTip = false;\n\n// 按需使用\nVue.use(Button);\nVue.use(Row);\nVue.use(DatePicker);\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n})\n\n```\n\n**使用组件：**看文档，cv使用组件标签\n\n```html\n<el-button type=\"primary\">主要按钮</el-button>\n<el-date-picker\n  type=\"date\"\n  placeholder=\"选择日期\">\n</el-date-picker>\n```\n\n# 项目上线\n**打包：**`npm run build` 生成 **dist** 文件夹\n\n将打包出的文件部署到服务端，交给后端去搞\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[四]-动画、Vuex","url":"/article/4c286eee.html","content":"\n# 过渡与动画\nVue 封装了过渡与动画效果\n\n**作用：**在**插入**、**更新**、**移除** Dom 元素时，自动在合适的时刻在**过渡标签**上**添加**或**移除不同的类名**，只需写动画和过渡效果并应用到**对应时刻的类名**上，而无需手动操作 Dom \n\n**过渡标签：**\n(1) `<transition>` 包裹需要动画效果的**单个**元素\n(2) `<transition-group>` 包裹需要动画效果的**多个**元素，每个元素都需要配置 **Key** 属性\n\n**不同时刻样式类名：**\n(1) 控制元素**进入**的样式\n1. **v-enter** 进入的起点\n2. **v-enter-active** 进入过程中\n3. **v-enter-to** 进入的终点\n\n(2) 控制元素**离开**的样式\n1. **v-leave** 离开的起点\n2. **v-leave-active** 离开过程中\n3. **v-leave-to** 离开的终点\n\n过渡标签添加 **name** 属性来配置**类名的前缀**，默认是 **v**，如进入起点的类名是 **.v-enter** 或 **<前缀>-enter**\n\n**离开和进入：**即元素的**插入**、**更新**、**移除**，通常配合 **v-show**、**v-if** 来控制\n\n添加 `appear` 属性让动画在网页首次加载时、元素首次插入时也触发\n\n## 元素飞入飞出案例\n\n分别用**动画属性** `animate` 和**过渡属性** `transition` 配合不同的类名实现**相同的**动画效果\n\n<img src=https://cdn.chuckle.top/images/56-2.gif width=\"200px\" loading=\"lazy\">\n\n**模板结构：**\n\n```html\n<template>\n  <div>\n    <button @click=\"isShow=!isShow\">显示隐藏</button>\n    <transition name=\"hello\" appear>\n      <h1 v-show=\"isShow\" class=\"title\">你好</h1>\n    </transition>\n  </div>\n</template>\n```\n\n**交互：**\n\n```js\nexport default {\n  name: 'Test-',\n  data(){\n    return{\n      isShow: true,\n    }\n  }\n}\n```\n\n使用**动画属性** `animate` 配合 **.v-enter-active** 和 **.v-leave-active**\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n/* 进入过程的动画 */\n.hello-enter-active{\n  animation: titleShow 1s;\n}\n/* 离开过程的动画 */\n.hello-leave-active{\n  animation: titleShow 1s reverse;\n}\n/* 动画 */\n@keyframes titleShow{\n  from {\n    transform: translateX(-100%);\n  }\n  to{\n    transform: translateX(0px);\n  }\n}\n\n```\n\n**过渡属性** `transition` 配合进入和离开的起点、终点的样式实现动画\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n/* 设置进入起点的样式 */\n.hello-enter {\n  transform: translateX(-100%);\n}\n/* 设置进入终点的样式 */\n.hello-enter-to {\n  transform: translateX(0);\n}\n/* 设置离开起点的样式 */\n.hello-leave {\n  transform: translateX(0);\n}\n/* 设置离开终点的样式 */\n.hello-leave-to {\n  transform: translateX(-100%);\n}\n/* 设置 transition 属性 */\n.hello-enter-active, .hello-leave-active {\n  transition: 0.5s linear;\n}\n\n```\n\n## 第三方动画库\n有许多优秀的动画库，引入即可使用，以 [animate.css](https://www.npmjs.com/package/animate.css) 为例\n\n**安装：**`npm install animate.css --save`\n\n使用第三方库时，通常要在**过渡标签**上通过几个属性来自定义**样式类名的后缀**，name属性设置前缀\n(1) **enter-active-class** 属性：设置**进入过程中**的样式类名\n(2) **leave-active-class** 属性：设置**离开过程中**的样式类名\n\n**使用：**引入动画库后，在**过渡标签**上设置name前缀以使用该动画库，然后在[animate.css文档](https://animate.style/)中挑选动画效果，将进入动画的类名设置到 **enter-active-class** 属性中，离开动画的类名设置到 **leave-active-class** 属性中，通过**设置样式类名**后缀来使用具体的动画效果\n\n**案例：**\n\n<img src=\"https://cdn.chuckle.top/images/56-3.gif\" loading=\"lazy\">\n\n```js\n// 引入动画库\nimport 'animate.css'\nexport default {\n  name: 'Test-',\n  data() {\n    return {\n      isShow: true,\n    }\n  }\n}\n```\n\n**模板结构：**\n\n```html\n<template>\n  <div>\n    <button @click=\"isShow = !isShow\">显示隐藏</button>\n    <!-- 设置动画 -->\n    <!-- name设置前缀表示使用animate.css动画库 -->\n    <!-- 通过设置样式类名后缀来使用具体的动画效果 -->\n    <transition \n      name=\"animate__animated animate__bounce\" \n      enter-active-class=\"animate__swing\"\n      leave-active-class=\"animate__backOutUp\" \n      appear\n    >\n      <h1 v-show=\"isShow\" class=\"title\" key=\"1\">你好</h1>\n    </transition>\n  </div>\n</template>\n```\n\nCSS 样式，因为使用了动画库，就无需自己写动画了\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n```\n\n# ToDoList添加动画\n给 ToDoList 案例中每个todo  的新增和删除添加动画\n\n**效果：**\n\n<img src=\"https://cdn.chuckle.top/images/56-4.gif\" width=\"70%\" loading=\"lazy\">\n\n修改 **ToDoList.vue** 组件\n\n```html\n<template>\n  <div class=\"todo-list\">\n    <ul>\n      <transition-group name=\"todo\">\n        <ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\"></ListItem>\n      </transition-group>\n    </ul>\n  </div>\n</template>\n\n<!-- ...... -->\n\n<style>\n/* ........ */\n/* 动画 */\n.todo-enter,\n.todo-leave-to {\n  opacity: 0;\n  transform: translateX(-50%);\n}\n\n.todo-enter-to,\n.todo-leave {\n  opacity: 1;\n  transform: translateX(0);\n}\n.todo-enter-active, .todo-leave-active {\n    transition: all 0.3s;\n}\n</style>\n\n```\n\n# Vue中发请求\n在 Vue 中发请求通常用 [Axios](https://github.com/axios/axios)\n\n**安装：** `npm i axios`\n\nAxios 笔记: [AJAX请求相关-Axios](/article/f3334fd0.html#Axios)\n\n## Vue-cli配置代理\n当后端没有配置 **cors** 时，本地开发环境请求后端API就会产生**跨域**问题\n\n服务器之间通信没有跨域问题，可以在本地配置一个代理服务器去请求API\n\n在 **vue.config.js** 中添加 **devServer** 配置项，以在开发环境下将 API 请求代理到 API 服务器\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n    proxy: '<转发的url>' \n  }\n})\n```\n\n配置代理后，将请求的 baseURL 改为本地ip+端口，如 120.0.0.1:8080，代理服务会将请求转发，自己去请求实际的API地址，然后返回数据\n\n有些时候并不想所有发往自身获取资源的请求都被代理转发，实际想获取的是本地public文件夹下的资源，而不是远程API的\n\n可以写完整版 devServer 配置，匹配路径去选择性代理\n\n**作用：**可以配置多个代理，且可以灵活的控制发往本地的请求是否走代理转发\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n    proxy: {\n      // 匹配路径代理\n      '/api': {\n        target: '<url>', // 代理目标的baseURL\n        ws: true, // 用于支持websocket\n        changeOrigin: true, // 伪造Host为代理目标baseURL\n        pathRewrite: {'<正则匹配路径>', '<替换内容>'} // 重写路径\n      },\n      '/foo': {\n        target: '<other_url>'\n      }\n    }\n  }\n})\n\n```\n\n~~还是让后端配cors好~~\n\n## 获取所有账单\n在 NodeJS 中写过一个记账本案例，里面写了一套完整的 API，刚好拿来用\n\n[KeepingBook-API文档](https://console-docs.apipost.cn/preview/3d8ecc659c1e192b/da97e0b2ec13fd71)\n\n**功能：**点击登陆提示登陆中，登陆成功提示成功登陆，点击获取账单，提示加载中，请求成功后展示所有账单的列表\n\n<img src=\"https://cdn.chuckle.top/images/56-5.gif\" loading=\"lazy\">\n\n```html App.vue\n<template>\n  <div>\n    <button @click=\"login\">登录获取token</button>\n    <button @click=\"getData\">获取所有账单</button>\n    <!-- 提示 -->\n    <div v-show=\"tip !== ''\" class=\"tip\">{{ tip }}</div>\n    <ul>\n      <li v-for=\"(item, index) in kpb\" :key=\"item.id\">\n        {{ index + 1 }}： {{ item.matter }} | {{ item.date }} | {{ item.type }} | {{ item.account }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport axios from \"axios\";\naxios.defaults.baseURL = 'https://kpb.qcqx.cn';\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      // 登陆返回的token\n      token: \"\",\n      // 账单数据\n      kpb: \"\",\n      // 提示\n      tip: \"欢迎，请登陆\",\n    }\n  },\n  methods: {\n    // 登陆\n    login() {\n      this.kpb = \"\";\n      this.tip = \"登陆中....\";\n      axios({\n        url: '/api/login',\n        method: 'post',\n        data: {\n          username: 'qx',\n          password: '123'\n        },\n        // 请求超时\n        timeout: 5000\n      }).then(res => {\n        // 响应体对象\n        console.log(res.data);\n        this.token = res.data.data.token;\n        this.tip = \"登陆成功\";\n      }).catch(err => {\n        console.log(err);\n        this.tip = \"登陆失败\";\n      });\n    },\n    // 获取账单\n    getData() {\n      this.kpb = \"\";\n      this.tip = \"账单加载中....\";\n      axios({\n        url: '/api',\n        method: 'get',\n        headers: {\n          token: this.token\n        },\n        // 请求超时\n        timeout: 5000\n      }).then(res => {\n        // 响应体对象\n        console.log(res.data);\n        if (res.data.data === null) {\n          this.tip = res.data.msg;\n          return;\n        }\n        this.kpb = res.data.data;\n        this.tip = \"\";\n      }).catch(err => {\n        console.log(err);\n        this.tip = \"获取账单失败\";\n      });\n    }\n  }\n};\n</script>\n\n```\n\n# 插槽\n**插槽**是由**子组件**在模板的合适位置通过 `<slot>` 定义的\n\n**作用：**让父组件可以向子组件定义的**插槽**处插入 html 结构\n\n**插槽的种类：**\n(1) **默认插槽：**简单地将组件标签中所有html结构放到插槽处\n(2) **具名插槽：**通过 `<slot>` 上的 **name** 属性区分插槽，通过 `v-slot:<插槽名>` 将html插入到指定插槽\n(3) **作用域插槽：**用于**数据在子组件**中，且不将数据外传，根据数据生成的结构由父组件决定的情况\n\n**注意：**\n(1) 父组件中要插入插槽的html结构也是在父组件中完成模板解析的，可以访问父组件中的数据，而不能直接访问到自组件的数据\n(2) 三种插槽可以混合使用\n\n## 默认插槽\n简单地将组件标签中所有html结构放到插槽处\n\n```html 父组件\n<ListBox>\n  <ul>\n    <li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li>\n  </ul>\n</ListBox>\n```\n\n```html 子组件\n<!-- 定义插槽 -->\n<slot></slot>\n```\n\n## 具名插槽\n通过 `<slot>` 上的 **name** 属性区分插槽，通过 `v-slot:<插槽名>` 将html插入到指定插槽\n\n`v-slot:` 可以简写为 `#`\n\n```html 父组件\n<ListBox>\n  <template v-slot:list>\n    <ul><li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li></ul>\n  </template>\n  <!-- v-slot: 简写为 # -->\n  <template #other>\n    <h2>chuckle</h2>\n  </template>\n</ListBox>\n\n```\n\n```html 子组件\n<slot name=\"list\"></slot>\n<slot name=\"other\"></slot>\n```\n\n## 作用域插槽\n用于**数据在子组件**中，且不将数据外传，根据数据生成的结构由父组件决定的情况\n\n子组件通过 `<slot>` 的标签属性传数据给父组件（只能在组件标签中使用）\n父组件通过 `#<插槽名>=\"obj\"` 的 obj 接收一个**对象**，对象中有传过来的属性名和属性值（数据）\n\n```html 父组件\n<ListBox>\n  <!-- default代表无名插槽 -->\n  <template #default=\"{arr}\">\n    <ul><li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li></ul>\n  </template>\n  <!-- v-slot接收到的是一个对象 -->\n  <template #other=\"obj\">\n    <div>{{ obj.x }} | {{ obj.y }}</div>\n  </template>\n</ListBox>\n\n```\n\n```html 子组件\n<!-- 将子组件的数据传给父组件内的组件标签中使用 -->\n<slot :arr=\"arr\"></slot>\n<!-- 传给父组件多个数据 -->\n<slot name=\"other\" :x=\"x\" :y=\"y\"></slot>\n```\n\n# Vuex\n在实现**组件间通信**时，无论是**全局事件总线**还是**消息订阅与发布**，大量的声明事件或消息名，会让代码变得臃肿、难以维护\n\n[Vuex](https://github.com/vuejs/vuex) 是实现**集中式状态（数据）管理**的一个 Vue 插件，对 Vue 应用中多个组件的**共享状态**进行集中式的管理（读/写）\n\n**安装：** `npm install vuex --save` Vue2 只能使用 Vuex3\n\n**功能：**将原本某一组件管理的数据拿出来给 Vuex 管理，所有组件都能看到 Vuex 中管理数据的仓库 **Store**，以及使用仓库所提供的，对数据读和写的方法\n\n**何时用 Vuex 管理状态（数据）：**\n(1) 多个组件依赖于同一状态\n(2) 来自不同组件的行为需要变更同一状态\n\n## Vuex工作原理\n**Vuex 工作原理图：**\n\n<img src=\"https://cdn.chuckle.top/images/56-7.webp\" loading=\"lazy\">\n\nVuex 有**三个重要组成部分**，这三个部分都在 **Store** 实例上，本质都是**对象**\n1. **Actions：**进行一些业务逻辑（异步）的操作，如发送 AJAX 请求，不直接对数据进行操作\n2. **Mutations：**对数据进行直接的维护，有许多对数据进行操作的自定义方法\n3. **State：**状态（数据），存放着多个组件共享的数据\n\n**Vuex的工作循环：**\n1. 组件通过 `dispatch()` 调用 **Actions** 中的方法，触发一些业务逻辑\n2. **Actions** 中业务逻辑处理完后，在合适时机调用 `commit()` 触发 **Mutations** 中对数据进行直接操作的方法\n3. 然后 **State** 中数据**响应式**地变化，触发对应**视图更新**\n\n**注意：**如果对数据的操作不带有更多的业务逻辑，组件也可以直接调用 `commit()` 方法\n\n**Store：**由 `Vuex.Store()` 构造函数创建，提供了三个重要组成部分以及 `dispatch()` 、`commit()` 等各种API\n\n## 搭建Vuex环境\n新建一个JS文件，用于配置和创建 Store 实例，通常是 `src/store/index.js`\n\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 创建三个重要组成部分\nconst actions = {}\nconst mutations = {}\nconst state = {}\n\n// 创建store实例，并暴露出去\nexport default new Vuex.Store({\n  // 将三个重要部分都交给store管理\n  actions,\n  mutations,\n  state\n});\n\n```\n\n然后在 `new Vue()` 时将 **Store** 实例作为配置项传入\n\n**目的：**让 vm 和 vc 身上新增一个 **$store** 属性，让所有组件都能访问到数据仓库 **store**\n\n```js main.js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 引入store实例\nimport store from \"./store\";\n\nVue.config.productionTip = false;\n\nnew Vue({\n    el: \"#app\",\n    // 使用store\n    store,\n    render: h => h(App),\n})\n\n```\n\n## 纯Vue求和案例\n\n<img src=\"https://cdn.chuckle.top/images/56-6.webp\" loading=\"lazy\">\n\n```html App.vue\n<template>\n  <div>\n    <CountNum></CountNum>\n  </div>\n</template>\n\n<script>\nimport CountNum from \"./components/CountNum.vue\";\nexport default {\n  name: \"App\",\n  components: {\n    CountNum,\n  }\n};\n</script>\n\n```\n\n```html\n<template>\n  <div>\n    <h3>{{ sum }}</h3>\n    <select v-model.number=\"num\">\n      <option value=\"1\">1</option>\n      <option value=\"2\">2</option>\n      <option value=\"3\">3</option>\n    </select>\n    <button @click=\"add\">+</button>\n    <button @click=\"reduce\">-</button>\n    <button @click=\"addOdd\">当前总和是奇数再加</button>\n    <button @click=\"addWait\">延迟1s再加</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"CountNum\",\n  data() {\n    return {\n      // 总和\n      sum: 0,\n      // 选择的数字\n      num: 0,\n    }\n  },\n  methods: {\n    // 加\n    add() {\n      this.sum += this.num;\n    },\n    // 减\n    reduce(){\n      this.sum -= this.num;\n    },\n    // 当前总和是奇数再加\n    addOdd(){\n      if(this.sum%2){\n        this.sum += this.num;\n      }\n    },\n    // 延迟1s再加\n    addWait(){\n      setTimeout(()=>{\n        this.sum += this.num;\n      }, 1000)\n    }\n  },\n}\n</script>\n\n```\n\n## Vuex版求和案例\n对纯 Vue 版进行修改，将 sum 交给 vuex 的 store 管理，将直接对数据的操作放到 Mutations 中，将带有业务逻辑的操作放到 Actions 中\n\n**一些总结与注意：**\n1. 虽然 `$store.state.xxx = xxx` 直接修改数据，也能响应式更新视图，但这样做无法被 vuex-tools 所监视，所以**不要直接修改数据** \n2. `commit()` 和 `dispatch()` 都只能传入两个参数，第一个是要触发的**函数名**，第二个是传入的数据\n3. **actions** 中的函数收到两个参数，第一个 **context** 指上下文，是一个 mini 的 store，有部分 store 上的属性和方法，第二个 **value** 是 `dispatch()` 传来的数据\n4. **mutations** 中的函数也收到两个参数，第一个 **state** 是 store 中的数据，第二个 **value** 是 `commit()` 传来的数据\n\n```html CountNum.vue\n<template>\n  <div>\n    <!-- 通过vc身上的$store.state获取数据 -->\n    <h3>{{ $store.state.sum }}</h3>\n    <select v-model.number=\"num\">\n      <option value=\"1\">1</option>\n      <option value=\"2\">2</option>\n      <option value=\"3\">3</option>\n    </select>\n    <button @click=\"add\">+</button>\n    <button @click=\"reduce\">-</button>\n    <button @click=\"addOdd\">当前总和是奇数再加</button>\n    <button @click=\"addWait\">延迟1s再加</button>\n    <button @click=\"$store.state.sum = 1\">测试直接修改数据</button>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"CountNum\",\n  data() {\n    return {\n      // 选择的数字\n      num: 0,\n    }\n  },\n  methods: {\n    // 加\n    add() {\n      // 传入函数名去匹配对数据的操作和选择的数字\n      this.$store.commit('add', this.num)\n    },\n    // 减\n    reduce(){\n      this.$store.commit('reduce', this.num)\n    },\n    // 当前总和是奇数再加\n    addOdd(){\n      this.$store.dispatch('addOdd', this.num)\n    },\n    // 延迟1s再加\n    addWait(){\n      this.$store.dispatch('addWait', this.num)\n    }\n  },\n}\n</script>\n\n```\n\n```js /store/index.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 有业务逻辑的操作放在actions中\nconst actions = {\n  // context：上下文，一个mini都store，有store中的部分属性和方法\n  // value，组件中dispatch()传过来的值\n  addOdd(context, value) {\n    if (context.state.sum % 2) {\n      // 业务逻辑处理完后调用上下文中的commit()\n      context.commit('add', value);\n    }\n  },\n  addWait(context, value) {\n    setTimeout(() => {\n      context.commit('add', value);\n    }, 1000)\n  }\n}\n\n// 没有业务逻辑的操作放在mutations中\nconst mutations = {\n  // mutations中的函数收到两个参数\n  // state：store中的数据，value：commit()传过来的值\n  add(state, value) {\n    state.sum += value;\n  },\n  reduce(state, value) {\n    state.sum -= value;\n  },\n}\n\nconst state = {\n  // 数据\n  sum: 0,\n}\n\n// 创建store实例\nexport default new Vuex.Store({\n  actions,\n  mutations,\n  state\n});\n\n```\n\n## getters配置项\n除了三个重要组成部分必须作为 Store 的配置项之外，还有其它配置项\n\ngetters 和计算属性差不多，对数据进行加工后再返回，其中的函数收到一个参数 state\n\n```js\n// 准备getters\nconst getters = {\n  // 对sum进行放大10倍\n  bigSum(state){\n    return state.sum * 10;\n  }\n}\nexport default new Vuex.Store({\n  actions,\n  mutations,\n  state,\n  // 配置getters\n  getters\n});\n\n```\n\n通过 `$store.getters` 获取加工后的数据\n\n```html\n<h3>{{ $store.state.sum }}</h3>\n<h3>{{ $store.getters.bigSum }}</h3>\n```\n\n## mapState和mapGetters\n当一个组件需要获取**多个状态**时，总在模板中用 `$store.state.xxx` 获取状态，代码重复且冗余\n\n即使是手动写成**计算属性**，也要重复去 `return $store.state.xxx`\n\n`mapState()` 和 `mapGetters()` 可以帮我们**生成状态的计算属性**，以此简洁地使用状态\n\n需要引入后才能使用：\n\n```js\nimport { mapState, mapGetters} from 'vuex'\n```\n\n**使用注意：**\n1. 传入一个对象，key-value 是 `<生成的计算属性名>:<状态名或getter名>`\n2. 返回值是包含多个计算属性的对象，需要用 `...` 对象展开运算符，将其与组件的计算属性对象合并\n\n```js\n// \nimport { mapState, mapGetters} from 'vuex'\nexport default {\n  /* .... */\n  computed: {\n    test(){\n      return 'test'\n    },\n    // 对象展开运算符\n    ...mapState({\n      sum: 'sum'\n    }),\n    ...mapGetters({\n      bigSum: 'bigSum'\n    })\n  },\n  /* .... */\n}\n\n```\n\n当要**生成的计算属性名**和**状态名或getter名**一样时，可以使用数组简写形式，传入数组，元素是**状态名或getter名**\n\n```js\nmapState(['sum'])\n```\n\n## mapActions和mapMutations\n在 methods 中也写了很多看起来重复的代码\n\n```js\n// 加\nadd() {\n  // 传入函数名去匹配对数据的操作和选择的数字\n  this.$store.commit('add', this.num)\n},\n// 减\nreduce(){\n  this.$store.commit('reduce', this.num)\n},\n// 当前总和是奇数再加\naddOdd(){\n  this.$store.dispatch('addOdd', this.num)\n},\n// 延迟1s再加\naddWait(){\n  this.$store.dispatch('addWait', this.num)\n}\n```\n\n`mapActions()` 和 `mapMutations()` 能够生成调用 commit 和 dispatch 方法的方法\n\n用法和 mapState 和 mapGetters 差不多\n\n```js\nmethods: {\n  ...mapMutations(['add', 'reduce']),\n  ...mapActions({\n    addOdd: 'addOdd',\n    addWait: 'addWait'\n  }),\n},\n```\n\n生成的方法长这样，需要传入一个value\n\n```js\nadd(value){\n  this.$store.commit('add', value)\n}\n```\n\n所以调用时就需要手动传入 value\n\n```html\n<!-- 手动传入加数num -->\n<button @click=\"add(num)\">+</button>\n<button @click=\"reduce(num)\">-</button>\n<button @click=\"addOdd(num)\">当前总和是奇数再加</button>\n<button @click=\"addWait(num)\">延迟1s再加</button>\n```\n\n## Vuex模块化\n不同的功能会用到不同的数据，当很多实现不同功能的数据都写在一个 index.js 中或一个配置项中时，会导致命名冲突且代码不易维护\n\n**作用：**让代码更好维护，让多种数据分类更加明确\n\n将不同数据的 store 配置项单独拿出，每个模块的函数获取的数据或上下文都是模块自己的，无需再指定，即**模块的局部状态**\n\n```js /store/count.js\nexport default {\n  // 开启命名空间\n  namespaced: true,\n\n  actions: {\n    // context：上下文，一个mini都store，有store中的部分属性和方法\n    // value，组件中dispatch()传过来的值\n    addOdd(context, value) {\n      if (context.state.sum % 2) {\n        context.commit('add', value);\n      }\n    },\n    addWait(context, value) {\n      setTimeout(() => {\n        context.commit('add', value);\n      }, 1000)\n    }\n  },\n\n  mutations: {\n    // mutations中的函数收到两个参数\n    // state：store中的数据，value：commit()传过来的值\n    add(state, value) {\n      state.sum += value;\n    },\n    reduce(state, value) {\n      state.sum -= value;\n    },\n  },\n\n  state: {\n    sum: 0,\n  },\n\n  getters: {\n    bigSum(state) {\n      return state.sum * 10;\n    }\n  }\n}\n\n```\n\n通过 `Store()` 的 **modules** 配置项使用模块\n\n```js /store/index.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 导入求和案例配置\nimport count from \"./count.js\";\n\n// 创建store实例\nexport default new Vuex.Store({\n  modules: {\n    // 使用模块\n    count,\n  }\n});\n\n```\n\n调整 `mapState()`、`mapGetters()` 等的参数，指定是触发哪个模块的 **actions** 或 **mutations**\n\n```js\ncomputed: {\n  ...mapState('count',['sum']),\n  ...mapGetters('count',['bigSum'])\n},\nmethods: {\n  ...mapMutations('count',['add', 'reduce']),\n  ...mapActions('count',['addOdd', 'addWait']),\n},\n```\n\n**总结：**\n**(1)** **命名空间：**默认情况下，模块内部的 action、mutation 和 getter 注册在**全局命名空间**，这样使得多个模块能够对同一个 mutation 或 action 作出响应。如果希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。\n\n**(2)** **开启命名空间后：**\n1. 组件中读取 state 数据\n```js\n// 方式一：直接读取\nthis.$store.count.sum\n// 方式二：借助mapState\n...mapState('count',['sum'])\n```\n2. 组件中读取 getters 数据\n```js\n// 方式一：直接读取\nthis.$store.getters['count/bigSum']\n// 方式二：借助mapGetters\n...mapGetters('count',['bigSum'])\n```\n3. 组件中调用 dispatch\n```js\n// 方式一：直接读取\nthis.$store.dispatch('count/addOdd', value)\n// 方式二：借助mapActions\n...mapActions('count',['addOdd', 'addWait']),\n```\n4. 组件中调用 commit\n```js\n// 方式一：直接读取\nthis.$store.commit('count/add', value)\n// 方式二：借助mapActions\n...mapMutations('count',['add', 'reduce']),\n```\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[三]-ToDoList","url":"/article/f82307c5.html","content":"\n# 查看和运行\n[github仓库](https://github.com/qxchuckle/ToDoList-Vue)\n\n在1024code上在线查看和运行[ToDoList-Vue](https://1024code.com/codecubes/0vj8mqd)\n\n# 组件化编码流程\n**组件化编码流程:**\n1. **实现静态组件：**设计页面，根据**功能**或**区域**分割页面板块设计组件，使用组件实现静态页面效果\n2. **展示动态数据：**设计每个组件应有的数据，以及数据之间的联系，将数据样例应用到组件中\n3. **交互**从绑定事件监听开始\n\n# ToDoList\n**页面设计与组件：**\n\n将页面整体分为三大块，header（头部）、list（内容）、footer（尾部）\n\nlist 中重复的部分提取为 item 组件\n\n<img src=https://cdn.chuckle.top/images/55-2.webp width=\"80%\" loading=\"lazy\">\n\n# 实现静态组件\n写好静态页面和样式\n\n```html App.vue\n<template>\n  <div id=\"app\">\n    <div id=\"todo-container\">\n      <div id=\"todo-wrap\">\n        <ToDoHeader></ToDoHeader>\n        <ToDoList></ToDoList>\n        <ToDoFooter></ToDoFooter>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport ToDoHeader from \"./components/ToDoHeader.vue\";\nimport ToDoList from \"./components/ToDoList.vue\";\nimport ToDoFooter from \"./components/ToDoFooter.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    ToDoHeader,\n    ToDoList,\n    ToDoFooter,\n  },\n};\n</script>\n\n<style lang=\"less\">\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nul {\n  list-style: none;\n}\n\n#app {\n  margin: 20px 10px;\n  font-size: 16px;\n}\n\n#todo-container {\n  max-width: 600px;\n  min-width: 300px;\n  height: auto;\n  margin: 0 auto;\n  padding: 10px;\n  border: @todo-border;\n  border-radius: @todo-border-radius;\n\n  #todo-wrap {\n    width: 100%;\n  }\n\n}\n</style>\n\n```\n\n```html ToDoHeader.vue\n<template>\n    <div class=\"todo-header\">\n        <input type=\"text\" placeholder=\"回车新增ToDo\" />\n        <button>新增</button>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: \"ToDoHeader\",\n};\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n.input-focus {\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),\n        0 0 8px rgba(82, 168, 236, 0.6);\n    border-color: rgba(82, 168, 236, 0.8);\n    outline: none;\n}\n\n.todo-header {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    margin-bottom: 15px;\n\n    input {\n        width: 100%;\n        font-size: 16px;\n        padding: 8px 10px;\n        border: @todo-border;\n        border-radius: @todo-border-radius;\n\n        &:focus {\n            .input-focus();\n        }\n    }\n\n    button {\n        margin-left: 10px;\n        width: 65px;\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        background: rgb(52, 201, 238);\n        font-size: 16px;\n        color: #fff;\n    }\n\n}\n</style>\n\n```\n\n```html ToDoList.vue\n<template>\n  <div class=\"todo-list\">\n    <ul>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport ListItem from \"./ListItem.vue\";\nexport default {\n  name: \"ToDoList\",\n  components: {\n    ListItem,\n  },\n};\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n.todo-list {\n  margin-bottom: 15px;\n  border-radius: @todo-border-radius;\n  border: @todo-border;\n}\n</style>\n\n```\n\n```html ListItem.vue\n<template>\n    <li>\n        <label>\n            <input type=\"checkbox\">\n            <span>这是一个ToDo</span>\n        </label>\n        <button class=\"list-item-btn\">删除</button>\n    </li>\n</template>\n\n<script>\nexport default {\n    name: 'ListItem',\n}\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\nli {\n    border-bottom: @todo-border;\n    display: flex;\n    height: 38px;\n    line-height: 37px;\n    justify-content: space-between;\n\n    &:last-child{\n        border-bottom: none;\n    }\n\n    label {\n        margin-left: 10px;\n\n        input {\n            top: -1px;\n            position: relative;\n            vertical-align: middle;\n            margin-right: 10px;\n        }\n    }\n\n    button {\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        font-size: 14px;\n        margin: 5px;\n        padding: 0 5px;\n        background: #dc7878;\n        color: #fff;\n    }\n}\n</style>\n\n```\n\n```html ToDoFooter.vue\n<template>\n    <div id=\"todo-footer\">\n        <input type=\"checkbox\">\n        <div class=\"statistics\">已完成0 / 全部4</div>\n        <button>清除已完成</button>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'ToDoFooter',\n}\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n#todo-footer {\n    width: 100%;\n    height: 40px;\n    line-height: 40px;\n    padding-left: 10px;\n\n    input {\n        top: 1px;\n        position: relative;\n    }\n\n    .statistics {\n        width: fit-content;\n        display: inline-block;\n        margin-left: 20px;\n    }\n\n    button {\n        float: right;\n        padding: 5px 10px;\n        margin: 5px 0;\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        color: #fff;\n        background: rgb(220, 120, 120);\n        font-size: 15px;\n    }\n}\n</style>\n\n```\n\n# 设计数据\n数据在 List 中展示，所以下面操作 **ToDoList.vue** 组件\n\n有许多todo，而每个todo都有许多属性，如内容、是否完成、以及唯一标识该 todo 的id\n\n所以数据的结构应该是这样：\n\n```\ntodos: [\n    {\n      id: \"001\",\n      title: \"第一件事\",\n      complete: false\n    },\n    {\n      id: \"002\",\n      title: \"第二件事\",\n      complete: true\n    },\n    {\n      id: \"003\",\n      title: \"第三件事\",\n      complete: false\n    }\n  ],\n}\n\n```\n\n有了动态的数据，使用 **v-for** 遍历数据，将原来写死的模板替换掉，\n\n并且将遍历的每个 todo 通过**组件标签**传给子组件 **ToDoItem.vue**\n\n```html ToDoList.vue\n<ul>\n  <ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\"></ListItem>\n</ul>\n```\n\n子组件使用 **props** 接收父组件传来的 **todo** 进行内容展示\n\n```html ToDoItem.vue\n<template>\n    <li>\n        <label>\n            <input type=\"checkbox\" :checked=\"todo.complete\">\n            <span>{{ todo.title }}</span>\n        </label>\n        <button class=\"list-item-btn\">删除</button>\n    </li>\n</template>\n\n<script>\nexport default {\n    name: 'ListItem',\n    props: ['todo'],\n}\n</script>\n\n```\n\n# 完善添加功能\nvue 是以**数据驱动**的，所以不应该直接操控dom，而是让数据发生变化，触发视图的更新\n\n添加一个todo分为两步：\n1. 按下回车或按钮时获取输入框的内容\n2. 将获取到的内容添加到 **ToDoList.vue** 组件 data 中的 **todos** 数组中\n\n## 获取输入框内容\n这里还是要写点原生js代码的，但不多\n\n```html ToDoHeader.vue\n<template>\n    <div class=\"todo-header\">\n        <input type=\"text\" placeholder=\"回车新增ToDo\" @keyup.enter=\"addToDo\"/>\n        <button @click=\"addToDo\">新增</button>\n    </div>\n</template>\n\n<script>\nimport {nanoid} from \"nanoid\";\nexport default {\n    name: \"ToDoHeader\",\n    methods: {\n        addToDo(e){\n            // 获取input框元素\n            let input = e.target.tagName === \"INPUT\" ? e.target : e.target.parentNode.firstElementChild\n            // 输入框为空返回\n            if(input.value === \"\"){\n                return\n            }\n            // 生成数据对象\n            let todo = {\n                // 正常来说数据由后端返回，id由数据库维护，这里使用nanoid生成唯一id\n                id: nanoid(),\n                title: input.value,\n                complete: false\n            }\n            // 清空input\n            input.value = \"\";\n            console.log(todo);\n        }\n    }\n};\n</script>\n\n```\n\n## 修改todos数组\n通过 **props** 子组件能接收父组件传来的数据，但现在 **ToDoHeader.vue** 与 **ToDoList.vue** 是兄弟组件\n\n实现兄弟组件之间的通信有很多种办法：全局事件总线、消息对外发布、vuex等\n\n这些高级的办法后面再学，现在先用一种老办法：让兄弟组件共同的父组件（App.vue）去管理数据（todos），通过 **props** 传数据给子组件使用，父组件通过传一个函数来接收子组件的数据（让子组件在合适时候调用该接口函数，并传入父组件所需的数据）\n\n修改 App.vue：\n\n```html App.vue\n<template>\n  <div id=\"app\">\n    <div id=\"todo-container\">\n      <div id=\"todo-wrap\">\n        <!-- 将接口函数传给子组件 -->\n        <ToDoHeader :receive=\"receive\"></ToDoHeader>\n        <!-- 将todo数据传给list组件使用 -->\n        <ToDoList :todos=\"todos\"></ToDoList>\n        <ToDoFooter></ToDoFooter>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport ToDoHeader from \"./components/ToDoHeader.vue\";\nimport ToDoList from \"./components/ToDoList.vue\";\nimport ToDoFooter from \"./components/ToDoFooter.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    ToDoHeader,\n    ToDoList,\n    ToDoFooter,\n  },\n  data(){\n    return {\n      todos: [\n        {\n          id: \"001\",\n          title: \"第一件事\",\n          complete: false\n        },\n        {\n          id: \"002\",\n          title: \"第二件事\",\n          complete: true\n        },\n        {\n          id: \"003\",\n          title: \"第三件事\",\n          complete: false\n        }\n      ],\n    }\n  },\n  methods: {\n    // 接口函数，让子组件在合适时候调用，并传入父组件所需的数据\n    receive(value){\n      // 操控数组数据\n      this.todos.unshift(value);\n    }\n  }\n};\n</script>\n\n```\n\n## 自定义事件与$emit()\n子组件调用父组件的函数，以**向父组件传数据**，更规范的做法是用**组件的自定义事件**\n\n**用法：**父组件给子组件实例绑定一个**自定义事件**，并且**指定回调**（父组件中的函数），子组件在合适的时候 使用 `$emit()` 触发该自定义事件，并且给该事件的回调函数传入所需的参数，以此实现**子组件向父组件传数据**\n\n```html\n<!-- 父组件绑定一个事件 -->\n<ToDoHeader @receive=\"receive\" ></ToDoHeader>\n<script>\nexport default {\n  methods: {\n    // 事件回调函数\n     receive(value){\n       // 操控数组数据\n       this.todos.unshift(value);\n     }\n  }\n}\n</script>\n\n<!-- 子组件也有一个自己的事件 -->\n<button @click=\"addToDo\">新增</button>\n<script>\nexport default {\n  methods: {\n    addToDo(e){\n      let todo = {}\n      // 去触发父组件的receive事件，并向receive事件的回调函数传入todo对象作为参数\n      this.$emit('receive',todo)\n    }\n  }\n}\n</script>\n\n```\n\n当一个子组件要绑定**多个**事件时，在组件标签上写太多绑定就过于臃肿了，可以使用 `$refs` 获取子组件实例对象，再在父组件生命周期 `mounted()` 上用 `$on()` **绑定自定义事件**\n\n并且这样**动态绑定**事件**更加灵活**\n\n**注意：**绑定在组件标签上的事件都会被当做自定义事件，所以若要绑定**原生事件**（如click），需加上 **native** 修饰符\n\n```html\n<ToDoHeader ref=\"ToDoHeader\" @click.native=\"alter('原生事件')\"></ToDoHeader>\n<script>\nexport default {\n  methods: {\n    // 事件回调函数\n     receive(value){\n       // 操控数组数据\n       this.todos.unshift(value);\n     }\n  },\n  mounted(){\n    // 等效于<ToDoHeader @receive=\"receive\" ></ToDoHeader>\n    this.$refs.ToDoHeader.$on('receive',this.receive);\n  }\n}\n</script>\n\n```\n\n**注意：**看起来是子组件触发父组件的回调，但 **$emit** 底层并**不是触发**，而是**冒泡**\n\n有时要在合适时刻用**vc**上的 `$off(<事件名>)` 解绑事件，解绑多个事件则传入**事件名数组**，若不传入参数则**解绑所有事件**\n\n# 完善勾选功能\n**功能：**页面中勾选 todo 后，修改对应数据的 complete 属性，以表示 todo 是否已完成\n\n**实现方式：**点击勾选后，拿到该 todo 的 id 值，传给管数据的 App.vue，找到对应的 todo，让其 complete 取反\n\n由于ListItem是App的孙子，所以要先通过 `$emit()` 将数据传给父组件（ToDoList），再由父组件传给爷爷组件（App）\n\n```html\n<!-- App.vue中，updateComplete接收id并对complete取反 -->\n<ToDoList :todos=\"todos\" @updateComplete=\"updateComplete\"></ToDoList>\n<script>\n updateComplete(id){\n   // 遍历找到对应的todo\n   this.todos.forEach((item)=>{\n     if(item.id === id){\n       // complete取反\n       item.complete = !item.complete;\n     }\n   });\n}\n</script>\n\n<!-- ToDoList.vue中receiveId将子组件传过来的id再传给App，起中转效果 -->\n<ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\" @receiveId=\"receiveId\"></ListItem>\n<script>\nreceiveId(id){\n  this.$emit('updateComplete', id)\n}\n</script>\n\n<!-- ListItem.vue中 -->\n<input type=\"checkbox\" :checked=\"todo.complete\" @change=\"changeComplete(todo.id)\">\n<script>\nchangeComplete(id){\n   // 由于ListItem是App的孙子，所以要先通过$emit()将数据传给父组件，再由父组件传给爷爷组件\n   this.$emit('receiveId', id)\n}\n</script>\n\n```\n\n# 完善删除功能\n**功能：**点击每个todo对应的删除按钮就在数据中删除该todo\n\n实现起来和勾选功能差不多，也是逐层传id给App，再遍历查找删除\n\n```html\n<!-- App.vue中 -->\n<ToDoList :todos=\"todos\" @updateComplete=\"updateComplete\" @deleteToDo=\"deleteToDo\"></ToDoList>\n<script>\ndeleteToDo(id) {\n   this.todos.forEach((item, index, arr) => {\n     if (item.id === id) {\n       arr.splice(index, 1)\n     }\n   });\n }\n</script>\n\n<!-- ToDoList.vue中 -->\n<ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\" @receiveId=\"receiveId\" @deleteToDo=\"deleteToDo\"></ListItem>\n<script>\ndeleteToDo(id){\n   this.$emit('deleteToDo', id)\n }\n</script>\n\n<!-- ListItem.vue中 -->\n<button class=\"list-item-btn\" @click=\"deleteToDo(todo.id)\">删除</button>\n<script>\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   this.$emit('deleteToDo', id)\n}\n</script>\n\n```\n\n# 完善底部\n**功能：**全选按钮、已完成统计、清除所有已完成按钮\n\n**实现：**使用计算属性并遵循数据驱动，结合之前的父子组件通信方法很容易实现\n\n```html ToDoFooter.vue\n<template>\n    <div id=\"todo-footer\">\n        <div v-show=\"this.todos.length\">\n            <input type=\"checkbox\" v-model=\"checkValue\">\n            <div class=\"statistics\">已完成{{ doneToDo }} / 全部{{ todos.length }}</div>\n            <button @click=\"deleteComplete\">清除已完成</button>\n        </div>\n        <div class=\"tip\" v-show=\"!this.todos.length\">没有ToDo</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'ToDoFooter',\n    props: ['todos'],\n    computed: {\n        // 计算已完成数量\n        doneToDo() {\n            // 通过reduce统计已完成\n            return this.todos.reduce((pre, item) => {\n                return pre + (item.complete ? 1 : 0)\n            }, 0)\n        },\n        // 全选按钮的状态\n        checkValue: {\n            // checkValue无论是设置还是确定值，都要通过数据驱动，遍历所有数据来确定todo是否全部完成\n            get() {\n                // 比较已完成数量和全部todo数量，且todo至少要有一个才打勾\n                return this.doneToDo === this.todos.length && this.todos.length > 0;\n            },\n            // 将changeAll()移到此处，点击checkbox后通过changeAll()修改数据后，自动触发计算属性的getter并更新视图\n            set() {\n                this.changeAll()\n                return\n            }\n        }\n    },\n    methods: {\n        // 全选或全不选，即全都变为目前全选按钮状态的反状态\n        changeAll() {\n            // 因为现在checkValue是计算属性，checkbox点击变化后的未来值要通过“非”体现\n            // 数据变化，checkValue计算属性也自动触发getter更新视图，v-model更新checked\n            this.$emit('changeAll', !this.checkValue)\n        },\n        // 删除所有已完成项\n        deleteComplete() {\n            this.$emit('deleteComplete')\n        }\n    }\n}\n</script>\n\n```\n\n```html App.vue\n<ToDoFooter :todos=\"todos\" @changeAll=\"changeAll\" @deleteComplete=\"deleteComplete\"></ToDoFooter>\n<script>\n// 全选或全不选，即全都变为目前全选按钮状态的反状态\n changeAll(checkValue){\n   this.todos.forEach((item) => {\n     if(item.complete !== checkValue) {\n       item.complete = checkValue;\n     }\n   });\n },\n // 删除所有已完成项\n deleteComplete(){\n   this.todos = this.todos.filter((item) => {\n     return !item.complete;\n   });\n }\n</script>\n\n```\n\n# ToDo本地存储\n使用 localStorage 保存todos，初始化todos，本地存储有则拿，没有则赋值空数组\n\nwatch 监视 todos 的变化，数据多层开启深度监视，只要数据**发生改变就更新**本地存储的数据\n\n```js App.vue\nexport default {\n  data() {\n    return {\n      // 初始化todos，本地存储有则拿，没有则赋值空数组\n      todos: JSON.parse(localStorage.getItem(\"todos\")) || [],\n    }\n  },\n  watch: {\n    // 监视todos的变化\n    todos: {\n      // 数据多层开启深度监视\n      deep: true,\n      handler(value) {\n        // 只要数据发生改变就更新本地存储的数据\n        localStorage.setItem(\"todos\", JSON.stringify(value));\n      }\n    }\n  }\n};\n\n```\n\n# 全局事件总线\n在之前，使用 **props**、自定义事件、`$emit()` 来实现**父组件**与**子组件**的通信（数据传输）\n\n现在可以通过**全局事件总线**实现**任意组件**之间的通信\n\n实现全局事件总线并不需要学习新的API，本质还是通过自定义事件来实现的，是一种经验\n\n**实现：**\n**1、总线：**vm 和所有 vc 都能获取的东西，所以要将其放在 **Vue 的原型**上\n**2、事件总线：**这个总线应用要能够调用 `$on()` 绑定各种事件，能够调用 `$emit()` 触发事件，因为 `$on()` 和 `$emit()` 两个方法都在 Vue **原型**上，所以使用现成的 vm 作为总线即可，在生命周期 `beforeCreate()` 将 vm 放到 Vue.prototype 上，`Vue.prototype.$bus = this`\n\n```js\nnew Vue({\n  render: h => h(App),\n  beforeCreate(){\n    Vue.prototype.$bus = this;// 安装全局事件总线，this指的就是vm\n  }\n}).$mount('#app')\n```\n\n**使用全局事件总线`$bus`：**A 组件需要 B 组件传来某些数据，则 A 组件调用 `$bus` 的 `$on()` 方法绑定一个**自定义事件**，事件的回调函数写在 A组件中，然后在 B 组件中调用 `$bus` 的 `$emit()` 方法，触发**对应的事件**，并传入 A 组件所需的数据，于是 A 组件就能通过回调函数收到 B 组件传来数据\n\n```js\n// A组件\nexport default {\n  name: 'A'\n  methods: {\n    // 接收数据的方法\n    receive(data){\n      console.log(`收到了数据：${data}`);\n    }\n  },\n  mounted(){\n    // 在全局事件总线上发布一个事件\n    this.$bus.$on('receive', this.receive)\n  }\n}\n// B组件\nexport default {\n  name: 'B'\n  methods: {\n    // 在合适时刻调用该方法，通过$bus发送数据给A组件\n    sendOut(){\n      let data = 'chuckle'\n      // 触发receive事件，将data传给该事件的回调函数\n      this.$bus.$emit('receive', data)\n    }\n  }\n}\n\n```\n\n简单得说，就是在 Vue 原型上的 $bus 绑定了一堆自定义事件，通过自定义事件的回调接收与触发，就实现了任意组件间的通信\n\n当然，若事件较多，可以不使用vm作为全局事件总线，不同类型组件的通信，单独 new 一个 vc 出来当事件总线\n\n**注意：**规范起见，每个组件应该在生命周期 `beforeDestroy()` 时解绑事件\n\n```js\nbeforeDestroy(){\n  this.$bus.$off('<要解绑的事件名>')\n}\n```\n\n> Vue3中没有Vue()，而是createApp()，且$on $off $once都已废弃，所以Vue3中使用全局事件总线要安装第三方库：[mitt](https://www.npmjs.com/package/mitt)\n\n## TodoList使用$bus\n让 **ListItem** 组件通过全局事件总线，直接和管理 todos 数据的 **App** 组件通信，不再经过 **ToDoList** 组件\n\n修改 App.vue\n\n```html\n<!-- 不再给ToDoList绑定事件 -->\n<ToDoList :todos=\"todos\"></ToDoList>\n<script>\nexport default {\n  name: \"App\",\n  /* ······ */\n  mounted(){\n    // 在全局事件总线上发布事件\n    this.$bus.$on('updateComplete', this.updateComplete)\n    this.$bus.$on('deleteToDo', this.deleteToDo)\n  }\n}\n</script>\n\n```\n\n修改 ListItem.vue 的相关函数\n\n```js\nchangeComplete(id) {\n   // 触发事件传入id\n   this.$bus.$emit('updateComplete', id)\n},\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   // 触发事件传入id\n   this.$bus.$emit('deleteToDo', id)\n}\n\n```\n\n# 消息发布与订阅\n**消息发布与订阅**可以实现**任意组件**间的通信\n\n**提供**数据的组件**发布消息**，**接收**数据的组件**订阅该消息**\n\nvue并不自带消息库，原生js实现起来也麻烦，所以一般调用第三方库，这里使用 [pubsub-js](https://www.npmjs.com/package/pubsub-js)\n\n**安装：** `npm i pubsub-js`\n\n**使用：**`subscribe()` 订阅消息、`publish()` 发布消息、`unsubscribe()` 根据id取消订阅\n\n```js\n// 引入pubsub-js库\nimport pubsub from 'pubsub-js';\n\n// 订阅消息，返回一个唯一的订阅的id\nconst subID = pubsub.subscribe('<消息名>', (msgName, data)=>{\n  // 消息回调函数传入两个参数\n  // 第一个是消息名，第二个是发布消息时传入的数据\n  console.log(data);\n})\n\n// 发布消息\npubsub.publish('<消息名>', '<数据>')\n\n// 根据id取消订阅\npubsub.unsubscribe(subID)\n\n```\n\n对比全局事件总线，两者非常相似\n\n## TodoList使用pubsub\n在**ListItem** 与 **App** 组件通信，将每个todo的删除功能改为**消息发布与订阅**实现，勾选功能仍然保留全局事件总线的实现，方便对比学习\n \n修改 App.vue 的相关函数\n\n```js\nexport default {\n  name: \"App\",\n  /* ······ */\n  mounted(){\n    this.$bus.$on('updateComplete', this.updateComplete)\n    // this.$bus.$on('deleteToDo', this.deleteToDo)\n    \n    // 订阅消息\n    pubsub.subscribe('deleteToDo', (magName, data)=>{\n      magName; // eslint不允许不使用参数，这里使用一下\n      // 将接收到的数据（要删除的id）传给删除函数\n      this.deleteToDo(data)\n    })\n  }\n}\n\n```\n\n修改 ListItem.vue 的相关函数\n\n```js\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   // 触发事件传入id\n   // this.$bus.$emit('deleteToDo', id)\n\n   // 发布消息\n   pubsub.publish('deleteToDo', id);\n}\n\n```\n\n# 添加编辑功能\n这个功能较为综合\n\n**功能：**点击编辑按钮，title变成可编辑的input框并获取焦点，编辑按钮变取消按钮，并显示保存按钮，输入框失去焦点后也能保存修改\n\n修改 App.vue 相关函数\n\n```js\nmethods: {\n// 修改todo的title\n editToDo(id,value){\n   this.todos.forEach((item, index, arr) => {\n     if (item.id === id) {\n       arr[index].title = value;\n     }\n   });\n }\n}\n\nmounted(){\n  // 订阅修改todo的消息\n  pubsub.subscribe('editToDo', (magName,arr)=>{\n    magName;\n    this.editToDo(arr[0],arr[1])\n  })\n}\n```\n\n大改 ListItem.vue\n\n```html\n<template>\n    <li>\n        <label>\n            <input v-show=\"!isEdit\" type=\"checkbox\" :checked=\"todo.complete\" @change=\"changeComplete(todo.id)\">\n            <span v-show=\"!isEdit\" ref=\"titleToDo\">{{ todo.title }}</span>\n            <input v-show=\"isEdit\" class=\"todo-title-input\" type=\"text\" :value=\"todo.title\" ref=\"titleInput\"\n                @blur=\"editToDo(todo.id)\" contenteditable=\"true\">\n        </label>\n        <div class=\"btn-box\">\n            <button v-show=\"isEdit\" class=\"list-item-btn\" @click=\"editToDo(todo.id)\">保存</button>\n            <button v-show=\"isEdit\" class=\"list-item-btn\" @click=\"completeEdit()\">取消</button>\n            <button v-show=\"!isEdit\" class=\"list-item-btn\" @click=\"edit()\">编辑</button>\n            <button class=\"btn-delete\" @click=\"deleteToDo(todo.id)\">删除</button>\n        </div>\n    </li>\n</template>\n\n<script>\nimport pubsub from \"pubsub-js\";\nexport default {\n    name: 'ListItem',\n    props: ['todo'],\n    data() {\n        return {\n            // 是否在修改，控制输入框显隐\n            isEdit: false,\n        }\n    },\n    methods: {\n        changeComplete(id) {\n            // 触发事件传入id\n            this.$bus.$emit('updateComplete', id)\n        },\n        deleteToDo(id) {\n            if (!confirm('确认删除吗?')) {\n                return\n            }\n            // 触发事件传入id\n            // this.$bus.$emit('deleteToDo', id)\n            // 发布消息\n            pubsub.publish('deleteToDo', id);\n        },\n        // 进行修改\n        edit() {\n            this.isEdit = true;\n            // $nextTick的回调函数会在dom节点更新之后再执行\n            this.$nextTick(()=>{\n                // 让输入框获取焦点\n                this.$refs.titleInput.focus();\n            });\n        },\n        // 完成修改（取消也是完成）\n        completeEdit() {\n            this.isEdit = false;\n            this.ifEdit = false;\n        },\n        // 修改todo并发生消息\n        editToDo(id) {\n            this.completeEdit()\n            // 获取input框元素\n            let input = this.$refs.titleInput;\n            // 如果输入框内容没有变则返回\n            if (input.value === this.todo.title) return;\n            // 如果输入框内容为空提示为空并返回\n            if (input.value.trim() === \"\") {\n                alert('ToDo内容为空！请重新修改')\n                return;\n            }\n            pubsub.publish('editToDo', [id, input.value]);\n        }\n    }\n}\n</script>\n\n```\n\n## $nextTick\n在编辑功能中，通过 `$nextTick()` 方法实现了input框出现时自动获取焦点\n\n**作用：**在下一次DOM更新结束后执行其指定的回调\n\n**何时使用：**当改变数据后，要基于更新后的新DOM进行某些操作时，要在 `$nextTick()` 的回调函数中进行操作\n\n```js\nedit() {\n   this.isEdit = true;\n   // $nextTick的回调函数会在dom节点更新之后再执行\n   this.$nextTick(()=>{\n       // 让输入框获取焦点\n       this.$refs.titleInput.focus();\n   });\n}\n\n```\n\n也可以不使用这个 API，直接包裹一个没设定时间的定时器，由于**事件循环**的机制，也能成功对更新后的新DOM进行某些操作\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[二]-组件化","url":"/article/331af2cc.html","content":"\n# 生命周期\nVue会在一些特殊时刻去调用一些特殊的函数\n\n这些要经过的特殊时刻就是**生命周期**，要调用的特殊函数就是**生命周期函数**（生命周期钩子，生命周期回调函数）\n\n**为什么叫钩子：**vm在某个步骤上已经写了执行该名称的函数，但函数内容未定义，得程序员来定义。即生命周期函数的名字不可更改，但函数的具体内容需要程序员根据业务需求编写\n\n**Vue实例的生命周期：**\n**1、初始化显示**\n1. `beforeCreate()` => 初始化：生命周期、事件，但数据代理还未开始\n2. `create()` => 初始化：数据监测、数据代理\n3. `beforeMount()` => 模板解析完毕，虚拟DOM建立，但还未挂载\n4. `mounted()` => 挂载完毕，虚拟DOM转为真实DOM\n\n**2、更新状态: this.xxx = value**\n1. `beforeUpdate()` => 数据已更新，但页面还未更新，新旧虚拟dom还未对比\n2. `updated()` => 数据和页面都是新的\n\n**3、销毁 vue 实例:** `vm.$destroy()` 触发下面两个钩子\n1. `beforeDestroy()` => 此时vm上所有东西都是可用的，但不再解析模板更新页面\n2.  `destroyed()` => vm彻底被销毁\n\n<img src=https://cdn.chuckle.top/images/53-3.webp width=\"100%\" loading=\"lazy\">\n\n还有三个钩子不在图中，和路由相关\n\n**常用钩子：**\n1. **mounted:** 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】\n2. **beforeDestroy:** 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】\n\n**关于销毁Vue实例：**\n1. 在大多数场景中不应该调用 vm.$destroy() 。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。\n2. 销毁后借助Vue开发者工具看不到任何信息\n3. 销毁后自定义事件会失效，但原生D0M事件依然有效\n4. 在beforeDestroy中做好善后工作\n\n# 组件\n**组件：**应用中**局部**功能**代码**和**资源**的**集合**\n\n在 Vue 中，组件是**可复用**的 **Vue实例**\n\n组件体现了**封装**的思想，组件也可以嵌套封装\n\n**组件化：**编写一套组件，在所需的页面**引入**组件，当应用中的功能都是多组件的方式来编写的, 这个应用就是一个组件化的应用\n\n**为什么要组件化：**传统的三件套可以只能做到拆分css、js模块化，而html结构不复用，且文件依赖关系（N-1-N）复杂，组件化后，页面的每个部分都对应一个组件，组件中的小功能部分也能对应更多组件，组件逐层嵌套，最终由一个Vue实例管理，依赖关系清晰，通过引入组件构建页面，代码复用率高，后续维护也能针对性找到组件进行操作\n\n## 非单文件组件\n**非单文件组件：**一个文件中包含n个组件，**实际开发几乎不用**这种写法\n\n**使用组件流程：**\n1. **定义组件：** `Vue.extend()`\n**-** 配置项中**不能写el属性**，因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器\n**-** 组件中的data必须用**函数式**，避免组件被复用时，数据存在引用关系。\n**-** 使用 **template** 配置组件模板结构，必须有一个根元素包裹\n```js\nconst school = Vue.extend({\n   // 模板，template中的模板必须有一个根元素包裹\n   template: `\n       <div>\n           <h3>{{name}}</h3>\n           <h3>{{city}}</h3>\n       </div>\n   `,\n   // 组件中的data必须用函数式\n   // 因为对象是引用类型数据，函数式返回一个新对象才能保证多次引用组件的data互不影响\n   data() { \n       return {\n           name: '五道口',\n           city: '京海'\n       }\n   }\n})\n\n```\n2. **注册组件：**\n**-** `Vue.component()` 全局注册\n**-** 局部注册，在vm配置项的 **components** 属性中\n```js\n// 全局注册组件，多个vue实例都能使用该组件\nVue.component('school', school)\n// 组件由vm管理\nnew Vue({\n   el: '#root',\n   data: {\n       msg: '信息'\n   },\n   // 局部注册组件\n   components: {\n       // 组件名\n       student\n   }\n})\n\n```\n3. **使用组件：**在容器中写**组件标签**\n\n**案例：**\n\n```html 非单文件组件案例\n<div id=\"root\">\n  <h2>{{msg}}</h2>\n  <!-- 引用组件，组件标签 -->\n  <school></school>\n  <hr />\n  <!-- 多次引用组件，且数据独立互不影响 -->\n  <student></student>\n  <student></student>\n</div>\n<script>\n  // 使用Vue.extend定义一个组件，传入一个配置项\n  const school = Vue.extend({\n      // 模板，template中的模板必须有一个根元素包裹\n      template: `\n          <div>\n              <h3>{{name}}</h3>\n              <h3>{{city}}</h3>\n          </div>\n      `,\n      // 组件中的data必须用函数式\n      // 因为对象是引用类型数据，函数式返回一个新对象才能保证多次引用组件的data互不影响\n      data() { \n          return {\n              name: '五道口',\n              city: '京海'\n          }\n      }\n  })\n  const student = Vue.extend({\n      template: `\n          <div>\n              <h3>{{name}}</h3>\n              <h3>{{age}}</h3>\n              <button @click=\"age++\">年龄加一</button>\n          </div>\n      `,\n      data() { \n          return {\n              name: 'chuckle',\n              age: '19'\n          }\n      }\n  })\n  // 全局注册组件，多个vue实例都能使用该组件\n  Vue.component('school', school)\n  // 组件由vm管理\n  new Vue({\n      el: '#root',\n      data: {\n          msg: '信息'\n      },\n      // 局部注册组件\n      components: {\n          // 组件名\n          student\n      }\n  })\n</script>\n\n```\n\n## 注意事项\n**关于组件名：**\n1. 组件名只有**一个单词**时，引用组建时写**小写** `<student>` 或**大写** `<Student>` Vue只会去找小写的组件名，即组件名**只有一个单词时**需使用**小写**\n2. 组件名由**多个单词**组成时，有两种写法：**横杠写法**、**双驼峰写法**（只能在脚手架环境中使用）\n```html\n<!-- 横杠写法 -->\n<my-school></my-school>\n<script>\n  Vue.component('my-school', MySchool)\n</script>\n<!-- 双驼峰写法（只能在脚手架环境中使用） -->\n<MySchool></MySchool>\n<script>\n  Vue.component('MySchool', MySchool)o[]\n</script>\n\n```\n3. 不能使用html已有标签名作为组件名\n4. 在定义组件时添加 **name** 配置，无论注册使用时是什么名，在开发者工具中显示的都是该 name（首字母同样会自动显示大写）\n```js\nconst school = Vue.extend({\n  // 设置 name\n  name: 'MySchool',\n  template: ``,\n  data() { \n    return {}\n  }\n})\n\n```\n\n在**脚手架环境**下，可以使用组件时可以写**双标签** `<school></school>` 或**自闭合标签** `<school/>`，不用使用脚手架时，`<school/>` 会导致后续组件不能渲染。\n\n定义组件可以**简写:**\n注册组件时底层有判断，若是一个对象，Vue会帮我们调用Vue.extend，并将对象作为配置项传入\n\n```js\n// 简写，实际上也调用了Vue.extend\nconst school = {\n   template: ``,\n   data() { \n       return {}\n   }\n}\n// 写上 Vue.extend 不简写\nconst school = Vue.extend({\n   template: ``,\n   data() { \n       return {}\n   }\n})\n\n```\n\n## 组件嵌套\n**组件嵌套：**一个组件也会用到其它多个组件，组件关系逐层嵌套，形成**父子组件**关系\n\n**使用方式：**在父组件中 **components** 配置项注册其子组件，组件在哪注册就要在哪使用\n\n**开发中的技巧：**定义一个名为 **app** 的组件，用于管理页面中**最上层**的所有组件，而 vm 本身只管理 app 组件\n\n```html\n<div id=\"root\"></div>\n<script>\n  // 子组件的定义要放到父组件前\n  const student = {\n      template: `\n          <div>\n              <h3>学生姓名：{{name}}</h3>\n              <h3>学生年龄：{{age}}</h3>\n          </div>\n      `,\n      data() {\n          return {\n              name: 'chuckle',\n              age: '19'\n          }\n      }\n  }\n  // 定义父组件\n  const school = {\n      // 在父组件中使用子组件\n      template: `\n          <div>\n              <h2>学校名：{{name}}</h2>\n              <hr />\n              <student></student>\n          </div>\n      `,\n      data() {\n          return {\n              name: '五道口'\n          }\n      },\n      // 注册子组件\n      components: {\n          student,\n      }\n  }\n  // 定义一个欢迎语组件，和school组件同级\n  const hello = {\n      template: `\n          <div>\n              <h3>{{welcome}}</h3>\n              <hr/>\n          </div>\n      `,\n      data() {\n          return{\n              welcome: '欢迎！'\n          }\n      }\n  }\n  // 定义app组件，管理所有组件\n  const app = {\n      template: `\n          <div>\n              <hello></hello>\n              <school></school>\n          </div>\n      `,\n      // 管理下一层的父级组件\n      components: {\n          school,\n          hello\n      }\n  }\n  new Vue({\n      el: '#root',\n      // 应用app组件，替换掉root容器\n      template:`<app></app>`,\n      components: {\n          // vm只管理app组件\n          app\n      }\n  })\n  </script>\n\n```\n\n## VueComponent构造函数\n每个**组件的本质**都是一个 `VueComponent()` 构造函数，它由 `Vue.extend()` 生成并返回\n\n**每次调用 `Vue.extend()` ，返回的都是一个全新的 `VueComponent()` 构造函数**\n\n打印app组件：\n\n```js\nconst app = Vue.extend({\n   template: ``,\n   components: {}\n})\nconsole.log(app)\n```\n\n```js 输出\nƒ VueComponent(options) {\n     this._init(options);\n  }\n```\n\n既然是构造函数，使用它就需要 new 创建实例\n只需要在合适的位置写 `<school></school>` ，Vue 在**解析模板时**会自动去创建对应的**VueComponent**构造函数的**实例**\n\n即Vue会在**解析模板**时**自动执行**：`new VueComponent(options)`\n\n**1、this的指向：**\n(1) `Vue.extend(options)` 组件配置中，this 指向 VueComponent 实例对象\n(2) `new Vue(options)` 配置中，this 指向 vm 实例对象\n\n**2、Vue对组件的关系设计：**\n1. **每种**组件定义时都需要调用 `Vue.extend()` ，它返回一个新的 `VueComponent()` 构造函数，即不同种类的组件，其对应的 **VueComponent** 构造函数不同，以此来**区分组件的种类**\n2. Vue在**解析模板时**，会对每个**组件标签**都调用一次对应的构造函数，**返回的实例**都是互不影响的，以此来区分**同种组件**的**不同实例**（同种组件在出现在页面不同位置，展示不同内容）\n\n## vm与vc\n`VueComponent()` 的实例对象，简称**vc**(也可称之为：组件实例对象)\n`Vue()` 的实例对象，简称**vm**。\n\n**对vm和vc的理解：**\n**1、**vm 和 vc 长得差不多（属性和方法都一样的），因为 `Vue(options)` 和 `VueComponent(options)` 两个构造函数，在源码中都是调用了其**原型上**的 `_init(options)`\n\n**2、**vm 或 vc 的 **`$children`** 属性以**数组**形式保存着 vm 或 vc 所**管理的组件**或**子组件**的**实例对象**\n\n**3、**组件是**可复用**的 Vue 实例（vm），所以它们与 `new Vue()` 接收相同的配置选项 **options**，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 **el** 这样**根实例特有**的选项。\n\n**4、**vc 由 vm 管理，vc 没有 el 配置，只有 vm 能通过 el 配置来指定为谁服务\n\n## 重要内置关系\n**VueComponent.prototype.\\_\\_proto\\_\\_ = Vue.prototype**\n\n复习**原型与原型链**：[JavaScript基础笔记(3)--原型与原型链](/article/7d8b8b34.html#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE)\n\n\\$mount、$watch 等属性和方法都在 **Vue.prototype** 上，也就是 Vue 的原型上\n\n**作用：**这个重要的内置关系将**组件的原型**与**Vue的原型**通过 **\\_\\_proto\\_\\_** 相连，使 **VueComponent** 继承 **Vue原型**，让组件实例顺着原型链也能使用\\$mount、$watch 等属性和方法，\n\n\n**目的：**让**组件实例对象**(vc)可以访问到**Vue原型**上的属性、方法\n\n## 单文件组件\n**单文件组件：**一个文件中仅包含一个组件，文件后缀为 **.vue**\n\n浏览器并不认识.vue文件，需要通过 **webpack** 或**脚手架**，将其加工为**JS文件**\n\n**文件名推荐规则：**单个单词**大写**，多个单词**双驼峰**\n\n.vue文件中代码分为**三个标签**：\n1. `<template>` => 组件的结构\n2. `<script>` => 组件交互相关代码，包含组件所用的**数据**、方法\n3. `<style>` => 组件的样式\n\n**主要的文件：**需放入脚手架中才能运行\n1、xxx.vue 各种组件\n2、App.vue 汇总所有组件\n3、main.js 入口文件，创建Vue实例，注册App组件并应用\n4、index.html 页面\n\n```html 一个简单的组件\n<template>\n    <!-- 组件的结构 -->\n    <div class=\"student\">\n        <h2>{{ name }}}</h2>\n        <h3>{{ age }}}</h3>\n    </div>\n</template>\n\n<script>\n// 组件交互相关代码\n// 省略Vue.extend,直接暴露组件的配置对象\nexport default {\n    name: 'Student', //最好与文件名保持一致\n    data() {\n        return {\n            name: 'chuckle',\n            age: '19'\n        }\n    }\n}\n</script>\n\n<style>\n/* 组件的样式 */\n.student {\n    background: #ccc;\n    border-radius: 8px;\n}\n</style>\n\n```\n\n必须有 **App.vue** 汇总所有组件\n\n```html\n<template>\n    <div>\n        <School></School>\n    </div>\n</template>\n\n<script>\n    // 引入Student组件\n    import School from \"./Student.vue\"\n\n    export default {\n        name: \"App\",\n        components: {\n            School\n        }\n    }\n</script>\n\n<style></style>\n\n```\n\n**main.js** 入口文件，创建Vue实例，注册App组件并应用\n\n```js\nimport App from \"./App.vue\" // 引入App组件\n\nnew Vue({\n    el: '#root',\n    template: '<App></App>',\n    components: {\n        App\n    }\n})\n\n```\n\nindex.html 页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <!-- 准备一个容器 -->\n    <div id=\"root\"></div>\n    <!-- 引入vue文件 -->\n    <script src=\"../../js/vue.js\"></script>\n    <!-- 引入入口文件 -->\n    <script src=\"./main.js\"></script>\n</body>\n</html>\n\n```\n\n# 脚手架Vue-cli\nVue **脚手架**是 Vue 官方提供的标准化开发工具（开发平台）\n\nVue 有多种脚手架，[Vue-cli](https://cli.vuejs.org/zh/) 是其中一种 \n\n## 起步\n**安装：**该全局模块会暴露一个**全局命令vue**\n\n```js\nnpm install -g @vue/cli\n```\n\n创建一个项目\n\n```js\nvue create <项目名>\n```\n\n选择项目的vue版本，babel用于ES6转ES5，eslint语法检查\n\n```js\nVue CLI v5.0.8\n? Please pick a preset:\n  Default ([Vue 3] babel, eslint) \n> Default ([Vue 2] babel, eslint) \n  Manually select features   \n```\n\n等待安装完毕，运行项目\n\n```js\nnpm run serve\n```\n\n## 项目文件结构\n默认 HelloWord 项目结构：\n\n```\n├─ public\n│  ├─ favicon.ico\n│  └─ index.html\n│\n├─ src\n│  ├─ assets\n│  │  └─ logo.png\n│  ├─ components\n│  │  └─ HelloWorld.vue\n│  ├─ App.vue\n│  └─ main.js\n│\n├─ .gitignore\n├─ vue.config.js\n├─ babel.config.js\n├─ jsconfig.json\n├─ package-lock.json\n├─ package.json\n\n```\n\n**文件解释：**\n\n**1、**根目录中的一些**配置文件：**\n1. **babel.config.js** babel控制文件，脚手架已写好，无需再动\n2. **package.json** 定义了当前项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等）\n3. **package-lock.json** 锁定所有模块的版本号,包括主模块和所有依赖子模块\n4. **.gitignore** git忽略文件配置\n5. **jsconfig.json** 指定根文件和JavaScript语言服务提供的功能选项，明确项目的文件范围\n6. **vue.config.js** 一个可选的脚手架配置文件，进行vue项目本地运行和构建相关配置，若根目录中存在这个文件，它会被 @vue/cli-service 自动加载\n\n**2、src文件夹：**有些熟悉的文件，main.js入口文件、app.vue组件等\n**-** **assets文件夹：**存放静态资源\n**-** **components：**存放组件，除了App组件\n\n```js main.js有一些变化\n// 整个项目的入口文件\n// 引入Vue\nimport Vue from 'vue'\n// 引入App组件，是所有组件的父组件\nimport App from './App.vue'\n\n// 关闭Vue的生产环境提示\nVue.config.productionTip = false\n\n// 创建Vue实例对象\nnew Vue({\n  // 将App组件放入容器中\n  render: h => h(App),\n}).$mount('#app') // 绑定容器\n\n```\n\n**3、public文件夹：**页面的根目录，存放了index.html和ico图标\n\n**应该知道：**main.js之所以是入口文件，而且它能找到public中的index.html去绑定容器，是脚手架配置、规定的\n\n## render函数\n在 main.js 中，`render: h => h(App)` 作用是将App组件放入容器中\n\n若使用之前的模板写法，控制台会报错\n\n```js 模板写法\nimport App from \"./App.vue\" // 引入App组件\nnew Vue({\n    el: '#root',\n    template: '<App></App>',\n    components: {\n        App\n    }\n})\n\n```\n\n**报错内容:** [vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.\n**意思是：**正在使用Vue的仅运行时版本（runtime模式），其中模板编译器不可用。将模板预编译为render函数，或者使用包含编译器的内部版本。\n\n**问题原因：**\nVue包含两个部分，**核心部分**与**模板解析器**，核心部分是生命周期与各种属性与函数，模板解析器用于解析模板，当通过cdn引入来使用Vue时，应该将两者都引入，但如果使用脚手架、webpack将.vue文件都翻译为.js文件，且**模板都已经解析为html**，模板解析器在**生产环境**就没有用了\n\n因为Vue中不是所有部分都在生产环境中用到，且模板解析器占Vue体积的三分之一，所以Vue除了完整版，还有许多精简版，带模板解析器的称为 **compiler（模板）模式**，反之称为 **runtime（运行时）模式**\n\n(1) vue.js 是完整版Vue，包含：核心功能+模板解析器\n(2) vue.runtime.xxx.js 是运行版Vue，只包含核心功能，没有模板解析器\n\n通过 `import Vue from 'vue'` 引入的就是不带模板解析器的精简版，vue模块的package.json的main/model字段默认为runtime模式，指向了”dist/vue.runtime.common.js”。\n\n**解决办法一**：引入完整版Vue，不推荐\n\n```js\nimport Vue from 'vue/dist/vue.js'\n```\n\n**解决办法二**：使用渲染函数 `render()` 代替模板写法\n\n**render** 配置项是一个函数，传入 **createElement** 参数也是一个函数\n\n`createElement()` 可以创建具体的元素，可以**传入一个组件**或是 `('标签名','标签内容')`的形式 ，返回创建好的元素\n\nVue会调用 `render()` 并接收其返回值，将 `createElement()` 的返回值（创建好的元素）返回即可\n\n```js\n// 完整写法\nrender(createElement) {\n    return createElement('h1', '你好啊')\n}\n// 箭头函数简写\nrender: h => h(App)\n```\n\n**注意：**在开发环境中有 vue-cli 自带有 **vue-template-compiler** 插件，能解析 **.vue** 文件中的 `<template></template>` 模板，但写在配置对象 **template** 属性中的模板没有插件能解析，所以要使用 `render()`\n\n> 以后一般也只有在创建vm时配置项里会用到render\n\n## 自定义脚手架配置\n脚手架默认使用main.js作为入口文件等默认配置都在一个文件中，该文件被隐藏了起来\n\n使用命令导出、查看脚手架配置文件的**拷贝**\n\n```js\nvue inspect > output.js\n```\n\n在[vue-cli配置参考项](https://cli.vuejs.org/zh/config/)中查看可配置项\n\n在 **vue.config.js** 文件中进行自定义配置\n\n```js\n// vue.config.js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  // 配置选项\n})\n```\n\n# ref标签属性\n替代 id 属性给元素或**子组件**注册**引用信息**（打标识）\n\n给**元素标签**或**组件标签**添加 **ref** 属性，就能在组件实例对象的 **$refs** 上获取**dom元素**或**子组件实例对象**\n\n```html\n<!-- 打标识 -->\n<h1 v-text=\"msg\" ref=\"xxx\"></h1>\n<School ref=\"xxx\"></School>\n<!-- 获取dom元素或子组件vc -->\n<script>\n    this.$refs.xxx\n</script>\n```\n\n```html\n<template>\n  <div>\n    <h1 v-text=\"msg\" ref=\"title\"></h1>\n    <button @click=\"showTitle\">显示/隐藏标题</button>\n    <School></School>\n  </div>\n</template>\n\n<script>\nimport School from \"./components/school.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    School,\n  },\n  data() {\n    return {\n      msg: \"学校信息\",\n    };\n  },\n  methods: {\n    showTitle() {\n      this.$refs.title.classList.toggle('hide');\n    },\n  },\n};\n</script>\n\n<style>\n.hide {\n    opacity: 0;\n}\n</style>\n\n```\n\n# props配置项\n子组件的 **props** 配置项接收父组件通过**组件标签**传入的数据\n\n**作用：**实现父组件与子组件的通信\n\n通过标签属性给子组件**传数据**：\n\n**注意：**\n1. 普通属性传的是**字符串**，要传入**其它数据类型**的属性，需要 v-bind 绑定属性，传入**表达式**的值\n2. 传入引用数据类型时，传的是**引用**，浅拷贝\n\n```html\n<Student name=\"chuckle\" sex=\"男\" :age=\"18\"></Student>\n```\n\n子组件**接收数据**，三种写法\n\n```js\n// 简单接收，不对数据类型进行限制\nprops: ['name', 'age', 'sex']\n// 接收同时限制数据类型\nprops: {\n name: String,\n age: Number,\n sex: String\n}\n// 更多配置，必须的、默认值等\nprops: {\n name: {\n   type: String,\n   required: true // 必须的\n },\n age: {\n   type: Number,\n   required: true // 必须的\n },\n sex: {\n   type: String,\n   default: \"男\"\n }\n}\n\n```\n\n**props** 接收到的数据会代理到 **vc** 身上，但**不允许修改**只能读取（直接修改也有效果，但控制台会发出警告），所以也不能使用 **v-model** 绑定\n\n若需修改，应先将数据拷贝到data中，用一个新属性接收\n\n```js\ndata() {\n return {\n   myAge: this.age + 1\n };\n},\n```\n\n# mixins混入\n多个相似组件中通常会有重复的配置项，可以将这些配置项提取成一个**混入对象**，给这些组件引入复用（混入）\n\n将相同的配置项提取至 **mixin.js**\n\n```js mixin.js\nexport const mixin1 = {\n    data(){\n        return {\n            x: 100,\n            y: 200\n        }\n    }\n}\nexport const mixin2 = {\n    data() {\n        return {\n            name: '',\n        }\n    },\n    methods: {\n        showName(){\n            console.log(this.name);\n        }\n    },\n}\n\n```\n\n组件通过 **mixins** 配置项引入 **mixin.js** 中的配置\n\nVue会将这些外部的配置**混入**组件的同名配置中（混合合并），配置中**重复的属性**保留组件中的\n\n`mixins: []` 局部混入\n\n```js 局部组件混入\n// 引入混入对象文件\nimport {mixin1, mixin2} from '../mixin.js';\nexport default {\n    // 局部混入\n    mixins: [mixin1,mixin2],\n};\n```\n\n`Vue.mixin()` 全局混入\n\n```js 在main.js中全局混入，给所有组件\nimport {mixin1, mixin2} from '../mixin.js';\nVue.mixin(mixin1)\nVue.mixin(mixin2)\n```\n\n# 插件\nVue中插件本质是一个对象，对象中必须有一个 `install()` 方法\n\n在 **plugins.js** 或其它名字的独立js文件中定义插件\n\n```js\nexport default {\n    install(){\n        console.log('这是一个插件');\n    }\n}\n```\n\n在 **main.js** 中导入并使用 `Vue.use()` 应用插件\n\n```js\n// 导入插件\nimport plugins from \"./plugins\";\n// 使用插件\nVue.use(plugins);\n```\n\n插件对象的 `install()` 方法默认**第一个参数**接收 **Vue构造函数** 作为参数，在插件中可以进行各种全局配置以及在原型上添加属性和方法\n\n```js plugins.js\nimport {mixin1, mixin2} from './mixin.js';\nexport default {\n    // 第一个参数接收Vue构造函数作为参数\n    install(Vue){\n        // 配置全局过滤器\n        Vue.filter('interceptStr',(value, num=4)=>{\n            return value.slice(0,num)\n        })\n\n        // 注册全局自定义指令\n        Vue.directive('inHtml', function(el, binding){\n            el.innerHTML = binding.value\n        })\n\n        // 应用全局混入\n        Vue.mixin(mixin1)\n        Vue.mixin(mixin2)\n\n        // 在Vue原型上添加属性和方法\n        Vue.prototype.hello = function(){\n            console.log('Hello')\n        }\n\n    }\n}\n\n```\n\n**自定义参数：**\n`Vue.use()` 使用插件时也可以传入其它参数，会被 `install()` 方法接收，第一个参数仍然是 **Vue构造函数**\n\n```js\n// 传入三个自定义参数，三个数字\nVue.use(plugins,1,2,3);\ninstall(Vue,a,b,c){\n    console.log(a,b,c);// 1 2 3\n}\n```\n\n# scoped样式\n多个组件有多个 style 标签，所有组件样式都会汇总到一个 CSS 文件中\n\n当组件中有相同类名时，样式就会冲突，可以给组件的 style 标签加上 **scoped** 属性解决冲突\n\n**作用：**让样式仅在当前组件中生效，防止样式冲突\n\n**原理：**当style标签加上 **scoped** 属性后，Vue会给该组件所有标签元素都加上一个随机的 **data-v** 属性，css选择器也会自动选择 **data-v**\n\n```html\n<div data-v-22321ebb=\"\" class=\"demo\">\n    <h2 data-v-22321ebb=\"\">学生姓名：chuckle</h2>\n    <h2 data-v-22321ebb=\"\">学生性别：男</h2>\n    <h2 data-v-22321ebb=\"\">学生年龄：19</h2>\n    <hr data-v-22321ebb=\"\">\n</div>\n```\n\n```css\n.demo[data-v-22321ebb] {\n    background: rgb(78, 180, 220);\n}\n```\n\n**注意：**一般在 **App.vue** 的 style 标签中写全局共用样式，所以 App 不适合加 **scoped**\n\n**更多：** style 标签的 **lang** 属性可以指定 CSS 预处理语言，常用 **less**，使用 less 前需要安装 **less-loader** 用于解析 less\n\n```html\n<style lang=\"less\" scoped>\n</style>\n```\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[一]-初识","url":"/article/adf5c49.html","content":"\n# Vue简介\n[Vue](https://cn.vuejs.org/) 是一套用于**构建用户界面**的**渐进式** JavaScript 框架\n\n构建用户界面: 在合适的时刻将**数据**应用到合适的位置\n渐进式: Vue可以自底向上逐层的应用，即**需要什么用什么**，可以只用一个vue核心库，也可以装一堆插件库\n\n**Vue的特点：**\n1. **组件化**模式，提高代码复用率，让代码更好维护\n2. **声明式**编码，无需直接操作DOM，提高开发效率\n3. **响应性**，Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM\n4. 使用**虚拟DOM**和优秀的**Diff算法**，尽量复用DOM节点\n\n[Vue2](https://v2.cn.vuejs.org/)，[API](https://cn.vuejs.org/api/)\n\n体验Vue的方便：\n\n```js 命令式编码\nlet html = '';\ndata.forEach(item => {\n    html += `<li>${item.id}-${item.name}</li>`\n})\ndocument.getElementById('list').innerHTML = html;\n```\n\n```html 声明式\n<ul id=\"list\">\n    <li v-for=\"item in data\">\n        {{item.id}} - {{item.name}}\n    </li>\n</ul>\n```\n\n> 下面的笔记是从Vue2开始的，直到Vue3\n\n# 初次使用与理解\n使用cdn或本地文件引入\n\n```js\n<script src=\"https://cdn.chuckle.top/npm/vue@2.7.14/dist/vue.js\"></script>\n<script src=\"/js/vue.js\"></script>\n```\n\n引入后，全局就多了一个名为 **Vue** 的**构造函数**，它接收一个配置对象参数\n\n初次使用步骤：\n1. 创建vue实例\n2. 挂载到容器\n3. 插值语法应用数据\n\n**思想：**将数据交给Vue实例动态地去使用，而不去直接操作DOM\n\n```html\n<!-- 容器 -->\n<div id=\"root\">\n  <!-- vue的插值语法 -->\n  <h1>hello {{msg}}</h1>\n</div>\n\n<script>\n// 创建vue实例\nnew Vue({\n   el: '#root', // element元素，挂载到哪个容器\n   // 数据对象，只能给该容器使用\n   data: {\n       msg: 'chuckle'\n   }\n});\n\n// 效果\n// hello chuckle\n</script>\n\n```\n\n插值语法 `{{ }}` 中写的是js**表达式**（表达式即能生成一个值的代码），访问的数据以data为基准，当data中的数据发生改变，vue会自动重新解析模板更新数据\n\n容器中的代码仍然符合html规范，vue会解析容器中的特殊语法（vue模板），然后应用数据和进行操作\n\n**注意：**容器与实例是**一一对应**的，且不能嵌套容器，但一个容器和实例可以拆分成许多**组件**\n\n# 模板语法\nVue有两种模板语法：\n1. **插值**语法 `{{ }}`\n2. **指令**语法 `v- `\n\n插值语法用于**标签体内容**\n指令语法用于**解析标签**（标签属性、标签体内容、绑定事件），数据都以data为基准\n\n`{{ }}` 能看见（写） Vue 实例和原型上所有的属性\n\ndata数据对象中的键值对，最终都会通过**数据代理**作为 Vue 实例的属性\n\n# 数据绑定\n**单向数据绑定** `v-bind`，只能由data去影响页面，可以简写为**冒号**\n**双向数据绑定** `v-model`，data和页面中数据变化都会互相影响\n\n**注意：** v-model只能用于**表单标签**的**value属性**上，v-model:value= 可以简写为 v-model=\n\n**v-bind** 案例：数据绑定标签属性\n\n```html\n<div class=\"root\">\n<!-- vue的插值语法 -->\n  <h1>hello {{msg}}</h1>\n  <!-- v-bind简写为冒号 -->\n  <a :href=\"url\">前往首页</a>\n</div>\n<script>\n// 创建vue实例\nnew Vue({\n  el: \".root\",\n  data: {\n    msg: \"chuckle\",\n    url: \"https://www.qcqx.cn/\"\n  },\n});\n</script>\n\n```\n\n**v-model**案例：输入框内容变化会影响 data.msg 的值\n\n```html\n<div class=\"root\">\n单向数据绑定<input type=\"text\" :value=\"msg\">\n<br />\n双向数据绑定<input type=\"text\" v-model=\"msg\">\n</div>\n<script>\n// 创建vue实例\nnew Vue({\n  el: \".root\",\n  data: {\n    msg: \"chuckle\"\n  },\n});\n</script>\n\n```\n\n# 挂载和数据写法\n**挂载容器**有两种写法：配置对象中的 **el** 属性和实例对象的 `$mount()` 方法 \n\n**tip:** Vue实例和原型上以 **$** 开头的属性和方法都是提供给程序员使用的\n\n```js 第一种\nnew Vue({\n  el: \".root\"\n});\n```\n\n```js 第二种\nconst vm = new Vue({ });\nvm.$mount('.root');\n```\n\n**data数据**也有两种写法：**对象式**和**函数式**\n函数式返回一个数据对象，**组件中需用函数式**，函数式中的this是Vue实例对象。由Vue所管理的函数都不要写成箭头函数\n\n```js 对象式\nnew Vue({\n  data: {\n    msg: \"chuckle\"\n  }\n});\n```\n\n```js 函数式\nnew Vue({\n  // data: function(),在对象属性值中写函数，一般删掉冒号和function\n  data(){\n    return{ msg: \"chuckle\" }\n  }\n});\n```\n\n# MVVM模型\nVue参考了[MVVM模型](https://zh.wikipedia.org/wiki/MVVM)\n1. **M：**模型(Model) - data 中的数据\n2. **V：**视图(View) - 模板\n3. **VM：**视图模型(ViewModel) - Vue 实例对象\n\nModel 通过 VM 向 View 绑定数据，View 通过 VM 监听 Model 的数据变化\n\n<img src=https://cdn.chuckle.top/images/53-2.webp width=\"50%\" loading=\"lazy\">\n\n前端的框架大多都遵循这种模型，将数据放到指定位置，写好指定的模板代码，如何将数据和模板关联起来是框架的事，需要学习框架的语法\n\n# 数据代理\n**数据代理：**通过一个对象代理对另一个对象中属性的操作（读/写）\n\nVue2中使用 `Object.defineProperty` 实现数据代理，Vue3使用 `Object.proxy()` 以后再说\n\n该方法可以向一个对象**添加新属性**或修改现有属性，且默认不可枚举、修改、删除\n\n```js\nconst obj = { name: 'chuckle' }\nObject.defineProperty(obj, 'age', {\n    value: 19,\n    enumerable: true, // 使新添加的属性可被枚举，默认false\n    writable: true, // 控制属性是否能被修改，默认false\n    configurable: true // 控制属性是否能被删除，默认false\n})\n\n```\n\n当 num 发生修改，obj.age 获取的值也会发生改变，当修改 obj.age ，num也会被修改，实现了两个对象间数据的双向绑定\n\n```js\nconst obj = { name: 'chuckle' }\nlet num = 19;\nObject.defineProperty(obj, 'age', {\n    // 当读取obj的age属性时，getter就会被调用，返回age的值\n    get() {\n        return num;\n    }\n    // 当修改obj的age属性时，setter就会被调用\n    set(value) {\n        num = value;\n    }\n})\n```\n\nVue中的数据代理：\n\n配置对象 data 中的键值对都会通过数据代理给 vm 管理，当读取或修改属性时触发对应的 getter 和 setter\n\n原来的data对象通过**数据劫持**变为 vm 上的 _data 属性，不直接赋值是为了实现响应式\n\n触发 setter 后，_data里对应的属性也会发生改变，Vue监听_data有发生改变，让模板（页面）也发生改变\n\n# 事件处理\n\n## v-on事件监听\n使用 `v-on` 指令进行事件监听，可简写为@，`@<事件名>=\"<回调函数名>\"`，也可以写一些简单的语句\n\n事件触发后的回调函数写在 **methods** 属性中，不做数据代理\n\n```html\n<div class=\"root\">\n  <button v-on:click=\"fun\">{{msg}}</button>\n  <!-- v-on:可以简写为@ -->\n  <button @click=\"fun\">{{msg}}</button>\n</div>\n<script>\n  new Vue({\n    el: \".root\",\n    data: {\n      msg: \"点击\",\n    },\n    methods: {\n      fun() {\n        alert(\"chuckle\");\n      },\n    },\n  });\n</script>\n\n```\n\nv-on 可以传入参数，默认传入 event，后续传入参数会覆盖 event，但可以传入 $event 来获取事件对象\n\n```html\n <div class=\"root\">\n   <button @click=\"fun('你好', $event)\">{{msg}}</button>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun(str, e) {\n         alert(`${str}chuckle`);\n         console.log(e);\n       },\n     },\n   });\n </script>\n\n```\n\n## 事件修饰符\nv-on 有事件修饰符。使用： `@<事件名>.<修饰符>` \n修饰符可以连着写多个 `@<事件名>.<修饰符>.<修饰符>`，分先后执行顺序\n\n**作用：**为了让方法中数据逻辑更加的纯粹，而不用去处理 DOM 的逻辑细节\n\n使用 prevent 修饰符代替 e.preventDefault() 阻止默认事件：\n\n```html e.preventDefault()和prevent修饰符阻止默认事件\n<!-- prevent修饰符 -->\n <div class=\"root\">\n   <a href=\"/\" @click.prevent=\"fun\">{{msg}}</a>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun() {\n         console.log('点击');\n       },\n     },\n   });\n </script>\n<!-- e.preventDefault() -->\n <div class=\"root\">\n   <a href=\"/\" @click=\"fun\">{{msg}}</a>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun(e) {\n         console.log('点击');\n         e.preventDefault();\n       },\n     },\n   });\n </script>\n\n```\n\n**常用的点击事件修饰符：**\n1. **prevent** 阻止默认事件\n2. **stop** 阻止事件冒泡\n3. **once** 事件只触发一次\n4. **capture** 使用事件的捕获模式\n5. **self** 只有e.target是当前操作的元素才触发事件\n6. **passive** 事件的默认行为立即执行，无需等待回调函数执行完毕\n\n鼠标修饰符：\n1. left 左键\n2. right 右键\n3. middle 中建\n\n## 键盘事件\nVue中可以使用**按键别名**（修饰符）让特定按键去触发键盘事件，而无需使用e.key去判断\n\n**常用按键别名：**\n1. 回车 enter\n2. 删除、退格 delete\n3. 退出 esc\n4. 空格 space\n5. 换行 tab（不适合keyup 适合keydown）\n6. 上 up 下 down 左 left 右 right\n\n```html\n <div class=\"root\">\n   <input type=\"text\" @keyup.enter=\"fun\" placeholder=\"回车输入\"></input>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     methods: {\n       fun(e) {\n         console.log(e.target.value);\n       },\n     },\n   });\n </script>\n```\n\n也可以通过 **.键名** 来绑定其它按键\n\n双驼峰的键名需要写成小写再用横杆连接，如 CapsLock 要写成 caps-lock\n\n```js\n@keyup.a=\"fun\" // 绑定字母A键\n@keyup.caps-lock=\"fun\" // 绑定切换大小写键\n@keyup.Control=\"fun\" // 绑定ctrl键\n```\n\n**系统修饰键：**ctrl、alt、shift、meta\n(1) 配合kyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n(2) 配合kydown使用：正常触发\n\n**自定义**键盘别名(不推荐使用)：\n\n```js\nVue.config.keyCodes.自定义键名=键码\n```\n\n技巧：利用keyup系统修饰键特性**绑定组合键**\n\n```js\n@keyup.ctrl.a=\"fun\" // 绑定ctrl+a，先按下ctrl再按下a，然后释放a才触发\n@keyup.alt.q=\"fun\" // 绑定alt+q\n```\n\n# 计算属性computed\n**计算属性：**通过已有的数据（属性）加工出一个新的属性\n\n在 `computed` 配置项中定义计算属性，计算属性要写成对象形式，并添加getter和setter(非必须)\n使用this访问vm上的属性\n\n计算属性会在**第一次**被调用后被**缓存**，即getter只触发一次，后续使用该属性会从缓存中拿\n当计算属性所**依赖**数据(在vm上的)发生变化时，会再次调用getter更新缓存\n\n**案例：**通过姓和名计算出全名\n\n```html\n <div class=\"root\">\n   姓：<input type=\"text\" v-model=\"firstName\"><br />\n   名：<input type=\"text\" v-model=\"lastName\"><br />\n   全名：<input type=\"text\" v-model=\"fullName\"><br />\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       firstName: \"张\",\n       lastName: \"三\"\n     },\n     // 计算属性配置项\n     computed:{\n          // 计算属性\n         fullName:{\n             get(){\n                 return `${this.firstName}-${this.lastName}`\n             },\n             set(name){\n                 let arr = name.split(\"-\");\n                 this.firstName = arr[0];\n                 this.lastName = arr[1];\n             }\n         }\n     }\n   });\n </script>\n\n```\n\n当计算属性**只读不写**时，可以简写，直接将计算属性值写成一个函数，作为getter\n\n```js\nnew Vue({\nel: \".root\",\ndata: {\n firstName: \"张\",\n lastName: \"三\"\n},\n// 计算属性配置项\ncomputed:{\n    // 计算属性\n    fullName(){\n        return `${this.firstName}-${this.lastName}`\n    }\n}\n}\n});\n\n```\n\n当计算量非常大的时候，而且访问量次数非常多，改变的时机却很小，那就需要用到computed；缓存会减少很多计算量\n\n**computed** 与 **methods** 区别：\n1. computed是属性访问，而methods是函数调用。computed带有缓存功能，而methods没有\n2. computed是响应式的，methods并非响应式\n3. computed是以对象的属性方式存在的，在视图层直接调用就可以得到值，如：`{{msg}}` ，而methods必须以函数形式调用，例如：`{{msg()}}` ，computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果\n4. computed带缓存，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行\n5. computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n\n# 监视属性watch\n**watch** 配置项中定义监视属性，监视某一**属性的变化**，监视属性本身也是一个配置项\n\n可以监视data中的属性，也可以监视计算属性，若属性不存在也不会报错\n\n**作用：**当属性值发生变化后进行某些操作\n\n```js\nwatch: {\n  <属性名>: {\n    <监视配置项>\n  }\n}\n```\n\n```html\n <div class=\"root\">\n     <h2>今天天气: {{weather}}</h2>\n     <button @click=\"changeWeather\">切换天气</button>\n </div>\n <script>\n   const vm = new Vue({\n     el: \".root\",\n     data: {\n         isHot: true,\n     },\n     computed: {\n         weather(){\n             return this.isHot ? \"炎热\" : \"凉爽\"\n         }\n     },\n     methods: {\n         changeWeather(){\n             this.isHot = !this.isHot;\n         }\n     },\n     watch: {\n         weather: {\n             // 初始化时调用一次handler\n             immediate: true,\n             // 当监视属性发生变化时触发handler\n             handler(newValue, oldValue){\n                 // 传入属性新老值两个参数\n                 console.log(newValue, oldValue);\n             }\n         }\n     }\n   });\n </script>\n\n```\n\n也可以通过vm的 `$watch()` 方法来监视某个属性\n\n```js\nvm.$watch(\"weather\", {\n  // 初始化时调用一次handler\n  immediate: true,\n  // 当监视属性发生变化时触发handler\n  handler(newValue, oldValue) {\n    // 传入属性新老值两个参数\n    console.log(newValue, oldValue);\n  },\n});\n\n```\n\n**深度监视：**\n\n当监视多级结构中的**某个属性**时，属性名要写成字符串，或者 num[a]\n\n```js\nconst vm = new Vue({\n  el: \".root\",\n  data: {\n      num: {\n        a: 1,\n        b: 2\n      }\n  },\n  watch: {\n      // 深度监视写成字符串\n      'num.a': {\n          // 初始化时调用一次handler\n          immediate: true,\n          // 当监视属性发生变化时触发handler\n          handler(newValue, oldValue){\n              // 传入属性新老值两个参数\n              console.log(newValue, oldValue);\n          }\n      }\n  }\n});\n```\n\n监视**整个**多级结构所有属性时，要添加配置项 **deep: true**，handler参数是该num对象\n\n```js\nconst vm = new Vue({\n  el: \".root\",\n  data: {\n      num: {\n        a: 1,\n        b: 2\n      }\n  },\n  watch: {\n      // 深度监视写成字符串\n      num: {\n          // 监视整个num和num里的属性\n          deep: true,\n          // 初始化时调用一次handler\n          immediate: true,\n          // 当监视属性发生变化时触发handler\n          handler(newValue, oldValue){\n              // 传入属性新老值两个参数\n              console.log(newValue, oldValue);\n          }\n      }\n  }\n});\n\n```\n\n当监视属性配置中只有 handler 方法时，可以简写\n\n```js\nwatch: {\n   weather(newValue, oldValue){\n      console.log(newValue, oldValue);\n   }\n}\n// 不再传一个配置对象，直接传一个函数作为handler\nvm.$watch(\"weather\", function(newValue, oldValue){\n  console.log(newValue, oldValue);\n});\n\n```\n\n**注意：**计算属性多个影响一个的时候用，监听属性一个影响多个或有复杂（异步）业务的时候用\n\n# 绑定class样式\n通过 **v-bind** 动态得将样式class应用到盒子上\n\n每个标签只能有一个 class 属性，但vue会自动将绑定的 class 合并到现有的 class 属性上\n\n有三种绑定形式：\n1. **字符串写法**，适用于样式的类名不确定，需要动态指定\n2. **数组写法**，适用于要绑定的样式个数不确定，名字也不确定\n3. **对象写法**，适用于要绑定的样式个数、名字确定，但需要动态决定用不用\n\n```css\n.basic {\n  border: 1px solid #222;\n  margin: 20px;\n}\n/* 控制盒子大小，互斥 */\n.big {\n  width: 300px;\n  height: 300px;\n}\n.small {\n  width: 100px;\n  height: 100px;\n}\n.normal {\n  width: 200px;\n  height: 200px;\n}\n/* 控制其它样式，可同时使用 */\n.fcolor {\n  color: rgb(227, 57, 57);\n}\n.bg {\n  background: #ccc;\n}\n.bdcolor {\n  border-color: rgb(20, 153, 149);\n}\n\n```\n\n```html\n <div id=\"root\">\n   <!-- 字符串写法，适用于样式的类名不确定，需要动态指定 -->\n   <div class=\"basic\" :class=\"size\" @click=\"changeSize\">{{msg}}</div>\n   <!-- 数组写法，适用于要绑定的样式个数不确定，名字也不确定 -->\n   <div class=\"basic normal\" :class=\"classArr\">{{msg}}</div>\n   <!-- 对象写法，适用于要绑定的样式个数确定，名字也确定，但需要动态决定用不用 -->\n   <div class=\"basic normal\" :class=\"classObj\">{{msg}}</div>\n </div>\n <script>\n   let sizeArr = [\"small\", \"normal\", \"big\"];\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       size: \"normal\",\n       classArr: [\"fcolor\", \"bg\", \"bdcolor\"],\n       classObj: {\n         // true则应用样式，false不应用\n         fcolor: false,\n         bg: true,\n         bdcolor: true,\n       },\n     },\n     methods: {\n       //点击随机切换大小\n       changeSize() {\n         this.size = sizeArr[Math.floor(Math.random() * sizeArr.length)];\n       },\n     },\n   });\n </script>\n\n```\n\n# 绑定style行内样式\n两种写法：对象写法、数组写法。对象中属性名单驼峰\n\n```html\n <div id=\"root\">\n     <!-- 对象写法 -->\n   <div class=\"basic\" :style=\"styleObj\">{{msg}}</div>\n   <!-- 数组写法 -->\n   <div class=\"basic\" :style=\"styleArr\">{{msg}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       styleObj: {\n         fontSize: '40px',\n         color: '#363636',\n         background: '#ccc',\n       },\n       // 数组内写样式对象，一般不用\n       styleArr: [\n         {\n             fontSize: '40px',\n         },\n         {\n             background: '#ccc',\n         }\n       ]\n     }\n   });\n </script>\n\n```\n\n# 条件渲染v-if\n条件渲染，符合某些条件才渲染元素，即通过指令去控制元素的显隐，不同指令实现原理不同\n\n`v-show=\"<表达式>\"` 表达式结果需能表示为布尔值\n\n**原理：**使用 `display:'none'` 隐藏元素，节点仍在\n\n`v-if=\"<表达式>\"` 表达式结果需能表示为布尔值\n\n**原理：**在模板解析时不渲染该元素，节点不存在，会用一个空注释占位\n\n```html\n <div id=\"root\">\n   <!-- v-show -->\n   <div v-show=\"isShow\">{{msg}}</div>\n   <!-- v-if -->\n   <div v-if=\"isShow\">{{msg}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       isShow: false,\n     },\n   });\n </script>\n\n```\n\n当显隐切换频率高使用 v-show 性能更好\n\n`v-else-if`和`v-else` 需配合 **v-if** 使用，效果和js中 if-else 一样\n\n使用这两个指令需要div结构**相邻**\n\n```html\n <div id=\"root\">\n   <!-- v-else-if -->\n   <div v-if=\"n === 1\">{{n}}</div>\n   <!-- 当if匹配到一个就不会再往后判断 -->\n   <div v-else-if=\"n === 1\">重复{{n}}</div>\n   <div v-else-if=\"n === 2\">{{n}}</div>\n   <div v-else-if=\"n === 3\">{{n}}</div>\n   <!-- v-else不用写表达式 -->\n   <div v-else>{{n}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       n: 1\n     },\n   });\n </script>\n\n```\n\n当多个标签显隐条件一样时，可以使用 `＜template＞` 标签包裹，在该标签中写 **v-if** ，实际html结构中不会存在该标签\n\n```html\n<template v-if=\"n===1\">\n  <h1>{{msg}}</h1>\n  <h2>{{msg}}</h2>\n  <h3>{{msg}}</h3>\n</template>\n```\n\n# 列表渲染v-for\n`v-for` 将数组或对象中一系列重复、相似的数据渲染到页面中，这些数据应该要有**唯一标识**（通常是id）\n\n使用方法类似js中的 **for-in**\n\n使用 v-for 遍历渲染需要在标签内绑定上 **key** 属性作为唯一标识\n\n```html 用法\n<ul>\n  <!-- 参数1 p是persons中的元素，参数2 index/key是索引，遍历数组时是从0开始的数组下标，遍历对象时是每个属性名-->\n  <!-- key标签属性是唯一标识 -->\n  <li v-for=\"(p,index) in persons\" :key=\"p.id\">{{index}} - {{p.name}} - {{p.age}}</li>\n</ul>\n```\n\n遍历数组：\n\n```html\n <div id=\"root\">\n   <ul>\n     <li v-for=\"(p,index) in persons\" :key=\"p.id\">{{index}} - {{p.name}} - {{p.age}}</li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 需渲染的数据\n       persons: [\n         { id: '001', name: 'chuckle', age:'19'},\n         { id: '002', name: 'qx', age:'18'},\n         { id: '003', name: 'giggles', age:'20'},\n       ],\n     },\n   });\n </script>\n\n```\n\n遍历对象：\n\n```html\n <div id=\"root\">\n   <ul>\n     <li v-for=\"(p,key) in commodity\" :key=\"key\">{{key}} - {{p}}</li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 需渲染的数据\n       commodity: {\n         name: '商品1',\n         price: 20,\n         place: '中国'\n       }\n     },\n   });\n </script>\n\n```\n\n## key\nv-for 遍历渲染时需要给每个标签绑定 key 属性，作为**唯一标识**\n\nkey 在 vue 内部**虚拟DOM**上使用，解析模板时不会渲染到页面上\n\n**作用：**vue在解析模板到真实DOM上时，会先将数据转为虚拟DOM，当数据发生变化，又会再生成一次虚拟DOM，然后会用diff算法**对比**新旧两份虚拟DOM，对比过程依赖 **key**，将key相同的标签内**所有属性和节点**单独进行对比，将相同的节点进行**dom复用**，不同的则**新覆盖旧**，新虚拟DOM中**没有的key则删除**对应标签\n\n**diff算法:** 对比两个新旧虚拟dom（两棵树）之间的差异的一种算法\n\n**选择key：**\n使用后端维护的唯一标识，id、手机号、学号等\n\n若不手动绑定key，vue会自动将index作为key\n一般不使用 index 作为key，因为index不与数据一一对应，会导致diff算法对比时发生问题（逆序操作时无法正常复用dom、虚拟dom中不存在的用户输入\\[input\\]会发生错位）\n\n如果不存在对数据的逆序添加、逆序明除等破坏顺序操作，仅用于渲染列表用于展示，可以使用index作为key\n\n## 列表过滤\n业务中经常需要对原数据进行搜索过滤后再展示，可以使用计算属性实现\n\n若业务较复杂也可使用监视属性实现，但应优先考虑计算属性\n\n```html\n <div id=\"root\">\n   <!-- 列表过滤 -->\n   <input type=\"text\" placeholder=\"模糊搜索姓名\" v-model=\"keyWord\">\n   <ul>\n     <li v-for=\"(p,index) in fillPersons\" :key=\"p.id\">\n       {{index+1}} - {{p.name}} - {{p.age}} - {{p.sex}}\n     </li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 搜索的关键字\n       keyWord: \"\",\n       // 需渲染的数据\n       persons: [\n         { id: \"001\", name: \"张三\", age: \"19\", sex: \"男\" },\n         { id: \"002\", name: \"李三\", age: \"18\", sex: \"女\" },\n         { id: \"003\", name: \"李四\", age: \"20\", sex: \"女\" },\n         { id: \"004\", name: \"刘四\", age: \"18\", sex: \"男\" },\n       ]\n     },\n     computed: {\n       // 通过搜索关键字和原数据计算出的数据\n       fillPersons: {\n         get(){\n           return this.persons.filter((item)=>{\n             return item.name.indexOf(this.keyWord) !== -1;\n           })\n         }\n       }\n     }\n   });\n </script>\n\n```\n\n## 列表排序\n实际业务中多是后端排好序，但前端排序有时也会用到\n\n列表排序和列表过滤通常一起用\n\n```html\n <div id=\"root\">\n   <!-- 列表过滤和排序 -->\n   <input type=\"text\" placeholder=\"模糊搜索姓名\" v-model=\"keyWord\" />\n   <br />\n   <button @click=\"sortType=1\">年龄升序</button>\n   <button @click=\"sortType=-1\">年龄降序</button>\n   <button @click=\"sortType=0\">原序</button>\n   <ul>\n     <li v-for=\"(p,index) in fillPersons\" :key=\"p.id\">\n       {{index+1}} - {{p.name}} - {{p.age}} - {{p.sex}}\n     </li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 控制排序类型,0原序1升-1降\n       sortType: 0,\n       // 搜索关键字\n       keyWord: \"\",\n       // 需渲染的数据\n       persons: [\n         { id: \"001\", name: \"张三\", age: 19, sex: \"男\" },\n         { id: \"002\", name: \"李三\", age: 18, sex: \"女\" },\n         { id: \"003\", name: \"李四\", age: 21, sex: \"女\" },\n         { id: \"004\", name: \"刘四\", age: 20, sex: \"男\" },\n       ],\n     },\n     computed: {\n       // 通过搜索和排序类型计算出的数据\n       fillPersons: {\n         get() {\n           // 根据关键字筛选\n           let arr = this.persons.filter((item) => {\n             return item.name.indexOf(this.keyWord) !== -1;\n           });\n           // 进行排序\n           if (this.sortType) arr.sort((a, b) => this.sortType * (a.age - b.age));\n           return arr;\n         },\n       },\n     },\n   });\n </script>\n\n```\n\n# 监视数据(响应式)原理\nVue 会监视 data 中所有层次的数据。当数据发生改变，会重新解析模板，也就是数据的**响应式**\n\n这种监视是通过**每个属性**对应的 **setter** 实现的，在 setter 中对数据进行实际的修改、重新解析模板等操作\n\n## 数据劫持\n对 data 中的数据进行加工，添加 getter、setter 以实现某些交互功能（响应式） 就是**数据劫持**\n\n与**数据代理**的区别：数据代理是通过一个对象代理对另一个对象中属性的操作（读/写），而数据劫持是对一个对象中原有的属性进行加工\n\n利用数据劫持简单复刻一下 Vue 的响应式：\n\n```js\n// data数据\nlet data = {\n   name: 'chuckle',\n   age: 19\n}\n// 创建监视实例对象，监视data中数据变化\nconst obs = new Observer(data)\n\n// vue实例对象\nlet vm = {}\n// 将obs引用地址赋给vm._data和data\n// 此刻就完成了数据劫持，原来的data的地址只有当时传入Observer的参数obj才知道\n// data只是地址发生了改变，但原来的数据仍然在一个地址中，被obs所管理\nvm._data = data = obs\n\n// 监视构造函数，能创建监视实例对象\n// 传入要监视的对象\nfunction Observer(obj) {\n   // 拿到对象后提取所有属性名到一个数组中\n   const keys = Object.keys(obj)\n   // 遍历keys，加工属性\n   keys.forEach((k)=>{\n       // 和数据代理一样，用到defineProperty\n       // 构造函数中的this是其实例对象\n       // 这一步相当于将data上的数据代理到实例对象上\n       Object.defineProperty(this,k,{\n           // 添加getter、setter。实现属性的读写\n           get(){\n               return obj[k]\n           },\n           set(val){\n               obj[k] = val\n               // 修改完值后，就可以去重新解析模板\n               parsingTemplates()\n           }\n       })\n   })\n}\n// vue重新解析模板的函数实现，怎么实现的暂时不研究\nfunction parsingTemplates(){\n   console.log('重新解析模板');\n}\n\n```\n\n输出 vm._data 对象：\n\n```js\nObserver {}\n  age: （…） // 19\n  name: （…） // 'qx'\n  get age: ƒ get()\n  set age: ƒ set(val)\n  get name: ƒ get()\n  set name: ƒ set(val)\n  [[Prototype]]: Object\n\n```\n\n**实现效果：**当修改 vm._data 中的数据，控制台会输出【重新解析模板】\n\n**发生了什么：**通过**数据代理**将 data 中数据的读和写操作代理到了**监视实例对象** obs 身上，并且在 setter 中调用**解析模板**的函数，这是实现**响应式**的关键，然后将 obs 引用地址赋值给 vm._data，上面这些步骤就实现了**数据劫持**，即 Vue 中并不是直接将 data 赋值给 vm._data，而是先劫持 data，对 data 进行加工后，将加工好的 obs 赋给 vm._data\n\n后面就是正常的数据代理操作，将 vm._data 通过数据代理到 vm 身上，方便操作\n\n**注意：**Vue中的响应式实现要比这完善得多\n1. 没有考虑data数据是多层次情况，Vue会找到data中所有层次的对象的属性进行加工\n2. 数组中元素的响应式\n\n## $set()追加属性\n通过之前的操作 Vue 可以响应式地监视 data 数据\n\n但如果不是编写代码时就写在 data 中的数据，而是之后通过 **.** 动态添加的属性，Vue则无法监视，修改这些属性值，模板不会重新解析，页面不会变化\n\n可以通过 `Vue.set()` 或 `vm.$set()` 动态添加可被 Vue 监视的属性\n传入三个参数 **(<目标对象>, <属性名>, <属性值>)**\n\n**作用：**向响应式对象中添加一个 property（属性），并让这个新 property 同样是响应式的，且触发视图更新。\n\n**注意：目标对象**不能是data或vm实例，只能是其中的某个**实际存在**的对象，\n\n```js\nconst vm = new Vue({\n  el: '#root',\n  data: { student: {} }\n})\n// 追加属性\nVue.set(vm.student, 'name', 'chuckle')\n// $set()还能用于修改属性值\n// 一般是在修改数组元素后为了能被Vue监视到这次修改而使用\nvm.$set(vm.student, 'name', 'qx')\n\n// 不能直接在data或vm实例上添加属性\nvm.$set(vm, 'name', 'qx')\nvm.$set(vm._data, 'name', 'qx')\n\n// 直接添加不会被Vue监视，无法响应式\nvm._data.student.name = 'chuckle'\nvm.student.name = 'chuckle'\n\n```\n\n## 对数组的监视\nJS中数组也是一个对象，但它不能添加getter和setter，也就是不能通过数据劫持来实现数组中元素的响应式，无法触发视图更新\n\nVue 无法在元素被**通过索引值**修改后，响应式地重新解析模板，触发视图更新\n\n```js\nconst vm = new Vue({\n  el: '#root',\n  data: { student: ['001', 'chuckle', '19'] }\n})\n// 修改student数组中第一个元素，不会触发视图更新\nvm.student[0] = '002';\n```\n\n**Vue对数组元素的监视：**将被监视的数组的**变更方法**进行了**包装**，调用这些变更方法就会触发**视图更新**。\n\n**变更方法：**push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n\n**包装:**在Vue中的数组上重写同名的变更方法，在重写的方法中也会调用原来 **Array** 上的变更方法，但还加入了视图更新等操作\n\n也可以通过 `$set()` 在变更数组时也触发视图更新：\n\n```js\n// 修改第二个元素\nvm.$set(vm.student, 1, 'qx')\n```\n\n# 收集表单数据\n**v-model** 对不同表单元素有特殊的处理\n1. 若 **< input type='text'/>** 文本输入框 v-model 收集 **value** 值，即收集用户在输入框的输入\n2. 若 **< input type='radio'/>** 单选框 v-model 收集 **value** 值，但要给标签配置 value 值\n3. 若 **< input type='checkbox'/>** 多选框\n  1. 没有配置value值，则默认收集checked，一个被勾选会导致全部被勾选\n  2. 配置value值后，v-model初始值为数组，收集的是value值作为元素到数组中，初始值为空字符串，则收集checked\n\nv-model 也有**修饰符**，对收集的数据进行简单处理\n1. lazy 失去焦点再收集数据\n2. number 输入字符串转为有效数字，通常和 **< input type='number'/>** 一起使用\n3. trim 去除字符串首尾空格\n\n```html 案例：用户信息收集\n<div id=\"root\">\n  <!-- 绑定提交事件，后续发送ajax请求 -->\n  <form @submit.prevent=\"submit\">\n      用户名： <input type=\"text\" v-model.trim=\"formInfo.username\" /><br />\n      密码： <input type=\"password\" v-model=\"formInfo.password\" /><br />\n      <!-- 数字输入 -->\n      年龄： <input type=\"number\" v-model.number=\"formInfo.age\" /><br />\n      <!-- 单选框 -->\n      性别：\n      <label for=\"man\">男</label>\n      <input type=\"radio\" v-model=\"formInfo.sex\" name=\"sex\" id=\"man\" value=\"男\"/>\n      <label for=\"woman\">女</label>\n      <input type=\"radio\" v-model=\"formInfo.sex\" name=\"sex\" id=\"woman\" value=\"女\"/><br />\n      <!-- 多选框 -->\n      爱好：\n      <label for=\"hobbyOne\">吃饭</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyOne\" value=\"吃饭\"/>\n      <label for=\"hobbyTwo\">睡觉</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyTwo\" value=\"睡觉\"/>\n      <label for=\"hobbyThree\">打豆豆</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyThree\" value=\"打豆豆\"/><br />\n      <!-- 下拉框 -->\n      城市：\n      <select v-model=\"formInfo.city\">\n          <option value=\"北京\">北京</option>\n          <option value=\"上海\">上海</option>\n          <option value=\"广州\">广州</option>\n      </select><br />\n      其他信息：\n      <textarea v-model.lazy=\"formInfo.other\"></textarea><br />\n      <input type=\"checkbox\" v-model=\"formInfo.agree\" name=\"agree\"/>接受用户协议<br />\n      <button>提交</button>\n  </form>\n</div>\n\n<script>\n  new Vue({\n      el: \"#root\",\n      data: {\n          // 表单信息对象\n          formInfo: {\n              username: \"\",\n              password: \"\",\n              age: \"\",\n              sex: \"\",\n              hobby: [],\n              city: \"\",\n              other: \"\",\n              agree: false,\n          },\n      },\n      methods: {\n          submit() {\n              // 输出收集的表单数据并转为json格式\n              console.log(JSON.stringify(this.formInfo));\n          },\n      },\n  });\n</script>\n\n```\n\n# 过滤器\nVue3中已废弃过滤器\n\n在 **filters** 中配置**局部**过滤器，`Vue.filter()` 中配置**全局**过滤器\n\n和计算属性一样，过滤器也是对现有数据进行加工，本质上是函数\n\n**使用：** `{{ 数据 | 过滤器1 | 过滤器2 }}` **管道符**分隔，会依次传参调用，也可以在指令语法中使用，前一个的结果作为后面过滤器的**第一个**参数，返回这作为结果，还可以再传额外的参数\n\n```html\n<div id=\"root\">\n  <h3>时间：{{ time | fmtTime | interceptStr }}</h3>\n</div>\n<script>\n  // 全局过滤器\n  Vue.filter('interceptStr',(value, num=4)=>{\n      return value.slice(0,num)\n  })\n  new Vue({\n      el: '#root',\n      data: {\n          time: 1683449879865,\n      },\n      // 局部过滤器\n      filters: {\n          fmtTime(value, str='YYYY-MM-DD HH:mm:ss'){\n              return dayjs(value).format(str);\n          }\n      }\n  })\n</script>\n\n```\n\n# 常见内置指令\n前面已经学习了不少内置指令，v-on、v-bind、v-model、v-show、v-if、v-for等\n\nVue中还有一些常见的内置指令：\n1. `v-text` innerText同款效果\n2. `v-html` innerHtml同款效果，需注意安全性问题xss攻击\n3. `v-clock` 当Vue接管容器时，删除所有v-clock属性，配合css属性选择器实现隐藏未编译的 Mustache 标签直到实例准备完毕，或加载动画\n```css\n[v-cloak] { display: none; }\n```\n4. `v-once` 只渲染元素和组件一次，后续重新解析模板渲染页面会直接复用带有v-once的标签，视为静态内容，这可以用于优化更新性能\n5. `v-pre` 跳过这个元素和它的子元素的编译过程，用于跳过没有指令和插值语法的节点，能加快编译。\n\n# 自定义指令\n指令通过操控dom来控制交互或样式，如 v-show 通过操控css display 属性，来控制元素显隐\n\nVue的指令就是将原生操控dom的JS代码进行了**封装**\n\n自定义指令需要亲自去写操控 dom 的JS代码\n\n**注册指令：**\n自定义指令函数式传入两个参数\n1. **el** 指令所在的标签dom元素\n2. **binding** 一个对象，包含绑定相关的信息，其中 **value** 属性值是表达式的值\n\n分为**全局指令**和**局部指令**:\n\n```js\n// 注册全局指令\nVue.directive('<指令名>', function(el, binding){\n  el.innerHTML = binding.value\n})\n// 注册局部指令\nnew Vue({\n  el: '#root',\n  data: { },\n  directives: {\n    '<指令名>'(el, binding){\n      el.innerHTML = binding.value\n    }\n  }\n})\n\n```\n\n**指令名的问题：**\n指令名不应该写成驼峰形式，要用**横杠形式**。若指令名为单驼峰形式，使用指令时会找不到指令\n\n```js\ndirectives: {\n    'num-tenfold'(el, binding){ }\n  }\n// 使用指令：\n// <span v-num-tenfold=\"n\"></span>\n```\n\n**注意：**指令中的this指向window\n\n## 指令内容写法\n自定义指令的内容有**两种写法**：对象式、函数式\n\n**1、对象式：**\n\n```html\n<div id=\"root\">\n  <h3>n值：{{n}}</h3>\n  <h3>\n      放大十倍n值：\n      <!-- v-tenfold让n值放大10倍再应用到标签内容上 -->\n      <span v-tenfold=\"n\"></span>\n  </h3>\n  <button @click=\"n++\">让n+1</button>\n</div>\n<script>\n  new Vue({\n      el: '#root',\n      data: {\n          n: 0\n      },\n      // 注册局部指令\n      directives: {\n          // 指令名不用带v-\n          tenfold: {\n              // 指令与元素成功绑定（还未放到页面上）时调用\n              bind(el, binding){\n                  el.innerHTML = binding.value * 10;\n              },\n              // 元素应用到页面后，进行dom相关操作\n              inserted(el, binding){\n                  // 让其父元素背景变灰色\n                  el.parentNode.style.background = \"#ccc\";\n              },\n              // 指令所在的模板被重新解析时调用\n              update(el, binding) {\n                  el.innerHTML = binding.value * 10;\n              },\n          }\n      }\n  })\n</script>\n\n```\n\n**对象式**指令被调用：\n1. 指令与元素成功绑定（还未放到页面上）时，调用对象中 `bind()` 函数\n2. 指令所在元素被插入页面上时，调用对象中 `inserted()` 函数\n3. 指令所在的模板被重新解析时，调用对象中 `update()` 函数\n\nVue在不同时刻会调用指令对象中不同的函数\n\n**2、函数式：**\n\n```html\n<div id=\"root\">\n  <h3>n值：{{n}}</h3>\n  <h3>\n      放大十倍n值：\n      <!-- v-tenfold让n值放大10倍再应用到标签内容上 -->\n      <span v-tenfold=\"n\"></span>\n  </h3>\n  <button @click=\"n++\">让n+1</button>\n</div>\n<script>\n  new Vue({\n      el: '#root',\n      data: {\n          n: 0\n      },\n      // 注册局部指令\n      directives: {\n          // 指令名不用带v-\n          tenfold(el, binding){\n              el.innerHTML = binding.value * 10;\n              // 因为没有inserted状态，且在bind状态时获取不到dom元素\n              // 父元素一开始并不会应用此灰色背景\n              // 后续重新解析模板时就有效果，因为元素已被应用可获取到父元素\n              el.parentNode.style.background = \"#ccc\";\n          }\n      }\n  })\n</script>\n\n```\n\n函数式将对象式的 `bind()` 与 `update()` 函数合二为一，Vue2中没有合并上 `inserted()` 函数的效果，即Vue2中函数式里一般不能进行dom相关操作\n\n**函数式**指令被调用：\n1. 指令与元素成功绑定（还未放到页面上）时\n2. 指令所在的模板被重新解析时\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Promise异步编程","url":"/article/7a1fbbc5.html","content":"\n# 同步与异步\nJS是**单线程**语言，不能多个线程并发执行，即同一时间，只能处理一个任务\n\n单线程指的是浏览器中只有一个主线程(**JS引擎线程**)负责解释和执行JS代码，但是浏览器还提供了额外多个副线程用于实现**异步非阻塞**\n1、事件触发线程\n2、定时触发器线程\n3、异步http请求线程\n4、GUI渲染线程\n\n副线程处理完成之后会把对应的**回调函数**交给**消息队列**（任务队列）维护，JS引擎线程会在同步任务执行完后，去消息队列中每次取一个任务执行\n\n**两种任务**\n**同步任务：**在主线程上排队执行任务，只有前一个任务执行完毕，才能执行后一个任务\n**异步任务：**不进入主线程，而是进入**消息队列**的任务\n\n## 宏、微任务\n每次执行栈中执行的代码就是一个**宏任务**，在执行宏任务时遇到Promise等，会创建**微任务**（.then()里面的回调），并加入到微任务队列队尾。\n\n微任务必然是在某个宏任务执行过程时创建的\n\n宏任务来源：script，setTimeout，setInterval，setImmediate，I/O，requestAnimationFrame，UI rendering\n微任务来源：process.nextTick，promisesObject.observe，MutationObserver\n\n**微任务的执行：**在执行栈为空时，会从消息队列中取一个回调函数作为宏任务，在这个宏任务**执行前**，会执行微任务队列中**所有的**微任务\n\n## 事件循环\n事件循环就是主线程**重复**从消息队列中取消息（回调函数）并执行的过程\n\n<img src=https://cdn.chuckle.top/images/52-2.webp width=\"100%\" loading=\"lazy\">\n\n**参考：**\n[一篇搞定（Js异步、事件循环与消息队列、微任务与宏任务）](https://zhuanlan.zhihu.com/p/139967525)\n[JS的事件轮询(Event Loop)机制](https://juejin.cn/post/6844904047271477255)\n\n# Promise\nPromise(承诺) ES6的新类，是异步编程的新解决方案\n\n**作用：**把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数\n\n**回调地狱：**通过回调函数依次执行多个异步操作。Promise通过链式操作解决了回调地狱问题，也能更好地进行错误处理\n\n```js\nsetTimeout(function () {\n    console.log(\"等待一秒\");\n    setTimeout(function () {\n        console.log(\"再等一秒\");\n        setTimeout(function () {\n            console.log(\"又等一秒\");\n        }, 1000);\n    }, 1000);\n}, 1000);\n\n```\n\n以fetch为例，它返回一个Promise对象，承诺会在某个时刻返回请求到的数据，请求成功，会调用.then中的回调函数，失败则调用.catch中的\n\n任意一个then出现错误都会触发catch，而then不再往下执行，但catch后的then会继续执行\n\n.then中也可以返回一个Promise，如 res.json() 返回一个Promise，承诺之后将请求的数据返回为json格式，以此实现链式操作\n\n无论是成功还是失败，最后都会执行 .finally 中的回调函数，可以用于提示请求完成、关闭加载动画等\n\n```js\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> console.log(data) )\n.catch(err => console.error(err) )\n.finally(()=> console.log('请求结束') )\n```\n\n## 使用\nPromise本身是一个构造函数，其对象用来封装一个异步操作，并可以获取其成功或失败的结果值\n\n它拥有all、reject、resolve等方法，原型上有then、catch等方法\n\n**有三种状态：**pending（进行中）、resolved / fulfilled（已成功）和rejected（已失败），初始状态pending，只能转变为其它状态**一次**。\n状态\\[\\[PromiseState\\]\\]是Promise实例对象的属性，但并不是一个暴露的属性，无法获取和外部修改\n\nPromise的构造函数接收一个函数参数，传入两个参数：**resolve**，**reject**，分别表示异步操作执行**成功后的回调**函数和异步操作执行**失败后的回调**函数。\nresolve() 会将Promise的状态置为**resolved**，reject() 会将Promise的状态置为**rejected**\n\n`.then(onResolved, onRejected)` onResolved 和 onRejected 是两个回调函数，分别接收 resolve() 和 reject() 传入的参数，并在对应状态时回调\n\n> **注意：**Promise中所谓的成功或失败，需要根据业务的需要而定义，它只是提供了这两个状态供使用。\n\n```js\nconst p = new Promise((resolve, reject)=>{\n    // 随机生成0或1\n    let num = Math.round(Math.random());\n    // 定义num为1时是成功，0为失败，调用resolve()\n    if(num){\n        resolve(num);\n    }else{\n        reject(num);\n    }\n});\n\np.then(\n    data => { console.log(data) },\n    data => { console.log(data) }\n);\n\n```\n\nPromise封装AJAX\n\n```js\nfunction sendAJAX(url) {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.responseType = 'json';\n        xhr.open('GET', url, true);\n        xhr.send();\n        // 处理结果\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                 // 请求完成进行判断\n                if ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304) {\n                    // 定义为请求成功，将响应传入\n                    resolve(xhr.response);\n                } else {\n                    // 定义失败将状态码传入\n                    reject(xhr.status);\n                }\n            }\n        };\n    })\n}\n\n```\n\n使用封装好的 sendAJAX()\n\n```js\nsendAJAX('https://api.ooomn.com/api/yan?encode=json')\n.then(\n    res => console.log(res),\n    reason => console.log(reason)\n)\n.catch( err => console.log(err) )\n.finally(()=> console.log('请求完成') )\n```\n\n## 基本流程\n\n<img src=https://cdn.chuckle.top/images/52-3.webp width=\"100%\" loading=\"lazy\">\n\n## 属性和方法\n**1、\\[\\[PromiseResult\\]\\]** 承诺结果，保存着异步任务成功或失败的结果，即保存着 resolve() 或 reject() 传入的值，then中回调函数的参数可获取\n\n**2、**Promise构造函数传入的函数参数，其内部的操作是**同步**的\n\n```js\nnew Promise((resolve, reject) => {\n    console.log('1');\n})\n console.log('2');\n // 1\n // 2\n```\n\n**3、then 和 catch**\n**Promise.prototype.then** : (onResolved, onRejected) => {}\n(1) onResolved 函数: 成功的回调函数 (value) => {}\n(2) onRejected 函数: 失败的回调函数 (reason) => {}\n说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调\n返回一个新的 promise 对象\n\n**Promise.prototype.catch** : (onRejected) => {}\n(1) onRejected 函数: 失败的回调函数 (reason) => {}\n说明: then()的语法糖, 相当于: then(undefined, onRejected)\n\n> 通常不使用then的第二个参数，而是直接使用catch捕获失败\n\n**4、resolve 和 reject**\n**Promise.resolve** : (value) => {}\n(1) value: 成功的数据或 promise 对象\n说明: 当传入promise对象时，参数的结果决定了promise的结果。将状态从 pending 转为 fulfilled\n返回一个成功/失败的 promise 对象\n\n**Promise.reject** : (reason) => {}\n(1) reason: 失败的原因\n将状态从 pending 转为 rejected\n永远返回一个失败的 promise 对象\n\n```js\nlet p1 = Promise.resolve(123);\np1.then(data => console.log(data));// 123\n\nlet p2 = Promise.resolve(new Promise((resolve, reject) => {\n    reject('Error');\n}));\np2.catch(reason => {\n    console.log(reason);// Error\n})\n\n```\n\n**5、all**\n**Promise.all** : (promises) => {}\n(1) promises: 包含 n 个 promise 对象的数组\n返回一个新的 promise, 所有的 promise 都成功才成功, 只要一个失败就直接失败，多个失败返回第一个失败\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    resolve('OK');\n})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\nconst result = Promise.all([p1, p2, p3])\nresult.then(data=>console.log(data))\n// (3) ['OK', 'Success', 'Oh Yeah']\n\n```\n\n**6、race**\n**Promise.race** : (promises) => {}\n(1) promises: 包含 n 个 promise 的数组\n返回一个新的 promise, 第一个改变状态的 promise 的结果就是返回的结果状态\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\nconst result = Promise.race([p1, p2, p3]);\nresult.then(data => console.log(data));\n// Success\n\n```\n\n## 更多\n**1、then的返回值**\npromise.then()返回一个新 promise 对象\n其结果状态如下：\n(1) then中抛出异常，返回的 promise 状态为 rejected, reason 为抛出的异常\n(2) 返回的是非 promise 的任意值, 状态为 resolved, value 为返回的值\n(3) 返回的是另一个 promise, 该 promise 的结果就是返回的 promise 的结果\n\n```js\nconst obj = { name: 'chuckle' }\nconst p = new Promise((resolve, reject) => {\n    resolve(obj);\n})\np.then(data => {\n    console.log(data);// {name: 'chuckle'}\n    data.age = 19;\n    return Promise.resolve(JSON.stringify(data));\n}).then(data => {\n    console.log(data);// {\"name\":\"chuckle\",\"age\":19}\n}).then(data => {\n    console.log(data);// undefined\n})\n\n```\n\n**2、异常穿透**\n多个then链式调用，只需要在最后写一个catch，当一个then失败，就不再执行后续的then，直接到catch，catch后面的then会正常执行\n\n```js\nconst p = Promise.reject('err');\np.then(data => {\n    console.log(1);\n}).then(data => {\n    console.log(2);\n}).catch(err => {\n    console.log('err')\n}).then(data => {\n    console.log(3);\n})\n// err\n// 3\n\n```\n\n**3、中断Promise链**\n在回调函数中返回一个 **pendding** 状态的 promise 对象，因为then中回调函数是在 Promise 状态改变时调用的\n\n```js\nconst p = Promise.resolve('err');\np.then(data => {\n    console.log(1);\n}).then(data => {\n    console.log(2);\n    return new Promise(()=>{})\n}).then(data => {\n    console.log(3);\n})\n// 1\n// 2\n\n```\n\n# 手写Promise\n\n> 咕咕咕咕咕咕~~\n\n# async-await\n使用Promise对象去实现异步操作，通常会出现一堆异步任务到点了该处理的情况，每次执行的顺序都不一定一样\n而**async-await**允许我们用同步编程的方式去写异步代码，async是基于Promise的语法糖\n\nasync函数永远返回一个Promise对象，和then的规则是一样的\n\nawait 右侧的表达式一般为 promise 对象, 但也可以是其它的值\n1、如果表达式是 promise 对象, await 返回的是 promise 成功的值\n2、如果表达式是其它值, 直接将此值作为 await 的返回值\n\n```js 声明一个async函数\nasync function fun(){\n    console.log('chuckle')\n    return 'qx'// 返回什么,返回的Promise对象的结果就是什么\n}\nconsole.log(fun())\n//Promise {<fulfilled>: 'qx'}\n// [[Prototype]]: Promise\n// [[PromiseState]]: \"fulfilled\"\n// [[PromiseResult]]: \"qx\"\nfun().then(data=>{\n    console.log(data);// qx\n})\n\n```\n\nasync函数中的 await 能让js引擎等待其后的代码(通常是返回Promise对象的函数)有结果后再往下执行\n\n```js\nfunction a(){\n    return new Promise((resolve, reject) =>{\n        setTimeout(() =>{\n            resolve(2)\n        }, 1000);\n    })\n}\nasync function fun(){\n    console.log(1)\n    let num = await a();\n    console.log(num)\n    console.log(3)\n}\nfun();\n// 1\n// 等待一秒后\n// 2\n// 3\n\n```\n\n当多个fetch运行时，结果输出顺序有时并不是代码顺序，有时我们需要它按顺序执行，如果嵌套到then中，反而不美观\n\n```js\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(1)\n})\n\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(2)\n})\n\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(3)\n})\n\n```\n\n使用 async 优化fetch\n\n```js\nasync function fun(){\n    const url = 'https://api.ooomn.com/api/yan?encode=json';\n    try{\n        let res = await Promise.all(\n            [fetch(url), fetch(url), fetch(url)]\n        );\n        let jsons = res.map(res => res.json());\n        // json()返回的是promise对象,还需要再进行一次Promise.all\n        let values = await Promise.all(jsons)\n        console.log(values);\n    } catch(err){\n        console.log(err);\n    }\n}\nfun();\n\n```\n\n让一个函数等待另一个函数中fetch执行完\n\n```js\nasync function fun(){\n    const url = 'https://api.ooomn.com/api/yan?encode=json';\n    try{\n        let res = await Promise.all(\n            [fetch(url), fetch(url), fetch(url)]\n        );\n        let jsons = res.map(res => res.json());\n        // json()返回的是promise对象,还需要再进行一次Promise.all\n        let values = await Promise.all(jsons)\n        return values;\n    } catch(err){\n        console.log(err);\n    }\n}\nasync function fn(){\n    let data = 1;\n    data = await fun();\n    console.log(data);\n}\nfn();// (3) [{…}, {…}, {…}]\n\n```\n\nasync-await等待AJAX请求完成，不使用.then\n\n```js\n// 之前封装的Promise形式AJAX\nfunction sendAJAX(url) {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.responseType = 'json';\n        xhr.open('GET', url, true);\n        xhr.send();\n        // 处理结果\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                 // 请求完成进行判断\n                if ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304) {\n                    // 定义为请求成功，将响应传入\n                    resolve(xhr.response);\n                } else {\n                    // 定义失败将状态码传入\n                    reject(xhr.status);\n                }\n            }\n        };\n    })\n}\n\n// 点击按钮后等待请求完成再显示请求内容\nbtn.addEventListener('click',async function(){\n    let json = await sendAJAX('https://api.ooomn.com/api/yan?encode=json');\n    // 后面进行操作\n    console.log(json);\n});\n\n```\n\n# promisify\nJavascript异步演化史，是从callback到Promise再到Async/Await的历程\n\n对于一些老函数，可以使用 nodejs-util、其它第三方库中的 **promisify** 方法将其转为 Promise 形式的函数\n\npromisify函数作用就是把 callback 形式转成 promise 形式。\n\n只有符合 nodeCallback 的函数才能被 promisify 转化\nnodeCallback 有两个条件：1. 回调函数在主函数中的参数位置必须是最后一个；2. 回调函数参数中的第一个参数必须是 error \n\n```js nodejs中\nconst fs = require('fs');\nconst util = require('util');\nconst mineReadFile = util.promisify(fs.readFile);\n\nasync function main(){\n    try{\n        let data1 = await mineReadFile('./1.txt');\n        let data2 = await mineReadFile('./2.txt');\n        let data3 = await mineReadFile('./3.txt');\n        console.log(data1 + data2 + data3);\n    }catch(e){\n        console.log(e);\n    }\n}\nmain();\n\n```\n\n简单实现一个promisify\n\n```js\nvar promisify = (func, ctx) => {\n    // 返回一个新的function\n    return function() {\n        // 初始化this作用域\n        var ctx = ctx || this;\n        // 新方法返回的promise\n        return new Promise((resolve, reject) => {\n            // 调用原来的非promise方法func，绑定作用域，传参，以及callback（callback为func的最后一个参数）\n            func.call(ctx, ...arguments, function() {\n                // 将回调函数中的的第一个参数error单独取出\n                var args = Array.prototype.map.call(arguments, item => item);\n                var err = args.shift();\n                // 判断是否有error\n                if (err) {\n                    reject(err)\n                } else {\n                    // 没有error则将后续参数resolve出来\n                    args = args.length > 1 ? args : args[0];\n                    resolve(args);\n                }\n            });\n        })\n    };\n};\n\n// nodeCallback方法func1\nvar func1 = function(a, b, c, callback) {\n    callback(null, a+b+c);\n}\n// promise化后的func2\nvar func2 = promisify(func1);\n// 调用后输出6\nfunc1(1, 2, 3, (err, reuslt) => {\n    if (!err) {\n        console.log(result); //输出6\n    }\n})\nfunc2(1, 2, 3).then(console.log); //输出6\n\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"AJAX请求相关","url":"/article/f3334fd0.html","content":"\n# AJAX简介\nAJAX（Asynchronous JavaScript And XML）即异步的 JS 和 XML，发送异步请求，无刷新获取数据\n\n作用：进行前后端交互，[前后端交互初步概念](https://www.qcqx.cn/article/709b5ecb.html)\n\n**组成：**\n1. XMLHttpRequest/Fetch API (异步的与服务器交换数据)\n2. JavaScript/DOM (信息显示/交互)\n3. CSS (给数据定义样式)\n4. XML/JSON (作为转换数据的格式)\n\n优点：\n1. 无需刷新页面而与服务器端进行通信，获取数据。\n2. 根据事件动态获取所需数据，提高效率。\n\n缺点：\n1. 跨域问题\n2. SEO不友好\n3. 无浏览历史\n\nXML可扩展标记语言，用于传输和存储数据\n\n结构上与html标签结构类似，但XML内都是自定义标签\n\n```js\n<student>\n  <name>chuckle</name>\n  <age>19</age>\n</student>\n```\n\n# 发请求\n浏览器内建有 XMLHttpRequest 构造函数，通过操控其构造出的对象，就能发送AJAX请求\n\nxhr的 **readyState** 的属性记录了当前响应处于哪个过程，其值的的变化会触发 **readystatechange** 事件\n0 未调用open方法，1 调用了open还未调用send，2 发送了请求还未收到响应，3 收到了部分响应，4 响应都接收完了\n\n**基本属性和方法：**\n1. open(请求方法, URL, 是否异步) 初始化\n2. send(请求体) 发送请求\n3. setRequestHeader() 设置请求头\n4. abort() 取消请求\n5. timeout 设置超时时间，超时触发timeout事件\n\n**响应相关：**\n1. status 响应状态码\n2. statusText 状态字符串\n3. getAllResponseHeaders() 获取所有响应头\n4. response 响应体\n5. responseType 设置响应类型，自动转换\n6. responseXML 接收 xml 格式的响应数据\n7. responseText 接收文本格式的响应数据\n\n##  GET请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.responseType = 'json';\nxhr.open('GET', 'https://kpb.qcqx.cn/api', true);\nxhr.send();\nxhr.onreadystatechange = () => {\n   if(xhr.readyState === 4 && ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304)){\n       let text = xhr.responseText;\n       console.log(xhr.status);\n       console.log(xhr.statusText);\n       console.log(xhr.getAllResponseHeaders());\n       console.log(xhr.response);\n       console.log(text);\n   }\n};\n\n```\n\n## POST请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.responseType = 'json';\nxhr.open(\"POST\", \"https://kpb.qcqx.cn/api/login\", true);\nxhr.setRequestHeader(\n \"content-type\",\n \"application/x-www-form-urlencoded\"\n);\nxhr.send(\"username=qx&password=123\");\nxhr.onreadystatechange = () => {\n if (\n   xhr.readyState === 4 &&\n   ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304)\n ) {\n   console.log(xhr.status);\n   console.log(xhr.statusText);\n   console.log(xhr.getAllResponseHeaders());\n   console.log(xhr.response);\n }\n};\n\n```\n\n## 超时和错误处理\nxhr.timeout 设置超时时间，超时会触发timeout事件\n出错(网络错误)会触发error事件\n\n```js\nxhr.timeout = 2000; // 两秒超时\nxhr.ontimeout = ()=>{\n  console.log('连接超时');\n}\nxhr.onerror = ()=>{\n  console.log('出错了');\n}\n\n```\n\n## 取消请求\n`abort()` 可以取消一个请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://kpb.qcqx.cn/api', true);\nxhr.send();\nxhr.abort();// 取消请求\n```\n\n# JQ-AJAX\n使用JQ发送AJAX请求\n\nget和post方法：\n1. $.get(url, [data], [callback], [type])\n2. $.post(url, [data], [callback], [type])\nurl:请求的 URL 地址。\ndata:请求携带的参数。\ncallback:载入成功时回调函数。\ntype:设置返回内容格式\n\n通用方法 [ajax](https://www.bejson.com/apidoc/jquery/jQuery.Ajax.html)：\n\n```js\n$.ajax({\n  url: '',\n  type: 'GET',\n  // 请求头\n  headers: {\n    a: 100\n  }\n  // 数据类型\n  dataType: 'json',\n  // 请求体数据\n  data: {\n    username: 'qx',\n    password: '123'\n  },\n  // 请求超时时间\n  timeout: 2000,\n  // 是否异步处理，默认true\n  async: true,\n  // 请求成功回调\n  success: (data)=>{\n    console.log(data)\n  },\n  // 失败回调\n  error: (err)=>{\n    console.log(err)\n  }\n})\n\n```\n\n# Axios\n[Axios](https://github.com/axios/axios) 是一个简单的基于 promise 的 HTTP 客户端，适用于浏览器和 node.js。 Axios 在具有非常可扩展的接口的小包中提供了一个简单易用的库。\n\n**使用：**\n\n```code\nnpm install axios\n```\n\n```js cdn\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.min.js\"></script>\n```\n\n**常用方法：**\n**用于发送请求：**\n1. `axios(config)`: 通用/最本质的发任意类型请求的方式\n2. `axios(url[, config])`: 可以只指定 url 发 get 请求\n3. `axios.request(config)`: 等同于 axios(config)\n4. `axios.get(url[, config])`: 发 get 请求\n5. `axios.post(url[, data, config])`: 发 post 请求\n6. `axios.delete(url[, config])`: 发 delete 请求\n7. `axios.put(url[, data, config])`: 发 put 请求\n8. `axios.patch(url[, data, config])`: 发 patch 请求\n\n## 基本使用\n\nget请求：`axios.get()`\n\n```js\n// 设置baseURL\naxios.defaults.baseURL = 'https://kpb.qcqx.cn';\naxios.get('/api', {\n // url参数，查询字符串\n params: {},\n // 请求头\n headers: {\n   token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U'\n },\n}).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\npost请求：`axios.post()`\n\n```js\naxios.post('/api/login', {\n   // 第二个参数请求体\n   username: 'qx',\n   password: '123'\n },{\n  // 第三个参数其余配置\n }).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\n通用方法 `axios()`\n\n```js\naxios({\n url: '/api/login',\n method: 'post',\n // url参数，查询字符串\n params: {},\n // 请求头\n headers: {},\n // 请求体\n data: {\n   username: 'qx',\n   password: '123'\n },\n // 请求超时\n timeout: 5000\n}).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\n## 响应结果\n\n1. **config** 配置对象，里面有请求方法、请求头、请求url等\n2. **data** 响应体\n3. **headers** 响应头\n4. **request** axios发送请求时创建的原生的AJAX请求对象 XMLHttpRequest\n5. **status** 响应码\n6. **statusText** 响应状态字符串\n\n```js\n{data: Array(4), status: 200, statusText: 'OK', headers: i, config: {…}, …}\nconfig: {transitional: {…}, adapter: Array(2), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}\ndata: (4) [{…}, {…}, {…}, {…}]\nheaders: i {cache-control: 'no-cache', content-length: '299', content-type: 'application/json; charset=utf-8', expires: '-1', pragma: 'no-cache'}\nrequest: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}\nstatus: 200\nstatusText: \"OK\"\n[[Prototype]]: Object\n\n```\n\n## config配置对象\n\n1. **url** 给谁发送请求\n2. **method** 请求方法\n3. **baseURL** 设置url的基础结构\n4. **params** url参数，查询字符串\n5. **headers** 请求头\n6. **data** 请求体\n7. **timeout** 请求超时\n8. **transformRequest** 对请求的数据进行处理后再发送\n```js\ntransformRequest: [function (data, headers) {\n    return data;\n  }],\n```\n9. **transformResponse** 对响应体进行预处理\n```js\ntransformResponse: [function (data) {\n    return data;\n  }],\n```\n10. **paramsSerializer** url参数序列化，设置url参数的格式\n```js\nparamsSerializer: {\n    encode?: (param: string): string => { \n      // 自定义操作并返回转换后的字符串\n    },\n    // url参数序列化\n    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ),\n    indexes: false // 数组索引格式 null-无括号，false（默认）-空括号，true-带索引的括号\n  },\n// /api?a=100&b=200\n// /api/a/100/b/200\n// /api/a.100/b.200\n\n```\n11. **withCredentials**: 跨域请求是否携带cookie，默认false\n12. **responseType**: 响应体结果类型，默认json，array、buffer、document、json、text、stream\n13. **responseEncoding**: 响应结果的字符集，默认utf8\n14. **xsrfHeaderName**和**xsrfCookieName** 防止跨站请求攻击\n```markdown\nxsrfCookieName: 'XSRF-TOKEN', // default\nxsrfHeaderName: 'X-XSRF-TOKEN', // default\n在客户端第一次发送get请求时，服务器响应数据会携带一个会话cookie(XSRF-TOKEN)一同发送到客户端\n在后续请求发送前，http服务会从cookie中读取一个token(默认为XSRF-TOKEN)并且将其设置到HTTP头部(X-XSRF-TOKEN)一同发送到服务器。\n然后，服务器端会判断HTTP头部是否携带X-XSRF-TOKEN值，如果该值与之前发送的会话cookie值相同，就可以判定为来自己同一domain请求，否者会拦截该请求\n```\n15. **maxContentLength**: 2000 定义node.js中允许的http响应内容的最大大小\n16. **maxBodyLength**: 2000 定义http请求内容的最大大小\n17. **validateStatus** 请求成功的响应码范围\n```js\nvalidateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  }\n```\n18. **maxRedirects**: 21 node.js中允许最大重定向数\n19. **proxy**: 设置代理\n```js\nproxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    hostname: '127.0.0.1' //如果同时定义了“host”，则优先于“host”\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n```\n20. **cancelToken** 用于取消、打断请求，后面有详细介绍\n21. **signal** 使用AbortController取消Axios请求\n\n## 全局默认配置\n一些重复的配置项可以使用 **axios.defaults** 进行全局配置\n\n```js\n// 全局baseURL\naxios.defaults.baseURL = 'http://127.0.0.1';\n// 设置headers中默认token\naxios.defaults.headers.token = \"adra2nh12h4jh91\";\n```\n\n## 创建实例对象\n`axios.create(config)` 创建实例对象，传入配置项\n\n当需要大量发送请求时，可以创建一个实例对象，分别传入所需的基础配置项，可以减少代码的书写量，功能和axios几乎一样\n\n```js\nconst example = axios.create({\n  baseURL: 'http://127.0.0.1'\n});\n```\n\n发请求:\n\n```js\nexample({\n  url: '/api'\n}).then(res=>{\n  console.log(res)\n})\n```\n\n## 拦截器\n拦截器是一些函数，分为请求拦截器和响应拦截器，实例对象能单独添加\n\n可以添加多个拦截器，响应拦截器按代码位置先后**倒序**执行，响应拦截器顺序执行（请求拦截器进入的是堆栈，响应拦截器进入的是队列）\n\n**作用：**对请求的参数和内容进行检测（判断token，设置请求头）。对响应结果进行预处理（失败提醒、数据格式化）\n\n```js 基础使用\n// 请求拦截器\naxios.interceptors.request.use(function () {/*...*/})\n// 响应拦截器\naxios.interceptors.response.use(function () {/*...*/})\n// 实例对象添加拦截器\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n// 移除拦截器\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n// 清除请求或响应的所有拦截器\nconst instance = axios.create();\ninstance.interceptors.request.clear();\ninstance.interceptors.response.clear();\n\n```\n\n### 请求拦截器\n对请求的参数和内容进行检测（判断token，设置请求头）\n\n```js\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n```\n\n### 响应拦截器\n对响应结果进行预处理（失败提醒、数据格式化）\n\n```js\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n```\n\n## 取消请求\n**1、**使用 **cancelToken** 中断axios请求（v0.22.0后弃用），两种方式：\n\n```js CancelToken.source 工厂创建取消令牌\n//创建取消令牌的生成器对象\nconst CancelToken = axios.CancelToken\n//获取令牌对象\nconst source = CancelToken.source()\n\n// const source = axios.CancelToken.source()\naxios.get('/test',{\n\tcancelToken: source.token\n})\n\n//取消请求\nsource.cancel()\n\n```\n\n```js 将执行函数传递给 CancelToken 构造函数来创建取消标记\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new axios.CancelToken(function(c) {\n    // 执行器函数接收一个取消函数作为参数\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n\n```\n\n**2、**使用 **AbortController** :\n[AbortController](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 接口表示一个控制器对象，允许根据需要中止一个或多个 Web 请求\n\n通过AbortController创建一个信号对象signal，然后将signal传递给config的signal属性，调用AbortController对象的abort()方法来中止请求\n\n```js\n// 创建AbortController对象\nconst controller = new AbortController();\n// 获取信号对象\nconst { signal } = controller;\nconst config = {\n  method: 'get',\n  url: \"http://localhost:3000/posts\",\n  signal: signal\n}\naxios(config)\n.then((result) => {\n  console.log(result);\n  console.log(result.data);\n}).catch((err) => {\n  console.log(err);\n});\n// 取消请求\ncontroller.abort();\n\n```\n\n# Fetch\n\nget请求：\n\n```js\nconst options = {\n method: \"GET\",\n headers: {\n   token:\n     \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U\",\n },\n};\n\nfetch(\"https://kpb.qcqx.cn/api\", options)\n .then((response) => response.json())\n .then((response) => console.log(response))\n .catch((err) => console.error(err));\n\n```\n\npost请求：\n\n```js\nconst options = {\n method: \"POST\",\n headers: {\n   token:\n     \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U\",\n   \"content-type\": \"application/x-www-form-urlencoded\",\n },\n // 请求体\n body: new URLSearchParams({\n   matter: \"吃饭\",\n   data: \"2023-04-24\",\n   type: \"支出\",\n   account: \"20\",\n   remark: \"在食堂吃的\",\n }),\n};\n\nfetch(\"https://kpb.qcqx.cn/api\", options)\n .then((response) => response.json())\n .then((response) => console.log(response))\n .catch((err) => console.error(err));\n\n```\n\n使用AbortController打断fetch请求，在执行fetch请求时，可以通过AbortController创建一个信号对象signal，然后将signal作为配置选项传递给fetch()方法，调用AbortController对象的abort()方法来中止请求。\n\n```js\n// 创建AbortController对象\nconst controller = new AbortController();\n// 获取信号对象\nconst { signal } = controller;\n// 将信号对象传入fetch配置项\nfetch(url, { signal })\n  .then(response => response.json())\n\n// 调用abort() 中止 fetch 请求\ncontroller.abort();\n\n```\n\n# 跨域\n**同源策略：**浏览器的一种安全策略，同源即协议、域名、端口号必须完全相同。违背同源策略就是跨域\n\n**CORS**（Cross-Origin Resource Sharing），跨域资源共享。官方的解决跨域方\n案，在后端进行设置。\n\nCORS通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。\n\nexpress设置cors：\n\n```js\napp.all(\"/*\",function(req,res,next){\n  //设置允许跨域的域名，*代表允许任意域名跨域\n  res.header('Access-Control-Allow-Origin', '*');\n  //允许的header类型(允许自定义header)\n  res.header('Access-Control-Allow-Headers', '*');\n  // 指示资源的MIME类型，一般跨域都是请求api时发送，api应该都是返回json\n  res.header('Content-Type', 'application/json;charset=utf-8');\n  //跨域允许的请求方式 \n  res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, PATCH ,OPTIONS');\n  // 跨域的时候是否携带cookie\n  res.header(\"Access-Control-Allow-Credentials\", true);\n  if(req.method.toLowerCase() == 'options')\n      res.send(200); // 让options 尝试请求快速结束\n  else\n      next();\n})\n\n```\n\n**jsonp：**非官方的解决跨域方法\n\n利用一些天生具有跨域能力的标签发请求，如：img link iframe script。\n\n**步骤：**\n1. 新建一个script标签\n2. 设置 script 的 src，设置回调函数\n3. 将 script 添加到 body 中\n4. 服务端将数据扔进回调函数中返回\n5. script接收到响应会自动解析运行回调函数，从而获取到数据\n\n```js 简单案例\n<script src=\"https://127.0.0.1:3000/test\"></script>\n// 后端部分\nconst data = {\n  name: 'chuckle'\n}\napp.all('/test', (req,res)=>{\n  res.end(`console.log(${data.name})`);\n})\n\n```\n\nJQ实现jsonp\n\n```js\n$.getJSON(\"/api?callback=?\", function(data) {\n  // 获得数据\n  console.log(data);\n})\n// 后端设置\nconst data = {\n  name: 'chuckle'\n}\napp.all('/api', (req,res)=>{\n  // 将数据转化为字符串\n  let str = JSON.stringify(data);\n  // 接收回调函数\n  let cb = req.query.callback;\n  // 返回数据data\n  res.end(`${cb}(${str})`);\n})\n\n```\n\n\n","tags":["前端","AJAX"],"categories":["学习笔记"]},{"title":"NodeJS接口、会话控制","url":"/article/a1e193d6.html","content":"\n# 接口\n接口即API，是前后端通信的桥梁.用于实现前后端通信\n\n在NodeJS中，一个接口就是服务中的一个路由规则\n\nAPI给客户端返回结果通常是 **JSON** 格式\n\n后端直接使用ejs、pug渲染好页面再返回是前后端不分离的表现，后端（HTTP服务）通过API将数据交给前端（网页、APP、小程序），后端只需考虑提供前端所需要的数据，而不用管数据的渲染，API 是通用的，不同的类型的前端使用同一个API就能渲染出多种页面。\n\n## 接口的组成\n接口的组成会在API文档中详细说明，[随机图片验证码API文档](https://www.free-api.com/doc/582)\n\n1. 请求方式 GET / POST\n2. 接口地址 URL\n3. 请求参数\n4. 响应结果、格式\n\n## RESTful API\n[RESTful API 设计指南--阮一峰](https://www.ruanyifeng.com/blog/2014/05/restful_api.html)\nRESTful API 是一种接口的规范，为了减少前后端的沟通成本\n同一个URL路径（可带上路由参数）不同的请求方法代表不同的功能，且语义要相符，API 返回的状态码也要相符\n\n| 操作         | 请求类型 | URL      | 返回                 |\n| ------------ | -------- | -------- | -------------------- |\n| 新增         | POST     | /song    | 返回新生成的歌曲信息 |\n| 删除         | DELETE   | /song/10 | 返回一个空文档       |\n| 覆盖修改         | PUT      | /song/10 | 返回更新后的歌曲信息 |\n| 局部修改         | PATCH    | /song/10 | 返回更新后的歌曲信息 |\n| 获取所有     | GET      | /song    | 返回歌曲列表数组     |\n| 获取单个(id) | GET      | /song/10 | 返回单个歌曲信息     |\n\n状态码语义：404 找不到资源、403 禁止访问、500服务器内部错误\n\n~~当然通常是POST亿把梭哈~~\n\n## json-server\n[json-server](https://github.com/typicode/json-server) 是一个 JS 编写的全局工具包，可以快速搭建 RESTful API 服务，也用于前端临时搭建接口使用\n\n安装：`npm i -g json-server`\n\n新建一个json文件\n\n```json\n{\n  \"song\": [\n    { \"id\": 1, \"name\": \"干杯\", \"singer\": \"五月天\" },\n    { \"id\": 2, \"name\": \"当\", \"singer\": \"动力火车\" },\n    { \"id\": 3, \"name\": \"不能说的秘密\", \"singer\": \"周杰伦\" }\n  ]\n}\n\n```\n\n```js 使用：以 JSON 文件所在文件夹作为工作目录 ，执行该命令，端口默认3000\njson-server --watch <文件名>.json\n```\n\n命令行的提示：\n\n```js\n\\{^_^}/ hi!    \n\n  Loading 01.json\n  Done\n\n  Resources\n  http://localhost:3000/song\n\n  Home\n  http://localhost:3000\n\n```\n\n## 接口测试工具\n**常用接口测试工具：**[apipost](https://www.apipost.cn/)，[apifox](https://apifox.com/)，[postman](https://www.postman.com/)\n\n**apipost**基本使用：\n1. Header 设置请求头\n2. Query 设置查询字符串\n3. Body 设置请求体\n   1. none 没有内容\n   2. form-data 表单形式数据\n   3. x-www-form-urlencoded Query-String形式的数据\n   4. raw 原生请求体，json格式数据\n\n# 记账本添加API\n因为API即请求方法+路由，所以去修改routes文件夹下的路由，将原来的index.js页面路由放到web文件夹，新建账单相关接口路由account.js，放到api文件夹\n\n然后在app.js中使用路由，接口路径添加上api前缀\n\n```js /app.js\n// 导入接口路由\nvar accountRouter = require('./routes/api/account');\n// 使用接口路由，并添加api前缀\napp.use('/api', accountRouter);\n```\n\naccount.js总览，相同路径、不同请求方法、带路由参数来实现增删改查接口，符合RESTful API接口规范\n\n<img src=https://cdn.chuckle.top/images/50-2.webp width=\"50%\" loading=\"lazy\">\n\n**接口的设计：**\n1. 接口通常返回的都是 **JSON**\n2. 一个接口通常由**响应编号 code**、**响应信息 msg**、**响应数据 data** 组成\n3. 即使出现错误或失败也是通过响应编号去体现错误，而不设置状态响应码\n4. 响应编号，字符串，四个0表示成功，非0（如：1001）表示失败\n5. 响应信息，字符串，如：查找成功、删除成功\n\n```js /routes/api/account.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 获取所有记录接口\nrouter.get('/', function (req, res, next) {\n\n    // 读取所有数据，按日期降序\n    AccountModel.find().sort({ date: -1 })\n        .then(data => {\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            // 接口的状态信息标识在code中，不设置响应码\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1001',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 获取单条记录接口\nrouter.get('/:id', (req, res) => {\n    let { id } = req.params;\n    AccountModel.findById(id)\n        .then(data => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            });\n        })\n        .catch(err => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1004',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n})\n\n// 添加记录接口\nrouter.post('/', function (req, res, next) {\n\n    // 插入一条数据\n    AccountModel.create({\n        // 解构赋值\n        ...req.body,\n        // 覆盖修改日期为日期对象\n        date: moment(req.body.date).toDate()\n    })\n        .then(data => {\n            console.log(data);\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '添加成功',\n                // 响应的数据，返回创建成功的文档\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1002',\n                // 响应的信息\n                msg: '添加失败',\n                // 响应的数据\n                data: null\n            })\n        });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.delete('/:id', (req, res) => {\n    // 获取路由参数id\n    let id = req.params.id;\n    AccountModel.deleteOne({ _id: id })\n        .then(data => {\n            console.log(data);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '删除成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1003',\n                // 响应的信息\n                msg: '删除失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 更新账单接口\nrouter.patch('/:id', (req, res) => {\n    let { id } = req.params;\n    AccountModel.updateOne({ _id: id }, req.body)\n    .then(data => {\n        res.json({\n            code: '0000',\n            msg: '更新成功',\n            data: data\n        })\n    })\n    .catch(err=>{\n        res.json({\n            code: '1005',\n            msg: '更新失败',\n            data: null\n        })\n    })\n})\n\n\nmodule.exports = router;\n\n```\n\n# 会话控制\n每一个 HTTP 请求都是一个会话，但 HTTP 是一种无状态的协议，它没有办法区分不同的请求、不同的会话是否来自于同一个客户端，即无法区分、识别用户\n\n所以需要后端实现会话控制来区分用户，如使用注册登陆来区分用户，以此保护不同用户的**数据安全**\n\n常见的会话控制技术：**cookie**、**session**、**token**\n\n# cookie\ncookie 是 HTTP 服务器发送到用户浏览器并保存在本地的一小块数据，按域名划分，本质上是Key-Value键值对\n\n浏览器向服务端发送请求时，会自动携带对应域名下的所有 cookie 设置在请求头的 Cookie 属性中\n\n服务端通过响应报文的 set-cookie 在浏览器设置cookie\n\n## 设置cookie\n`cookie()` 在响应报文set-cookie中携带cookie\n\n设置浏览器关闭时自动销毁的cookie：\n\n```js\nres.cookie('name', 'chuckle');\n// 响应报文：\nSet-Cookie: name=chuckle; Path=/\n```\n\n设置一段时间后过期的cookie，设置时maxAge单位毫秒，响应报文中Max-Age单位秒\n\n```js\n// 设置maxAge，cookie存活多少ms\nres.cookie('user', 'giggles',{maxAge: 60000});\n// 响应报文：\nSet-Cookie: user=giggles; Max-Age=60; Path=/; Expires=Sun, 23 Apr 2023 01:12:07 GMT\n```\n\n后续请求头中Cookie属性携带cookie，Key-Value\n\n```js\nCookie: name=chuckle; user=giggles\n```\n\n## 删除cookie\n`clearCookie()` 通过设置对应cookie的过期时间为1970年，使cookie过期自动删除\n\n```js\nres.clearCookie('name');\nres.clearCookie('user');\n```\n\n```js 响应报文\nSet-Cookie: name=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT\nSet-Cookie: user=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT\n```\n\n## 获取cookie\n需要安装 [cookie-parser](https://www.npmjs.com/package/cookie-parser) 是一个中间件\n\n```js 使用cookie-parser\n// 导入\nconst cookieParser = require('cookie-parser');\n// 设置中间件\napp.use(cookieParser())\n```\n\n设置完中间件后，通过 **req.cookies** 即可获取所有cookie\n\n```js\nconsole.log(req.cookies);\n// {\n//   name: 'chuckle',\n//   user: 'giggles'\n// }\n```\n\n## cookie安全\n**1、httpOnly** 设置cookie时带上 httpOnly 属性，客户端脚本代码(js)尝试读取该cookie，浏览器将返回一个空字符串作为结果\n\nHttpOnly是包含在http返回头Set-Cookie里面的一个附加的属性\n\n```js\nres.cookie('name', 'chuckle',{httpOnly: true});\n// 响应报文\nSet-Cookie: name=chuckle; Path=/; HttpOnly\n```\n\n**2、加密cookie**，设置cookie时带上 **signed** 属性，并给 cookieParser(secret) 中间件传入一个字符串secret用于加密，获取时使用 **req.signedCookies**\n\n```js\n// 设置加密字符串\nconst secret = 'qx';\napp.use(cookieParser(secret))\n// 设置cookie\nres.cookie('number','123456',{signed: true,maxAge: 60*1000});\nconsole.log(req.signedCookies);// { number: '123456' }\n```\n\n在浏览器端查看该cookie，可以看到已经被加密\n\n```js\nnumber: s%3A123456.gnY%2Bp%2BEFLYanFxZP9eAYnlyW9IkToo4KlHZyIJ3DJgc\n```\n\n# session\nsession 在服务器端保存当前访问用户的相关信息（用户名、用户id、邮箱等）\n\n**作用：**识别用户\n\n**登陆例子:**\n当用户输入账号密码传给服务端后，会去数据库查找是否正确，如果正确，服务端会给这个用户创建一个session对象，保存当前用户的基本信息，该对象还会生成并保存一个唯一session_id会话id（sid，在数据库中字段名是_id），然后服务端会将sid以cookie形式返回给浏览器，浏览器之后的请求就会带上这个sid，服务端可以通过这个sid在一堆session对象数组中识别是哪个用户。\n\n## 使用session\n安装 [express-session](https://www.npmjs.com/package/express-session) 和 [connect-mongo](https://www.npmjs.com/package/connect-mongo) 两个包\n\nexpress-session用于将session存到内存中，connect-mongo可以将session存到数据库中，方便查看\n\n**设置中间件进行配置:**\n\n后续的增删改查操作，中间件会自动匹配好当前请求是哪个用户\n\n```js\n// 引入包\nconst session = require(\"express-session\");\nconst MongoStore = require('connect-mongo');\n// 使用中间件\napp.use(session({\n    name: 'sid', //设置cookie的name，默认值是：connect.sid\n    secret: 'chuckle', //参与加密的字符串（又称签名）\n    saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id\n    resave: true, //是否在每次请求时重新保存session，用于重置session过期时间\n    // 设置session存储位置\n    store: MongoStore.create({\n        // 存储到mongodb中\n        mongoUrl: 'mongodb://127.0.0.1:27017/test' //数据库的连接配置\n    }),\n    // 浏览器端cookie设置\n    cookie: {\n        httpOnly: true, // 开启后前端无法通过 JS 操作\n        maxAge: 1000 * 60 // 不仅控制cookie，也控制session的生命周期\n    },\n}))\n```\n\n## 设置session\n模拟登陆情况\n\n```js\napp.get('/login', (req, res) => {\n    let uname = req.query.username;\n    // 登陆需要传递查询字符串，账号和密码\n    if(req.query.username === 'chuckle' && req.query.password === '123456'){\n        // 设置session，就是把用户的基本信息传进去\n        req.session.username = uname;// 传入用户名\n        res.send('登陆成功');\n        return;\n    }\n    res.send('登陆失败');\n});\n// 响应报文\nSet-Cookie: sid=s%3A-5tzIG5ZCDk4JaT7POAgODadySTDZVur.H7%2Fh5xrNRApVa%2Fl1J4fynkE48fREOM1yfLjdZd68bps; Path=/; Expires=Sun, 23 Apr 2023 03:16:14 GMT; HttpOnly\n\n```\n\n数据库中：\n\n<img src=https://cdn.chuckle.top/images/50-3.webp width=\"100%\" loading=\"lazy\">\n\n## 读取session\n检测session是否存在，不存在则让用户登陆\n\n```js\napp.get('/', (req, res) => {\n    // 检测session中是否有用户信息\n    // 中间件已经自动获取当前cookie中的用户信息，从数据库中取出来，存到session内存中\n    if(req.session.username){\n        // 有信息则说明已经登陆，直接欢迎\n        res.send('Welcome');\n        return;\n    }\n    res.send('还未登陆');\n});\n\n```\n\n## 销毁session\n`destroy()`，如用户主动退出登陆\n\n```js\napp.get('/logout', (req, res) => {\n    // 中间件已经自动匹配好当前请求是哪个用户，直接调用destroy()即可销毁\n    req.session.destroy(()=>{\n        res.send('退出成功')\n    })\n});\n\n```\n\n# cookie与session区别\n1. 存在的位置\ncookie：浏览器端\nsession：服务端\n2. 安全性\ncookie 是以明文的方式存放在客户端的，安全性相对较低\nsession 存放于服务器中，所以安全性相对较好\n3. 网络传输量\ncookie 设置内容过多会增大报文体积， 会影响传输效率\nsession 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率\n4. 存储限制\n浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制（165）\nsession 数据存储在服务器中，所以没有这些限制\n\n\n# 记账本-注册登陆\n**效果：**不同用户登陆后显示对应用户的账单，没有登陆就跳转到登录页面\n\n大概步骤：\n1. 先在app.js中导入session操作相关的包，并设置中间件\n2. 创建注册登陆的ejs页面\n3. 创建用户文档模型，后续通过其将用户信息写入数据库\n4. 修改账单文档模型，添加一个userID字段来保存账单对应用户的_id，用以区分账单属于哪个用户\n5. 创建注册登陆的路由 auth.js，使用 [md5](https://www.npmjs.com/package/md5) 对密码进行加密\n6. 创建中间件 checkLoginMiddleware.js 来检测用户是否登陆\n7. 修改index.js路由，应用检测登陆的中间件，并根据业务需要调整部分代码\n\n**业务逻辑：**\n1. 用户注册后将用户名和经过md5加密后的密码保存在数据库users集合中，并且每次新注册会检测用户名是否已经存在\n2. 登陆时获取客户端传来的用户名和密码去数据库中找是否有对应的用户，因为保存在数据库中的密码是经过md5加密的，所以要将密码经过一次md5加密后再去查找，同一字符串经过md5加密后结果是相同的\n3. 用户存在即登陆成功，则将用户信息（用户名和_id）写入session\n4. 在新增账单记录时，从session中找到当前用户的_id，然后保存到账单文档的userID字段\n5. 渲染账单列表时，只渲染属于当前用户的账单文档，对比当前登陆用户的_id和每个文档userID是否相同\n6. 退出登陆即销毁当前的session\n7. 对于从请求头cookie中获得sid然后找到对应的session，并提取用户的信息，是express-session包内中间件自动完成的，后续业务只需要req.session.<属性名>即可获取当前用户的信息\n\n数据库：\n\n<img src=https://cdn.chuckle.top/images/50-4.webp width=\"100%\" loading=\"lazy\">\n\n先在app.js中导入session操作相关的包，并设置中间件\n\n```js app.js\n// 导入session操作相关包\nconst session = require(\"express-session\");\nconst MongoStore = require('connect-mongo');\n// 导入数据库连接配置文件\nconst { HOST, PORT, NAME } = require('./config');\n\n// 使用中间件\napp.use(session({\n  name: 'sid', //设置cookie的name，默认值是：connect.sid\n  secret: 'chuckle', //参与加密的字符串（又称签名）\n  saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id\n  resave: true, //是否在每次请求时重新保存session，用于重置session过期时间\n  // 设置session存储位置\n  store: MongoStore.create({\n    // 存储到mongodb中\n    mongoUrl: `mongodb://${HOST}:${PORT}/${NAME}` //数据库的连接配置\n  }),\n  // 浏览器端cookie设置\n  cookie: {\n    httpOnly: true, // 开启后前端无法通过 JS 操作\n    maxAge: 1000 * 60 * 60 * 24 * 7 // 不仅控制cookie，也控制session的生命周期\n  },\n}))\n\n```\n\n创建注册登陆的ejs页面\n\n```js /views/auth/reg.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"/css/page.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>注册</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/login\">去登陆</a>\n        </div>\n        <form action=\"/reg\" method=\"post\" autocomplete=\"off\">\n          <div class=\"form-item\">\n            <label for=\"username\">用户名</label>\n            <input class=\"control\" type=\"text\" name=\"username\" id=\"username\" required/>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"password\">密码</label>\n            <input class=\"control\" type=\"text\" name=\"password\" id=\"password\" required/>\n          </div>\n          <hr />\n          <button>注册</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```js /views/auth/login.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"/css/page.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>登陆</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/reg\">去注册</a>\n        </div>\n        <form action=\"/login\" method=\"post\" autocomplete=\"off\">\n          <div class=\"form-item\">\n            <label for=\"username\">用户名</label>\n            <input class=\"control\" type=\"text\" name=\"username\" id=\"username\" required/>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"password\">密码</label>\n            <input class=\"control\" type=\"text\" name=\"password\" id=\"password\" required/>\n          </div>\n          <hr />\n          <button>登陆</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```css /public/css/page.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\nhr{\n    margin: 20px auto;\n    border: 0;\n    border-top: 1px solid rgb(220, 220, 220);\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.home{\n    margin-top: 10px;\n    padding-left: 20px;\n    display: flex;\n    justify-content: space-between;\n}\n.home a{\n    color: rgb(33, 70, 181);\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.content-box form{\n    margin-top: 10px;\n}\n.form-item{\n    margin-bottom: 15px;\n}\n.form-item label{\n    display: block;\n    height: 32px;\n    line-height: 32px;\n    font-size: 18px;\n}\n.form-item>*{\n    width: 100%;\n}\n.form-item>.control{\n    padding: 6px 12px;\n    height: 36px;\n    font-size: 16px;\n    line-height: 36px;\n    color: #363636;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n    outline: none;\n    font-family:\"Microsoft YaHei\",微软雅黑;\n}\n.form-item>.control:focus{\n    border-color: #66afe9;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n}\n.form-item>textarea.control{\n    padding: 8px 12px;\n    height: 100px;\n    line-height: 1;\n    resize: none;\n}\n.content-box form>button{\n    width: 100%;\n    padding: 6px 12px;\n    margin-bottom: 15px;\n    border: 1px solid rgb(57, 162, 204);\n    background: rgb(37, 173, 204);\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    font-size: 17px;\n    color: #fff;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.content-box form>button:hover{\n    background: rgb(32, 153, 190);\n}\n\n```\n\n创建用户文档模型，后续通过其将用户信息写入数据库\n\n```js /models/UserModel.js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet UserSchema = new mongoose.Schema({\n    username: {\n        type: String,\n        required: true\n    },\n    password: {\n        type: String,\n        required: true\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('users', UserSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n修改账单文档模型，添加一个userID字段来保存账单对应用户的_id，用以区分账单属于哪个用户\n\n```js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet AccountSchema = new mongoose.Schema({\n    matter: {\n        type: String,\n        required: true\n    },\n    date: {\n        type: Date,\n        required: true\n    },\n    type: {\n        type: String,\n        enum: ['支出', '收入'],\n        default: '支出'\n    },\n    account: {\n        type: Number,\n        required: true\n    },\n    remark: {\n        type: String,\n        default: '无'\n    },\n    // 通过userID保存账单属于哪个用户的\n    userID:{\n        type: String,\n        required: true\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('accounts', AccountSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n创建注册登陆的路由 auth.js，使用 [md5](https://www.npmjs.com/package/md5) 对密码进行加密\n\n```js /routes/web/auth.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入用户文档模型\nconst UserModel = require('../../models/UserModel');\n// 导入md5对密码进行加密\nconst md5 = require('md5');\n\n// 注册\n// 注册页面路由\nrouter.get('/reg', (req, res) => {\n    res.render('auth/reg');\n})\n// 注册操作路由\nrouter.post('/reg', (req, res) => {\n    // 如果用户名重复就重新注册\n    UserModel.findOne({ username: req.body.username })\n        .then(data => {\n            // data不为空说明用户名重复\n            if (data) {\n                res.render('tip', { msg: '用户名已存在', url: '/reg' });\n                return;\n            }\n            // 用户名不重复则创建用户\n            UserModel.create({\n                ...req.body,\n                // 使用md5对密码进行加密\n                password: md5(req.body.password)\n            })\n                .then(data => {\n                    res.render('tip', { msg: '注册成功', url: '/login' });\n                })\n                .catch(err => {\n                    res.status(500).render('tip', { msg: '注册失败!', url: '/reg' });\n                })\n        })\n})\n\n// 登陆\n// 登陆页面路由\nrouter.get('/login', (req, res) => {\n    res.render('auth/login');\n})\n// 登陆操作路由\nrouter.post('/login', (req, res) => {\n    // 获取用户名和密码\n    let { username, password } = req.body;\n    // 如果用户名或密码为空则返回失败\n    if (!username || !password) {\n        res.render('tip', { msg: '用户名或密码错误', url: '/login' });\n        return;\n    }\n    // 查询数据库，看有没有该用户\n    // 要对密码也做一次md5加密然后去数据库对比\n    UserModel.findOne({\n        username: username,\n        password: md5(password)\n    })\n        .then(data => {\n            // 如果data为空说明用户不存在\n            if (!data) {\n                res.render('tip', { msg: '用户名或密码错误', url: '/login' });\n                return;\n            }\n            // 用户存在则将用户信息写入session\n            req.session.username = data.username;\n            req.session._id = data._id;\n            // 渲染成功提示页\n            res.render('tip', { msg: '登陆成功', url: '/' });\n        })\n        .catch(err => {\n            res.status(500).render('tip', { msg: '登陆失败!', url: '/login' });\n        })\n})\n\n// 退出登陆，避免跨站请求伪造，使用post\nrouter.post('/logout', (req, res) => {\n    // 销毁session\n    req.session.destroy(() => {\n        res.render('tip', { msg: '退出成功', url: '/login' });\n    });\n});\n\n\nmodule.exports = router;\n\n```\n\n创建中间件 checkLoginMiddleware.js 来检测用户是否登陆\n\n```js /middleware/checkLoginMiddleware.js\nconst checkLoginMiddleware = (req, res, next) => {\n    if (!req.session.username) {\n        // redirect重定向到登陆页面\n        return res.render('tip', { msg: '还未登陆!', url: '/login' });\n    }\n    next();\n}\n\nmodule.exports = checkLoginMiddleware;\n\n```\n\n修改index.js路由，应用检测登陆的中间件，并根据业务需要调整部分代码\n\n```js /routes/web/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 导入检测是否登陆的中间件、\nconst checkLoginMiddleware = require('../../middleware/checkLoginMiddleware');\n\n// 将首页重定向到账单页\nrouter.get('/', (req, res)=>{\n  res.redirect('/account');\n})\n\n// 记账本页面路由\nrouter.get('/account',checkLoginMiddleware, function (req, res, next) {\n  // 读取对应用户所有数据，按日期降序\n  AccountModel.find({userID: req.session._id}).sort({ date: -1 })\n    .then(data => {\n      // 将数据数组传递过去遍历渲染，为了格式化日期，将moment传入\n      res.render('index', { content: data, moment });\n    })\n    .catch(err => {\n      console.log(err);\n      // 查找失败则返回500\n      res.status(500).render('tip', { msg: '查找失败!', url: '/' });\n    })\n\n});\n\n// 添加记录页面路由\nrouter.get('/add',checkLoginMiddleware, function (req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add',checkLoginMiddleware,  function (req, res, next) {\n\n  // 插入一条数据\n  AccountModel.create({\n    // 解构赋值\n    ...req.body,\n    // 覆盖修改日期为日期对象\n    date: moment(req.body.date).toDate(),\n    // 将对应用户id传入\n    userID: req.session._id\n  })\n    .then(data => {\n      console.log(data);\n      // 成功跳转到提示页\n      res.render('tip', { msg: '添加成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      // 添加失败则返回500\n      res.status(500).render('tip', { msg: '添加失败!', url: '/' });\n    });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id',checkLoginMiddleware,  (req, res) => {\n  // 获取路由参数id\n  let id = req.params.id;\n  AccountModel.deleteOne({ _id: id })\n    .then(data => {\n      console.log(data);\n      // 删除成功跳转提示页\n      res.render('tip', { msg: '删除成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      res.status(500).render('tip', { msg: '删除失败!', url: '/' });\n    })\n\n});\n\nmodule.exports = router;\n\n```\n\n# token\ntoken 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token中保存着用户信息\n\n**作用：**实现会话控制，识别用户的身份，主要用于移动端 APP\n\n**与session区别：**token将用户信息存放于客户端，而session将用户信息存放于服务端，在客户端仅存放session的sid（_id）\n\n**token工作流程：**\n1. 用户填写账号和密码校验身份，校验通过后服务端响应 token，一般放在响应体中\n2. 后续发送请求时，需要手动将 token 添加在请求报文的 token 属性中，一般放在请求头中\n\n**token特点：**\n1. 数据存储在客户端，服务端压力更小\n2. 数据加密、可以避免 CSRF（跨站请求伪造），相对更安全\n3. 扩展性更强：服务间可以共享，增加服务节点更简单\n\n## JWT\nJWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证\n\ntoken实现身份验证有很多办法，但 JWT 使 token 的生成与校验更规范\n\n使用 [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) 包 来操作 token\n\n**使用：**\n1. `sign()` 生成token\nsign(用户信息数据对象, 加密字符串, 配置对象)\n2. `verify` 校验解析token\nverify(token, 加密字符串, 回调函数)\n\n```js\nconst jwt = require('jsonwebtoken');\n// 生成token\n// sign(用户信息数据对象, 加密字符串, 配置对象)\n// 在配置对象中设置生命周期等等\nlet token = jwt.sign({\n    username: 'chuckle',\n    id: '123456'\n}, 'qx', {\n    // 设置生命周期，单位秒\n    expiresIn: 60\n});\n\nconsole.log(token);\n// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNodWNrbGUiLCJpZCI6IjEyMzQ1NiIsImlhdCI6MTY4MjI2NTI3OSwiZXhwIjoxNjgyMjY1MzM5fQ._Or0D76QY78NofSGpZt81-B_T8K4iX_v0jEzDBvnObk\nlet t = token;\n\n// 校验解析token，获得用户信息\n// verify(token, 加密字符串, 回调函数)\njwt.verify(token, 'qx', (err, data) => {\n    if(err){\n        console.log('校验失败');\n        return;\n    }\n    console.log(data);\n    //{ username: 'chuckle', id: '123456', iat: 1682265279, exp: 1682265339 }\n});\n\n```\n\n# 记账本-接口token\n记账本的页面端已经做了会话控制、用户区分，但API接口仍然没有做约束、没区分用户，下面使用token进行会话控制\n\n## 注册登陆接口\n注册登陆接口，即注册成功则在数据库users集合中新建一个用户文档，登陆成功则返回一个token\n\n在api路由文件夹中新建auth.js，作为注册登陆接口的路由\n\n```js /routes/api/auth.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入用户文档模型\nconst UserModel = require('../../models/UserModel');\n// 导入md5对密码进行加密\nconst md5 = require('md5');\n// 导入jwt控制token\nconst jwt = require('jsonwebtoken');\n// 导入配置文件，获取加密字符串\nconst config = require('../../config');\n\n// 注册\n// 注册操作API\nrouter.post('/reg', (req, res) => {\n    // 如果用户名重复就重新注册\n    UserModel.findOne({ username: req.body.username })\n        .then(data => {\n            // data不为空说明用户名重复\n            console.log(data);\n            if (data) {\n                res.json({\n                    code: '2003',\n                    msg: '用户名已存在',\n                    data: null\n                })\n                return;\n            }\n            // 用户名不重复则创建用户\n            UserModel.create({\n                ...req.body,\n                // 使用md5对密码进行加密\n                password: md5(req.body.password)\n            })\n                .then(data => {\n                    res.json({\n                        code: '0000',\n                        msg: '注册成功',\n                        data: {\n                            username: req.body.username\n                        }\n                    })\n                })\n                .catch(err => {\n                    res.json({\n                        code: '2004',\n                        msg: '注册失败',\n                        data: null\n                    })\n                })\n        })\n})\n\n// 登陆\n// 登陆操作API\nrouter.post('/login', (req, res) => {\n    // 获取用户名和密码\n    let { username, password } = req.body;\n    // 如果用户名或密码为空则返回失败\n    if (!username || !password) {\n        res.json({\n            code: '2001',\n            msg: '用户名或密码错误',\n            data: null\n        })\n        return;\n    }\n    // 查询数据库，看有没有该用户\n    // 要对密码也做一次md5加密然后去数据库对比\n    UserModel.findOne({\n        username: username,\n        password: md5(password)\n    })\n        .then(data => {\n            // 如果data为空说明用户不存在\n            if (!data) {\n                res.json({\n                    code: '2001',\n                    msg: '用户名或密码错误',\n                    data: null\n                })\n                return;\n            }\n            // 创建并返回token\n            let token = jwt.sign({\n                username: data.username,\n                _id: data._id\n            }, config.token_secret, {\n                expiresIn: 60 * 24 * 7\n            });\n            res.json({\n                code: '0000',\n                msg: '登陆成功',\n                data: {\n                    token: token\n                }\n            })\n        })\n        .catch(err => {\n            res.json({\n                code: '2002',\n                msg: '登陆出错',\n                data: null\n            })\n        })\n})\n\n// 退出登陆\nrouter.post('/logout', (req, res) => {\n    // 客户端删除token即可\n    res.json({\n        code: '0000',\n        msg: '退出成功',\n        data: null\n    })\n});\n\n\nmodule.exports = router;\n\n```\n\n其中token的加密字符串 token_secret 保存在配置文件中\n\n```js /config.js\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test',\n    session_secret: 'chuckle',\n    token_secret: 'chuckle'\n}\nmodule.exports = config;\n\n```\n\n## 业务接口\n有了token后，要对 account.js 里原有的业务接口进行修改，并添加一个中间件对token进行校验，校验完后将token中的用户信息（username和userID）写入req中\n\n中间件 checkTokenMiddleware.js\n\n```js middleware/checkTokenMiddleware.js\nconst jwt = require(\"jsonwebtoken\");\nconst config = require('../config');\n\nconst checkTokenMiddleware = (req, res, next) => {\n    // 获取请求头中的token\n    let token = req.get('token');\n    // 没有token则报错\n    if (!token) {\n        res.json({\n            code: '2008',\n            msg: '缺失token',\n            data: null\n        })\n        return;\n    }\n    jwt.verify(token, config.token_secret, (err, data) => {\n        if (err) {\n            res.json({\n                code: '2009',\n                msg: 'token校验失败',\n                data: null\n            })\n            return;\n        }\n        // 校验成功后，将username和userID绑定到req上\n        req.username = data.username;\n        req.userID = data._id;\n        next();\n    })\n}\n\nmodule.exports = checkTokenMiddleware;\n\n```\n\n在业务接口中应用中间件\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 导入token校验中间件\nconst checkTokenMiddleware = require('../../middleware/checkTokenMiddleware');\n\n// 获取所有记录接口\nrouter.get('/', checkTokenMiddleware, function (req, res, next) {\n\n    // 读取所有数据，按日期降序\n    AccountModel.find({userID: req.userID}).sort({ date: -1 })\n        .then(data => {\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            // 接口的状态信息标识在code中，不设置响应码\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1001',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 获取单条记录接口\nrouter.get('/:id', checkTokenMiddleware, (req, res) => {\n    let { id } = req.params;\n    AccountModel.findById(id)\n        .then(data => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            });\n        })\n        .catch(err => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1004',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n})\n\n// 添加记录接口\nrouter.post('/', checkTokenMiddleware, function (req, res, next) {\n\n    // 插入一条数据\n    AccountModel.create({\n        // 解构赋值\n        ...req.body,\n        // 覆盖修改日期为日期对象\n        date: moment(req.body.date).toDate(),\n        userID: req.userID\n    })\n        .then(data => {\n            console.log(data);\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '添加成功',\n                // 响应的数据，返回创建成功的文档\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1002',\n                // 响应的信息\n                msg: '添加失败',\n                // 响应的数据\n                data: null\n            })\n        });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.delete('/:id', checkTokenMiddleware, (req, res) => {\n    // 获取路由参数id\n    let id = req.params.id;\n    AccountModel.deleteOne({ _id: id })\n        .then(data => {\n            console.log(data);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '删除成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1003',\n                // 响应的信息\n                msg: '删除失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 更新账单接口\nrouter.patch('/:id', checkTokenMiddleware, (req, res) => {\n    let { id } = req.params;\n    AccountModel.updateOne({ _id: id }, req.body)\n    .then(data => {\n        res.json({\n            code: '0000',\n            msg: '更新成功',\n            data: data\n        })\n    })\n    .catch(err=>{\n        res.json({\n            code: '1005',\n            msg: '更新失败',\n            data: null\n        })\n    })\n})\n\n\nmodule.exports = router;\n\n```\n\n最后在app.js中应用路由\n\n```js\n// 导入注册登陆API路由\nvar authApiRouter = require('./routes/api/auth');\n// 使用注册登陆API路由\napp.use('/api', authApiRouter)\n```\n\n# 记账本完全体\n记账本演示：[KeepingBook](https://kpb.qcqx.cn/)\n\ngithub地址：[KeepingBook-vercel](https://github.com/qxchuckle/KeepingBook-vercel)\n\nAPI文档：[KeepingBook-api](https://console-docs.apipost.cn/preview/3d8ecc659c1e192b/da97e0b2ec13fd71)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"NodeJS-MongoDB","url":"/article/bd0448f7.html","content":"\n# 简介\n[MongoDB](https://www.mongodb.com/) 基于分布式文件存储的数据库\n\n相较于用 db.json 纯文件管理数据，用数据库管理数据速度更快、扩展性高、安全性高\n\nMongoDB的操作语法与JS相似\n\n**核心概念：**\n1. 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存\n放很多集合\n2. 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档，一个集合存放一种文档（字段类型相同的文档）\n3. 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象，一个文档中有许多字段（对象的属性）\n\n# 命令行交互\n在将bin文件夹添加至环境变量后，在终端中输入 **mongod** 启动服务端，**mongo** 启动客户端\n\n**1、数据库命令**\n\n```js\n// 显示所有的数据库\nshow dbs\n// 切换到指定数据库，若不存在则创建\nuse <数据库名>\n// 显示当前所在的数据库\ndb\n// 删除当前数据库\nuse <数据库名>\ndb.dropDatabase()\n\n```\n\n**2、集合命令**\n\n```js\n// 创建集合\ndb.createCollection('集合名')\n// 显示当前数据库中的所有集合\nshow collections\n// 删除某个集合\ndb.集合名.drop()\n// 重命名集合\ndb.集合名.renameCollection('新名')\n\n```\n\n**3、文档命令**\n\n```js\n// 插入文档\ndb.集合名.insert(文档对象)\n// 查询文档，_id 是 mongodb 自动生成的唯一编号，用来唯一标识文档\ndb.集合名.find(查询条件)\n// 更新文档\ndb.集合名.update(查询条件,新的文档)\n// 删除文档\ndb.集合名.remove(查询条件)\n\n```\n\n# Mongoose\n[Mongoose](https://mongoosejs.com/) 是一个对象文档模型库，在异步环境中工作，用代码操作 mongodb 数据库\n\n**连接数据库：**\n\n```js\nconst mongoose = require('mongoose');\n\n// 连接数据库 mongodb://127.0.0.1:<端口号，默认27017可不写>/<数据库名，没有会自动创建>\nmongoose.connect('mongodb://127.0.0.1/test');\n\n// 设置回调\n// 连接成功回调，使用once回调函数只执行一次\nmongoose.connection.once('open', () => {\n    console.log('连接成功');\n});\n// 连接错误回调\nmongoose.connection.on('error', () => {\n    console.log('连接失败');\n});\n// 连接关闭回调\nmongoose.connection.on('close', () => {\n    console.log('连接关闭');\n});\n\n```\n\n**常用方法：**\n**1、创建文档模型对象：**\n1. `mongoose.Schema()` 创建文档的结构对象，约束文档字段的数据类型\n2. `mongoose.model(<集合名称>, <结构对象>)` 创建模型对象，对文档操作的封装对象，集合有则使用无则自动创建，集合名称会**自动变为复数**\n\n**2、插入、增加文档：**\n1. `create())` 创建并插入一个新文档\n2. `insertMany()` 传入文档数组批量添加新文档\n\n**3、删除文档：**\n1. `deleteOne()` 删除一条文档\n2. `deleteMany()` 批量删除\n\n**4、更新文档：**\n1. `updateOne()` 更新一条文档\n2. `updateMany()` 批量更新\n\n**5、查找、读取文档：**\n1. `findOne()` 查找一条\n2. `findById()` 通过_id找一条\n3. `find()` 批量查找，无论找到多少条都返回数组\n\n**6、条件控制：**\n1. \\> `$gt`\n2. < `$lt`\n3. \\>= `$gte`\n4. <= `$lte`\n5. !== `$ne`\n6. || `$or` 也可以用 ||\n7. && `$and` 也可以用 &&\n8. 正则匹配 `{author: /鱼/}`\n\n**7、规则控制：**\n1. `select()` 字段筛选\n2. `sort()` 排序\n3. `skip()` 数据截取，跳过\n4. `limit()` 数据截取，限定\n\n## 插入文档\n**插入新文档流程：**在open事件的回调函数中操作\n1. `mongoose.Schema()` 创建文档的结构对象，约束文档字段的数据类型\n2. `mongoose.model(<集合名称>, <结构对象>)` 创建模型对象，对文档操作的封装对象，集合有则使用无则自动创建，集合名称会**自动变为复数**\n3. `模型对象.create({文档数据对象}).then(data=>{})` 创建新文档\n\n```js\n// 在open事件的回调函数中操作\nmongoose.connection.once('open', () => {\n    console.log('连接成功');\n    // 创建文档的结构对象BookSchema\n    // 并约束文档字段的数据类型\n    let BookSchema = mongoose.Schema({\n        name: String,\n        author: String,\n        price: Number\n    });\n    // 创建模型对象，对文档操作的封装对象，第一个参数是集合，会自动创建\n    let BookModel = mongoose.model('books', BookSchema);\n    // 使用模型对象去增删改查\n    // 创建新文档\n    BookModel.create({\n        name: '三体',\n        author: '刘慈欣',\n        price: 30\n    }).then(data=>{\n        console.log(data);\n        // {\n        //     name: '三体',\n        //     author: '刘慈欣',\n        //     price: 30,\n        //     _id: new ObjectId(\"6442809af5fae6b874c172f0\"),\n        //     __v: 0\n        // }\n    }).catch(err=>{\n        console.log(err);\n    })\n    // 关闭数据库连接（项目运行过程中不会添加该代码）\n    // mongoose.disconnect();\n});\n\n```\n\n## 批量插入文档\ncreate() 一次只能新增一个文档，使用 `insertMany()` 传入文档数组批量添加新文档\n\n```js 使用文档模型对象的insertMany()方法批量插入文档\nmongoose.connection.once('open', () => {\n  // 文档结构对象\n  let BookSchema = new mongoose.Schema({\n    name: String,\n    author: String,\n    price: Number,\n    is_hot: Boolean\n  });\n  // 文档模型对象\n  let BookModel = mongoose.model('novels', BookSchema);\n  // 批量添加文档\n  BookModel.insertMany([{\n    name: '西游记',\n    author: '吴承恩',\n    price: 19.9,\n    is_hot: true\n  }, {\n    name: '红楼梦',\n    author: '曹雪芹',\n    price: 29.9,\n    is_hot: true\n  }, {\n    name: '三国演义',\n    author: '罗贯中',\n    price: 25.9,\n    is_hot: true\n  }, {\n    name: '水浒传',\n    author: '施耐庵',\n    price: 20.9,\n    is_hot: true\n  }, {\n    name: '活着',\n    author: '余华',\n    price: 19.9,\n    is_hot: true\n  }, {\n    name: '狂飙',\n    author: '徐纪周',\n    price: 68,\n    is_hot: true\n  }, {\n    name: '大魏能臣',\n    author: '黑男爵',\n    price: 9.9,\n    is_hot: false\n  },\n  {\n    name: '知北游',\n    author: '洛水',\n    price: 59,\n    is_hot: false\n  },{\n    name: '道君',\n    author: '跃千愁',\n    price: 59,\n    is_hot: false\n  },{\n    name: '七煞碑',\n    author: '游泳的猫',\n    price: 29,\n    is_hot: false\n  },{\n    name: '独游',\n    author: '酒精过敏',\n    price: 15,\n    is_hot: false\n  },{\n    name: '大泼猴',\n    author: '甲鱼不是龟',\n    price: 26,\n    is_hot: false\n  },\n  {\n    name: '黑暗王者',\n    author: '古羲',\n    price: 39,\n    is_hot: false\n  },\n  {\n    name: '不二大道',\n    author: '文刀手予',\n    price: 89,\n    is_hot: false\n  },\n  {\n    name: '大泼猴',\n    author: '甲鱼不是龟',\n    price: 59,\n    is_hot: false\n  },\n  {\n    name: '长安的荔枝',\n    author: '马伯庸',\n    price: 45,\n    is_hot: true\n  },\n  {\n    name: '命运',\n    author: '蔡崇达',\n    price: 59.8,\n    is_hot: true\n  },\n  {\n    name: '如雪如山',\n    author: '张天翼',\n    price: 58,\n    is_hot: true\n  },\n  {\n    name: '三体',\n    author: '刘慈欣',\n    price: 23,\n    is_hot: true\n  },\n  {\n    name: '秋园',\n    author: '杨本芬',\n    price: 38,\n    is_hot: true\n  },\n  {\n    name: '百年孤独',\n    author: '范晔',\n    price: 39.5,\n    is_hot: true\n  },\n  {\n    name: '在细雨中呼喊',\n    author: '余华',\n    price: 25,\n    is_hot: true\n  }]);\n\n});\n\n```\n\n## 字段\n文档结构可选的常用**字段类型：**\n1. String 字符串\n2. Number 数字\n3. Boolean 布尔值\n4. Array 数组，也可以使用 [] 来标识\n5. Date 日期\n6. Buffer Buffer 对象\n7. Mixed 任意类型，需要使用 mongoose.Schema.Types.Mixed 指定\n8. ObjectId 文档对象 ID，用于设置外键，保存其它文档的id，需要使用 mongoose.Schema.Types.ObjectId 指定\n9. Decimal128 高精度数字，需要使用 mongoose.Schema.Types.Decimal128 指定\n\n**字段值验证：**一些内建验证器，可以对字段值进行验证，或者说进一步约束字段内容\n1. required: true 设置必填项\n2. default: 'qx' 设置默认值\n3. enum: ['男','女'] 枚举值，字段值必须在数组中\n4. unique: true 设置值唯一，需要重建集合才有效果\n\n在创建文档的结构对象时添加字段验证\n\n```js\nlet BookSchema = mongoose.Schema({\n  name: { \n      type: String,\n      required: true, // 必填项\n      unique: true, // 唯一值\n  },\n  author: {\n      type: String,\n      default: '匿名' // 默认值\n  },\n  style: {\n      type: String,\n      required: true, // 必填项\n      enum: ['科幻','言情','玄幻'] // 枚举值\n  },\n  price: {\n      type: Number,\n      required: true // 必填项\n  },\n});\n\n```\n\n## 删除文档\n`deleteOne()` 删除一条文档，`deleteMany()` 批量删除\n\n```js\n// 删除单条文档\nBookModel.deleteOne({ _id: '64428b3a01df4070e7bc2df3' })\n  .then(data => {\n      console.log(data);// { acknowledged: true, deletedCount: 1 }\n  })\n  .catch(err => {\n      console.log('删除失败');\n  })\n\n// 批量删除文档\nBookModel.deleteMany({ is_hot: false })\n  .then(data => {\n      console.log(data);// { acknowledged: true, deletedCount: 9 }\n  })\n  .catch(err => {\n      console.log('删除失败');\n  })\n\n```\n\n## 更新文档\n`updateOne()` 和 `updateMany()`\n\n```js\n// 更新单条\nBookModel.updateOne({name: '红楼梦'}, {price: 9.9})\n  .then(data=>{\n      console.log(data);\n  })\n//更新多条\nBookModel.updateMany({is_hot: true}, {is_hot: false})\n  .then(data=>{\n      console.log(data);\n      // {\n      //   acknowledged: true,\n      //   modifiedCount: 12,\n      //   upsertedId: null,\n      //   upsertedCount: 0,\n      //   matchedCount: 12\n      // }\n  })\n\n```\n\n## 查找文档\n`findOne()` 查找一条，`findById()` 通过_id找一条，`find()` 批量查找，无论找到多少条都返回数组\n\n```js\n// 读取单条\nBookModel.findOne({name: '狂飙'})\n  .then(data=>{\n      console.log(data);\n      // {\n      //   _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84f9a\"),\n      //   name: '狂飙',\n      //   author: '徐纪周',\n      //   price: 68,\n      //   is_hot: true,\n      //   __v: 0\n      // }\n  })\n// 通过_id获取\nBookModel.findById('6442a4a0f5bcc6fb8cc84fa7')\n  .then(data=>{\n      console.log(data);\n      // {\n      //   _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84fa7\"),\n      //   name: '三体',\n      //   author: '刘慈欣',\n      //   price: 23,\n      //   is_hot: true,\n      //   __v: 0\n      // }\n  })\n//读取多条，没用参数则获取全部文档\nBookModel.find({author: '余华'})\n  .then(data=>{\n      console.log(data);\n      // [\n      //   {\n      //     _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84f99\"),\n      //     name: '活着',\n      //     author: '余华',\n      //     price: 19.9,\n      //     is_hot: true,\n      //     __v: 0\n      //   },\n      //   {\n      //     _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84faa\"),\n      //     name: '在细雨中呼喊',\n      //     author: '余华',\n      //     price: 25,\n      //     is_hot: true,\n      //     __v: 0\n      //   }\n      // ]\n  })\n\n```\n\n## 条件控制\nmongodb中没有条件运算符，必须使用替代符号\n1. \\> `$gt`\n2. < `$lt`\n3. \\>= `$gte`\n4. <= `$lte`\n5. !== `$ne`\n6. || `$or` 也可以用 ||\n7. && `$and` 也可以用 &&\n\n```js\n// 价格高于20\nBookModel.find({price: {$gte:20}})\n// 价格高于20且低于30\nBookModel.find({ $and: [{ price: { $gte: 20 }, price: { $lt: 30 } }] })\nBookModel.find({ price: { $gte: 20 } && { $lt: 30 } })\n// 查找甲鱼不是龟写的价格低于30的书\nBookModel.find({ $and: [{ author: '甲鱼不是龟', price: { $lt: 30 } }] })\n\n```\n\n**正则匹配：**条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询\n\n```js\n// 搜索作者名带鱼写的书\nBookModel.find({ author: /鱼/})\n```\n\n## 规则控制\n**1、字段筛选** `select()` 查找时只查找文档的某些字段，提高查找效率，1 需要，0 排除，_id默认为1\n\n```js 查找价格低于30的书，字段只包含书名、作者和价格\nBookModel.find({price: { $lt: 30 }}).select({name:1,author:1,price:1})\n  .then(data=>{\n      console.log(data);\n  })\n```\n\n**2、排序** `sort()`，按某个字段的升序（1）或降序（-1）排序\n\n```js 查找所有书，按价格升序排序，字段只包含书名、作者和价格\nBookModel.find().sort({price:1}).select({name:1,author:1,price:1})\n  .then(data=>{\n      console.log(data);\n  })\n```\n\n**3、数据截取**，`skip()` 跳过，`limit()` 限定\n\n```js 查找所有书，按价格降序排序，字段只包含书名和价格，只取前三本书\nBookModel.find().sort({price:-1}).select({name:1,price:1}).limit(3)\n.then(data=>{\n  console.log(data);\n})\n```\n\n```js 查找所有书，按价格降序排序，字段只包含书名和价格，跳过最贵的前三本书\nBookModel.find().sort({price:-1}).select({name:1,price:1}).skip(3)\n.then(data=>{\n  console.log(data);\n})\n```\n\n## 代码模块化\nmongoose的模块化：\n1. 将数据库连接部分独立，并放入一个函数中暴露出去\n2. 将数据库中不同的文档对象模型每个单独一个js文件独立到modules文件夹中，将文档对象模型暴露出去\n3. 将数据库的连接信息独立到config.js再暴露出去给db.js使用\n4. index.js导入数据库连接函数和文档对象模型，并将连接数据库成功后的操作，都放在数据库连接函数的第一个参数中，作为连接成功的回调函数\n\n```js 原来的文件\nconst mongoose = require('mongoose');\n\nmongoose.set('strictQuery', true);\n\nmongoose.connect('mongodb://127.0.0.1:27017/test');\n\nmongoose.connection.once('open', () => {\n    // 文档结构对象\n    let BookSchema = new mongoose.Schema({\n        name: String,\n        author: String,\n        price: Number,\n        is_hot: Boolean\n    });\n    // 文档模型对象\n    let BookModel = mongoose.model('novels', BookSchema);\n    // 读取单条\n    BookModel.findOne({name: '狂飙'})\n        .then(data=>{\n            console.log(data);\n        })\n    // 通过_id获取\n\n});\n\n// 设置连接错误的回调\nmongoose.connection.on('error', () => {\n    console.log('连接失败');\n});\n\n//设置连接关闭的回调\nmongoose.connection.on('close', () => {\n    console.log('连接关闭');\n});\n\n```\n\n**模块化后：**\n\n作用：当需要对数据库中一个集合操作时，只需要在models文件夹中新建该集合的文档对象模型，然后在index.js中导入，当要连接其它mongodb数据库时也只需要修改config.js\n\n```js index.js\nconst mongoose = require('mongoose');\n// 将数据库连接函数导入\nconst db = require('./db/db');\n// 导入BookModel文档对象模型\nconst BookModel = require('./models/BookModel');\n// 传入两个回调函数\ndb(() => {\n    // 连接成功则对数据库进行操作，增删改查\n    // 查找《狂飙》的信息\n    BookModel.findOne({ name: '狂飙' })\n        .then(data => {\n            console.log(data);\n        })\n});\n\n```\n\n```js config.js\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test'\n}\nmodule.exports = config;\n\n```\n\n```js ./db/db.js\n// 暴露一个函数，success数据库连接成功的回调，error连接失败的回调\nmodule.exports = function (success, error = () => { console.log('连接失败'); }) {\n\n    const mongoose = require('mongoose');\n    // 导入数据库连接配置文件\n    const {HOST,PORT,NAME} = require('../config');\n\n    mongoose.connect(`mongodb://${HOST}:${PORT}/${NAME}`);\n\n    mongoose.connection.once('open', () => {\n        success();\n    });\n    // 设置连接错误的回调\n    mongoose.connection.on('error', () => {\n        error();\n    });\n    //设置连接关闭的回调\n    mongoose.connection.on('close', () => {\n        console.log('连接关闭');\n    });\n\n}\n\n```\n\n```js ./models/BookModel.js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet BookSchema = new mongoose.Schema({\n    name: String,\n    author: String,\n    price: Number,\n    is_hot: Boolean\n});\n// 文档模型对象\nlet BookModel = mongoose.model('novels', BookSchema);\n// 将文档模型对象暴露出去\nmodule.exports = BookModel;\n\n```\n\n# 图形化管理\n使用图形化软件更方便操控数据库 [Robo3T](https://github.com/Studio3T/robomongo) [Navicat](https://www.navicat.com.cn/)\n\n# 记账本优化\n使用 mongodb 数据库替代 lowdb 文件管理，使用 [moment](https://momentjs.com/) 处理日期类型\n\n<img src=https://cdn.chuckle.top/images/49-2.webp width=\"85%\" loading=\"lazy\">\n\n<img src=https://cdn.chuckle.top/images/49-3.gif width=\"60%\" loading=\"lazy\">\n\n**主要文件：**\n**数据库相关：**\n\n```js /db/db.js 数据库连接函数，连接成功后才能在回调函数中做后续业务\n// 暴露一个函数，success数据库连接成功的回调，error连接失败的回调\nmodule.exports = function (success, error = () => { console.log('连接失败'); }) {\n\n    const mongoose = require('mongoose');\n    // 导入数据库连接配置文件\n    const { HOST, PORT, NAME } = require('../config');\n\n    mongoose.connect(`mongodb://${HOST}:${PORT}/${NAME}`);\n\n    mongoose.connection.once('open', () => {\n        success();\n    });\n    // 设置连接错误的回调\n    mongoose.connection.on('error', () => {\n        error();\n    });\n    //设置连接关闭的回调\n    mongoose.connection.on('close', () => {\n        console.log('连接关闭');\n    });\n\n}\n\n```\n\n```js /models/AccountModel.js 账本的文档对象模型，用于约束和操控数据库集合中的文档，增删改查\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet AccountSchema = new mongoose.Schema({\n    matter: {\n        type: String,\n        required: true\n    },\n    date: {\n        type: Date,\n        required: true\n    },\n    type: {\n        type: String,\n        enum: ['支出', '收入'],\n        default: '支出'\n    },\n    account: {\n        type: Number,\n        required: true\n    },\n    remark: {\n        type: String,\n        default: '无'\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('accounts', AccountSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n```js config.js 数据库连接配置\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test'\n}\nmodule.exports = config;\n\n```\n\n**启动http服务的www文件：**导入数据库连接函数，将http服务的代码都扔进db的回调函数中，待数据库连接成功再执行回调函数运行http服务\n\n```js /bin/www\n#!/usr/bin/env node\n// 导入数据库连接函数\nconst db = require('../db/db');\n// 将http相关操作放到连接成功的回调中\ndb(()=>{\n/**\n * Module dependencies.\n */\n\nvar app = require('../app');\nvar debug = require('debug')('keepingbook:server');\nvar http = require('http');\n\n/**\n * Get port from environment and store in Express.\n */\n\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n/**\n * Create HTTP server.\n */\n\nvar server = http.createServer(app);\n\n/**\n * Listen on provided port, on all network interfaces.\n */\n\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n\n/**\n * Normalize a port into a number, string, or false.\n */\n\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n\n  return false;\n}\n\n/**\n * Event listener for HTTP server \"error\" event.\n */\n\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n\n/**\n * Event listener for HTTP server \"listening\" event.\n */\n\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\n})\n\n```\n\n**路由相关：**index.js内有增删该查的页面、接口路由，在这个文件中引入文档对象模型，就能在对应路由内对数据库文档做对应操作\n\n```js /route/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../models/AccountModel');\n\n// 记账本页面路由\nrouter.get('/', function (req, res, next) {\n\n  // 读取所有数据，按日期降序\n  AccountModel.find().sort({ date: -1 })\n    .then(data => {\n      // 将数据数组传递过去遍历渲染，为了格式化日期，将moment传入\n      res.render('index', { content: data, moment });\n    })\n    .catch(err => {\n      console.log(err);\n      // 查找失败则返回500\n      res.status(500).render('tip', { msg: '查找失败!', url: '/' });\n    })\n\n});\n\n// 添加记录页面路由\nrouter.get('/add', function (req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add', function (req, res, next) {\n\n  // 插入一条数据\n  AccountModel.create({\n    // 解构赋值\n    ...req.body,\n    // 覆盖修改日期为日期对象\n    date: moment(req.body.date).toDate()\n  })\n    .then(data => {\n      console.log(data);\n      // 成功跳转到提示页\n      res.render('tip', { msg: '添加成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      // 添加失败则返回500\n      res.status(500).render('tip', { msg: '添加失败!', url: '/' });\n    });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id', (req, res) => {\n  // 获取路由参数id\n  let id = req.params.id;\n  AccountModel.deleteOne({ _id: id })\n    .then(data => {\n      console.log(data);\n      // 删除成功跳转提示页\n      res.render('tip', { msg: '删除成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      res.status(500).render('tip', { msg: '删除失败!', url: '/' });\n    })\n\n});\n\n\nmodule.exports = router;\n\n```\n\n除了index.ejs，其它页面无变化\n\n```js index.ejs渲染日期时，调用moment去格式化\n<div class=\"date\"><%= moment(item.date).format('YYYY-MM-DD') %></div>\n```\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"Express框架","url":"/article/8ddaf637.html","content":"\n# express框架\n[express](https://www.expressjs.com.cn/) 是一个web框架，也是npm的一个工具包，功能和http模块类似，但功能更加强大，开发服务端效率更高\n\n基本使用步骤：\n1. 导入express框架\n2. 创建服务器实例对象\n3. 绑定事件\n4. 监听端口，启动服务器\n\n```js\n//导入express\nconst express = require('express');\n// 创建对象\nconst app = express();\n//创建路由，req请求报文的封装对象，res响应报文\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome');\n})\n// 监听端口启动服务\napp.listen(3000, () => {\n    console.log('服务启动');\n});\n\n```\n\n## 路由\n**路由：**确定如何响应客户端对特定端点的请求\n\n```js 使用方法，由请求方法、路径、回调函数组成\napp.<method>(path，(req, res) => {})\n```\n\n```js\n//创建路由，req请求报文的封装对象，res响应报文\n//从上往下匹配，匹配到则不再往后匹配\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome /home');\n})\n\napp.get('/', (req, res) => {\n    res.end('Welcome /');\n});\n\napp.post('/login', (req, res) => {\n    res.end('Welcome /login');\n});\n\napp.all('/test', (req, res)=>{\n    res.end('Welcome /test');\n});\n// 匹配所有路径和方法，可以放在最后进行404响应\napp.all('*', (req, res)=>{\n    res.end('404');\n});\n\n```\n\n## 获取请求报文\n\n```js\napp.get('/', (req, res) => {\n    //express兼容原生操作\n    console.log(req.method);//请求方法\n    console.log(req.url);//请求url\n    console.log(req.httpVersion);//http版本\n    console.log(req.headers);//请求头\n    //express封装方法\n    console.log(req.path);//请求路径\n    console.log(req.query);//查询字符串\n    console.log(req.ip);//用户ip\n    console.log(req.get('host'));//获取特定请求头的属性值\n\n    res.send('Welcome /');\n});\n\n```\n\n### 路由参数\n路由参数指的是 URL 路径中的参数（数据），如多篇文章按1.html、2.html往后排，匹配路由参数从而无需写多个路由\n\n获取路由参数：`req.params.id`\n\n```js\napp.get('/:id.html',(req, res) => {\n    res.send('id为' + req.params.id);\n}); \n```\n\n路由参数练习：\n\n```json\n{\n  \"singers\": [\n    {\n      \"singer_name\": \"周杰伦\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M0000025NhlN2yWrP4.webp\",\n      \"other_name\": \"Jay Chou\",\n      \"singer_id\": 4558,\n      \"id\": 1\n    },\n    {\n      \"singer_name\": \"林俊杰\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001BLpXF2DyJe2.webp\",\n      \"other_name\": \"JJ Lin\",\n      \"singer_id\": 4286,\n      \"id\": 2\n    },\n    {\n      \"singer_name\": \"G.E.M. 邓紫棋\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001fNHEf1SFEFN.webp\",\n      \"other_name\": \"Gloria Tang\",\n      \"singer_id\": 13948,\n      \"id\": 3\n    }\n  ]\n}\n\n```\n\n```js\nconst express = require('express');\n// 创建对象\nconst app = express();\n//导入json文件\nconst {singers} = require('./JSON/singers.json');\n\napp.get('/singer/:id.html',(req, res) => {\n    let {id} = req.params;\n    let result = singers.find((item)=>{\n        if(item.id === Number(id)){\n            return true;\n        }\n    });\n    // console.log(result);\n    if(!result){\n        res.send(\"404\");\n        return;\n    }\n    res.send(`\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Document</title>\n    </head>\n    <body>\n        <h2>${result.singer_name}</h2>\n        <img src=${result.singer_pic}}></img>\n    </body>\n    </html>\n    `);\n}); \n\napp.listen(3000, () => {\n    console.log('服务启动');\n})\n\n```\n\n## 响应设置\n一般响应\n\n```js\napp.get('/', (req, res)=>{\n    // 原生响应\n    res.statusCode = 200;\n    res.statusMessage = 'OK';\n    res.setHeader('Content-Type', 'text/html;charset=UTF-8');\n    // express\n    res.status(200);\n    res.set('Content-Type', 'text/html');\n    res.send('你好');//自动添加字符集，不乱码\n    // 连贯操作\n    res.status(200).set('xxx','yyy').send('你好');\n});\n\n```\n\n其它响应，一般不能多个同时成功响应\n\n```js\napp.get('/', (req, res)=>{\n    // 302重定向\n    res.redirect('https://www.baidu.com/');\n    // 下载响应\n    res.download('../3.mp4');\n    // 响应JSON\n    res.json({\n            a:1\n        });\n    // 响应文件内容\n    res.sendFile(__dirname + '/package.json');\n});\n\n```\n\n## 中间件\n中间件（Middleware）本质是一个回调函数\n\n中间件函数可以像路由回调一样访问请求对象（request），响应对象（response）\n\n**作用：**使用函数封装公共操作，简化代码\n\n**类型：**全局中间件、路由中间件\n\n每一个请求到达服务端后都会执行全局中间件函数\n满足某个路由规则的请求会触发指定路由中间件函数\n\n```js 声明中间件函数\nfunction middleware(req,res,next){\n//实现功能代码\n//执行next函数\n//调用next()执行完中间件函数后，继续执行路由中的回调函数\nnext();\n}\n```\n\n### 全局中间件\n每一个请求到达服务端后都会执行全局中间件函数\n\napp.use是专门解析中间件函数的方法，使用之后express会将http请求响应对象交给中间件函数，中间件函数处理完通过next()方法传递给下一中间件函数，直到返回响应数据\n\n可以使用 app.use() 定义多个全局中间件\n\n案例：\n\n```js 利用中间件对所有路由记录访问路径和用户ip\n// 声明中间件\nfunction middleware1(req, res, next) {\n    let {url, ip} = req;\n    fs.appendFileSync(path.resolve(__dirname + '/1.log'), `${url} ${ip}\\r\\n`);\n    // 中间件函数处理完请求后，通过next方法将http请求对象交给下一个中间件或路由，直到返回响应\n    next();\n}\nfunction middleware2(req, res, next) {\n    let {url, ip} = req;\n    console.log(url, ip);\n    next();\n}\n// 使用app.use定义全局中间件，express将http请求对象交给中间件\napp.use(middleware1);\napp.use(middleware2);\n\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\napp.get('/admin', (req, res)=>{\n    res.send('后台');\n});\n\n```\n\n### 路由中间件\n满足某个路由规则的请求会触发指定路由中间件函数\n\n只需要对某一些路由进行功能封装，则使用路由中间件，可以设置多个中间件函数\n\n```js 格式\napp.get('/路径',`中间件函数1`,`中间件函数2`,(req,res)=>{});\n```\n\n案例：\n\n```js 访问后台和设置页的请求必须携带code为123的参数\nfunction checkCode(req, res, next){\n    if (req.query.code === '123'){\n        next();//继续执行路由回调\n    }else{\n        res.send('code参数错误');\n    }\n}\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\n// 放到需要的路由上\napp.get('/admin', checkCode, (req, res)=>{\n    res.send('后台');\n});\napp.get('/setting', checkCode, (req, res)=>{\n    res.send('设置');\n});\n\n```\n\n## 静态资源中间件\nexpress内置处理静态资源的中间件\n\n```js\napp.use(express.static('<静态资源目录>'));\n```\n\n设置后，所有静态资源都会根据静态资源目录去寻找，index.html、index.css等为默认打开的资源\n\n果静态资源与路由规则同时匹配，从上而下谁先匹配谁就响应\n\n一般用路由响应动态资源，如搜索结果等，用静态资源中间件响应静态资源，如html、css等\n\n```js\n// 设置静态资源目录，会自动添加Mime类型\napp.use(express.static('../public-test'));\n//访问在public-test下的index.html\napp.get('/', (req, res)=>{\n    res.send('首页');\n});\n//访问在public-test/css下的index.html\napp.get('/css/index.css', (req, res)=>{\n    res.send('css');\n});\n\n```\n\n## 获取请求体\nexpress 可以使用 [body-parser](https://www.npmjs.com/package/body-parser) 包处理请求体，该包内置许多中间件来处理请求体，需要先npm安装`npm i body-parser`\n\n包内常用中间件，当中间件解析完请求后会向 req 对象上添加 body 属性，里面包含了请求体对象\n\n```js\n// 解析 json 格式的中间件\nvar jsonParser = bodyParser.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\n```\n\n案例：\n\n```js 获取表单post提交的用户名和密码，get请求则显示登录页面\nconst bodyParser = require('body-parser');\n// 获取表单post提交的用户名和密码，get请求则显示登录页面\napp.get('/login', (req, res)=>{\n    // 响应登录页面\n    res.sendFile(__dirname + '/login.html');\n});\n// 获取 bodyParser 包中的中间件函数\n// 解析 json 格式的中间件\nvar jsonParser = bodyParser.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\napp.post('/login', urlencodedParser, (req, res) => {\n    // 当urlencodedParser中间件执行完毕，会向req对象上添加一个body属性\n    console.log(req.body);//{ username: '543', password: '345' }\n    // 成功获取包含用户名和密码的对象\n    res.send('登录成功!');\n});\n```\n\n## 防盗链\n请求报文中的 referer 会携带当前访问资源的域名和端口，限制 referer 的值即可实现防盗链\n\n```js 全局中间件实现防盗链\napp.use((req, res, next) => {\n    // 获取请求头中的referer\n    let referer = req.get('referer');\n    // referer不为空再去执行\n    if (referer) {\n        // 解析referer\n        let url = new URL(referer);\n        // url.hostname 获取域名，判断是否是目标域名\n        if (url.hostname !== '127.0.0.1') {\n            res.status(404).send('404 Not Found');\n            return;\n        }\n    }\n    next();\n});\n\n```\n\n## 路由模块化Router\nRouter 是一个完整的中间件和路由系统，相当于一个小型的 app 对象。\n\n```js 声明Router和app\nconst router = express.Router();\nconst app = express();\n```\n\n```js home.js一个完整的路由\nconst express = require('express');\n\nconst router = express.Router();// 相当于一个小型的app对象\n\nrouter.get('/home', (req, res)=>{\n    res.send('首页');\n});\n\nrouter.get('/search', (req, res)=>{\n    res.send('搜索');\n});\n\n// 将路由暴露出去\nmodule.exports = router;\n\n```\n\n```js 在主文件需要导入路由并使用\nconst express = require('express');\n// 导入路由\nconst homeRouter = require('./home.js');\nconst adminRuter = require('./admin.js');\n\nconst app = express();\n// 使用路由\napp.use(homeRouter);\napp.use(adminRuter);\n\napp.all('*', (req, res) => {\n    res.send('404 Not Found');\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\napp.use可以添加一个路径参数，来给路由添加前缀\n\n```js\napp.use('/', indexRouter);\napp.use('/users', usersRouter);// 路由中的路径都会自动添加这个前缀\n```\n\n## 模板引擎ejs\n模板引擎是分离**用户界面**和**业务数据**的一种技术，在许多语言都有的一种通用技术\n\n[EJS](https://ejs.devjs.cn/) 是一个高效的 Javascript 的模板引擎，用于分离html和服务端js\n\n```js\nconst ejs = require('ejs');\n// 字符串\nlet str1 = 'qx';\nlet str2 = `${str1}chuckle`;\nconsole.log(str2);// qxchuckle\n\n// 使用ejs\nlet str = '<%= str %>chuckle';\nlet result = ejs.render(str, {str:str1});\nconsole.log(result);// qxchuckle\n\n```\n\n将 ejs 模板写在单独的文件再由fs读入\n\n```js\nlet str = fs.readFileSync('./01.html').toString();\nlet [name,age] = ['chuckle',19]\nlet result = ejs.render(str, {name,age});\nconsole.log(result);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h2><%= name %></h2>\n    <h3><%= age %></h3>\n</body>\n</html>\n\n```\n\nejs列表渲染：\n\n```js 原生js, js和html耦合在一起\nconst arr = [1,2,3,4];\nlet html = '<ul>';\narr.forEach(item=>{\n    html += `<li>${item}</li>`;\n})\nhtml += '</ul>';\nconsole.log(html);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\n```js 使用ejs, 分离html和服务端js\nconst arr = [1,2,3,4];\nlet html = `<ul>\n    <% arr.forEach(item => { %>\n        <li><%= item %></li>\n    <% }) %>\n</ul>`;\nlet result = ejs.render(html, {arr});\nconsole.log(result);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\nejs条件渲染\n\n```js\nlet isLogin = true;\nlet html = `<% if(isLogin) { %>\n    <span>登陆</span>\n<%}else{ %>\n    <span>注册</span>\n<%} %>`;\nlet result = ejs.render(html, {isLogin});\nconsole.log(result);\n// <span>登陆</span>\n\n```\n\n### express使用ejs\n使用 app.set() 设置express使用的模板引擎、设置模板文件存放位置\n\n```js\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n```\n\n然后就可以用res调用render方法响应渲染好的页面\n\n```js\n// res.render('<模板文件名>','<数据>');\nlet name = 'chuckle';\n// 在模板文件夹中创建home.ejs\nres.render('home', {name});\n```\n\n完整案例：\n\n```js\nconst express = require('express');\nconst path = require('path');\n\nconst app = express();\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n// 然后就可以用res调用render方法\napp.get('/', (req, res) => {\n    // res.render('<模板文件名>','<数据>');\n    let name = 'chuckle';\n    // 在模板文件夹中创建home.ejs\n    res.render('home', {name});\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## express-generator\nexpress-generator是一个node的自动化创建项目工具，类似于vue-cli，能快速构建express项目标准骨架\n\n安装后会暴露一个全局命令：express\n\n```js 安装\nnpm install -g express-generator\nexpress -v //查看版本和帮助\n```\n\n构建项目：\n\n```js\nexpress -e <文件夹名称>// -e参数是添加ejs支持\n```\n\n1. app.js是项目主文件；\n2. views目录用于存放页面文件；\n3. routes目录用于存放路由文件；\n4. public用于存放静态文件；\n5. bin中的www是项目的启动文件；\n\n## 文件上传\n在index.js中添加两个路由,get显示表单，post接收上传的数据\n\n```js\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  res.send('上传成功');\n});\n\n```\n\n新建 portrait.ejs 创建表单页面，对于文件上传，form表单必须添加 enctype=\"multipart/form-data\" 属性\n\n```ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h3>文件上传</h3>\n    <form action=\"/portrait\" method=\"post\" enctype=\"multipart/form-data\">\n        用户名：<input type=\"text\" name=\"username\"><br />\n        头像：<input type=\"file\" name=\"portrait\"><br />\n        <button>提交</button>\n    </form>\n</body>\n</html>\n\n```\n\n处理文件上传需要使用 [formidable](https://www.npmjs.com/package/formidable) 包，它是用于解析表单数据的 Node.js 模块，尤其是文件上传。\n\n```js 完整的index.js\nvar express = require('express');\nvar router = express.Router();\n// 导入formidable\nconst formidable = require('formidable');\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  // 创建表单对象\n  const form = formidable({ \n    multiples: true,\n    // 设置上传文件的保存目录\n    uploadDir: __dirname + '/../public/images',\n    // 保持文件后缀\n    keepExtensions: true\n  });\n  // 解析表单对象\n  form.parse(req, (err, fields, files) => {\n    if (err) {\n      next(err);\n      return;\n    }\n    // fields存放除文件上传的一般表单提交\n    console.log(fields);\n    // files保存文件上传\n    console.log(files);\n    // res.json({ fields, files });\n    // 保存上传文件的存放路径，以后将此数据保存在数据库中\n    let url = '/images/' + files.portrait.newFilename;\n    res.send(url);// 给用户返回url路径\n  });\n});\n\nmodule.exports = router;\n\n```\n\n## lowdb包\n在保存一些简单数据时可以使用 [lowdb](https://www.npmjs.com/package/lowdb/v/1.0.0) 包，在json中进行增删改查数据，推荐使用1.0.0版本\n\n案例：\n\n```js\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync('db.json')\n// 获取db对象\nconst db = low(adapter)\n// 初始化数据，也可以手动自定义初始化\ndb.defaults({ posts: [], user: {} }).write()\n\n// 增删改都需要最后调用write()\n// 往posts这个数组尾中添加元素\ndb.get('posts')\n    // push从尾部插入元素\n    .push({ id: 1, title: 'lowdb is awesome'})\n    .write()\ndb.get('posts')\n    // unshift从头插入元素\n    .unshift({ id: 2, title: 'lowdb is awesome'})\n    .write()\n\n// 获取数据\nlet value = db.get('posts').value();\nconsole.log(value);\n// 获取单条数据\nlet single = db.get('posts').find({id: 1}).value();\nconsole.log(single);\n\n// 删除所有匹配的数据，返回被删除的数据\ndb.get('posts').remove({id: 1}).write();\n\n// 更新数据,先获取再修改\ndb.get('posts').find({id: 2}).assign({title: 'chuckle'}).write();\n\n```\n\n## 案例-记账本\n\n<img src=https://cdn.chuckle.top/images/49-3.gif width=\"60%\" loading=\"lazy\">\n\n主要的一些文件\n\n主要路由：\n\n```js /routes/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 使用lowdb存储数据\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync(__dirname + '/../data/db.json')\n// 获取db对象\nconst db = low(adapter)\n\n// 导入shortid为数据生成id\nconst shortid = require('shortid');\n\n// 记账本页面路由\nrouter.get('/', function(req, res, next) {\n  // 获取所有账单记录数据\n  let content = db.get('content').value();\n  // 将数据数组传递过去遍历渲染\n  res.render('index', {content});\n});\n\n// 添加记录页面路由\nrouter.get('/add', function(req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add', function(req, res, next) {\n  // 生成唯一id\n  let id = shortid.generate();\n  // 往db.josn写入数据\n  db.get('content').unshift({id:id, ...req.body}).write();\n  // 跳转到提示页\n  res.render('tip',{msg: '添加成功!', url: '/'});\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id',(req, res) => {\n  let id =  req.params.id;// 获取路由参数\n  db.get('content').remove({id}).write();\n  res.render('tip',{msg: '删除成功!', url: '/'});\n});\n\n\nmodule.exports = router;\n\n```\n\n页面ejs：\n\n```html /views/index.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>记账本</title>\n    <link rel=\"stylesheet\" href=\"/css/index.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>记账本</h2>\n        </div>\n        <div class=\"add\">\n          <a href=\"/add\">添加</a>\n        </div>\n        <div class=\"record-box\">\n          <% content.forEach(item=>{%>\n          <div class=\"record-item\">\n            <div class=\"date\"><%= item.date %></div>\n            <div class=\"type <%= item.type==='支出'?'expenditure':'income'%>\">\n              <%= item.type %>\n            </div>\n            <div class=\"record-body\">\n              <div class=\"record-content\">\n                <div class=\"matter\"><%= item.matter %></div>\n                <div class=\"account\"><%= item.account %> 元</div>\n              </div>\n              <a href=\"/delete/<%= item.id %>\" class=\"delete\">删除</a>\n            </div>\n          </div>\n          <%})%>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/add.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"/css/add.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>添加记录</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/\">账单列表</a>\n        </div>\n        <form action=\"/add\" method=\"post\">\n          <div class=\"form-item\">\n            <label for=\"matter\">事项</label>\n            <input class=\"control\" type=\"text\" name=\"matter\" id=\"matter\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"date\">时间</label>\n            <input class=\"control\" type=\"date\" name=\"date\" id=\"date\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"type\">类型</label>\n            <select class=\"control\" name=\"type\" id=\"type\">\n              <option selected=\"\">支出</option>\n              <option>收入</option>\n            </select>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"account\">金额</label>\n            <input class=\"control\" type=\"text\" name=\"account\" id=\"account\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"remark\">备注</label>\n            <textarea class=\"control\" name=\"remark\" id=\"remark\"></textarea>\n          </div>\n          <hr />\n          <button>添加</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/tip.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"/css/tip.css\" />\n  </head>\n  <body>\n    <div class=\"content\">\n      <h3><%= msg %></h3>\n      <a href=\"<%= url %>\">返回</a>\n    </div>\n  </body>\n</html>\n\n```\n\ncss：\n\n```css /public/css/index.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.add{\n    margin-top: 10px;\n    padding-left: 20px;\n}\n.add a{\n    text-decoration: none;\n}\n.record-box{\n    margin-top: 10px;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.record-item{\n    margin-bottom: 15px;\n    border: 1px solid rgb(226, 226, 226);\n    border-radius: 6px;\n    -webkit-border-radius: 6px;\n    -moz-border-radius: 6px;\n    -ms-border-radius: 6px;\n    -o-border-radius: 6px;\n    position: relative;\n}\n.record-item>.date{\n    height: 34px;\n    background: rgb(174, 209, 237);\n    padding: 6px 12px;\n    font-size: 14px;\n    line-height: 22px;\n}\n.record-body{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    padding: 10px 20px;\n    justify-content: space-between;\n    align-content: center;\n}\n.record-content{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    flex: 1;\n}\n.record-body>.delete{\n    padding-left: 10px;\n    margin-left: 10px;\n    border-left: 1px solid rgb(201, 201, 201);\n    color: rgb(33, 70, 181);\n}\n.record-item>.type{\n    position: absolute;\n    top: 5px;\n    right: 10px;\n    font-size: 14px;\n    padding: 0 6px;\n    height: 22px;\n    line-height: 22px;\n    color: #fff;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n.type.expenditure{\n    background: rgb(241, 141, 158);\n}\n.type.income{\n    background: rgb(85, 194, 134);\n}\n\n```\n\n```css /public/css/add.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\nhr{\n    margin: 20px auto;\n    border: 0;\n    border-top: 1px solid rgb(220, 220, 220);\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.home{\n    margin-top: 10px;\n    padding-left: 10px;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.content-box form{\n    margin-top: 10px;\n}\n.form-item{\n    margin-bottom: 15px;\n}\n.form-item label{\n    display: block;\n    height: 32px;\n    line-height: 32px;\n    font-size: 18px;\n}\n.form-item>*{\n    width: 100%;\n}\n.form-item>.control{\n    padding: 6px 12px;\n    height: 36px;\n    font-size: 16px;\n    line-height: 36px;\n    color: #363636;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n    outline: none;\n    font-family:\"Microsoft YaHei\",微软雅黑;\n}\n.form-item>.control:focus{\n    border-color: #66afe9;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n}\n.form-item>textarea.control{\n    padding: 8px 12px;\n    height: 100px;\n    line-height: 1;\n    resize: none;\n}\n.content-box form>button{\n    width: 100%;\n    padding: 6px 12px;\n    margin-bottom: 15px;\n    border: 1px solid rgb(57, 162, 204);\n    background: rgb(37, 173, 204);\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    font-size: 17px;\n    color: #fff;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.content-box form>button:hover{\n    background: rgb(32, 153, 190);\n}\n\n```\n\n```css /public/css/tip.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    margin: 0 auto;\n    max-width: 300px;\n    padding: 20px 30px;\n    background: rgba(77, 190, 215, 0.6);\n    margin-top: 20px;\n    display: flex;\n    align-items: center;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n\n```","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"初识NodeJS","url":"/article/109cbe0a.html","content":"\n# 初识\nNodeJS是使用C++编写的基于ChromeV8引擎，开源、跨平台的JavaScript运行环境\n\n[中文API文档](https://nodejs.cn/api/)\n\n# Buffer\nBuffer(缓冲区)存放二进制数据的缓存区，类似数组Array\n\n```js\nlet buf = Buffer.alloc(10);//每个二进制位都清0\nlet buf_2 = Buffer.allocUnsafe(10);//不清0，可能有旧数据，但速度较快\n```\n\n字符串转二进制编码，每个字符按编码转为二进制存入\n\n```js\nlet buf_3 = Buffer.from('hello');\nconsole.log(buf_3);\n// <Buffer 68 65 6c 6c 6f>\n```\n\n将数组存入Buffer\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4);\n// <Buffer 6f 70 71 72>\n```\n\n`toString()`Buffer转字符串\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4.toString());// 默认采用UTF-8\n// opqr\n```\n\n使用下标访问Buffer\n\n```js\nlet buf_5 = Buffer.from('chuckle');\nconsole.log(buf_5[0]);//十六进制，99\nconsole.log(buf_5[0].toString(2));//转为二进制，1100011\nbuf_5[0] = 90;// 修改\nconsole.log(buf_5[0]);//十六进制，90\n```\n\n溢出，舍弃高位\n\n```js\nbuf_5[0] = 360;// 101101000\nconsole.log(buf_5[0]);//十六进制，104\nconsole.log(buf_5[0].toString(2));//1 0110 1000 => 110 1000\n```\n\nBuffer存中文，UTF-8中一汉字占三个字节\n\n```js\nlet buf_6 = Buffer.from('今天你好');\nbuf_6.write('轻笑');// 覆盖前两个\nconsole.log(buf_6);//<Buffer e8 bd bb e7 ac 91 e4 bd a0 e5 a5 bd>\nconsole.log(buf_6.toString());//轻笑你好\n```\n\n# fs模块\n文件系统（fs 模块）中的方法均有异步和同步版本，异步有回调函数，参数为err错误信息\n\n创建 text.txt 并写入内容\n\n```js\nconst fs = require('fs');\n//异步\nfs.writeFile('./text.txt', '轻笑chuckle', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n//同步\nfs.writeFileSync('./text.txt', '轻笑chuckle');\n\n```\n\n`appendFile` 追加写入\n\n```js\nfs.appendFile('./text.txt', '\\r\\n追加内容', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n// writeFile添加配置项实现追加写入\nfs.writeFile('./text.txt', '\\r\\n追加内容',{flag: 'a'} , err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n\n```\n\n`createWriteStream` 流式写入，适合频繁或大文件写入，与文件的连接不断开\n\n```js\nconst ws = fs.createWriteStream('.text.txt');\nws.write('1');\nws.write('2');\nws.write('3');\nws.close();// 断开连接，会自动断开，close可加可不加\n```\n\n`readFile` 文件读取\n\n```js\n// 回调函数两个参数，错误信息和文件内容\nfs.readFile('./text.txt', (err, data)=>{\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log(data.toString());\n});\n// 同步读取，直接返回文件内容\nlet data = fs.readFileSync('./text.txt');\nconsole.log(data.toString());\n\n```\n\n`createReadStream` 流式读取\n\n```js\nconst rs = fs.createReadStream('./1.mp4');\nrs.on('data', chunk =>{\n    console.log(chunk);// Buffer\n    console.log(chunk.length);// 每次读取64kb\n});\nrs.on('end', ()=>{\n    console.log('读取完成');\n});\n\n```\n\n复制文件，使用流式操作更快，占用内存更少\n\n```js\n// readFile\nfs.readFile('./text.txt', (err, data) =>{\n    if(err){\n        return console.error(err);\n    }\n    fs.writeFile('./text2.txt', data, err =>{});\n});\n// 流式操作\nconst rs = fs.createReadStream('./1.mp4');\nconst ws = fs.createWriteStream('./2.mp4');\nrs.on('data', chunk =>{\n    ws.write(chunk);\n});\n// 流式操作pipe\nrs.pipe(ws);\n\n```\n\n`rename` 文件重命名和移动\n\n```js\nfs.rename('./1.mp4', './3.mp4', err=>{});\nfs.rename('./3.mp4', './mp4/3.mp4', err=>{});\n```\n\n`unlink` 删除文件\n\n```js\nfs.unlink('./2.mp4', err=>{});\nfs.rm('./2.mp4', err=>{});\n```\n\n`mkdir` 创建文件夹\n\n```js\nfs.mkdir('./a', err=>{});\n// 递归创建\nfs.mkdir('./a/b/c', {recursive: true},err=>{});\n```\n\n`readdir` 读取文件夹，读取到一个目标文件夹下文件名的数组\n\n```js\nfs.readdir('./mp4', (err, data)=>{\n    console.log(data);// [ '3.mp4' ]\n});\n```\n\n`rmdir` 删除文件夹\n\n```js\nfs.rmdir('./a/b/c', err=>{});\n// 递归删除，文件夹非空时使用\nfs.rmdir('./a', {recursive: true},err=>{});\n// 或使用rm\nfs.rm('./a',{recursive: true} ,err=>{});\n```\n\n`stat` 查看资源状态\n\n```js\nfs.stat('./3.mp4', (err, data)=>{\n    console.log(data);// 输出信息\n    console.log(data.isDirectory());//是否是文件夹\n    console.log(data.isFile());//是否是普通文件\n});\n```\n\n**__dirname** 保存js文件所在目录的绝对路径，避免工作路径不同、工作区不同，导致相对路径不同而出bug\n\n```js\nfs.writeFileSync(__dirname + '/1.txt', 'chuckle');\n```\n\n批量重命名文件，在文件名前加上0\n\n```js\nfs.readdir(__dirname + '/rename', (err, data)=>{\n    data.forEach((item, index)=>{\n        let data = item.split('.');\n        let [num, suffix] = data;\n        if(Number(num)<10){\n            num = '0' + num;\n        }\n        fs.renameSync(`${__dirname}/rename/${item}`, `${__dirname}/rename/${num}.${suffix}`);\n    });\n});\n\n```\n\n# path模块\n`resolve` 拼接规范的绝对路径\n\n```js\nconst path = require('path');\nlet path1 = path.resolve(__dirname + '/rename');\nconsole.log(path1);// c:\\chuckle\\qx\\nodejs\\rename\n```\n\n其它方法\n\n```js\nconsole.log(path.sep);// 获取当前系统的路径分隔符\n// /\nconsole.log(path.parse(__filename));// 解析路径并返回对象\n// {\n//   root: 'c:\\\\',\n//   dir: 'c:\\\\chuckle\\\\qx\\\\nodejs',\n//   base: 'fs.js',\n//   ext: '.js',\n//   name: 'fs'\n// }\nconsole.log(path.basename(__filename));// 获取路径的基础名称\n// fs.js\nconsole.log(path.dirname(__filename));// 获取路径的目录名\n// c:\\chuckle\\qx\\nodejs\nconsole.log(path.extname(__filename));// 获取文件的扩展名\n// .js\n\n```\n\n# http模块\n搭建http服务：\n\n```js\n// 导入 http 模块\nconst http = require('http');\n// 创建服务对象\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');// 设置字符集防止乱码\n    response.end('你好');// 响应文本\n});\n\n// 监听端口，启动服务\nserver.listen(9000, ()=>{\n    // 当服务启动时运行回调函数\n    console.log('服务启动');\n});\n\n```\n\n## 获取请求报文\n\n获取请求行和请求头，修改createServe的回调函数\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    // 获取请求方法\n    console.log(request.method);\n    // 获取请求url，只包含路径和查询字符串\n    console.log(request.url);\n    // 获取http协议版本号\n    console.log(request.httpVersion);\n    // 获取http的请求头\n    console.log(request.headers);\n    // 获取请求头中单独的属性值\n    console.log(request.headers.host);\n    response.end('hello world');\n});\n\n```\n\n获取请求体\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    //获取请求体\n    let body = '';\n    // request也是一个可读流，绑定data事件一点点获取内容\n    request.on('data', chunk=>{\n        body += chunk;\n    })\n    // 绑定end事件\n    request.on('end', ()=>{\n        console.log(body);\n        // 响应\n        response.end('hello http');\n    });\n});\n\n```\n\n## 获取请求路径和查询字符串\n使用**url模块**获取请求路径和查询字符串\n\n```js\nconst url = require('url');// 导入url模块\nconst server = http.createServer((request, response)=>{\n    // 获取请求路径和查询字符串\n    console.log(request.url);\n    // 使用url模块解析url\n    let res = url.parse(request.url, true);// 第二个参数true将query属性值变为一个对象\n    console.log(res);\n    // Url {\n    //   protocol: null,\n    //   slashes: null,\n    //   auth: null,\n    //   host: null,\n    //   port: null,\n    //   hostname: null,\n    //   hash: null,\n    //   search: '?psw=1234&name=chuckle',\n    //   query: [Object: null prototype] { psw: '1234', name: 'chuckle' },\n    //   pathname: '/search',\n    //   path: '/search?psw=1234&name=chuckle',\n    //   href: '/search?psw=1234&name=chuckle'\n    // }\n    console.log(res.path);// 获取路径\n    console.log(res.query);// 获取查询字符串对象\n    console.log(res.query.psw);// 获取查询字符串中的属性值\n});\n\n```\n\n使用**URL类**获取请求路径和查询字符串\n\n```js\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    console.log(url);\n    // URL {\n    //   href: 'http://127.0.0.1:9000/search?psw=1234&name=chuckle',\n    //   origin: 'http://127.0.0.1:9000',\n    //   protocol: 'http:',\n    //   username: '',\n    //   password: '',\n    //   host: '127.0.0.1:9000',\n    //   hostname: '127.0.0.1',\n    //   port: '9000',\n    //   pathname: '/search',\n    //   search: '?psw=1234&name=chuckle',\n    //   searchParams: URLSearchParams { 'psw' => '1234', 'name' => 'chuckle' },\n    //   hash: ''\n    // }\n    console.log(url.pathname);// 获取路径\n    console.log(url.searchParams);// 获取查询字符串map对象\n    console.log(url.searchParams.get('psw'));// map对象用get获取属性值\n});\n\n```\n\n## 请求路径练习\n根据请求路径响应不同内容\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    // 获取请求方法\n    let {method} = request;\n    // 获取请求路径\n    let {pathname} = url;\n    // 根据请求路径响应不同内容\n    if (method === 'GET' && pathname === '/login'){\n        response.end('login');\n    }else if (method === 'GET' && pathname === '/reg'){\n        response.end('reg');\n    }else{\n        response.end('Not Found');\n    }\n});\nserver.listen(9000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## 设置响应报文\n设置响应码、响应头、响应体\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    // 1.设置响应状态码\n    response.statusCode = 200;\n    // 2.设置响应状态的描述\n    response.statusMessage = 'chuckle';\n    // 3.响应头，两个参数，响应名和值，可自定义\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    response.setHeader('Server', 'nodejs');\n    response.setHeader('MyHeader', 'chuckle');\n    // 设置多个同名响应头\n    response.setHeader('test', ['a', 'b', 'c']);\n    // 4. 设置响应体，end只能执行一个，write可以有多个\n    response.write('chuckle');\n    response.write('qx');\n    // end是必须的，但设置write后一般end设为空\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n配合fs模块响应文件\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    response.write(html);\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 响应文件练习\n根据文件路径响应不同内容，下面这种写法不方便，后面有优化\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    let css = fs.readFileSync(__dirname + '/2.css');\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    let {pathname} = url;\n    if(pathname === '/'){\n        response.write(html);\n    }else if(pathname === '/2.css'){\n        response.write(css);\n    }else {\n        response.statusCode = 404;\n        response.write('404');\n    }\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n优化版：静态资源响应服务\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 设置资源mime类型\nmime类型用于表示文档、文件或字节流的性质和类型\n\nHTTP服务可以设置响应头 Content-Type 来表明响应体的mime类型，浏览器会根据该类型决定如何处理资源\n\n常见mime类型：\n**1、html** text/html\n**2、css** text/css\n**3、js** text/javascript\n**4、png** image/png\n**5、jpg** image/jpeg\n**6、gif** image/gif\n**7、mp4** video/mp4\n**8、mp3** audio/mpeg\n**9、json** application/json\n\n对于未知的资源类型，可以选择 application/octet-stream 刘览器在遇到该类型的响应时，会对响应体内容进行独立存储，实现下载效果\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        console.log(type);\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 完善错误处理\n[Node.js常见系统错误](https://nodejs.cn/api/errors.html#common-system-errors)\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\nlet errs = {\n    ENOENT: 404,\n    EPERM: 403\n}\n\nconst server = http.createServer((request, response)=>{\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    // 请求方法错误\n    console.log(request.method);\n    if(request.method !== 'GET'){\n       response.statusCode = 405;\n       response.end('出错了');\n       return;\n    }\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            let errCode = errs[err.code] ? errs[err.code] : 500;\n            console.log(errCode);\n            response.statusCode = errCode;\n            response.write('出错了');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 模块化\n将一个复杂的程序文件，按一定规则拆分为多个文件，即模块化，每个小文件就算一个模块\n\n模块内部数据是私有的，但可以主动度外暴露出去\n\n**模块化项目：**\n编写项目时一个个模块编写，再组合起来\n\n**模块化优点：**\n1、防止命名冲突\n2、高服用性\n3、高维护性\n\n# 暴露数据\n在模块中使用`module.exports`和`exports`向外暴露数据，但两者不能同时使用\n\n隐式关系：exports = module.exports = {}\n\n```js\nlet name = 'chuckle';\nlet age = 19;\nfunction fun() {\n    console.log(name);\n}\nmodule.exports = {\n    name,\n    fun\n}\nexports.age = age;\n\n```\n\n# 导入模块\n1. 导入js/sjon文件或c编写的mode扩展插件可以省略后缀，同名优先导入js\n2. 导入自己的模块最好使用相对路径 **./**\n3. 导入其它类型的文件会以js文件处理\n4. 导入**文件夹**，首先会去找文件夹内package.json里main属性对应的文件，如果没用main属性或package.json则去找文件夹内的index.js或index.json，如果还没找到则报错，main属性对应的文件不存在也会报错\n5. 导入nodejs内置模块时，直接写模块名即可\n\n```js\nconst mod = require('./1.js');\nconst mod = require('./1');\n```\n\n# 包管理工具\n包，即package，是一组特定功能的源码集合，即别人写好的各种工具\n\n管理包，即对包进行下载、安装、删除、上传操作\n\n常见包管理工具：npm、yarn、cnpm\n\n## npm\nNode Package Manager即npm，是nodejs内置的包管理工具\n\npackage.json 是包必须有的配置文件\npackage-lock.json 存放依赖包的版本信息\n\nrequire导入npm包流程：\n1、在当前文件夹下的node_modules中找同名文件夹\n2、在上级目录中node_modules中找同名文件夹，直到磁盘根目录\n\n```js\nnpm i <包名@版本号>// 安装\nnpm r <包名>// 移除\n```\n\nnpm配置命令别名，修改package.json的 **scripts** 属性，通过npm run <命令名>运行命令，会自动向上寻找，添加start属性，可以省略run，直接npm start\n\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"server\": \"node ./index.js\",\n    \"start\": \"node ./index.js\"\n},\n// 使用\nnpm run server\nnpm start\n\n```\n\n通过指定源来提高包安装速度\n\n```js\nnpm i <包名> --registry=https://registry.npmmirror.com\n```\n\n## 开发和生产依赖\n开发环境：写源代码、工程文件时的环境，一般指程序员的电脑，只能由程序员访问\n生产环境：项目代码正式运行的环境，一般指服务器，所有用户都能访问\n\n开发依赖：只在写代码时用到的依赖包，安装时添加 -D 或 --save-dev\n生产依赖：默认项，既在写代码时使用，又在代码运行时使用的依赖包，安装时添加 -S 或 --save 参数，\n\npackage.json中，dependencies属性保存生产依赖包信息，devDependencies属性保存开发依赖包信息\n\n## 全局安装\n开发和生产依赖都是局部安装的包，存放在工作目录的node_modules文件夹中\n \n全局安装 npm i -g 不受工作目录位置限制，无需导入，一般是在命令行中通过独立命令去使用\n\nnpm root -g 查看全局安装包的位置\n\n只有全局类的工具如 gulp、nodemon等才适合全局安装，通过查看包的文档来确定安装方式\n\n## cnpm\n[cnpm--npmmirror镜像站](https://npmmirror.com/)\n使用方式和npm一样，是淘宝构建的完整 npmjs.org 镜像，了解即可，大多还是使用npm\n\n修改npm的源地址来使用淘宝镜像\n\n```js\n// 查看npm的源\nnpm config list\n// 不推荐，该源无法上传包\nnpm config set registry https://registry.npmmirror.com/\n// 安装时临时指定源\nnpm i <包名> --registry=https://registry.npmmirror.com\n// 使用nrm管理源，推荐\nnpm i -g nrm\nnrm use taobao\nnrm ls// 列出可切换的所有源\nnpm install -g nrm open@8.4.2 --save// 使用nrm有报错则运行此命令\n\n```\n\n## yarn\n[yarn](https://yarnpkg.com/) 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具\n\nyarn和npm需要按需选用，包管理工具不能混用，yarn的锁文件是yarn.lock\n\n`npm i -g yarn`安装yarn\n\n常用命令：\n1. 初始化 yarn init / yarn init -y\n2. 安装包\n    1. yarn add <包名> 生产依赖\n    2. yarn add <包名> --dev 开发依赖\n    3. yarn global add <包名> 全局安装，第一次使用记得手动配置环境变量\n3. 删除包\n   1. yarn remove uniq 删除项目依赖包\n   2. yarn global remove nodemon 全局删除包\n4. 安装项目依赖 yarn\n5. 运行命令别名 yarn <别名>\n6. 全局安装包的位置 yarn global bin\n\n## 管理npm包\n\n1. 修改 package.json 中的版本号\n2. npm publish 提交包\n3. npm unpublish --force 删除包\n\n# nvm管理node版本\nnvm 全称 Node Version Manager 用来管理 node 版本的工具\n\n常用命令：\n1. nvm list available 显示所有可以下载的 Node.js 版本\n2. nvm list 显示已安装的版本\n3. nvm install 18.12.1 安装 18.12.1 版本的 Node.js\n4. nvm install latest 安装最新版的 Node.js\n5. nvm uninstall 18.12.1 删除某个版本的 Node.js\n6. nvm use 18.12.1 切换 18.12.1 的 Node.js\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"文章摘要、相关推荐生成AI","url":"/article/17d3383a.html","content":"\n# 前言\n[@Heo](https://blog.zhheo.com/)又整新活了，给文章加上了AI，我也开写，竞速。\n\n**本项目地址**[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n\n大半夜领先一点就睡不着的屑Heo\n\n<img src=https://cdn.chuckle.top/images/46-2.webp width=\"60%\">\n\n**有这些特性：**\n1. **真AI！**，接入tianliGPT（或是使用官方api接口），JS动态获取全文所有纯文本，传给api实时获取文章摘要（受限于tianliGPT的成本，目前仍有缓存机制）\n2. 基于tianliGPT标注关键词、Python分析相关度的相关文章AI推荐\n3. 遇到标点符号慢下来，动态打字速度\n4. 使用requestAnimationFrame优化性能，动态清除setTimeout、打断fetch请求，交互放心\n5. 使用IntersectionObserver监听，当容器在视口不可见后停止生成摘要，重新出现在视口后继续生成\n6. 模拟GPT的光标效果\n7. 多个按钮实现多个功能，自我介绍、文章摘要、推荐相关文章等\n8. 良好兼容性，性能消耗小。\n9. 适配pjax\n10. 简单引入js后，即可生成QX-AI并自动挂载初始化\n  \n**未来的计划：**\n1. 目前数据库文章量已经够多，计划构建一个博文社区\n\n# 4.0重磅更新\n**新特性：**\n1. 新增相关文章AI推荐\n2. 引入缓存机制，减轻后端压力\n3. 优化代码及性能\n\n## 快速上手\n项目地址[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n\n非常简单，引入下面这些代码到你的网站内，并修改配置项后即可\n\nTIP: 为避免CDN和浏览器缓存的影响，建议指定资源版本号使用\n\n```html\n<!-- css -->\n<link rel=\"stylesheet\" href=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.css\">\n<!-- chuckle-post-ai.js现在可以在网页结构的任何位置插入，只要你能够 -->\n<script src=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.js\"></script>\n<!-- 但要确保的是，AI构造代码一定要在chuckle-post-ai.js之后插入 -->\n<script data-pjax defer>\n  // AI构造函数\n  new ChucklePostAI({\n    /* 必须配置 */\n    // 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n    el: '#post>#article-container',\n    // 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n    key:'123456',\n    /* 非必须配置 */\n    // 文章标题所在的元素属性的选择器，默认获取当前网页的标题\n    title_el: '.post-title',\n    // 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all\n    rec_method: 'web',\n    // 获取文章内容时，需要排除的元素及其子元素，默认如下\n    exclude: ['highlight', 'Copyright-Notice', 'post-ai', 'post-series', 'mini-sandbox']\n  })\n</script>\n```\n\n**AI构造函数 `ChucklePostAI({ /* 传入配置对象 */ })` 详解**\n1. `el` 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n2. `key` 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n3. `title_el` 文章标题所在的元素属性的选择器，默认获取当前网页的标题\n4. `rec_method` 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all\n5. `exclude` 获取文章内容时，需要排除的元素及其子元素\n\ntianliGPT的key请到[爱发电](https://afdian.net/item/f18c2e08db4411eda2f25254001e7c00)中购买，10元5万字符（常有优惠）。请求过的内容再次请求不会消耗key，可以无限期使用。\n\n更多详情请看项目仓库README\n\n# 3.0全新版本\n**新特性：**\n1. 简单引入js后，即可生成QX-AI并自动挂载初始化\n2. 新增项目地址[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n3. 优化代码逻辑，引入外部配置\n\n## 快速上手\n非常简单，引入下面这些代码到你的网站内即可，其中JS的引入的位置应该在文章内容之后\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.css\">\n<script data-pjax defer=\"true\">\n  var ai_option = {\n    el: '#post #article-container',\n    key:'123456'\n  }\n</script>\n<script src=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.js\" data-pjax defer=\"true\"></script>\n```\n\n**ai_option配置详解：**\n1. **el** 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n2. **key** 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n\n更多详情请看项目仓库README\n\n# 2.0之前旧版配置\n**注意：**\n1、为确保 recommendList() 函数正常运行、相关推荐能正常生成，btf主题用户请打开文章页侧边栏中的两个板块：最新文章和相关推荐，非btf用户也许需要手动更改相关js\n2、tianliGPT中国大陆访问速度快，key与域名相绑定，无需担心盗刷，一次生成后续不消耗key字数，tianliGPT的key购买渠道：[购买tianliGPT-Key](https://afdian.net/item/2e07e870dad911edacb852540025c377)\n3、如有bug，请在评论区讨论，请忽略js中的不规范命名和一堆变量，会优化的咕咕咕。\n\n手动修改js中这部分常量以使用AI实时简介\n\n```js\n//默认true，使用tianliGPT，false使用官方api，记得配置Key\nconst choiceApi = true;\nconst apiKey = \"填入chatGPT的apiKey\";\n//tianliGPT的参数\nconst tlReferer = 'https://你的授权域名/';\nconst tlKey = '填入tianliGPT的key';\n```\n\n虽然以及有AI实时生成了，但还是需要预设的，在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介或提升去点AI生成按钮，不想出现AI模块的文章就删去这个配置项\n\n```markdown\n---\ntitle:\nai: 暂无预设简介，请点击下方生成AI简介按钮。\n---\n```\n\n## 2.0版\n**新特性：**\n1. 真！AI，接入tianliGPT或是使用官方api接口，随意选择\n2. 前端限制请求频率、动态打断fetch\n3. 压缩文本降低key压力，纯文本1000字以上的文章，截取前500后200中间300字生成摘要，降低key字数消耗，当然，可以给 getTextContent 传入第二个参数为false，从而不压缩文本\n\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"/js/post-ai.js\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n4-16修复了若干bug\n\n```js\nfunction allAI() {\n  let animationRunning = true; // 标志变量，控制动画函数的运行\n  let explanation = document.querySelector('.ai-explanation');\n  let abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n  let post_ai = document.querySelector('.post-ai');\n  let ai_btn_item = document.querySelectorAll('.ai-btn-item');\n  let ai_str = '';\n  let ai_str_length = '';\n  let delay_init = 600;\n  let i = 0;\n  let j = 0;\n  let sto = [];\n  let elapsed = 0;\n  let completeGenerate = false;\n  let controller = new AbortController();//控制fetch\n  let signal = controller.signal;\n  //默认true，使用tianliGPT，false使用官方api，记得配置Key\n  const choiceApi = true;\n  const apiKey = \"填入chatGPT的apiKey\";\n  //tianliGPT的参数\n  const tlReferer = 'https://你的授权域名/';\n  const tlKey = '填入tianliGPT的key';\n  //-----------------------------------------------\n  const animate = (timestamp) => {\n    if (!animationRunning) {\n      return; // 动画函数停止运行\n    }\n    if (!animate.start) animate.start = timestamp;\n    elapsed = timestamp - animate.start;\n    if (elapsed >= 20) {\n      animate.start = timestamp;\n      if (i < ai_str_length - 1) {\n        let char = ai_str.charAt(i + 1);\n        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n        if (explanation.firstElementChild) {\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        explanation.innerHTML += char;\n        let div = document.createElement('div');\n        div.className = \"ai-cursor\";\n        explanation.appendChild(div);\n        i++;\n        if (delay === 150) {\n          document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n        }\n        if (i === ai_str_length - 1) {\n          observer.disconnect();// 暂停监听\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        sto[0] = setTimeout(() => {\n          requestAnimationFrame(animate);\n        }, delay);\n      }\n    } else {\n      requestAnimationFrame(animate);\n    }\n  };\n  const observer = new IntersectionObserver((entries) => {\n    let isVisible = entries[0].isIntersecting;\n    animationRunning = isVisible; // 标志变量更新\n    if (animationRunning) {\n      delay_init = i === 0 ? 200 : 20;\n      sto[1] = setTimeout(() => {\n        if (j) {\n          i = 0;\n          j = 0;\n        }\n        if (i === 0) {\n          explanation.innerHTML = ai_str.charAt(0);\n        }\n        requestAnimationFrame(animate);\n      }, delay_init);\n    }\n  }, { threshold: 0 });\n  function clearSTO() {\n    if (sto.length) {\n      sto.forEach((item) => {\n        if (item) {\n          clearTimeout(item);\n        }\n      });\n    }\n  }\n  function resetAI(df = true) {\n    i = 0;//重置计数器\n    j = 1;\n    clearSTO();\n    animationRunning = false;\n    elapsed = 0;\n    if (df) {\n      explanation.innerHTML = '生成中. . .';\n    } else {\n      explanation.innerHTML = '请等待. . .';\n    }\n    // console.log(completeGenerate);\n    if (!completeGenerate) {\n      controller.abort();\n      // console.log(completeGenerate);\n    }\n    ai_str = '';\n    ai_str_length = '';\n    observer.disconnect();// 暂停上一次监听\n  }\n  function startAI(str, df = true) {\n    resetAI(df);\n    ai_str = str;\n    ai_str_length = ai_str.length;\n    observer.observe(post_ai);//启动新监听\n  }\n  function aiIntroduce() {\n    startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n  }\n  function aiAbstract() {\n    startAI(abstract_value);\n  }\n  function aiRecommend() {\n    resetAI();\n    sto[2] = setTimeout(() => {\n      explanation.innerHTML = recommendList();\n    }, 300);\n  }\n  function aiGoHome() {\n    startAI('正在前往博客主页...', false);\n    sto[2] = setTimeout(() => {\n      pjax.loadUrl(\"/\");\n    }, 1000);\n  }\n  async function aiGenerateAbstract() {\n    // if(!verifyDomainName()){btf.snackbarShow('未经授权的域名');return;}\n    // if(!completeGenerate){\n    //   btf.snackbarShow('AI摘要正在生成，请勿重复发起');\n    //   return;\n    // }\n    if (clickFrequency()) {\n      return;\n    }\n    localStorage.setItem('aiTime', Date.now());\n    resetAI();\n    const ele = document.querySelector('#article-container');\n    const content = getTextContent(ele);\n    console.log(content);\n    const response = await getGptResponse(content, choiceApi);//true使用tianliGPT，false使用官方api\n    console.log(response);\n    startAI(response);\n  }\n  function recommendList() {\n    let info = `推荐文章：<br />`;\n    let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n    if (!thumbnail||thumbnail.length===0) {\n      info = '很抱歉，无法找到类似的文章，你也可以看看本站最近更新的文章：<br />';\n      thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n    }\n    info += '<div class=\"ai-recommend\">';\n    thumbnail.forEach((item, index) => {\n      info += `<div class=\"ai-recommend-item\"><span>推荐${index + 1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n    });\n    info += '</div>'\n    return info;\n  }\n  //ai首屏初始化，绑定按钮注册事件\n  function ai_init() {\n    explanation = document.querySelector('.ai-explanation');\n    abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n    post_ai = document.querySelector('.post-ai');\n    ai_btn_item = document.querySelectorAll('.ai-btn-item');\n    const funArr = [aiIntroduce, aiAbstract, aiRecommend, aiGenerateAbstract];\n    ai_btn_item.forEach((item, index) => {\n      item.addEventListener('click', () => {\n        funArr[index]();\n      });\n    });\n    aiIntroduce();\n  }\n  function clickFrequency(t = 3000) {\n    let time = Date.now() - localStorage.getItem('aiTime');\n    if (time < t) {\n      btf.snackbarShow(`${3 - parseInt(time / 1000)}后才能再次点击真AI简介`);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  // 真AI简介相关函数\n\n  // function verifyDomainName(){\n  //   const domain = window.location.hostname;\n  //   const authorized = ['www.qcqx.cn','www.chuckle.top','127.0.0.1'];\n  //   return authorized.includes(domain)\n  // }\n  //获取某个元素内的所有纯文本，并按顺序拼接返回\n  function getText(element) {\n    //需要排除的元素及其子元素\n    const excludeClasses = ['highlight', 'Copyright-Notice', 'post-ai', 'post-series', 'mini-sandbox',];\n    let textContent = '';\n    for (let node of element.childNodes) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        //如果是纯文本节点则获取内容拼接\n        textContent += node.textContent.trim();\n      } else if (node.nodeType === Node.ELEMENT_NODE) {\n        let hasExcludeClass = false;//跟踪元素是否包含需要排除的类名\n        //遍历类名\n        for (let className of node.classList) {\n          //如果包含则hasExcludeClass设为true，且break跳出循环\n          if (excludeClasses.includes(className)) {\n            hasExcludeClass = true;\n            break;\n          }\n        }\n        //如果hasExcludeClass为false，即该标签不包含需要排除的类，可以继续向下遍历子元素\n        if (!hasExcludeClass) {\n          //不同元素内获取的文本用句号隔开\n          let innerTextContent = getText(node);\n          // if (textContent && innerTextContent) {\n          //   //如果本来有标点符号则不添加\n          //   if (/[：:,.，。?？/；;!！（）、)(]$/.test(textContent) || /^[：:,.，。?？/；;!！（）、@#￥$%&)(]/.test(innerTextContent)) {\n          //     textContent += innerTextContent;\n          //   } else {\n          //     textContent += '。' + innerTextContent;\n          //   }\n          // } else {\n          //   textContent += innerTextContent;\n          // }\n          textContent += innerTextContent;\n        }\n      }\n    }\n    //返回纯文本节点的内容\n    return textContent.replace(/\\s+/g, '');\n  }\n  //获取各级标题\n  function extractHeadings(element) {\n    const headings = element.querySelectorAll('h1, h2, h3, h4');\n    const result = [];\n    for (let i = 0; i < headings.length; i++) {\n      const heading = headings[i];\n      const headingText = heading.textContent.trim();\n      result.push(headingText);\n      const childHeadings = extractHeadings(heading);\n      result.push(...childHeadings);\n    }\n    return result.join(\";\");\n  }\n  //按比例切割字符串\n  function extractString(str) {\n    // 截取前500个字符\n    var first500 = str.substring(0, 500);\n    // 截取末尾200个字符\n    var last200 = str.substring(str.length - 200);\n    // 截取中间300个字符\n    var midStartIndex = (str.length - 300) / 2; // 计算中间部分的起始索引\n    var middle300 = str.substring(midStartIndex, midStartIndex + 300);\n    // 将三个部分拼接在一起\n    var result = first500 + middle300 + last200;\n    // 返回截取后的字符串\n    return result;\n  }\n  //获得字符串，默认进行切割，false返回原文纯文本\n  function getTextContent(element, i = true) {\n    let content;\n    if (i) {\n      content = `文章的各级标题：${extractHeadings(element)}。文章内容的截取：${extractString(getText(element))}`;\n    } else {\n      content = `${getText(element)}`;\n    }\n    return content;\n  }\n  //发送请求获得简介\n  async function getGptResponse(content, i = true) {\n    completeGenerate = false;\n    controller = new AbortController();\n    signal = controller.signal;\n    let response = '';\n    if (i) {\n      try {\n        response = await fetch('https://summary.tianli0.top/', {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Referer\": tlReferer\n          },\n          body: JSON.stringify({\n            content: content,\n            key: tlKey\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求tianliGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.summary;\n      // console.log(outputText);\n      completeGenerate = true;\n      return outputText;\n    } else {\n      const prompt = `你是一个摘要生成工具，你需要解释我发送给你的内容，不要换行，不要超过200字，只需要介绍文章的内容，不需要提出建议和缺少的东西。请用中文回答，文章内容为：${content}`;\n      const apiUrl = \"https://api.openai.com/v1/chat/completions\";\n      try {\n        response = await fetch(apiUrl, {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": `Bearer ${apiKey}`\n          },\n          body: JSON.stringify({\n            model: \"gpt-3.5-turbo\",\n            messages: [{ \"role\": \"user\", \"content\": prompt }],\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求chatGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.choices[0].message.content;\n      completeGenerate = true;\n      return outputText;\n    }\n  }\n  ai_init();\n}\nallAI();\n\n```\n\n添加CSS，颜色变量可F12自取，建议自己重新配色(2.0版本无css更新)\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n\n## 1.1版\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"/js/post-ai.js?2\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n\n```js\nif (true) {\n let animationRunning = true; // 标志变量，控制动画函数的运行\n const explanation = document.querySelector('.ai-explanation');\n const abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n const post_ai = document.querySelector('.post-ai');\n let ai_str = '';\n let ai_str_length = '';\n let delay_init = 600;\n let i = 0;\n let j = 0;\n let sto = [];\n let elapsed = 0;\n const animate = (timestamp) => {\n   if (!animationRunning) {\n     return; // 动画函数停止运行\n   }\n   if (!animate.start) animate.start = timestamp;\n   elapsed = timestamp - animate.start;\n   if (elapsed >= 20) {\n     animate.start = timestamp;\n     if (i < ai_str_length-1) {\n       let char = ai_str.charAt(i+1);\n       let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n       if(explanation.firstElementChild){\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       explanation.innerHTML += char;\n       let div = document.createElement('div');\n       div.className = \"ai-cursor\";\n       explanation.appendChild(div);\n       i++;\n       if(delay === 150){\n         document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n       }\n       if(i === ai_str_length-1){\n         observer.disconnect();// 暂停监听\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       sto[0] = setTimeout(() => {\n         requestAnimationFrame(animate);\n       }, delay);\n     }\n   } else {\n     requestAnimationFrame(animate);\n   }\n };\n const observer = new IntersectionObserver((entries) => {\n   let isVisible = entries[0].isIntersecting;\n   animationRunning = isVisible; // 标志变量更新\n   if(animationRunning){\n     delay_init = i===0 ? 200 : 20;\n     sto[1] = setTimeout(() => {\n       if(j){\n         i = 0;\n         j = 0;\n       }\n       if(i===0){\n         explanation.innerHTML = ai_str.charAt(0);\n       }\n       requestAnimationFrame(animate);\n     }, delay_init);\n   }\n }, { threshold: 0 });\n function clearSTO(){\n   if(sto.length){\n     sto.forEach((item)=>{\n       if(item){\n         clearTimeout(item);\n       }\n     });\n   }\n }\n function startAI(str,df=true){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   if(df){\n     explanation.innerHTML = '生成中. . .';\n   }else{\n     explanation.innerHTML = '请等待. . .';\n   }\n   ai_str = str;\n   ai_str_length = ai_str.length;\n   observer.disconnect();// 暂停上一次监听\n   observer.observe(post_ai);//启动新监听\n }\n function aiIntroduce(){\n   startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n }\n function aiAbstract(){\n   startAI(abstract_value);\n }\n function aiRecommend(){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   explanation.innerHTML = '生成中. . .';\n   ai_str = '';\n   ai_str_length = '';\n   observer.disconnect();// 暂停上一次监听\n   sto[2] = setTimeout(() => {\n     explanation.innerHTML = recommendList();\n   }, 600);\n }\n function aiGoHome(){\n   startAI('正在前往博客主页...',false);\n   sto[2] = setTimeout(() => {\n     pjax.loadUrl(\"/\");\n   }, 1000);\n }\n const ai_btn_item = document.querySelectorAll('.ai-btn-item');\n ai_btn_item.forEach((item, index)=>{\n   item.addEventListener('click', ()=>{\n     switch(index) {\n       case 0:\n         aiIntroduce();\n         break;\n       case 1:\n         aiAbstract();\n         break;\n       case 2:\n         aiRecommend();\n         break;\n       case 3:\n         aiGoHome();\n       break;\n     } \n   });\n });\n function recommendList(){\n   let info = `推荐文章：<br />`;\n   let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n   if(!thumbnail){\n     info = '很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br />';\n     thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n   }\n   info += '<div class=\"ai-recommend\">';\n   thumbnail.forEach((item, index)=>{\n     info += `<div class=\"ai-recommend-item\"><span>推荐${index+1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n   });\n   info += '</div>'\n   return info;\n }\n aiIntroduce();\n}\n\n```\n\n添加CSS，颜色变量可F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n使用：在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介\n\n```markdown\n---\ntitle: 文章添加AI摘要和推荐\nai: 本文介绍了如何通过手动生成GPT网页版摘要，再用JS模拟GPT打字生成效果，实现AI摘要。作者详细讲解了实现思路，包括停顿、延迟等策略，以及如何监听视口并控制生成。作者还提到了未来计划，即使用API生成更多摘要。此外，作者还给出了修改 post.pug 和 CSS 的代码。\n---\n\n```\n\n\n## 1.0版\n才两个小时就沦为旧版的屑\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n   .post-ai\n   .ai-title\n   i.fa-brands.fa-airbnb\n   .ai-title-text AI摘要\n   .ai-tag GPT-4\n   .ai-explanation #{page.ai}\n   script.\n   if (true) {\n     let animationRunning = true; // 标志变量，控制动画函数的运行\n     const explanation = document.querySelector('.ai-explanation');\n     const post_ai = document.querySelector('.post-ai');\n     const ai_str = explanation.innerHTML;\n     const ai_str_length = ai_str.length;\n     let delay_init = 600;\n     let i = 0;\n     explanation.innerHTML = 'AI摘要生成中. . .';\n     const animate = (timestamp) => {\n       if (!animationRunning) {\n         return; // 动画函数停止运行\n       }\n       if (!animate.start) animate.start = timestamp;\n       const elapsed = timestamp - animate.start;\n       if (elapsed >= 20) {\n         animate.start = timestamp;\n         if (i < ai_str_length-1) {\n           let char = ai_str.charAt(i+1);\n           let delay = /[,.，。!?！？]/.test(char) ? 160 : 20;\n           if(explanation.firstElementChild){\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           explanation.innerHTML += char;\n           let div = document.createElement('div');\n           div.className = \"ai-cursor\";\n           explanation.appendChild(div);\n           i++;\n           if(delay === 160){\n             document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n           }\n           if(i === ai_str_length-1){\n             observer.disconnect();// 暂停监听\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           setTimeout(() => {\n             requestAnimationFrame(animate);\n           }, delay);\n         }\n       } else {\n         requestAnimationFrame(animate);\n       }\n     };\n     const observer = new IntersectionObserver((entries) => {\n       let isVisible = entries[0].isIntersecting;\n       animationRunning = isVisible; // 标志变量更新\n       if(animationRunning){\n         delay_init = i===0 ? 600 : 20;\n         setTimeout(() => {\n           if(i===0){\n             explanation.innerHTML = ai_str.charAt(0);\n           }\n           requestAnimationFrame(animate);\n         }, delay_init);\n       }\n     }, { threshold: 0 });\n     observer.observe(post_ai);\n   }\n\n```\n\n添加CSS，颜色变量F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n\n```\n","tags":["Butterfly","Hexo","ChatGPT"],"categories":["Hexo"]},{"title":"JavaScript—DOM案例","url":"/article/b0cb9f85.html","content":"\n# 搜索框下拉栏\n\n<div id=\"search-sandbox\"></div>\n\n```html\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        ul{\n            list-style: none;\n        }\n        .search-box{\n            position: relative;\n            width: 200px;\n            margin: 20px;\n            border-radius: 6px;\n        }\n        .search-box input{\n            width: 100%;\n            height: 40px;\n            font-size: 16px;\n            line-height: 100%;\n            border: 1px solid #65a8e2;\n            outline: none;\n            padding: 0 6px;\n            border-radius: 6px;\n            transition: all 0.3s;\n        }\n        .result-list{\n            width: 100%;\n            position: absolute;\n            top: 40px;\n            border: 1px solid #65a8e2;\n            height: auto;\n            border-top: 0;\n            background: rgba(200, 236, 243, 0.7);\n            border-radius: 0 0 6px 6px;\n            display: none;\n        }\n        .result-list li{\n            height: auto;\n        }\n        .result-list a{\n            transition: all 0.3s;\n            text-decoration: none;\n            color: #363636;\n            padding: 5px 10px;\n            display: block;\n            font-size: 14px;\n        }\n        .result-list a:hover{\n            background-color: rgba(210, 210, 210, 0.9);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"search-box\">\n        <input type=\"search\" placeholder=\"输入搜索内容\">\n        <ul class=\"result-list\">\n            <li><a href=\"#\">搜索词1</a></li>\n            <li><a href=\"#\">搜索词2</a></li>\n            <li><a href=\"#\">搜索词3</a></li>\n            <li><a href=\"#\">搜索词4</a></li>\n            <li><a href=\"#\">搜索词5</a></li>\n            <li><a href=\"#\">搜索词6</a></li>\n        </ul>\n    </div>\n    <script>\n        const input = document.querySelector('input');\n        const list = document.querySelector('.result-list');\n        input.addEventListener('focus',()=>{\n            list.style.display = \"block\";\n            input.style.borderRadius = '6px 6px 0 0'\n        });\n        input.addEventListener('blur',()=>{\n            list.style.display = \"none\";\n            input.style.borderRadius = '6px'\n        });\n    </script>\n</body>\n</html>\n\n```\n\n# 评论发布、字数统计\n\n<div id=\"input-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            box-sizing: border-box;\n        }\n\n        .comment-box {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n        }\n\n        .comment-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.chuckle.top/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        #comment-tx {\n            outline: none;\n            border-color: transparent;\n            resize: none;\n            background: #f5f5f5;\n            border-radius: 4px;\n            flex: 1;\n            padding: 10px;\n            transition: all 0.3s;\n            font-size: 12px;\n            height: 60px;\n        }\n\n        #comment-tx:focus {\n            border-color: #e4e4e4;\n            background: #fff;\n            height: 85px;\n        }\n\n        .comment-box button {\n            background: #00aeec;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            margin-left: 10px;\n            width: 70px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .comment-count {\n            width: 500px;\n            height: auto;\n            display: flex;\n            justify-content: flex-end;\n        }\n\n        .comment-count span {\n            margin-right: 80px;\n            color: #999;\n            margin-top: 5px;\n            transition: all 0.3s;\n            opacity: 0;\n        }\n\n        .content-list {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n            flex-direction: column;\n            flex-wrap: nowrap;\n        }\n\n        .content-item {\n            display: flex;\n            border-bottom: 1px solid #e4e4e4;\n            padding-bottom: 10px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-items: flex-start;\n            margin-bottom: 15px;\n        }\n\n        .content-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.chuckle.top/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        .content-warp {\n            width: calc(100% - 65px);\n            padding-right: 8px;\n        }\n\n        .content-name {\n            font-size: 16px;\n            margin-bottom: 6px;\n        }\n\n        .content-comment {\n            font-size: 18px;\n            white-space: normal;\n            word-break: break-all;\n            word-wrap: break-word;\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"comment-box\">\n        <div class=\"comment-avatar\"></div>\n        <textarea id=\"comment-tx\" placeholder=\"发一条友善的评论，回车发布评论\" maxlength=\"200\"></textarea>\n        <button>发布</button>\n    </div>\n    <div class=\"comment-count\">\n        <span>0/200字</span>\n    </div>\n    <div class=\"content-list\">\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">评论一</div>\n            </div>\n        </div>\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">22222222222222222222222222222222222222222222222222222222222222222222222222\n                </div>\n            </div>\n        </div>\n    </div>\n    <script>\n        // 评论输入框\n        const count = document.querySelector('.comment-count span');\n        const tx = document.querySelector('#comment-tx');\n        tx.addEventListener('focus', () => {\n            count.style.opacity = 1;\n        });\n        tx.addEventListener('blur', () => {\n            count.style.opacity = 0;\n        });\n        tx.addEventListener('input', () => {\n            count.innerHTML = `${tx.value.length}/200字`\n        });\n        // 评论展示\n        const contentList = document.querySelector('.content-list');\n        function applyComment() {\n            let comment = tx.value;\n            let html = `<div class=\"content-item\">\n                <div class=\"content-avatar\"></div>\n                <div class=\"content-warp\">\n                    <div class=\"content-name\">chuckle</div>\n                    <div class=\"content-comment\">${comment}</div>\n                </div>\n            </div>`;\n            contentList.insertAdjacentHTML('afterbegin', html);\n        }\n        tx.addEventListener('keyup', (e) => {\n            if (e.key == 'Enter') {\n                if (tx.value.trim()) {\n                    applyComment();\n                }\n                tx.value = '';\n                count.innerHTML = `${tx.value.length}/200字`\n            }\n        })\n        const button = document.querySelector('.comment-box button');\n        button.addEventListener('click', () => {\n            if (tx.value.trim()) {\n                applyComment();\n            }\n            tx.value = '';\n            count.innerHTML = `${tx.value.length}/200字`\n        })\n    </script>\n</body>\n</html>\n\n```\n\n# 轮播图\n当然还是直接用插件方便[swiper](https://www.swiper.com.cn/)\n\n<div id=\"rotBox-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .rot-box {\n            max-width: 560px;\n            height: 400px;\n            overflow: hidden;\n            border-radius: 12px;\n            box-shadow: 0 3px 8px 6px rgba(7, 17, 27, 0.05);\n            margin: 10px;\n        }\n\n        .rot-img {\n            width: 100%;\n            height: 80%;\n            display: flex;\n            flex-direction: row;\n            flex-wrap: wrap;\n            justify-content: center;\n            position: relative;\n        }\n\n        .rot-img img {\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        }\n\n        .rot-footer {\n            height: 20%;\n            background-color: rgb(100, 67, 68);\n            padding: 12px 12px 0 12px;\n            position: relative;\n        }\n\n        .rot-toggle {\n            position: absolute;\n            right: 10px;\n            top: 15px;\n            display: flex;\n        }\n\n        .rot-toggle button {\n            margin-right: 12px;\n            width: 28px;\n            height: 28px;\n            appearance: none;\n            border: none;\n            background: rgba(255, 255, 255, 0.1);\n            color: #fff;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .rot-toggle button:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n\n        .rot-title {\n            margin: 0;\n            color: #fff;\n            font-size: 18px;\n            margin-bottom: 10px;\n            margin-left: 10px;\n        }\n\n        ul.rot-select {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n            display: flex;\n            align-items: center;\n            margin-left: 10px;\n            height: 12px;\n        }\n\n        ul.rot-select li {\n            width: 8px;\n            height: 8px;\n            margin: 4px;\n            border-radius: 50%;\n            background: #fff;\n            opacity: 0.4;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        ul.rot-select li.active {\n            width: 12px;\n            height: 12px;\n            opacity: 1;\n        }\n        @media screen and (max-width:500px) {\n            .rot-box {\n                height: 320px;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"rot-box\">\n        <div class=\"rot-img\">\n            <img src=\"https://cdn.chuckle.top/images/41-1.webp\">\n        </div>\n        <div class=\"rot-footer\">\n            <div class=\"rot-title\">标题零</div>\n            <ul class=\"rot-select\">\n                <li class=\"active\"></li>\n            </ul>\n            <div class=\"rot-toggle\">\n                <button class=\"rot-prev\">&lt;</button>\n                <button class=\"rot-next\">&gt;</button>\n            </div>\n        </div>\n    </div>\n    <script>\n        const rotDate = [\n            {\n                url: 'https://cdn.chuckle.top/images/43-1.webp',\n                title: '标题一'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/42-1.webp',\n                title: '标题二'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/41-1.webp',\n                title: '标题三'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/38-1.webp',\n                title: '标题四'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/39-1.webp',\n                title: '标题五'\n            },\n        ];\n        //生成[0,arr长度)的随机整数\n        function getRandom(arr) {\n            return parseInt(Math.random() * arr.length);\n        }\n        const rotSelect = document.querySelector('.rot-select');\n        // 数组中有多少对象加几个li\n        rotSelect.innerHTML = '';// 先清空ul的内容\n        for (let i = 0; i < rotDate.length; i++) {\n            rotSelect.innerHTML += '<li></li>';\n        }\n        //让第一个li变成小白点\n        document.querySelector('.rot-select li:first-child').classList.toggle('active');\n        // 一开始随机选一张\n        // 获取要操作的元素\n        const img = document.querySelector('.rot-img img');\n        const title = document.querySelector('.rot-title');\n        const rot_li = document.querySelectorAll('.rot-select li');\n        // 数据数组长度\n        const dateLength = rotDate.length;\n        // 轮播展示序号，默认第一个\n        var num = 0;\n        // 轮播的对象,默认第一个\n        var rot = rotDate[num];\n        // 修改轮播容器的内容\n        function applyDate() {\n            //换标题和图片\n            rot = rotDate[num];\n            img.src = rot.url;\n            title.innerHTML = rot.title;\n            //移除之前的小白点，给当前li添加小白点\n            if (document.querySelector('.rot-select .active')) {\n                document.querySelector('.rot-select .active').classList.remove('active');\n            }\n            rot_li[num].classList.toggle('active');\n        }\n        // 随机展示一个\n        function ranDate(){\n            var random = getRandom(rotDate);\n            rot = rotDate[random];\n            num = random;\n            applyDate();\n        }\n        // 上一张\n        function prevDate() {\n            num > 0 ? --num : num = dateLength - 1;\n            applyDate();\n        }\n        // 下一张\n        function nextDate() {\n            //控制下一张是哪个\n            num = ++num % dateLength;\n            applyDate();\n        }\n        //获取两个按钮\n        const rotPrev = document.querySelector('.rot-prev');\n        const rotNext = document.querySelector('.rot-next');\n        //注册事件\n        rotPrev.addEventListener('click', () => {\n            prevDate();\n        })\n        rotNext.addEventListener('click', () => {\n            nextDate();\n        })\n        // 点击小圆点切换展示\n        rot_li.forEach((item, index, arr) => {\n            item.addEventListener('click', () => {\n                //让轮播展示序号变为当前点击的li的序号\n                num = index;\n                applyDate();\n            });\n        });\n        // 鼠标悬停停止轮播\n        const rotBox = document.querySelector('.rot-box');\n        rotBox.addEventListener('mouseenter',()=>{\n            clearInterval(itv);\n            console.log('暂停轮播');\n        });\n        // 鼠标移出恢复轮播\n        rotBox.addEventListener('mouseleave',()=>{\n            //未确保不重复定时，先清除一次\n            clearInterval(itv);\n            itv = setInterval(nextDate, 1000);\n            console.log('恢复轮播');\n        });\n        // 一开始随机展示一个，注释掉则默认展示第一个\n        //ranDate();\n        // 定时器轮播\n        var itv = setInterval(nextDate, 1000);\n        \n    </script>\n</body>\n</html>\n\n```\n\n# tab切换\n**1、for循环注册鼠标悬停版：**\n\n<div id=\"tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            padding: 2px 15px 0;\n            font-size: 18px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n            border-bottom: 1px solid #333;\n            margin-bottom: -1px;\n        }\n        .tab-nav ul li.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 30px;\n            display: block;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n        .tab-item{\n            display: none;\n        }\n        .tab-item.active{\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li class=\"active\"><a href=\"javascript:;\">栏1</a></li>\n                <li><a href=\"javascript:;\">栏2</a></li>\n                <li><a href=\"javascript:;\">栏3</a></li>\n                <li><a href=\"javascript:;\">栏4</a></li>\n                <li><a href=\"javascript:;\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelectorAll('.tab-nav ul li');\n        const tabItem = document.querySelectorAll('.tab-item');\n        tabNav.forEach((item,index)=>{\n            item.addEventListener('mouseenter',()=>{\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                item.classList.add('active');\n                tabItem[index].classList.add('active');\n            });\n        });\n    </script>\n</body>\n<div id=\"tab-sandbox\"></div>\n</html>\n\n```\n\n**2、事件委托鼠标点击版：**\n\n<div id=\"tab2-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            font-size: 18px;\n            border-bottom: 1px solid transparent;\n            margin-bottom: -1px;\n        }\n\n        .tab-nav ul li a.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 33px;\n            display: block;\n            padding: 2px 15px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n\n        .tab-item {\n            display: none;\n        }\n\n        .tab-item.active {\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li><a href=\"javascript:;\" data-id=\"0\" class=\"active\">栏1</a></li>\n                <li><a href=\"javascript:;\" data-id=\"1\">栏2</a></li>\n                <li><a href=\"javascript:;\" data-id=\"2\">栏3</a></li>\n                <li><a href=\"javascript:;\" data-id=\"3\">栏4</a></li>\n                <li><a href=\"javascript:;\" data-id=\"4\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelector('.tab-nav ul');\n        const tabItem = document.querySelectorAll('.tab-item');\n        //利用事件委托减少注册\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                e.target.classList.add('active');\n                tabItem[e.target.dataset.id].classList.add('active')\n            }\n        });\n    </script>\n</body>\n\n</html>\n\n```\n\n# 表单全选反选\n\n<div id=\"input-check-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        table {\n            border-collapse: collapse;\n            border-spacing: 0;\n            border: 1px solid #c0c0c0;\n            width: 500px;\n            text-align: center;\n        }\n\n        th {\n            background-color: rgb(40, 170, 220);\n            font: bold 16px;\n            color: #fff;\n            height: 22px;\n        }\n        td {\n            border: 1px solid #d0d0d0;\n            color: #363636;\n            padding: 6px 10px;\n            background: #f9f9f9;\n        }\n        tr td:not(:first-child){\n            min-width: 50px;\n        }\n        tr th:first-child{\n            width: 70px;\n        }\n    </style>\n</head>\n\n<body>\n    <table>\n        <tr>\n            <th>\n                <input type=\"checkbox\" id=\"check-all\">\n                <span>全选</span>\n            </th>\n            <th>书名</th>\n            <th>作者</th>\n            <th>价格</th>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>毛泽东选集</td>\n            <td>毛泽东</td>\n            <td>56</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>资本论</td>\n            <td>马克思</td>\n            <td>129</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>三体</td>\n            <td>刘慈欣</td>\n            <td>46</td>\n        </tr>\n    </table>\n    <script>\n        const checkAll = document.querySelector('#check-all');\n        const checks = document.querySelectorAll('.check-one');\n        checkAll.addEventListener('click',()=>{\n            checks.forEach((item)=>{\n                item.checked = checkAll.checked;\n            });\n        });\n        checks.forEach((item)=>{\n            item.addEventListener('click',()=>{\n                checkAll.checked = document.querySelectorAll('.check-one:checked').length === checks.length;\n            })\n        })\n    </script>\n</body>\n\n</html>\n\n```\n\n# 导航栏、电梯导航、哔哩tab\n\n<div id=\"nav-bl-tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            padding-bottom: 500px;\n        }\n\n        .tab-box {\n            width: 500px;\n            height: auto;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            display: flex;\n            list-style: none;\n            border-bottom: 1px solid #333;\n            background: rgb(233, 233, 233);\n            height: 40px;\n            flex-direction: row;\n            flex-wrap: nowrap;\n            justify-content: center;\n            align-items: center;\n            position: relative;\n        }\n\n        .tab-nav a {\n            margin: 5px;\n            padding: 0 10px;\n            text-decoration: none;\n            color: #000;\n            height: 40px;\n            line-height: 40px;\n        }\n\n        .tab-nav a.active {\n            color: rgb(23, 180, 215);\n        }\n\n        .tab-bar {\n            position: absolute;\n            width: 40px;\n            height: 3px;\n            background: rgb(23, 180, 215);\n            bottom: -1px;\n            transition: all 0.3s;\n        }\n\n        .item-box {\n            background: rgb(220, 220, 220);\n        }\n\n        .item {\n            text-align: center;\n            padding: 10px;\n            display: none;\n        }\n\n        .item.active {\n            display: block;\n            height: 100px;\n        }\n\n        /* 导航栏 */\n        #nav {\n            width: 100%;\n            height: 50px;\n            text-align: center;\n            line-height: 50px;\n            background: rgba(120, 182, 191, 0.5);\n            font-size: 20px;\n            position: fixed;\n            top: -50px;\n            transition: all 0.3s;\n            z-index: 9999;\n        }\n\n        .box {\n            margin-top: 10px;\n            width: 200px;\n            height: 200px;\n            background: rgb(144, 193, 230);\n            margin-bottom: 200px;\n            border-radius: 6px;\n        }\n\n        /* 电梯导航 */\n        .ele-nav {\n            position: fixed;\n            bottom: 20%;\n            background: rgb(233, 233, 233);\n            right: 10%;\n            border: 1px solid #333;\n            border-bottom: 0;\n            border-radius: 6px;\n            overflow: hidden;\n            transition: all 0.3s;\n            opacity: 0;\n            z-index: -99;\n        }\n        .ele-item.active{\n            color: rgb(23, 180, 215);\n            background: rgb(252, 200, 200);\n        }\n        .ele-item,\n        .back-top {\n            padding: 10px;\n            border-bottom: 1px solid #333;\n            user-select: none;\n            transition: all 0.3s;\n        }\n        .ele-item:hover,\n        .back-top:hover{\n            color: rgb(23, 180, 215);\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"nav\">导航栏</div>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <a href=\"javascript:;\" class=\"active\">栏1</a>\n            <a href=\"javascript:;\">栏2</a>\n            <a href=\"javascript:;\">栏3</a>\n            <a href=\"javascript:;\">栏4</a>\n            <a href=\"javascript:;\">栏114514</a>\n            <div class=\"tab-bar\"></div>\n        </div>\n\n        <div class=\"item-box\">\n            <div class=\"item active\">项目一</div>\n            <div class=\"item\">项目二</div>\n            <div class=\"item\">项目三</div>\n            <div class=\"item\">项目四</div>\n            <div class=\"item\">项目114514</div>\n        </div>\n    </div>\n    <div class=\"ele-nav\">\n        <div class=\"ele-item\">去第一个</div>\n        <div class=\"ele-item\">去第二个</div>\n        <div class=\"ele-item\">去第三个</div>\n        <div class=\"ele-item\">去第四个</div>\n        <div class=\"back-top\">回到顶部</div>\n    </div>\n    <div class=\"box\">第一个盒子,滚动到此(往上55像素)显示导航栏和电梯导航</div>\n    <div class=\"box\">第二个盒子</div>\n    <div class=\"box\">第三个盒子</div>\n    <div class=\"box\">第四个盒子</div>\n    <script>\n        //网页导航栏,还有电梯导航的显示和隐藏\n        const nav = document.querySelector('#nav');\n        const box = document.querySelectorAll('.box');\n        const ele_nav = document.querySelector('.ele-nav');\n        window.addEventListener('scroll', () => {\n            let n = window.scrollY;\n            let m = box[0].offsetTop;\n            let tf = n >= m-55;//减去55像素，不让电梯导航点击去第一个后消失\n            nav.style.top = tf ? '0px' : '-50px';\n            ele_nav.style.opacity = tf ? '1' : '0';\n            ele_nav.style.zIndex = tf ? '99' : '-99';\n        });\n        //bilibili导航\n        const bar = document.querySelector('.tab-bar');\n        const tabNav = document.querySelector('.tab-nav');\n        const tab_a = document.querySelectorAll('.tab-nav a');\n        const item = document.querySelectorAll('.item-box .item');\n        //给每个a依次添加data-id\n        tab_a.forEach((item, index) => {\n            item.dataset.id = index;\n        });\n        //将a的点击事件委托给tab-nav\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                //tab导航切换\n                document.querySelector('.tab-nav a.active').classList.remove('active');\n                document.querySelector('.item.active').classList.remove('active');\n                e.target.classList.add('active');\n                item[e.target.dataset.id].classList.add('active');\n                //bar移动和动态改变宽度\n                bar.style.width = `${e.target.offsetWidth}px`;\n                bar.style.left = `${e.target.offsetLeft}px`;\n            }\n        });\n        tab_a[0].click();//先初始化一次bar的位置\n        //电梯导航\n        //给每个电梯导航依次添加data-name\n        document.querySelectorAll('.ele-item').forEach((item, index) => {\n            item.dataset.name = `b${index+1}`;\n        });\n        //给每个box依次添加电梯导航对应的自定义属性的class\n        box.forEach((item, index) => {\n            item.classList.add(`b${index+1}`);\n        });\n        //移除ele的active\n        function reactive(){\n            let ele_active = document.querySelector('.ele-item.active');\n            if(ele_active){\n                //如果有，先清除\n                ele_active.classList.remove('active');\n            }\n        }\n        //去指定盒子,事件委托\n        ele_nav.addEventListener('click', (e) => {\n            let cname = e.target.className;\n            if (cname === 'ele-item'||cname === 'ele-item active') {\n                reactive();\n                //给点击的item添加active\n                e.target.classList.add('active');\n                //去对应的盒子\n                //通过自定义属性获取对应的盒子class名\n                let box = document.querySelector(`.${e.target.dataset.name}`);\n                // 其实监听滚动后，没必要再手动去给active，但想点击后导航立刻变色的话，可以取消下面的注释\n                // //先立刻移除页面滚动监听\n                // window.removeEventListener('scroll', scroll_light_ele);\n                // //一秒后重新监听\n                // setTimeout(() => {\n                //     //防止重复注册，先移除页面滚动监听\n                //     window.removeEventListener('scroll', scroll_light_ele);\n                //     window.addEventListener('scroll', scroll_light_ele);\n                // }, 800);\n                //更新当前页面在哪个盒子的范围位置\n                box_num = e.target.dataset.name.replace(/[^\\d]/g, \" \");\n                //滚动到指定位置\n                window.scrollTo({\n                    top: box.offsetTop - 50,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n            }\n            //点击返回顶部\n            if (cname === 'back-top') {\n                reactive();\n                window.scrollTo({\n                    top: 0,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n                box_num = -1;\n            }\n        });\n        //获取盒子的高度数组减去55px\n        const box_top_arr = Array.from(box).map((item)=>{\n            return item.offsetTop-55;\n        })\n        var box_num = -1;//记录当前在哪个盒子范围内\n        //页面滚动到对应box让电梯导航对应导航高亮\n        function scroll_light_ele(){\n            let n = window.scrollY;\n            let num = box_top_arr.reduce((prev, item, index)=>{\n                return n >= item ? index : prev;\n            },-1);\n            if(num === box_num){\n                //说明还在这个盒子范围内，直接返回\n                return;\n            }else{\n                //更新位置\n                box_num = num;\n            }\n            if(num > -1){\n                reactive();\n                document.querySelector(`[data-name=\"b${num+1}\"]`).classList.add('active');\n            }else{\n                box_num = -1;\n            }\n        }\n        window.addEventListener('scroll', scroll_light_ele);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 倒计时\n\n<div id=\"time-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        .time-box {\n            padding: 20px 15px;\n            background: rgb(30, 171, 210);\n            width: fit-content;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n            font-size: 18px;\n        }\n\n        .time-now {\n            width: 100%;\n            text-align: center;\n        }\n\n        .time-title {\n            font-size: 26px;\n            text-align: center;\n            width: 100%;\n            margin: 6px 0;\n        }\n\n        .clock {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            margin: 10px 0;\n        }\n        .hour,.minutes,.second{\n            font-size: 20px;\n            margin: 2px;\n            padding: 2px 3px;\n            border-radius: 4px;\n            background: rgba(36, 36, 36, 0.65);\n            color: #fff;\n        }\n        .colon{\n            font-size: 20px;\n            font-weight: bolder;\n            padding: 2px;\n        }\n        .target{\n            width: 100%;\n            text-align: center;\n            margin: 6px 0 0;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"time-box\">\n        <div class=\"time-now\">今天是1970年1月1日</div>\n        <div class=\"time-title\">倒计时</div>\n        <div class=\"clock\">\n            <div class=\"hour\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"minutes\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"second\">00</div>\n        </div>\n        <div class=\"target\">目标时间00:00:00</div>\n    </div>\n\n    <script>\n        const hour = document.querySelector('.hour');\n        const minutes = document.querySelector('.minutes');\n        const second = document.querySelector('.second');\n        const time_now = document.querySelector('.time-now');\n        const target = document.querySelector('.target');\n        const now = new Date();\n        const time = '18:00:00';\n        const targetTime = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()} 18:00:00`;\n        const last = new Date(targetTime);\n        let count = (last.getTime() - now.getTime()) / 1000;\n        function countDown() {\n            let h = parseInt(count / 60 / 60 % 24);\n            h = h < 10 ? '0' + h : h;\n            let m = parseInt(count / 60 % 60);\n            m = m < 10 ? '0' + m : m;\n            let s = parseInt(count % 60);\n            s = s < 10 ? '0' + s : s;\n            hour.innerHTML = h;\n            minutes.innerHTML = m;\n            second.innerHTML = s;\n            count--;\n            if (count == 0) {\n                count = 0;\n            }\n        }\n        time_now.innerHTML = `今天是${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日`;\n        target.innerHTML = `目标时间${time}`\n        countDown();\n        setInterval(countDown, 1000);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 学生信息表\n<a href=\"/dom/stu-info.html\" target=\"_blank\">学生信息表</a>\n\n本地存储，数据驱动，刷新不丢失\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        a {\n            text-decoration: none;\n            color: rgb(226, 14, 14);\n        }\n\n        .info-box {\n            width: 800px;\n            margin: 0 auto;\n            position: relative;\n        }\n\n        h1 {\n            text-align: center;\n            margin: 20px;\n            user-select: none;\n        }\n\n        .info {\n            width: 100%;\n            text-align: center;\n            margin: 40px 0;\n        }\n\n        .ipt-name {\n            width: fit-content;\n            display: inline-block;\n            line-height: 25px;\n            font-size: 16px;\n        }\n\n        .info input,\n        .info select {\n            width: 70px;\n            outline: none;\n            border-radius: 5px;\n            border: 1px solid #b8daff;\n            height: 25px;\n            padding: 0 5px;\n            margin: 0 15px 0 2px;\n        }\n\n        input.sname {\n            width: 80px;\n        }\n\n        input.age {\n            width: 40px;\n        }\n\n        .info button {\n            width: 60px;\n            height: 25px;\n            border-radius: 5px;\n            cursor: pointer;\n            background: rgb(82, 191, 231);\n            outline: none;\n            border: 1px solid rgb(98, 98, 98);\n            color: #fff;\n            font-size: 15px;\n        }\n\n        table {\n            margin: 0 auto;\n            width: 100%;\n            padding: 0 20px;\n            color: #363636;\n            border-collapse: collapse;\n            border-spacing: 0;\n        }\n\n        th {\n            padding: 5px 10px;\n            background: #cfe5ff;\n            font-size: 20px;\n            font-weight: 400;\n        }\n\n        td,\n        th {\n            border: 1px solid #b8daff;\n        }\n\n        td {\n            padding: 5px 10px;\n            text-align: center;\n            font-size: 16px;\n        }\n\n        tbody tr {\n            background: #fff;\n        }\n\n        tbody tr:hover {\n            background: #e1ecf8;\n        }\n        .info-num{\n            right: 10px;\n            width: fit-content;\n            position: absolute;\n            margin-top: -20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"info-box\">\n        <h1>新增学生信息</h1>\n        <form class=\"info\" autocomplete=\"off\">\n            <div class=\"ipt-name\">姓名</div>\n            <input type=\"text\" class=\"sname\" name=\"sname\">\n            <div class=\"ipt-name\">年龄</div>\n            <input type=\"text\" class=\"age\" name=\"age\">\n            <div class=\"ipt-name\">性别</div>\n            <select class=\"gender\" name=\"gender\">\n                <option value=\"男\">男</option>\n                <option value=\"女\">女</option>\n            </select>\n            <div class=\"ipt-name\">年级</div>\n            <select class=\"grade\" name=\"grade\">\n                <option value=\"大一\">大一</option>\n                <option value=\"大二\">大二</option>\n                <option value=\"大三\">大三</option>\n                <option value=\"大四\">大四</option>\n            </select>\n            <div class=\"ipt-name\">专业</div>\n            <select class=\"major\" name=\"major\">\n                <option value=\"计科\">计科</option>\n                <option value=\"机械\">机械</option>\n                <option value=\"会计\">会计</option>\n            </select>\n            <button class=\"add-info\">录入</button>\n        </form>\n        <h1>学生信息</h1>\n        <div class=\"info-num\">共有0条数据</div>\n        <table>\n            <thead>\n                <tr>\n                    <th>序号</th>\n                    <th>姓名</th>\n                    <th>年龄</th>\n                    <th>性别</th>\n                    <th>年级</th>\n                    <th>专业</th>\n                    <th>操作</th>\n                </tr>\n            </thead>\n            <tbody></tbody>\n        </table>\n    </div>\n    <script>\n        var arr = [\n            {\n                name: '张三',\n                age: 19,\n                gender: '男',\n                grade: '大一',\n                major: '计科'\n            },\n            {\n                name: '李四',\n                age: 18,\n                gender: '男',\n                grade: '大二',\n                major: '机械'\n            },\n            {\n                name: '李丽',\n                age: 18,\n                gender: '女',\n                grade: '大三',\n                major: '会计'\n            }\n        ];\n        const info = document.querySelector('.info');\n        const items = document.querySelectorAll('.info [name]');\n        const tbody = document.querySelector('tbody');\n        const infoNum = document.querySelector('.info-num');\n        info.addEventListener('submit', (e) => {\n            e.preventDefault();\n            let i = Array.from(items).reduce((prev, item) => {\n                return item.value === '' ? prev : prev += 1;\n            }, 0);\n            console.log(i);\n            if (i != items.length) {\n                return alert('输入内容不能为空');\n            }\n            let obj = {\n                name: info.children[1].value,\n                age: info.children[3].value,\n                gender: info.children[5].value,\n                grade: info.children[7].value,\n                major: info.children[9].value\n            }\n            console.log(obj);\n            //更新数据\n            arr.push(obj);\n            //重置表单\n            info.reset();\n            //信息本地存储\n            localStorage.setItem('info', JSON.stringify(arr));\n            //调用渲染函数\n            render();\n        });\n        function render() {\n            tbody.innerHTML = '';\n            let trArr = arr.map((item, index) => {\n                return `<tr>\n                    <td>${index + 1}</td>\n                    <td>${item.name}</td>\n                    <td>${item.age}</td>\n                    <td>${item.gender}</td>\n                    <td>${item.grade}</td>\n                    <td>${item.major}</td>\n                    <td><a href=\"javascript:\">删除</a></td>\n                </tr>`\n            });\n            tbody.innerHTML = trArr.join('');\n            infoNum.innerHTML = `共有${arr.length}条数据`;\n        }\n        //删除，事件委托\n        tbody.addEventListener('click', (e) => {\n            let target = e.target;\n            if (target.tagName === 'A') {\n                let num = e.target.parentNode.parentNode.firstElementChild.innerHTML\n                //拿到序号，删除一个\n                let tf = confirm(`确认删除第 ${num} 个学生信息吗？`);\n                if (tf) {\n                    arr.splice(num - 1, 1);\n                    localStorage.setItem('info', JSON.stringify(arr));\n                    render();\n                }\n            }\n        });\n        function infoInit() {\n            //先获取本地数据\n            let info = JSON.parse(localStorage.getItem('info'));\n            if (info) {\n                arr = info;\n            }\n            render();\n        }\n        //初始化\n        infoInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 注册界面\n\n<a href=\"/dom/reg.html\" target=\"_blank\">注册界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .reg-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .reg-box .reg-title {\n            width: 100%;\n            text-align: center;\n            margin: 15px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .reg-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .reg-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .reg-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"reg-box\">\n        <div class=\"reg-title\">新用户注册</div>\n        <form class=\"reg-form\">\n            <div class=\"form-item\">\n                <input name=\"uname\" type=\"text\" placeholder=\"设置用户名\" maxlength=\"12\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <div class=\"code-box\">\n                    <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\">\n                    <div class=\"msg\"></div>\n                    <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                </div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"password\" type=\"password\" placeholder=\"输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item\">\n                <input class=\"password-again\" type=\"password\" placeholder=\"再次输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n            <button class=\"reg-submit\">提交</button>\n        </form>\n    </div>\n\n    <script>\n        const code = document.querySelector('.code-box .code');\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', () => {\n                if (code_flag) {\n                    //存入点击发送验证码时的时间戳\n                    localStorage.setItem('code_time', new Date().getTime());\n                    code_flag = false;//可以点击\n                    code_limit_time();\n                    //这里就可以去做请求短信接口\n                }\n            });\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //输入框验证函数\n        function input_verification(input, rex, msg) {\n            let div = input.nextElementSibling;\n            if (rex.test(input.value)) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = msg;\n                return false;\n            }\n        }\n\n        // 输入框内容检查\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        const code_input = document.querySelector('.form-item input[name=\"code\"]');\n        const password = document.querySelector('.form-item input[name=\"password\"]');\n        const password_again = document.querySelector('input.password-again');\n        const agree = document.querySelector('.agree-check .agree');\n        //用户名验证\n        function inspect_uname() {\n            return input_verification(uname, /^\\w{4,12}$/g, \"4到12位用户名，只能包含数字、字母、下划线\") ? true : false;\n        }\n        //手机号验证\n        function inspect_phone() {\n            return input_verification(phone, /^1[3-9][0-9]{9}$/g, \"11位手机号\") ? true : false;\n        }\n        //检查验证码是否是6位数字\n        function inspect_code() {\n            return input_verification(code_input, /^\\d{6}$/g, \"6位数字验证码\") ? true : false;\n        }\n        //密码验证，开头必须是字母，6到20位\n        function inspect_password() {\n            return input_verification(password, /^(?=.*[a-z])(?=.*\\d)[a-z\\d]{6,20}$/gi, \"6到20位密码，必须包含数字和字母\") ? true : false;\n        }\n        //验证两次密码输入是否相同\n        function inspect_password_again() {\n            let div = password_again.nextElementSibling;\n            if (password_again.value === password.value) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"两次密码不一致\";\n                return false;\n            }\n        }\n        // 检查协议是否同意\n        function inspect_agree() {\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        //监听各个输入框内容是否改变\n        uname.addEventListener('change', () => {\n            inspect_uname();\n        });\n        phone.addEventListener('change', () => {\n            inspect_phone();\n        });\n        code_input.addEventListener('change', () => {\n            inspect_code();\n        });\n        password.addEventListener('change', () => {\n            inspect_password();\n            if (password_again.value) {\n                inspect_password_again();\n            }\n        });\n        password_again.addEventListener('change', () => {\n            inspect_password_again();\n        });\n        //密码点击查看隐藏\n        const see_psw = document.querySelectorAll('.form-item .see')\n        see_psw.forEach((item, index) => {\n            item.addEventListener('click', () => {\n                let input = item.parentNode.firstElementChild;\n                if (input.type === \"password\") {\n                    item.innerHTML = \"隐藏\";\n                    input.type = \"text\";\n                } else {\n                    item.innerHTML = \"显示\";\n                    input.type = \"password\";\n                }\n            });\n        });\n        //点击提交表单\n        const btn_submit = document.querySelector('.reg-submit');\n        const reg_form = document.querySelector('.reg-form');\n        reg_form.addEventListener('submit', (e) => {\n            //提交前再次把所有输入框检查一遍\n            if (!inspect_uname()) { e.preventDefault(); }\n            if (!inspect_phone()) { e.preventDefault(); }\n            if (!inspect_code()) { e.preventDefault(); }\n            if (!inspect_password()) { e.preventDefault(); }\n            if (!inspect_password_again()) { e.preventDefault(); }\n            if (!inspect_agree()) { e.preventDefault(); }\n        })\n        //初始化函数\n        function regInit() {\n            codeInit();\n        }\n        //执行初始化\n        regInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 登陆界面\n\n<a href=\"/dom/login.html\" target=\"_blank\">登录界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .login-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .login-box .login-title {\n            width: 100%;\n            text-align: center;\n            margin: 12px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .login-tab {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            align-items: center;\n            user-select: none;\n        }\n\n        .login-tab-line {\n            width: 1px;\n            height: 20px;\n            background: rgb(30, 110, 140);\n        }\n\n        .login-tab-item {\n            margin: 0px 10px;\n            transition: all 0.2s;\n        }\n\n        .login-tab-item.active {\n            color: #4b98db;\n        }\n\n        .login-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .login-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .login-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n\n        .login-form {\n            display: none;\n        }\n\n        .login-form.active {\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"login-box\">\n        <div class=\"login-title\">登陆</div>\n        <div class=\"login-tab\">\n            <div class=\"login-tab-item active\" data-id=\"0\">密码登陆</div>\n            <div class=\"login-tab-line\"></div>\n            <div class=\"login-tab-item\" data-id=\"1\">短信登陆</div>\n        </div>\n        <div class=\"form-box\">\n            <form class=\"login-form active\">\n                <div class=\"form-item\">\n                    <input name=\"uname\" type=\"text\" placeholder=\"用户名 / 手机号\" maxlength=\"13\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <input name=\"password\" type=\"password\" placeholder=\"密码\" maxlength=\"20\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                    <div class=\"see\">显示</div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <form class=\"login-form\">\n                <div class=\"form-item\">\n                    <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <div class=\"code-box\">\n                        <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\" required>\n                        <div class=\"msg\"></div>\n                        <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                    </div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n        </div>\n    </div>\n\n\n    <script>\n        const login_tab = document.querySelector('.login-tab');\n        const login_form = document.querySelectorAll('.login-form');\n        const code = document.querySelector('.code-box .code');\n        const agree = document.querySelector('.agree-check .agree');\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        login_tab.addEventListener('click', (e) => {\n            let class_name = e.target.className;\n            if (class_name === 'login-tab-item') {\n                document.querySelector('.login-tab-item.active').classList.remove('active');\n                e.target.classList.add('active');\n                //切换登录方式清空input\n                document.querySelectorAll('.login-form.active input').forEach((item) => {\n                    item.value = '';\n                })\n                document.querySelector('.login-form.active').classList.remove('active');\n                login_form[e.target.dataset.id].classList.add('active');\n            }\n        });\n        //短信模块\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        function codeClick() {\n            if (code_flag) {\n                //存入点击发送验证码时的时间戳\n                localStorage.setItem('code_time', new Date().getTime());\n                code_flag = false;//可以点击\n                code_limit_time();\n                //这里就可以去做请求短信接口\n            }\n        }\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', codeClick);\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //密码点击查看隐藏\n        const see_psw = document.querySelector('.form-item .see')\n        see_psw.addEventListener('click', () => {\n            let input = see_psw.parentNode.firstElementChild;\n            if (input.type === \"password\") {\n                see_psw.innerHTML = \"隐藏\";\n                input.type = \"text\";\n            } else {\n                see_psw.innerHTML = \"显示\";\n                input.type = \"password\";\n            }\n        });\n        // 检查协议是否同意\n        function inspect_agree() {\n            console.log(11);\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        function subInit() {\n            login_form.forEach((item, index) => {\n                item.addEventListener('submit', (e) => {\n                    e.preventDefault();\n                    if (!inspect_agree()) {\n                        return;\n                    }\n                    //存储用户名或手机号\n                    localStorage.setItem('user', uname.value||phone.value);\n                    //这里作跳转\n                    // location.href = '/'\n                });\n            })\n        }\n        //初始化函数\n        function loginInit() {\n            codeInit();\n            subInit();\n        }\n        //执行初始化\n        loginInit();\n    </script>\n</body>\n</html>\n\n```\n\n\n\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/45.js\"></script>\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript笔记DOM操作","url":"/article/6c6d4353.html","content":"\n# DOM简介\nHTML是一种纯文本格式的文件，也就是文档，[HTML基础笔记](/article/1475187a.html)\n\n**DOM：**Document Object Model 文档对象模型，将 HTML 文档结构化表示\n\nDOM 让网页 HTML 中的元素以树的方式呈现，并提供了访问、操控 DOM 树中各个节点的API，是为了让 JS 操作 HTML 元素而制定的一个规范，如今可看作是 JS 的一部分\n\n每个载入浏览器的 HTML 文档都会成为 Document 对象，Document 对象是 Window 对象的一部分，可通过 window.document 或 document 对其进行访问\n\n```html 获取DOM对象\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div>一个div</div>\n    <script>\n      console.log(document);\n      console.log(window.document);\n    </script>\n</body>\n</html>\n\n```\n\n控制台输出：获取到了网页所有元素，整个html文档\n\n<img src=https://cdn.chuckle.top/images/44-2.webp width=\"70%\">\n\n**DOM树：**\n网页中的一切元素都是 DOM 树中的节点\n\n<img src=https://cdn.chuckle.top/images/44-3.webp width=\"80%\">\n\n**节点类型：**\n1. **文档节点：**文档本身，整个 document 文档\n2. **元素节点：**所有 HTML 标签元素，<head> <body> <div> <span>\n3. **属性节点：**所有标签元素内的属性，id、class、href、name\n4. **文本节点：**标签元素内的文本\n5. **注释节点：**HTML中的注释，<\\!-- 注释 --\\>\n\n# 获取DOM元素\n**获取dom节点对象的方法：**\n1. `getElementById('id名')` 根据id获取**第一个dom对象**（通常id唯一）\n2. `getElementsByClassName('class类名')` 根据class名获取**dom对象数组 NodeList**\n3. `getElementsByTagName('标签名')` 根据标签名获取**dom对象数组**\n4. `getElementsByName('name名')` 根据name属性值获取**dom对象数组**，一般不用\n5. `querySelector('CSS选择器')` 查找匹配指定CSS选择器的**第一个dom对象**\n6. `querySelectorAll('CSS选择器')` 查找匹配指定CSS选择器的所有元素，返回**dom对象数组**\n\n获取到的dom对象数组都是伪数组\n\nJS获取的都是对象，使用`console.dir()`能更直观地看一个对象。\n\n## 操作元素的内容\n获取到dom对象后，通过两个**属性**就能获取、修改元素中的内容\n1. `innerText` **不解析**标签\n2. `innerHTML` **解析**标签，通常用这个\n\n使用 += 保留元素中原有内容，并在元素中末尾添加新内容\n\n## 操作元素的属性\n获取到dom对象后，直接访问**属性**（如src、href、id、class）就能进行修改或赋值\n\n```html\n<img src=\"1.webp\" alt=\"一张图片\">\n<script>\n  const img = document.querySelector('img');\n  img.src = \"2.webp\"\n</script>\n```\n\n## 操控元素样式\n**1、通过 style 属性控制元素样式：**css带有 - 连接符的属性，在js中采用小驼峰命名法获取\n\n```html\n<div class=\"box\"></div>\n<script>\nconst box = document.querySelector('.box');\nbox.style.background = 'blue';\nbox.style.backgroundColor = 'green';//background-color\n</script>\n```\n\n**2、通过类名控制元素样式：**直接修改style属性过于麻烦，可以先把样式写给一个类，再将类名赋给 **className** 属性，+= 保留原有类名\n\n```html\n<style>\n  .box1{\n    width: 100px;\n    height: 100px;\n  }\n  .box2{\n    width: 200px;\n    background: rgb(88, 164, 192);\n  }\n</style>\n<div class=\"box1\"></div>\n<script>\n  const box = document.querySelector('.box1');\n  box.className += ' box2';\n</script>\n```\n\n使用 += 号来保留原有class还是不够规范\n\n可以使用 **classList** 属性来添加、删除、切换(有就删除，没有就加上)类名\n\n```js\n// 添加一个类名\n元素.classList.add('类名');\n// 删除一个类名\n元素.classList.remove('类名');\n// 切换一个类名\n元素.classList.toggle('类名');\n```\n\n## 操作表单元素\ninput 标签框内的文本存放在其value属性中，获取即可\n\n```js\nconst ipt = document.querySelector('input');\nconsole.log(ipt.value);\n```\n\n操作 input 的 type 属性，来控制输入框样式\n\n```js\nconst ipt = document.querySelector('input');\nipt.type = 'password';\n```\n\n一些布尔值的属性(赋任意值都代表true)，disabled、checked、selected，添加上就有效果\n\n```js\nconst ipt = document.querySelector('input');\nipt.checked = true;\n```\n\n## 自定义属性\n**标准属性：**标签自带的属性，class、id、title等\n\n**自定义属性：**H5的新东西,以 data- 开头，格式 **data-自定义后缀** ，`对象.dataset.自定义后缀` 获取\n\n```html\n<div class=\"box\" data-id=\"123456\"></div>\n<script>\n  const box = document.querySelector('.box');\n  console.log(box.dataset.id);//123456\n</script>\n```\n\n# 定时器\n**1、间歇函数** `setInterval()` 每隔一段时间自动执行一段代码\n\n```js\nsetInterval(()=>{\n  console.log(1);\n},1000);\nsetInterval(fun,1000);\n```\n\n清除间歇函数定时器 `clearInterval()` ：\n\n```js\nvar itv = setInterval(fun,1000);\nclearInterval(itv);\n```\n\n**2、延时函数** `setTimeout()` 延时一段时间后执行代码\n\n```js\nsetTimeout(()=>{\n  console.log(1);\n},1000);\n```\n\n清除延时函数定时器 `clearTimeout()`\n\n# 事件\n**DOM事件：**在文档或浏览器窗口中产生的一系列交互，如拖动元素、点击按钮、提交表单等。\n\nJavaScript 以**事件驱动**为核心，通过监听事件或给事件绑定JS，可以在事件发生时执行特定 JS 以完成交互。\n\n{% folding, 常见事件  %}\n这里都是事件名，属性名一般在事件名前加 on\n\n**鼠标事件：**\n1. **click** 鼠标左键/键盘回车\n2. **dbclick** 双击鼠标左键\n3. **mouseenter** 光标移入元素，不冒泡\n4. **mouseleave** 光标移出元素，不冒泡\n5. **mouseover** 光标移入元素，冒泡\n6. **mouseout** 光标移出元素，冒泡\n7. **mousedown** 按下任意鼠标键\n8. **mouseup** 释放任意鼠标键\n9.  **mousewheel** 鼠标滚轮滚动\n10. **mousemove** 光标在元素上移动\n\n**用户界面事件：**\n1. **load** 页面或资源加载完成\n2. **unload** 卸载完成\n3.  **error** JS出错或资源加载失败\n4.  **select** 选中文字\n5.  **resize** 调整窗口大小\n6.  **scroll** 包含滚动条的元素\n\n**焦点事件：**\n1.  **blur** 失去焦点，不冒泡\n2.  **focus** 获得焦点，不冒泡\n3.  **focusout** 失去焦点，冒泡\n4.  **focusin** 获得焦点，冒泡\n\n**键盘和输入事件：**\n1. **keydown** 按下键盘某个键\n2. **keyup** 释放键盘某个键\n3. **input** 当输入框文本改变时立即触发\n4. **change** 当输入框内容发生改变,失去焦点时触发\n5. **textInput** 文本输入\n\n**HTML5事件：**\n1. **contextmenu** 右键菜单\n2. **beforeunload** 页面卸载之前\n3. **DOMContentLoaded** DOM树构建完成\n4. **readystatechange** 加载状态变化\n5. **hashchange** URL散列值变化\n\n{% endfolding %}\n\n**事件的三要素：**事件源、事件、事件驱动程序\n\n**事件源：**触发事件的元素，获取事件源，即获取DOM节点\n**事件：**JS定义的各种事件\n**事件驱动程序：**触发事件后进行的操作\n\n## 事件监听\n使用 `addEventListener` 监听事件\n\n```js\n元素对象.addEventListener('事件类型', 执行的函数)\n```\n\n可以重复绑定。\n\n## 事件对象\n事件对象存放了事件触发时的相关信息，如鼠标点击的位置坐标、键盘按下了哪个键\n\n事件绑定的回调函数的第一个参数就是事件对象event、e\n\n```js\n元素.addEventListener('事件',(e)=>{\n  console.lig(e);\n});\n```\n\n**事件对象常见属性：**\n1. **type** 当前事件类型\n2. **clientX 、 clientY** 获取光标相对于浏览器可见窗口左上角的位置\n3. **offsetX 、 offsetY** 获取光标相对于当前DOM元素左上角的位置\n4. **key** 当前按下的键盘键的值\n\n```js 监听是否按下回车\nconst ipt = document.querySelector('input');\nipt.addEventListener('keyup', (e)=>{\n  if(e.key == 'Enter'){ console.log('回车'); };\n});\n```\n\n## 常用事件\n**1、焦点事件 focus blur** 见案例-搜索框下拉栏\n\n**2、键盘事件 keydown keyup input** 见案例-评论发布、字数统计\n\n**3、mouseover 与 mouseenter**\nmouseover/mouseout 有冒泡效果，mouseenter/mouseleave 没有冒泡效果\n\n使用mouseover，有冒泡效果，所以鼠标从监听的元素到其子元素，虽然子元素没用绑定鼠标进入事件，但该事件会冒泡到父元素的同名事件，所以也会触发进入\n\n通常用 mouseenter/mouseleave\n\n**4、加载事件 load、DOMContentLoaded**\n**load** 监听某个元素内的所有资源（dom、css、img）加载完毕\n\n```js\n//等待页面所有资源加载完毕，再执行回调函数\nwindow.addEventListener('load', ()=>{})\n//等待图片加载完毕\nimg.addEventListener('load', ()=>{})\n```\n\n**DOMContentLoaded** 监听HTML文档加载完毕该事件就被触发，不等待css等其它资源\n\n```js\ndocument.addEventListener('DOMContentLoaded', ()=>{})\n```\n\n**5、滚动事件 scroll**\n当某个元素的滚动条滚动时，触发该事件，不冒泡\n\n通常配合元素的 **scrollTop** 和 **scrollLeft** 两个属性，获取的是**数字型**，不带单位，但意思是像素px，可读写，可让js去控制滚动\n\n```js\n//整个页面卷去的高度，document.documentElement获取html标签\ndocument.documentElement.scrollTop\n//元素被卷去的高度\ndiv.scrollTop\n```\n\n这两个属性都用来获取被卷去的大小，即元素随着滚动超出可视窗口的大小（单位px）\n**scrollTop** 滚动条往下，元素向上移动，即获取该元素向上移动超出可视区域的高度\n**scrollLeft** 滚动条往右，元素向左移动，即获取该元素向左移动超出可视区域的宽度\n\n获取页面滚动高度的时候优先考虑使用 window.pageYOffset 然后在使用scrollTop\n\n```js\nvar _scrollLeft = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft\nvar _scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop\n```\n\n**一些小案例：**\n\n```js \nwindow.addEventListener('scroll', function () {\n    const n = document.documentElement.scrollTop\n    if (n >= 100) { // 页面滚动高度超过100px进行一些操作\n    } else { // 页面滚动高度小于100px进行恢复操作\n    }\n})\n```\n\n```js 回到顶部\nconst backTop = document.querySelector('#backTop')\nbackTop.addEventListener('click', function () {\n  // document.documentElement.scrollTop = 0\n  // window.scrollTo(x, y)\n  window.scrollTo(0, 0)\n})\n```\n\n**5、窗口尺寸变化事件 resize**\n浏览器窗口大小发生变化的时候触发的事件\n\n```js\nwindow.addEventListener('resize', ()=>{})\n```\n\n**6、移动端触摸事件 touchstart touchend touchmove**\n\n**touchstart** 手指触摸到元素时触发\n**touchend** 手指从元素离开时触发\n**touchmove** 手指在元素上滑动时触发\n\n\n## 事件流\n**事件流：**事件完整执行过程中的流动路径\n\n两个阶段：**捕获**阶段、**冒泡**阶段\n\n捕获阶段从父节点到子，冒泡阶段从子到父\n\n处理函数默认在冒泡阶段执行，从子节点到父节点，依次向上调用所有父级元素的**同名事件**。\n\n**让处理函数在捕获阶段触发：**冒泡阶段不再触发\n\n```js 传入第三个参数true\n元素.addEventListener(事件类型, 处理函数, true);\n```\n**阻止冒泡：**\n默认存在冒泡模式，子元素触发事件也会触发父级同名事件，阻止冒泡能把事件限制在当前元素内\n\n`stopPropagation()` **阻止事件流动**传播，不仅能阻止冒泡也能阻止捕获\n\n```js\n事件对象.stopPropagation();\n```\n\n## 解绑事件\n`removeEventListener()` 对某个元素解绑某个处理函数，匿名、箭头函数无法被解绑\n\n```js\n元素.removeEventListener(事件类型, 处理函数);\nbtn.removeEventListener('click', fn);\n```\n\n## 事件委托\n**事件委托：**一种技巧，减少事件注册次数，提高程序性能。\n\n事件冒泡可以用来实现事件委托，给父元素注册事件，当触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。\n\n**案例：**当多个子元素需要注册点击事件时，可以将点击事件注册到父元素上，再由父元素的事件对象e去找被点击的子元素，`e.target` 就能找到实际触发事件的子元素，再用其className、id、tagName 来确定业务上应该要触发事件的子元素。\n\n```js\nconst ul = document.querySelector('ul');\nul.addEventListener('click', function (e) {\n    if (e.target.tagName === 'LI') {\n        e.target.style.color = 'red'\n    }\n})\n```\n\n## 阻止元素默认行为\n使用 `e.preventDefault()` 阻止元素默认行为\n\n```js 让a标签点击不跳转链接\n//<a href=\"http://www.baidu.com\">百度一下</a>\nconst a = document.querySelector('a')\na.addEventListener('click', function (e) {\n    e.preventDefault()\n})\n```\n\n# 元素的属性、方法\n获取到元素后常用的属性和方法\n## 元素的尺寸与位置\n获取元素的宽高：**clientWidth**、**clientHeight**两个属性，不包含padding、border，**offsetWidth**、**offsetHeight**包含padding、border\n\n获取窗口的宽高：`document.documentElement.clientWidth`\n\n**offsetTop**、**offsetLeft**获取元素距离自己最近一位带有定位的祖先元素的左、上位置\n\n`getBoundingClientRect()` 获取元素的大小和相对于**可视窗口**的位置，返回一个对象里面有width、height、top等属性\n\n## 元素节点操作\n**1、关系查找元素节点**，以元素节点之间的关系进行查找，父找子、子找父、找兄弟\n\n查找最近一级的**父节点**：`子元素.parentNode`\n\n查找最近一级的所有**子节点**，返回伪数组：`父元素.children`\n`firstElementChild` 第一个子节点\n`lastElementChild` 最后一个子节点\n\n**上一个**兄弟节点：`previousElementSibling`\n**下一个**兄弟节点：`nextElementSibling`\n\n**2、创建节点**\n\n`document.createElement('标签名')`\n\n**3、增加节点：**\n\n`appendChild(插入的元素)` 在指定节点的子节点列表**末尾**添加新的子节点\n\n`insertBefore(插入的元素,[放到哪个元素的前面])` 在节点的子节点列表**任意位置前**插入新的节点，默认在子节点列表的**末尾**插入\n\n**4、克隆节点**\n\n`元素.cloneNode(布尔)` 参数为true，后代节点也会被克隆，false克隆时不包含后代节点(即只克隆标签)，默认false\n\n**5、删除节点**\n\n`父元素.removeChild(子元素)` 通过父节点删除子节点\n\n\n# BOM\n**BOM** (Browser Object Model ) 是浏览器对象模型，提供了一些属性与方法\n\n## window对象\nwindow对象是一个全局对象，是BOM的顶层对象，也是js中最顶级的对象，document、alert()、console、定时器等都是其属性和方法\n\n所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法\n\nwindow对象下的属性和方法调用的时候可以省略window\n\n## location对象\nlocation拆分并保存了URL地址的各个组成部分\n\n常见属性和方法\n1. **href** 获取完整的URL地址，也可以赋值进行地址跳转\n2. **search** 获取地址中携带的参数，?后面的部分\n3. **hash** 获取地址中的哈希值，#后面的部分\n4. `reload()` 刷新当前页面，传入参数true表示强制刷新\n\n## navigator对象\nnavigator保存了浏览器的相关信息\n\n常见属性和方法\n1. **userAgent** 获取浏览器的类型、版本\n\n## history对象\nhistory管理历史记录，如前进、后退、历史记录等\n\n常见属性和方法\n1. `back()` 浏览器后退功能\n2. `forward()` 浏览器前进功能\n3. `go()` 参数1前进一个页面，-1后腿一个页面\n\n## 本地存储\n将数据存储这浏览器中，刷新页面不丢失数据，sessionStorage 和 localStorage，现在主要用**localStorage**\n\n本地存储只能存字符串或数值型\n\nlocalStorage 以**键值对**的形式存储，可以多页面共享\nsessionStorage 以**键值对**的形式存储，生命周期为关闭浏览器就消失，数据同一个页面共享\n\n新增/修改：`setItem`\n\n```js\nlocalStorage.setItem(key, value);\n```\n\n读取：`getItem`\n\n```js\nlocalStorage.getItem(key);\n```\n\n删除：`removeItem`\n\n```js\nlocalStorage.removeItem(key);\n```\n\n**存储复杂数据类型：**存一个对象\n\n由于本地存储只能存字符串，所以需要将对象先转为JSON字符串再存储，使用时再把JSON转为对象\n\n`JSON.parse()` 将数据转换为 JavaScript 对象\n`JSON.stringify()` 将 JavaScript 对象转换为 JSON 字符串\n\n```js\nconst obj = {\n    name: 'chuckle',\n    age: '19'\n}\nlocalStorage.setItem('obj', JSON.stringify(obj));\nvar obj2 = JSON.parse(localStorage.getItem('obj'));\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(3)","url":"/article/7d8b8b34.html","content":"\n# JS函数简介\n\n使用**function**关键字定义函数对象，函数的typeof类型也是**function**\n\n```js\nfunction hello(){\n    console.log('hello');\n}\nconsole.log(typeof hello)//function\nconsole.log(fun instanceof Object)//true\n```\n\n使用**函数表达式**创建**匿名函数**，即将匿名函数赋值给一个变量\n\n```js\nvar fun = function(){\n\tconsole.log(\"匿名函数\");\n};\nfun();//匿名函数\n```\n\n函数是对象，也可以new出来，但一般不用这种形式，Function里面的**参数都必须是字符串格式**\n\n```js\nvar fun = new Function('a', 'b', 'console.log(a + b);');\nfun(1,2); // 3\n```\n\n使用**return**终止函数或返回一些数据，默认返回undefined\n\n**函数名**就是整个函数，JS加载的时候，只加载函数名，不加载函数体\n\n```js\nfunction fun(){\n    console.log(\"hello\");\n};\nconsole.log(fun);//输出fun(){console.log(\"hello\");}\nconsole.log(fun());//先执行函数，再输出返回值\n```\n\n## 函数的调用\n\n**1、**调用函数可以函数名调用，可以用**call()**方法\n\n```js\nfunction fun(){ console.log('hello'); }\nfun(); // hello\nfun.call(); // hello\n```\n\n**2、**在对象中保存多个函数，通过对象的方法来调用，函数作为**对象的属性**保存，这个函数就是**对象的方法**\n\n```js\nvar obj = {\n    fun1: function(){\n        console.log(\"函数一\");\n    },\n    fun2: function(){\n        console.log(\"函数二\");\n    }\n}\nobj.fun1();// 函数一\nobj.fun2();// 函数二\n\n```\n\n**3、立即执行函数**，在定义后立即执行\n\n```js\n(function() {\n\tconsole.log('立即执行函数');\n})();\n//立即执行函数\n```\n\n**4、**通过**构造函数**调用\n\n```js\nfunction Fun() {\n\tconsole.log(\"这是一个函数\");\n}\nnew Fun();// 这是一个函数\n```\n\n**5、绑定事件函数**，触发事件后立即执行的函数\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log('点击按钮后，要做的事情');\n};\n```\n\n**6、定时函数**\n\n```js\nsetInterval(function () {\n    console.log(\"hello\");\n}, 1000);//每1000ms执行一次\n```\n\n## 形参和实参\n**形参：**函数在定义时要求传入的一些参数\n**实参：**调用函数时传入的一些参数\n\n实参将**按顺序传递**给函数中对应的形参\n\n```js\nfunction fun(a, b){//该函数需要两个形参\n    console.log(a + b);\n};\n//调用时传入两个实参\nfun(1, 2)// 3\n```\n\n实参和形参，数量可以不同，调用函数时，解析器不会检查实参的数量。\n\n**实参多余形参：**忽略多余的实参\n**实参少余形参：**没有接收到值的形参默认为undefined，undefined参与运算为NaN\n\n```js\nfunction fun(a, b){ console.log(a + b); };\nfun(1, 2)// 3\nfun(1, 2, 3)// 3\nfun(1)// NaN\n```\n\n调用函数时，解析器也不会检查实参类型，实参可以是**任意数据类型**\n\n## 类数组对象arguments\n在调用函数时，浏览器每次都会传递进两个隐含的参数：（箭头函数没有自己的this和arguments。）\n1. 函数的上下文对象 **this**\n2. 封装实参的对象 **arguments**\n\narguments是一个类数组对象（伪数组），不是一个真正的数组，除了length属性、可以通过索引获取元素之外没有任何数组属性和方法。\n\n`Array.from()`能将伪数组转为真数组\n\n```js\nfunction fun(a, b){ \n    console.log(arguments);// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    console.log(Array.from(arguments));// [1, 2]\n    console.log(typeof arguments);// object，arguments 的原型是 Object，而数组的原型是 Array\n    return a + b;\n};\nfun(1, 2);\n```\n\n**案例：**将传入的实参进行求和，无论实参的个数有多少：\n\n```js\nfunction fun() {\n    var arr = Array.from(arguments);\n    var result = arr.reduce((prev, item) => {\n        return prev + item;// 累计求和\n    }, 0);\n    return result;\n}\nvar sum = fun(0, 1, 2, 3, 4, 5, 6);\nconsole.log(sum); // 21\n\n```\n\n**arguments.callee**返回正在执行的函数\n\n```js\nfunction fun() {\n    console.log(arguments.callee);\n}\nfun();// 返回了fun这个函数对象， fun() {console.log(arguments.callee);}\n```\n\n通过**arguments**修改传入的实参\n\n```js\nfunction fun(a, b){ \n    //修改传入的最后一个参数为0\n    arguments[arguments.length-1] = 0;\n    return a + b;\n};\nconsole.log(fun(1, 2));// 1\n```\n\n# 作用域\n变量或函数的作用范围。作用域在函数定义时，就确定。\n**全局作用域**：作用于整个script标签内，或作用于一个独立的JS文件\n**函数作用域**：作用于函数部\n**块级作用域**：ES6新增，作用于一个区块{}内\n\n在全局作用域中有一个全局对象 **window**(~~和微软没有半毛钱关系~~)，它代表的是浏览器的窗口，由浏览器创建。\n\n创建的**全局变量**都会作为 window 对象的**属性**保存。\n创建的**全局函数**都会作为 window 对象的**方法**保存。\n\n变量如果未经声明(没有var、let、const)就赋值，是**全局变量**\n\n```js\nvar a = 1;\n(function() {\n    var [a, b] = [0, 0];\n    console.log(a);// 0\n    console.log(window.a);// 1,访问全局变量a\n})();\nconsole.log(b);// 报错Uncaught ReferenceError:b is not defined\n```\n\n**连续赋值**时，除了第一个声明的变量之外，后面的变量都是全局变量\n\n```js\nfunction fun(){\n    var a = b = 1; // 连续赋值，a是函数作用域变量，b是全局变量\n}\nfun();\nconsole.log(a);// 报错Uncaught ReferenceError: a is not defined\nconsole.log(b);// 1\n```\n\n\n## 变量、函数提升\n\n**全局作用域的预处理：**JS在解析代码之前，将当前 JS 代码中所有变量的定义和函数的定义，放到所有代码的最前面，先进行声明但不进行赋值，默认都是undefined。\n\n任何变量，如果**未经声明**(没有var、let、const)就赋值，此变量是属于 window 的属性，而且**不会做变量提升**\n\n```js\nconsole.log(a);//undefined\nvar a = 1;\n\nconsole.log(b);//报错Uncaught ReferenceError:b is not defined\nb = 1;//赋值但没定义，相当于window.b，不进行变量提升\nconsole.log(b);//1\n```\n\n其它作用域也有类似的预处理，这就是**变量提升**，即将变量声明提升到它所在作用域的最开始的部分。\n\n**函数的声明提前（函数提升）：**\n使用**函数声明**的形式创建的函数**function fun(){}**，**会**被函数提升，可以提前调用函数，能正常执行。\n使用**函数表达式**创建的函数**var fun = function(){}**，**不会**被函数提升，但属于变量提升，不能提前调用，会被认为不是一个函数。\n\n函数的形参就相当于在函数作用域中声明了变量。\n\n```js\nconsole.log(fun1(1, 2));// 3，提前调用可以正常执行函数\nfunction fun1(a, b){ return a + b; }\n\nfun2();//报错Uncaught TypeError: fun2 is not a function\nvar fun2 = function(){}\n```\n\n**函数提升优先于变量提升**\n\n```js\nfun(); // 先函数提升，所以输出B\n\n// 函数提升\nfunction fun() {\n  console.log('B');\n}\n\nconsole.log(fun);// ƒ fun() {console.log('B');}\n\n// 变量提升，此时相当于重新声明fun变量\nvar fun = function () {\n  console.log('A');\n};\n\nfun(); // A\n\n```\n\n**函数的嵌套：**会出现**作用域链**，在嵌套函数中，变量会从内到外逐层寻找它的定义（查找时，采用就近原则）。\n\n```js\nvar a = 0;\n\nfunction fn() {\n    // 外部函数\n\n    fun();//函数提升，提前调用也正常执行\n    function fun() {\n        // 内部函数\n        console.log(a);//先找到var  a = 1\n        //输出undefined，因为实际代码中变量的调用在变量声明之前，属于变量提升，默认值为undefined\n    }\n\n    var  a = 1;\n    //fun()若内部函数在此执行，则会输出 1\n}\nfn();\n\n```\n\n# this指向\n[JavaScript的this原理--阮一峰](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)\n\n`this` 即‘当前’，指的是**函数运行时所在的环境**，它永远指向函数的真实调用者，如果没有调用者，就指向全局对象window。\n\n```js foo()绑定给多个对象\nvar a = -1;\nfunction foo(){\n    console.log(this.a);\n};\nvar obj1 = {\n    a:1,\n    foo:foo\n};\nvar obj2 = {\n    a:0,\n    foo:foo\n};\nobj1.foo();// 1\nobj2.foo();// 0\nfoo();// -1\nwindow.foo();// -1\n\n```\n\nthis在**函数调用时**绑定，函数执行时会创建一个活动记录，这个记录里包含了该函数中定义的参数，也包含函数在哪里被调用（调用栈）,this就是其中的一个属性。\n\n## 绑定规则\n1. **默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n2. **对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n3. **构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n4. **以事件绑定函数的形式调用时，this指向绑定事件的对象**\n5. **箭头函数中的this：**指向函数作用域所用的对象\n\n\n**1、默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\n\nfun();//输出 Window、0、1\nwindow.fun();//输出 Window、0、1\n//fun代码块中，this指的都是window，而a变量是全局变量，即是window的属性，所以this.a访问的是window.a\n```\n\n**2、对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;// 先把对象中的a值改为0\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun//将fun绑定给obj对象的fun属性，此时fun的this指向obj这个真实调用者\n}\nobj.fun();//输出 obj对象{a: 1, fun: ƒ}、0、1\n\n```\n\n**多层对象**时，内部方法this指向离被调用函数最近的对象\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj1 = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun,//将fun绑定给obj1对象的fun属性\n    obj2: {\n        a: 2,\n        fun: fun\n    }\n}\nobj1.fun();//输出 obj1对象{a: 0, obj2: {…}, fun: ƒ}、1，2\nobj1.obj2.fun();//输出 obj2对象{a: 0, fun: ƒ}、2，3\n\n```\n\n上面代码中，若obj2中没有a属性，this.a是undefined，即无论对象嵌套多少层，this只会指向**直接调用该函数**的对象（离被调用函数最近的对象）\n\n**this永远指向函数的真实调用者**\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 2;\n    this.foo = fun2;\n}\nfunction fun2() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: new fun().foo\n}\nobj.fun();// 1，多次引用的传递，实际上是obj调用了fun2\n\n```\n\n**隐式绑定的丢失:**通过赋值，导致隐式绑定的丢失。\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: fun\n}\nobj.fun();// 1\nvar foo = obj.fun;\nfoo();// 0\n\n```\n\n上面代码中，obj的fun属性引用了fun函数的引用内存地址，在obj.fun()调用函数时，fun函数中的this会动态绑定对象(当前函数的直接调用者，即obj对象)，将obj.fun的引用地址赋值给了foo那么foo也引用了fun函数的引用内存地址，使用foo()时，fun函数中的this也会动态绑定对象(当前函数的直接调用者，即window对象)。\n\n**3、构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n\n```js\nfunction Fun(name, age){\n    this.name = name;// 让构造函数创建的实例对象中的name属性等于传入的实参name\n    this.age = age;\n}\nvar fun = new Fun('chuckle', 19);\nconsole.log(fun);//Fun {name: 'chuckle', age: 19}\nconsole.log(typeof fun);// object构造函数返回创建的对象\n```\n\n**4、以事件绑定函数的形式调用时，this指向绑定事件的对象**\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log(this);//this指向带有btn id的整个标签\n    //<button id=\"btn\"></button>\n};\n\n```\n\n**5、箭头函数中的this：**指向函数作用域所用的对象\n\n**箭头函数的重要特征**：箭头函数**没有**自己的this和arguments，但它会继承自己**定义时**所处的**外层执行环境的this指向**，指向当前**定义时所在的对象**，call()、apply()、bind()等方法**无法改变**箭头函数继承的this指向。\n\n简单地说，箭头函数会找它的上一级作用域。如果父级作用域还是箭头函数，就再往上找，一层层找，直到找到this指向的对象\n\n```js\nvar obj = {\n    a: 1,\n    fun: ()=>{\n        console.log(this);\n    }\n}\n//obj是一个全局变量，fun是一个箭头函数，在定义时指向这个全局变量的作用域，即window对象\nobj.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n多层对象时，仍然指向最外部对象定义时所在的环境\n\n```js\nvar obj1 = {\n    a: 1,\n    obj2: {\n        a: 2,\n        fun: ()=>{\n            console.log(this);\n        }\n    }\n}\n//obj2是obj1的属性，obj是一个全局变量，所以定义时箭头函数this仍然指向window对象\nobj1.obj2.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n用构造函数创建对象，创建出来的对象中的箭头函数和普通函数，都指向构造函数创建出来的对象，但一个是在定义时指向obj对象，一个是在调用时指向obj对象\n\n```js\nfunction foo(){\n    console.log(this);\n}\nfunction Fun(){\n    this.fun = ()=>{\n        console.log(this);\n    };\n    this.foo = foo;\n}\nvar obj = new Fun();\nobj.fun();//Fun {fun: ƒ, foo: ƒ}\nobj.foo();//Fun {fun: ƒ, foo: ƒ}\nconsole.log(typeof obj);// object\n\n```\n\n**普通函数中的箭头函数：**\n\n箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量window。\n\n或者说，**普通函数中的箭头函数的this被绑定到该函数执行的作用域上**\n\n```js\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n        //对象内部方法的this指向调用此方法的对象\n\t\tvar b = this.birth;// 1990\n        //箭头函数的this就是这个外层的普通函数的this，所以在定义时就指向obj\n\t\tvar fn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\n\n```\n\n```js\nvar birth = 2000\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n\t\tfn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\nvar foo = obj.getAge;//发生隐式绑定的丢失，函数的作用域从obj对象变为全局window\nfoo();// 23，\n\n```\n\n## 改变this指向的方法\nJS在Function的porpertype属性上提供了3个方法来强行修改**函数内部**的this指向，不想改变this指向则**传入null或this**，这三个方法都**不会改变原函数的指向（动态的）**\n\n1. `call()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n2. `apply()`：传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n3. `bind()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**（一个改变了this指向和已经传入了参数的新函数）\n\n**1、`call()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n\n```js 语法\nfun.call(想要将this指向的对象, 函数实参1, 函数实参2);\n```\n\n通过call()调用函数，不改变指向\n\n```js\nvar a = 1;\nfunction fun() {\n    console.log(this);// window\n    console.log(this.a);\n}\n//将this的指向又传给this，指向没有被改变\nfun.call(this); // 1\nfun(); // 1\nfun.call(); // 1\nfun.call(window); // 1\nfun.call(null); // 1\n\n```\n\n通过call()改变this指向\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun() {\n    console.log(this);\n    console.log(this.a);\n}\nfun(); // window 1\nfun.call(obj); // obj 0\n\n```\n\n**2、`apply()`：**传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n\n```js 语法\nfun.apply(想要将this指向的对象, [函数实参1, 函数实参2]);\n```\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n};\n\nfunction fun(name) {\n    console.log(this);// 输出obj对象{name: 'chuckle', age: 19}\n    console.log(this.name);//chuckle\n    this.name = name;//改变obj的name属性为传入的实参\n    console.log(this.name);//qx\n}\n\nfun.apply(obj, ['qx']);//传一个实参，也需要传数组\nconsole.log(obj);//{name: 'qx', age: 19},name被改变\n\n```\n\n通过apply()求数组的最大值：\n\n数组本身没有求最大值的方法，但是数学对象中有**Math.max**(数字1，数字2...)，apply可以传入一个数组作为其参数，不改变其指向即可\n\n```js\nvar arr = [4, 2, 6, 5];\nvar maxValue = Math.max.apply(this, arr);// 不改变执行，传入一个数组作为参数\nconsole.log(maxValue);// 6\n```\n\n**3、`bind()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun(a) {\n    console.log(this.a + a);\n}\nvar result = fun.bind(obj, 10); //返回指定this和指定实参的原函数拷贝\nconsole.log(typeof result);// function\nresult(10);// 10\nresult(20);// 10\n\nvar result = fun.bind(obj);\nresult(10);// 10\nresult(20);// 20\n\n```\n\n# 内存回收机制\nJS具有内存自动回收机制，周期性的找出不再继续使用的变量，然后释放其占用的内存。\n\n在闭包中，如果引用了外部的变量，则无法进行释放和回收，造成**内存泄漏**\n\n**常见内存泄漏：**全局变量、闭包、Dom元素的引用、定时器\n\nIE回收不了闭包里面引用的变量，但2023年了，主流浏览器都能回收闭包内不再使用的变量，[js闭包测试--司徒正美](https://www.cnblogs.com/rubylouvre/p/3345294.html)\n\n```js\nfor(let i = 0; i < 5; i++) {\n//for循环中是块级作用域，每执行一次循环，j就会被自动回收，所以不会报错（const 不能重新赋值）\n  const j = '局部变量'\n  console.log(j);\n}\n```\n\n# 闭包\n如果**外部作用域**有权访问另外一个**函数内部的局部变量**时，那就产生了**闭包**。这个内部函数称之为**闭包函数**\n\n**函数**和**函数内部能访问到的变量**的总和，就是一个闭包。\n\n闭包是JS函数作用域的副产品，因为JS的函数内部可以使用函数外部的变量。\n\n**闭包的生命周期:**\n**产生：**内部函数被声明时就产生了。\n**死亡：**嵌套的内部函数成为垃圾对象时。（比如fun = null，就可以让 fun 成为垃圾对象）\n\n**闭包的作用：**将函数内部的变量(局部变量)能被外部访问，隐藏一些变量，延长局部变量的生命周期\n\n```js\nfunction fun1() {\n  let a = 10;\n  return function fun2() {\n    console.log(a);\n  };\n}\n//获取到一个能访问fun1内部的变量的函数\nvar result = fun1();\n//在fun1函数的外部，执行了内部函数fun2，并访问到了fun1的内部变量a\nresult();// 10\n\n```\n\n上面的代码中，通过一些操作，让外部作用域（即全局作用域）有权访问函数fun1中的局部变量，在fun1中就产生了闭包，函数fun1是闭包函数，闭包是fun2和fun2所能访问到的变量a。\n\n**延长局部变量的生命周期：**\n\n```js\n// fun1执行完一次，局部变量就立即销毁，下次调用a还是0;\nfunction fun1() {\n  let a = 0;\n  a++;\n  console.log(a);\n}\nfun1();// 1\nfun1();// 1\n\n// 由于产生了闭包，fun2函数还要继续调用变量a，所以fun1函数中的变量a不会立即销毁，仍然保留在内存中。\n// 只有等所有函数把变量a调用完了，变量a才会销毁。\nfunction fun1() {\n  let a = 0;\n  function fun2() {\n    a++;\n    console.log(a);\n  };\n  return fun2;\n}\nvar result = fun1();\nresult();// 1\nresult();// 2\n\n```\n\n**隐藏一些变量：**\n\n打游戏时通常有血条和蓝条，我们当然不希望用户window.blood就能修改血量。将血量变量blood放进匿名函数中，在函数内部去声明一些修改血量的代码再赋给全局变量，就能在匿名函数外部通过这些函数去修改血量，但不能直接访问血量。\n\n```js\n!function(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    window.reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    window.increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    window.checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n}();\n// 先连续扣血\nreduceBlood();// 血量还有9\nreduceBlood(5);// 血量还有4\n//再加血\nincreaseBlood();// 血量还有5\nincreaseBlood(5);// 血量还有10\n//查询血量\ncheckBlood(); // 血量还有10\n\n```\n\n**封装JS模块:**定义具有特定功能的JS模块，将所有的数据和功能都封装在一个函数内部，只向外暴露指定的对象或方法。模块的调用者，只能调用模块暴露的对象或方法来实现对应的功能\n\n如果不想将这三个函数直接赋给全局变量，也可以让函数返回一个装有三个方法的对象\n\n```js\nfunction Blood(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    const reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    const increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    const checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n    // 返回一个对象，包含三个方法\n    return {\n        reduceBlood: reduceBlood,\n        increaseBlood: increaseBlood,\n        checkBlood: checkBlood\n    }\n};\n\nvar figure1 = new Blood();\nvar figure2 = new Blood();\n\nfigure1.checkBlood(); // 血量还有10\nfigure2.checkBlood(); // 血量还有10\n\n//可以看到，figure1和figure2是独立的,两个闭包函数是互不影响\n//减少1的血量不会减少2，血量不会互相干扰\nfigure1.reduceBlood(5);// 血量还有5\nfigure2.reduceBlood();// 血量还有9\n\n// 人物死亡需要重新创建角色，记得回收闭包\n// figure1 = null;\n\n```\n\n# 面向对象概述\nJava中已经学习过了什么是面向对象,这里不再扯概念。\n\nJS是基于**原型**的面向对象，JS中的对象（Object）是依靠**构造器**（constructor）和**原型**（prototype）构造出来的\n\n在ES6中，新引入了**类**（Class）和**继承**（Extends）来实现面向对象\n\n**面向对象的编程思想：**对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口\n\n调用对象的属性：`obj.name`或`obj['name']`\n\n## 对象的创建\n**创建对象：**\n\n**1、对象字面量{}**\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    obj2: {\n        a: 1,\n        b: 2\n    },\n    foo: function(){\n        console.log(`我的名字${this.name}`);\n    }\n}\nobj.foo();// 我的名字chuckle\nconsole.log(obj.name);// chuckle\nconsole.log(obj['name']);// chuckle\n\n```\n\n**2、工厂模式 new Object()** 大量创建同种对象\n\n```js\nfunction createPerson(name, age) {\n    //创建一个新的对象\n    var obj = new Object();\n    //向对象中添加属性\n    obj.name = name;\n    obj.age = age;\n    return obj;// 返回这个对象的引用\n}\n\nvar obj1 = createPerson('chuckle', 19);// {name: 'chuckle', age: 19}\nvar obj2 = createPerson('qx', 18);// {name: 'qx', age: 18}\n// 所以创建的对象都是 Object 这个类型\nconsole.log(typeof obj1);// object\nconsole.log(typeof obj2);// object\n\n```\n\n**3、构造函数**\n\n```js\nfunction Person(name, age) {\n    //构造函数中this指的是当前对象实例\n    this.name = name;\n    this.age = age;\n    this.foo = function () {\n        console.log(this.name);\n    };\n}\n\nvar p1 = new Person('chuckle', 19);\nconsole.log(p1);// Person {name: 'chuckle', age: 19, foo: ƒ}\nconsole.log(typeof p1);// object\np1.foo();// chuckle\n\n```\n\n## 构造函数\n**构造函数：**是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。\n\n创建构造函数时，里面的属性和方法前必须加this，this就表示当前要构造的对象。\n\n普通函数是直接调用，而构造函数需要使用 new 关键字来调用。\n\n**构造函数的执行流程：**\n1. 立刻创建一个对象\n2. 将新建的对象设置为函数中this，使得在构造函数中可以使用this来引用新建的对象\n3. 遂行执行函数中的代码，给这个新对象添加属性和方法\n4. 将新建的对象作为返回值返回(构造函数中无需return)\n\n```js\n// 构造函数\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nvar stu = new Student('chuckle');// Student {name: 'chuckle'}\n\n//上面的代码相当于：\nfunction Student(name) {\n    var obj = new Object();\n    obj.name = name;\n    return obj;\n}\nvar stu = Student('chuckle');// {name: 'chuckle'}\n\n```\n\n**静态成员和实例成员：**\n**1、静态成员**:构造函数本身上添加的成员，静态成员只能通过构造函数访问，不能通过对象访问\n**2、实例成员**:构造函数内部通过this添加的成员，实例成员只能通过实例化的对象进行访问\n\n```js\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nStudent.sName = 'qx';// 添加静态成员\nvar stu = new Student('chuckle');// 通过构造函数创建实例对象\n// 实例成员只能通过实例化的对象进行访问\nconsole.log(stu.name);// chuckle\nconsole.log(Student.name);// Student,函数的name是它的函数名\n// 静态成员只能通过构造函数访问，不能通过对象访问\nconsole.log(stu.sName);// undefined\nconsole.log(Student.sName);// qx\n\n```\n\n**类、实例**\n使用**同一个**构造函数创建的对象，都称为一类对象，也将**构造函数称为类**。通过一个构造函数创建的对象，称为该**类的实例**。\n\n使用 **instanceof** 可以检查一个对象是否为一个类的实例。\n\n```js\nfunction Person() {}\nfunction Dog() {}\nvar person = new Person();\nvar dog = new Dog();\n\nconsole.log(person instanceof Person); // true\nconsole.log(dog instanceof Person); // false\n//所有的对象都是Object的实例，所有类都是Object的子类。\nconsole.log(person instanceof Object); // true\n\n```\n\n## 对象的基本操作\n1. **向对象中添加属性：**`对象.属性名 = 属性值`\n2. **获取对象中的属性：**`对象.属性名`\n3. **修改对象的属性值：**`对象.属性名 = 新值`\n4. **删除对象的属性：**`delete 对象.属性名`\n5. **in 运算符：**`属性名 in 对象`检查一个对象中是否含有指定的属性\n\n```js\nvar obj = {};// 创建\nobj.name = 'chuckle';// 添加\nconsole.log(obj.name);// chuckle\nobj.name = 'qx';// 修改\nconsole.log(obj.name);// qx\ndelete obj.name;// 删除\nconsole.log('name' in obj);// false\n```\n\n## 遍历对象\n遍历对象时，要根据对象的结构配合使用多种方法，通常还需要配合数组的遍历方法\n\n**1、`for-in`遍历对象的属性，再使用**`对象[属性名]`**获取属性值**\n\n**for-of**用于遍历数组的元素，直接获取元素。\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\nfor(let i in obj){\n    //第一层循环获取student和teacher两个属性\n    console.log(i);//输出属性名\n    //obj[i]获取属性值，是数组，遍历数组使用for-of，虽然用for-in也行，这里都作展示\n    for(let j of obj[i]){\n        console.log(`${j.name}:${j.age}`);\n    }\n    // for(let j in obj[i]){\n    //     console.log(`${obj[i][j].name}:${obj[i][j].age}`);\n    // }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**2、`Object.keys`返回对象自身属性名组成的数组，`Object.values`返回对象自身属性值组成的数组**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.keys(obj).forEach((key) => {\n    console.log(key);//输出属性名\n    obj[key].forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\nObject.values(obj).forEach((value) => {\n    value.forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n\nchuckle:19\nqx:18\n张三:37\n李四:35\n```\n\n**3、`Object.entries()`返回Object.keys与Object.values的结合体，一个嵌套的数组，数组内包括了属性名与属性值，下标0存储属性名**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.entries(obj).forEach((item)=>{\n    console.log(item[0]);//输出属性名\n    //属性值仍是数组，接着遍历，数组中存着对象，直接去访问对象的属性拿到属性值输出\n    item[1].forEach((item)=>{\n         console.log(`${item.name}:${item.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**4、`Object.getOwnPropertyNames()`与Object.keys差不多**，不同的是会返回对象的所有属性，包括了不可枚举属性，如数组对象的length\n\n**5、`Object.getOwnPropertySymbols()`返回对象内的所有Symbol属性的数组**，对象初始化的时候，内部不包含任何Symbol属性\n\n## 对象访问器\nJS提供了Getter（**get**关键字）和 Setter（**set**关键字） 来定义对象访问器（属性访问器）\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    get getAge() {\n        return this.age;\n    },\n    set setAge(age) {\n        this.age = age;\n    }\n}\nconsole.log(obj.getAge);// 19\nobj.setAge = 20;\nconsole.log(obj.getAge);// 20\n\n```\n\n使用 getter 和 setter 可以确保更好的**数据质量**，一些会随时间而变等的属性（如年龄），实际无需静态地存储在对象中，且可以对数据进行加工处理，类似数据库中的视图的功能\n\n```js\nvar obj = {\n    name: 'chuckle',\n    birthYear: 2003,\n    get age() {\n//年龄不适合直接存储在对象中，我们可以存储生日，而年龄属性则作为一个getter进行处理后再返回\n        return  new Date().getFullYear() - this.birthYear;\n    },\n//如果去修改年龄，实际上应该修改birth出生年份\n    set age(age) {\n        this.birthYear = new Date().getFullYear() - age;\n    }\n}\nconsole.log(obj.age);// 20，对象中实际上没有age\nobj.age = 19;\nconsole.log(obj.age);// 19\nconsole.log(obj.birthYear);// 2004\n\n```\n\n# Object对象\nJavaScript中的对象其实就是一组数据和功能的集合。\n\n**Object对象**是所有对象的祖宗，其他对象都继承自Object，即其它对象都是Object的实例\n\n每个Object类型的实例**共有的属性和实例方法**（定义在Object原型对象Object.prototype上的方法。可以被Object实例直接使用）：\n1. **constructor：**保存用于创建当前对象的构造函数。\n2. **\\_\\_proto\\_\\_：**隐式原型，指向的Object原型对象（父对象，所有类型的对象都有这个属性）\n3. **`hasOwnProperty()`：**检测实例中是否有指定属性。\n4. **`isPrototypeOf()`：**判断传入的对象是否是当前对象的原型\n5. **`propertyIsEnumerble()`：**检查指定属性能否使用for-in来枚举遍历\n6. **`toLocaleString()`：**返回对象的字符串表示\n7. **`toString()`：**返回对象的字符串表示\n8. **`valueOf()`：**返回对象的字符串，数值，或布尔表示。通常和toString() 返回的值相同。\n   \n**静态方法：**直接定义在Object对象的方法，`Object.`直接调用\n\n**控制对象状态的方法：**\n1. **`preventExtensions()`：**防止对象扩展\n2. **`isExtensible()`：**判断对象是否可扩展\n3. **`seal()`：**禁止对象配置\n4. **`isSealed()`：**判断一个对象是否可配置\n5. **`freeze()`：**冻结一个对象\n6. **`isFrozen()`：**判断一个对象是否被冻结\n\n**对象属性模型的相关方法**\n1. **`keys()`：**返回对象自身属性名组成的数组\n2. **`getOwnPropertyNames()`：**与keys()差不多，但返回对象所有属性的数组，包括了不可枚举属性，如数组对象的length\n3. **`getOwnPropertyDescriptor()`：**获取某个属性的描述对象，参数(对象,属性名的字符串)\n4. **`defineProperty()`：**通过描述对象，定义或修改某个属性。给对象添加一个属性并指定该属性的配置\n5. **`defineProperties()`：**通过描述对象，定义多个属性。\n6. **`hasOwn()`：**判断是否为自身的属性\n\n**原型链相关方法**\n1. **`is()`：**比较两个值是否严格相等，严格比较\n2. **`create()`：**指定原型对象和属性，返回一个新的对象\n3. **`values()`：**返回对象自身属性值组成的数组\n4. **`entries()`：**返回一个数组，元素是对象自身的（不含继承的）所有可遍历属性的键值对数组\n5. **`fromEntries()`：**将一个键值对数组转为对象。\n6. **`assign()`：**对象的合并，复制一个或者多个对象来创建一个对象，浅拷贝，将源对象的所有可枚举的自身属性，复制到目标对象\n7. **`getPrototypeOf()`：**获取对象的原型对象(Prototype对象)\n8. **`setPrototypeOf()`：**设置对象的原型对象\n\n`Object.keys(obj).length`获取对象的长度\n\n`Object.prototype.toString.call()`可以在任意值(对象)上调用这个方法，以判断这个值的类型\n\n```js\n//[object Number]第一个值代表是对象，第二个值表示该值的构造函数即类型\nObject.prototype.toString.call(2); // \"[object Number]\"\nObject.prototype.toString.call(\"\"); // \"[object String]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(Math); // \"[object Math]\"\nObject.prototype.toString.call({}); // \"[object Object]\"\nObject.prototype.toString.call([]); // \"[object Array]\"\n\n```\n\n# JSON\n**JSON**（JavaScript Object Notation），即JavaScript对象表示法，它是一种**数据交换的文本格式**，使用JS语法来描述数据对象，而不是一种编程语言。\n\n大多数语言都支持对json的解析。JS中可以原生地把json转为object对象。\n\n**数据结构：**Object、Array\n**基本类型：**string，number，true，false，null(json无法表示undefined)\n\n```json\n{}//这是一个json\nnull//也可是一个json\n1//也可是一个json\n//下面也是一个json\n[\n    {},\n    {}\n]\n\n{ \n\t\"name\":\"chuckle\", \n\t\"age\":\"19\" \n}\n\n//一个常见的json\n{\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n}\n\n```\n\n对象和 json 没有长度，json.length 的打印结果是 undefined\n\n**使用for-in遍历json：**\n\n```js\n//将json存在变量中\nvar json = {\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n};\n\nfor (let i in json) {\n    console.log(i);\n    for(let j in json[i]){\n        console.log(`${json[i][j].name}:${json[i][j].age}`);\n    }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\nfor-in获取json对象的**属性**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(i);\n}\n// name\n// age\n```\n\nfor-in获取json对象的**属性的值**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(json[i]);\n}\n// chuckle\n// 19\n```\n\n前端收到的api通常也是json格式，如一言api：\n\n```json\n{\n    \"code\": 200,\n    \"type\": \"一言\",\n    \"content\": \"总觉得跟你在一起，不管多高的地方都可以到达。\"\n}\n\n```\n\n**`JSON.parse()`** 将数据转换为 JavaScript 对象\n**`JSON.stringify()`** 将 JavaScript 对象转换为字符串\n\n# Map对象\nMap对象保存键值对，元素会保持其插入时的顺序。\n\nMap的键可以是任意数据类型，包括函数、对象或任意基本类型。\n\n在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效\n\n```js 创建一个Map\nvar m = new Map();\n//或传入一个嵌套数组\nm = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n```\n\nObject与Map增删改查基本操作。\n\n```js\nvar o = {};\nvar m = new Map();\n//添加\no.x = 1;\nm.set('x', 1);\n//修改\no.x = 2;\nm.set('x', 2);\n//递增\no.x++;\nm.set('x', m.get('x')+1);\n//获取\no.x;\nm.get('x');\n//删除\ndelete o.x;\nmap.delete('x');\n\n```\n\nMap的键值对个数可以通过size属性获取\n\n```js\nvar m = new Map();\nm.set('x', 1);\nm.set('y', 2);\nconsole.log(m);//Map(2) {'x' => 1, 'y' => 2}\nconsole.log(m.size);//2\n```\n\n## Map的方法\n**基本方法：**\n1. **`get()`：**获取元素\n2. **`set()`：**设置元素\n3. **`has()`：**检查是否有指定key\n4. **`clear()`：**清空map\n5. **`delete()`：**删除指定元素\n\n**遍历方法：**\n1. **`keys()`：**提取键并返回**键**的迭代器MapIterator对象\n2. **`values()`：**提取值并返回**值**的迭代器MapIterator对象\n3. **`entries()`：**提取键值对并返回取**键值对**的迭代器MapIterator对象\n4. **`forEach()`：**传入回调函数(value, key)=>{}\n\n```js\nvar m = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n\nconsole.log(m.keys());//MapIterator {'x', 'y'}\nconsole.log(m.values());// MapIterator {1, 2}\nconsole.log(m.entries());// MapIterator {'x' => 1, 'y' => 2}\n\n//迭代器可以用for-of遍历\nfor (let [key, value] of m.entries()) {\n    console.log(key, value);//x 1, y 2\n}\n\nm.forEach((value, key) => {\n    console.log(key, value);//x 1, y 2\n})\n\n```\n\n# Set对象\n**Set**是**唯一值**的集合，与map类似，map存放的是键值对，而set只存放唯一值。\n\n**创建set对象：**\n\n```js\nvar s = new Set();\nvar s = new Set([1,2,3]);\n```\n\nset对象与数组也很像，可以互相转换\n\n```js\nvar arr1 = [1, 2, 3];\nvar s = new Set(arr1);//数组转为set对象，会去重\nvar arr2 = [...s];//set对象转为数组\n```\n\n可利用set值唯一的特性做**数组去重、并集、交集、差集**操作\n\n```js\n//1、去重\nvar s = new Set([1,2,3,3,2,1]);\nvar arr = [...s];//[1,2,3]\n\n//2、并集\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s = new Set([...arr1, ...arr2]); // {1, 2, 3, 4}\nvar arr = [...s];// [1,2,3,4]\n\n//3、交集，arr1和arr2共有的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => s2.has(x));//[2, 3]\n\n//4、差集,arr1去除arr2中的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => !s2.has(x));//[1]\n\n```\n\nSet值个数可以通过size属性获取\n\n```js\nvar s = new Set([1,2,3]);\nconsole.log(s);//Set(3) {1, 2, 3}\nconsole.log(s.size);//3\n```\n\n## Set的方法\n1. **`add()`：**添加新元素\n2. **`delete()`：**删除指定元素\n3. **`clear()`：**清空所有元素\n4. **`has()`：**判断是否存在某值\n5. **`forEach()`：**遍历每个元素，传入回调函数\n6. **`keys()`：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n7. **`values()`：**同keys()\n8. **`entries()`：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n**add()、delete()、clear()、has() ：**\n\n```js\nvar s = new Set([1,2,3]);\ns.add(4);\nconsole.log(s);//Set(4) {1, 2, 3, 4}\ns.delete(2);\ns.has(2);//false\ns.clear();\nconsole.log(s.size);// 0\n\n```\n\n**keys()、values() ：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.values();\nconsole.log(setIter);//SetIterator {1, 2, 3}\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // 2\nconsole.log(setIter.next().value); // 3\n```\n\n**entries() ：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.entries();\nconsole.log(setIter);//SetIterator {1 => 1, 2 => 2, 3 => 3}\nconsole.log(setIter.next().value); // [1, 1]\nconsole.log(setIter.next().value); // [2, 2]\nconsole.log(setIter.next().value); // [3, 3]\n```\n\n**forEach() ：**遍历每个元素，传入回调函数，参数：回调函数、thisArg执行回调函数时可以当作this来使用。\n回调函数参数：值（key）、值（value）、set对象\n\n```js\nvar s = new Set([1,2,3]);\ns.forEach((key,value,set)=>{\n    console.log(key,value);//1 1, 2 2, 3 3\n});\n```\n\n# 浅拷贝和深拷贝\n**浅拷贝：**只拷贝最外面一层的数据；更深层次的对象，只拷贝引用，浅拷贝的时候，是属于传址，而非传值。\n**深拷贝：**拷贝多层数据；每一层级别的数据都会拷贝，深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。\n\n**区分深拷贝与浅拷贝：**B复制了A，修改A，B也一样被修改是浅拷贝，B没变，是深拷贝。\n\n```js 浅拷贝举例\nvar a = [0,1,2,3];\nvar b = a;// 浅拷贝，传地址\nconsole.log(a===b);// 指向地址相同，true\na[0]=1;// 修改a\nconsole.log(b[0]);// 1，b也改变\n```\n\n通过`Object.assign()`实现浅拷贝:\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19\n};\nvar obj2 = Object.assign(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19}\nobj2.name = \"qx\";\nconsole.log(obj1.name);//qx,修改obj2，obj1也会被修改\n\n```\n\n## 实现深拷贝\n\n**通过`for-in`递归实现深拷贝**，即递归遍历整个对象，找到简单值，将值复制\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = {};\n\ndeepCopy(obj2,obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\nfunction deepCopy(newObj, oldObj) {\n    //遍历属性名或数组下标\n    for (let key in oldObj) {\n        // 获取属性值 oldObj[key]\n        let item = oldObj[key];//依次获取属性值\n        //下面进行创建属性与属性值的复制\n        if (item instanceof Array) {\n            // 判断这个值是否是数组\n            newObj[key] = [];\n            deepCopy(newObj[key], item);//递归\n        } else if (item instanceof Object) {\n            // 判断这个值是否是对象\n            newObj[key] = {};\n            deepCopy(newObj[key], item);//递归\n        } else {\n            // 简单数据类型，直接赋值\n            newObj[key] = item;\n        }\n    }\n}\n\n```\n\n通过JSON对象的**parse**和**stringify**方法实现**深拷贝**\n\n```js\nfunction deepClone(obj){\n    let str = JSON.stringify(obj);//将对象转为字符串这个基本类型\n    return JSON.parse(str);//再将字符串转为新对象，新对象与原对象就没有关系了\n}    \nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = deepClone(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\n```\n\n数组等对象的`slice()`不是完全的**深拷贝**，因为数组中存的是对象的引用地址，slice()只将地址拷贝了过去\n\n```js\nvar a = [0, 1, [1, 1, 1], 2, 3];\nvar b = a.slice();\n//修改b的第一层不影响a\nconsole.log(a[0]);// 0\nb[0] = 9;\nconsole.log(a[0]);// 0\nconsole.log(b[0]);// 9\n//修改嵌套的多层数组有影响\nconsole.log(a[2][0]);// 1\nb[2][0] = 0;\nconsole.log(a[2][0]);// 0\nconsole.log(b[2][0]);// 0\n\n```\n\n# 迭代器Iterator\n迭代以从一个数据集中按照一定的顺序，不断取出数据的过程。\n\n**迭代与遍历的区别：**\n1. 迭代强调依次取数据的过程，不保证把所有的数据都取完\n2. 遍历强调的是要把所有的数据依次全部取出\n\n迭代器是能调用`next()`实现迭代的一种对象，该方法返回一个具有两个属性的对象（value：可迭代对象迭代至此的值，done：布尔，是否已经取出所有数据）\n\n通过可迭代对象中的迭代器工厂函数`Symbol.iterator`来生成迭代器。每次生存的迭代器之间互不干扰。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nconsole.log(arrIter);// Array Iterator {}\nwhile(true){\n var next = arrIter.next();\n var value = next.value;\n var done = next.done;\n if(done){\n    break;\n }else{\n    console.log(value);// 1 2 3 4\n }\n}\n\n```\n\n迭代器对象可作为可迭代对象，**for-of**遍历可迭代对象\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    console.log(i);// 1 2 3 4\n}\n```\n\n如果可迭代对象在迭代期间被修改了，迭代器得到的结果也是修改后的。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    arr[2] = 0;\n    console.log(i);// 1 2 0 4\n}\n```\n\n当迭代到 **done: true** 时迭代器会处于一种完成但并不完成的状态，还能重复调用 next()，结果都是 **{ value: undefined, done: true }**\n\n# 正则表达式\n**正则表达式：**用某种模式去匹配一类字符串的公式，[正则表达式在线测试](https://c.runoob.com/front-end/854/)\n\n**正则表达式主体和修饰符：**\n\n```md 修饰符，修饰符用于执行区分大小写和全局匹配，顺序：/gim\ni：不区分大小写的匹配\ng：全局匹配（匹配所有匹配而非在找到第一个匹配后停止）\nm：多行匹配\n```\n\n```md 方括号 和 | ，表示或，匹配某个范围内的字符\n[abc] 匹配方括号之间的任何字符\n[^abc] 任何不在方括号之间的字符\n[0-9] 匹配 0 到 9 的数字。\n[a-z] 匹配从小写 a 到小写 z 的字符\n(aa|bb|cc) 匹配aa或bb或cc\n```\n\n```md 元字符，拥有特殊含义的字符\n.(点号) 匹配单个字符，除了换行和行结束符\n\\w 匹配数字、字母及下划线。\n\\W 匹配非单词字符\n\\d 匹配数字\n\\D 匹配非数字字符\n\\s 匹配空白字符\n\\S 匹配非空白字符\n\\b 匹配单词边界\n\\B 匹配非单词边界\n\n```\n\n```md 特殊转义符\n\\n 匹配换行符 \n\\r 匹配回车符 \n\\t 匹配制表符 \n\\f 匹配换页符 \n\\v 匹配垂直制表符 \n\\0 匹配null字符\n\\\\ 匹配\\\n\\\" 匹配 \"\n\\' 匹配 '\n\\xxx 匹配以八进制数 xxx 规定的字符\n\\xdd 匹配以十六进制数 dd 规定的字符\n\\uxxxx 匹配以十六进制数 xxxx 规定的 Unicode 字符\n\n```\n\n```md 量词，限定符，定位符\n+ 重复1次或更多次\n* 重复任意次数\n{n} 重复n次\n{n,} 重复n次或更多次（最少n次)\n{n,m} 重复n到m次\n^ 限定开始位置的字符\n$ 限定结尾位置的字符，如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式\n? 非贪婪模式，找到到第一个就不再往后匹配，正则默认贪婪匹配，在同一个匹配项中，尽量匹配更多所搜索的字符\n?=n 匹配其后有紧接指定字符串 n 的字符串\n?!n 匹配其后没有紧接指定字符串 n 的字符串\n?<=n 找到n但不匹配n\n\n```\n\n## RegExp对象\n\n在js中，正则表达式也是对象，**RegExp**是一个预定义了属性和方法的正则表达式对象\n\n```js\nvar re = /正则表达式主体/修饰符(可选);// re = /Hello/g\nvar re = new RegExp(\"正则表达式\"); // 参数是字符串\nvar re = new RegExp(\"正则表达式\", \"匹配模式\"); // 两个参数都是字符串\n```\n\n**RegExp对象的属性和方法：**\n1. **global：**\t判断是否设置了 \"g\" 修饰符\n2. **ignoreCase：**判断是否设置了 \"i\" 修饰符\n3. **multiline：**判断是否设置了 \"m\" 修饰符\n4. **lastIndex：**规定下次匹配的起始位置\n5. **source：**返回正则表达式的匹配模式\n6. **`test()`：**判断指定字符串是否符合正则规则，返回布尔\n7. **`exec()`：**返回一个数组，存放正则匹配的结果。无匹配返回 null\n8. **`toString()`：**返回正则表达式的字符串。\n\n\n`exec()`在 regexp 的属性 lastIndex 指定的字符处开始检索字符串，当它找到了与表达式相匹配的文本时，在匹配之后，它将把 regexp 的 lastIndex 属性设置为匹配文本后的第一个字符所在位置（调用test()也会改变lastIndex），可以通过反复地调用 exec() 方法来遍历字符串中的所有匹配文本，当 exec() 再也找不到匹配的文本时，它将返回 null，并且把属性 lastIndex 重置为 0\n\n**返回值：**匹配到的文本的数组，数组有四个属性，index 匹配文本第一个字符的位置，input 需匹配的原字符串，groups 当初中命名的分组时匹配到的分组对象\n\n```js\nvar str=\"Hello world! Hello china!\";\nvar re = /hello/gi;\nconsole.log(re.lastIndex);// 0\nconsole.log(re.test(str));// true\nconsole.log(re.lastIndex);// 5\nconsole.log(re.exec(str));// true\n//['Hello', index: 13, input: 'Hello world! Hello china!', groups: undefined]\nconsole.log(re.lastIndex);// 18\n\n```\n\n检查一个字符串是否是一个合法手机号\n\n以1开头（^1 表示1开头）\n第二位是3~9之间任意数字[3-9]\n三位以后任意9位数字[0-9]{9}重复9次的0-9\n\n```js\nvar str = \"15123456789\";\nvar re = /^1[3-9][0-9]{9}$/;\nconsole.log(re.test(str));// true\n```\n\n判断字符串是否为电子邮件\n\n```js\nvar str = \"916017604@qq.com\"\nvar re = /^\\w{3,}(\\.\\w+)*@[A-z0-9]+(\\.[A-z]{2,5}){1,2}$/\nconsole.log(re.test(str));// true\n```\n\n**支持正则表达式的 String 对象的方法：**\n1. **`search()`** 使用表达式来搜索匹配，然后返回匹配的位置\n2. **`replace()`** 返回模式被替换处修改后的字符串，不改变原字符串，返回替换后的字符串\n3. **`match()`** 返回匹配到的字符串的数组\n\n```js\nvar str = \"你好世界\"; \nvar n = str.match(/你好/);\nconsole.log(n[0]);// 你好\nconsole.log(str.replace(/世界/, '太阳系'));// 你好太阳系\n```\n\n```js 提取电话号码\nvar str = \"我的电话号码是15123456789\"; \nvar n = str.match(/1[3-9][0-9]{9}/);\nconsole.log(n[0]);// 15123456789\n```\n\n```js 替换url内的域名\nvar str = \"http://127.0.0.1:4000/\"; \nvar re = /(?<=(http|https):\\/\\/).+?(?=\\/)/g;\nvar n = str.replace(re, 'www.qcqx.cn');\nconsole.log(n);// http://www.qcqx.cn/\n```\n\n# 原型与原型链\n**省流：**\n原型其实就是一个对象，实例继承原型对象的属性，通过继承的这种方式，new出来的实例也有了这个属性\n\n对象的构造函数有一个 **prototype** 的属性，通过这个属性就能访问到原型\n\n对象有一个 **\\_\\_proto\\_\\_** 属性，指向构造函数的 **prototype** 的属性，所以也可以访问到原型\n\n构造函数也有 **\\_\\_proto\\_\\_** 属性，也是对象，因为所有函数都是 Function 构造的，所以都等于 Function.prototype\n\n原型也是对象，也有 **\\_\\_proto\\_\\_** 属性，通常浏览器称之为 **[[Prototype]]** ，它指向原型的原型，像单链表的next指针一样，构成原型链，直到Object构造函数，因为 Object 对象的原型 Object.prototype.__proto__ 为空null没有下一个原型了，Object.prototype是原型的终点\n\n原型与原型链其实是为了实现继承，原型就像java中的类，由构造函数构造的对象都继承了这个构造函数原型的属性和方法，当然，每个对象后续都可以添加自己的属性和方法来覆盖继承自原型的属性和方法。\n\n原型链中每个节点是构造函数的原型，每个节点有一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n普通对象也可以利用 Object.create() 作为新生成对象的原型。\n\n## 原型\n每个 JS 对象一定对应一个原型对象，并从这个原型对象继承属性和方法。\n\n**对象**只有隐式原型 **\\_\\_proto\\_\\_**\n**函数**有隐式原型 **\\_\\_proto\\_\\_** ，还有显式原型 **prototype**\n\n**对象**的 **\\_\\_proto\\_\\_** 指向 **其构造函数.prototype**，或者说 **对象.\\_\\_proto\\_\\_** 等于 **其构造函数.prototype** 保存的东西是一样的\n**函数**的 **\\_\\_proto\\_\\_** 都指向**Function.prototype**，因为所有函数都是由Function构造的，值为 ƒ(){[native code]}\n\n**函数**的 **prototype** 指向一个对象，就是通常所说的原型对象，一定有两个属性，**constructor** 指向构造函数本身，**[[Prototype]]**就是\\_\\_proto\\_\\_，它连接起一个个原型，构成**原型链**，Object 对象的原型 Object.prototype.__proto__ 为空null\n\n**两种获取对象隐式原型的方式：**对象的**\\_\\_proto\\_\\_** 属性（非标准），`Object.getPrototypeOf()`方法(标准)\n**获取显式原型：**构造函数.prototype\n\n```js\nvar obj = new Object();\nconsole.log(obj.__proto__);\nconsole.log(Object.getPrototypeOf(obj));\n//{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n//    constructor: ƒ Object()\n//    __proto__: null 原型的__proto__指向下一个原型，而Object对象的原型 Object.prototype.__proto__ 为空null\n//    原型上还有各种方法，所有Object和Object的子类都会继承这些属性和方法\n\nconsole.log(Object.__proto__);\nconsole.log(Function.prototype);\n//ƒ () { [native code] }\n\n```\n\n只有一个Object对象不够直观，新建一个构造函数，new一个Person对象\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\nconsole.log(person.__proto__);\nconsole.log(Object.getPrototypeOf(person));\n```\n\n下面的输出就是Person对象的原型，可以发现原型上并没有a属性，在构造函数中通过this直接定义实例成员，会作为实例对象的属性，而不是出现在原型上再被对象继承。\n\n```js 输出\n{constructor: ƒ}\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n这个原型上只有两个属性，我们可以在原型上添加属性和方法，所有对象都会继承这些属性和方法，哪怕是在这之前已经实例化的对象。\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\nconsole.log(Object.getPrototypeOf(person));\n```\n\n可以看到原型上出现了a属性，值为0\n\n```js 输出\n{a: 0, constructor: ƒ}\n    a: 0\n    b: 2\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n试着在实例化对象中使用继承来的a、b属性\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\n//使用继承来的a、b属性\nconsole.log(person.a);// 1\nconsole.log(person.__proto__.a);// 0\nconsole.log(person.b);// 2\n\n```\n\nperson.a 输出 1，访问的是实例成员a，也就是说对象的属性可以覆盖继承来的同名属性\n\n```js 输出\n1\n0\n2\n```\n\n再看原型中的的 constructor 属性，它指向该原型对应的构造函数，可以在控制台中展开\n\n<img src=https://cdn.chuckle.top/images/43-2.webp width=\"45%\">\n\n构成了一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n## 原型链\n原型是原型链上的节点，各个原型通过 **\\_\\_proto\\_\\_** 相连接，对象可以继承原型链上从Object构造函数开始至该对象构造函数的所有原型的属性和方法，即继承了其所有父级的所有属性和方法，且逐层可以覆盖\n\n**制造原型链：**\n\n**直接操作prototype属性：**\n\n```js\nfunction Parent(){}\nfunction Child(){\n    this.a=1;\n}\nParent.prototype.b = 2;// 在原型上添加属性\nParent.c = 0;//在构造函数上添加静态成员\n// 通过原型的__proto__连接起两个原型，表示Child继承Parent\nChild.prototype.__proto__ = Parent.prototype\n// 也可以通过setPrototypeOf设置原型的原型，来连接两个原型\nObject.setPrototypeOf(Child.prototype,Parent.prototype);\n\nvar child = new Child();\n\nconsole.log(child.a);// 1,访问实例成员\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.c);// undefined，不能通过原型链访问原型对应构造函数的静态成员\n\n```\n\n可以在控制台展开 **[[Prototype]]** 属性来查看原型链\n\n<img src=https://cdn.chuckle.top/images/43-3.webp width=\"50%\">\n\n通过 `Object.create()` 建立原型链，在Vue源码中 Object.create() 的使用频率非常高\n\n`Object.create()` 用于创建一个新对象，使用现有的对象来作为新创建对象的原型\n\n原型和普通对象都有__proto__和constructor属性，且作用都一样，利用Object.create()可以将一个普通对象作为新对象的原型\n\n```js\nfunction Parent(){\n    this.p = 0;\n}\nParent.prototype.b = 2;\nvar parent =  new Parent();\nparent.a = 1;\n\n// 使用现有的对象来作为新创建对象的原型\nvar child = Object.create(parent);\n\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.p);// 0\nconsole.log(child.a);// 1\n\n```\n\n将原型与构造函数的循环、原型与原型的链、构造函数的实例组成一张图：\n\n<img src=https://cdn.chuckle.top/images/43-4.webp width=\"100%\">\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(2)","url":"/article/c32976c2.html","content":"\n# JS对象简介\n尽管JavaScript里没有Java，但两者都是面向对象语言，按顺序学过java这部分也是大差不差。\n\n在JavaScript中，对象是一组**无序的相关属性**和**方法**的集合。\n对象中的属性均是**键值对**，属性名是键，属性值是值。\n\n**new**关键字可以创建对象的实例。\n\n```js\nvar chuckle = ['轻笑', 19, '男'];\n//虽然数组也是个对象，这js中是引用类型，但这样定义chuckle，值的表示不直观\n//使用对象来表示，结构会更清晰\nvar chuckle = {};//也可以new Object()来创建一个对象\nchuckle.name = '轻笑';\nchuckle.age = 19;\nchuckle.sex = '男';\n\nconsole.log(chuckle);\n//{name: '轻笑', age: 19, sex: '男'}\nconsole.log(chuckle.name);//轻笑\n```\n\n对象的属性值可以是任何的数据类型，也可以是个函数\n\n```js\nvar obj = new Object();\nobj.fun = function(){\n  console.log('这是一个函数');\n};\nconsole.log(obj.fun);//获取而不执行函数\nconsole.log(obj.fun());//执行函数,这是一个函数\n```\n\n对象的属性也可以是另一个对象\n\n```js\nvar obj1 = new Object(); obj1.inObj;\nvar obj2 = new Object(); obj2.name = \"一个对象\";\n//将整个obj2对象，设置为obj1的属性，保存的是对象的地址\nobj1.inObj = obj2;\nconsole.log(obj1.inObj);//{name: '一个对象'}\nconsole.log(obj1.inObj.name);//一个对象\n```\n\n对象变量保存的是对象的地址，当两个变量指向同一个对象时，两个变量都可以修改对象中的属性。\n\n**对象的分类**:\n1. **内置对象**: 由ES标准中定义的对象，如：Object、Math、Date、String、Array、Number、Boolean、Function等。\n2. **宿主对象**: 由JS的运行环境提供的对象，如浏览器提供了BOM、DOM，console、document。\n3. **自定义对象**: 开发者创建的对象。\n\n# 基本包装类型\n基本数据类型string无法绑定属性和方法，但将其转换为**基本包装类型**，就可以。\n\n```js\nvar str = '';\nstr.name = '一个字符串';//不会报错，但无法绑定\nconsole.log(str.name);//输出undefined\n```\n\n实际上，当我们对基本数据类型调用属性和方法(如str.length)时，js会自动将其临时转换为对应的基本包装类型（隐式类型转换），再调用内置方法。\n\n**基本包装类型**包括：**Number**、**Boolean**、**String**，它们都属于引用数据类型，可以绑定属性和方法。\n\n```js\nvar strObj = new String('');\nstrObj.name = '一个字符串';\nconsole.log(strObj.name);//一个字符串\n```\n\n1. `String()`：将基本数据类型字符串，转换为 String 对象。\n2. `Number()`：将基本数据类型的数字，转换为 Number 对象。\n3. `Boolean()`：将基本数据类型的布尔值，转换为 Boolean 对象。\n\n**注意**，在实际应用中一般不会使用基本数据类型的对象\n\n在底层，字符串以字符数组的形式保存\n\n```js\nvar str = 'chuckle';//保存方式[\"c\", \"h\", \"u\", \"c\", \"k\", \"l\", \"e\"]\nconsole.log(str.length);//7\nconsole.log(str[2]); //因为是数组，可以直接访问下标，字符串中的第3个字符,u\n```\n\n# 内置对象\n**内置对象**是语言自带的一些对象，提供了最基本最常用的**属性**和**方法**。\n\n**Arguments**(函数参数集合)，**Array**(数组)，**Boolean**(布尔对象)，**Math**(数学对象)，**Date**(日期时间)，**Error**(异常对象)，**Function**(函数构造器)，**Number**(数值对象)，**Object**(基础对象)，**RegExp**(正则表达式对象)，**String**(字符串对象)\n\n# 字符串对象String\n[String字符串--JavaScript基础笔记(1)](/article/3f7cd15d.html#String字符串)\n\n**字符串的所有方法，都不会改变原字符串**\n\n1. `indexOf()/lastIndexOf()`：获取字符串中指定内容的索引\n2. `search()`：获取字符串中指定内容的索引（参数里一般是正则）\n3. `includes()`：字符串中是否包含指定的内容\n4. `startsWith()`：字符串是否以指定的内容开头\n5. `endsWith()`：字符串是否以指定的内容结尾\n6. `charAt()`和`str[index]`：返回字符串指定位置(下标)的字符\n7. `charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码\n8. `slice()`：截取指定范围的字符串，可传入负值，代表倒数第几个字符（截取时包括该字符）\n9. `substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换\n10. `substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n11. `String.fromCharCode()`：据字符的 Unicode 编码获取字符\n12. `concat()`：拼接两个字符串，不如直接用+号\n13. `split()`：字符串转换为数组 【重要】\n14. `replace()`：替换字符串内容\n15. `repeat()`：重复该字符串指定次数\n16. `toUpperCase()` 和 `toLowerCase()`：大小写转换\n17. `trim()`：去除字符串头尾的空格\n\n## 查找字符\n**1、`indexOf()/lastIndexOf()`：获取字符串中指定内容的索引**\n\n`indexOf()`从前向后查找，`lastIndexOf()`从后向前，用法一致。\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'abc cba';\nconsole.log(str.indexOf('c'));//2\nconsole.log(str.lastIndexOf('c'));//4\n\nconsole.log(str.indexOf('a'));//0\nconsole.log(str.lastIndexOf('a'));//6\n```\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc'));//2,代表uc第一个字符u是字符串中第三个字符\n```\n\n添加起始位置参数，指定查找的起始位置\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc',2));//从下标2即字符串第三个字符开始找起，输出2\nconsole.log(str.indexOf('uc',3));//从下标3即字符串第四个字符开始找起，输出-1\n```\n\n**案例**：查找字符串\"abcabcabc\"中，所有 a 出现的位置以及次数\n\n```js\nvar str = \"abcabcabc\";\nvar num = 0;//记录次数\nvar index = -1;//记录位置下标，从-1开始\ndo{\n  index = str.indexOf('a', index + 1);//找到一个就从下一个字符下标开始找\n  if(index !== -1){\n    console.log(index);//输出下标0,3,6\n  }\n}while(index !== -1);//找到了就接着去找，直到找不到\n```\n\n**2、`search()`：获取字符串中指定内容的索引（参数里一般是正则）**\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'CHUCKLE';\nconsole.log(str.search('uc')); //-1\nconsole.log(str.search(/uc/i)); //2 正则写法，忽略大小写\n```\n\n**3、`includes()`：字符串中是否包含指定的内容**\n\n**功能**：判断字符串中是否含有指定内容。有返回 true；否则返回 false。可以传入起始位置参数。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.includes('uc')); //true\nconsole.log(str.includes('ab')); //false\nconsole.log(str.includes('ab',5)); //false\n```\n\n**4、`startsWith()`：字符串是否以指定的内容开头**\n\n**功能**：判断字符串是否以指定的字符串开头。是返回 true；否则返回 false。可以指定起始位置下标，指定的位置则当做字符串开头。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.startsWith('uc')); //false\nconsole.log(str.startsWith('c')); //true\nconsole.log(str.startsWith('uc',2)); //true\n```\n\n**5、`endsWith()`：字符串是否以指定的内容结尾**\n\n**功能**：判断字符串是否以指定的字符串结尾。是返回 true；否则返回 false。可以指定检索的字符串长度（检索到第几个字符）。\n\n```js\nvar str = \"chuckle\"\nconsole.log(str.endsWith('uc')); //false\nconsole.log(str.endsWith('e')); //true\nconsole.log(str.endsWith('uc',4)); //true\n```\n\n## 获取指定位置的字符\n**1、`charAt()`和`str[index]`：返回字符串指定位置(下标)的字符**\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.charAt(2));//u\nconsole.log(str[2]);//u\n```\n\n**2、`charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码**\n\n```js 判断字符串中是否有非英文字符\nvar str = \"chuckle轻笑\";\nfor(let i = 0; i < str.length; i++){\n  let char = str.charCodeAt(i);//保存该字符的Unicode编码\n  if(!(char >= 0 && char <= 127)){//英文字符的Unicode编码在0~127\n    console.log(`存在非英文,在第${i+1}个字符`);//存在非英文,在第8个字符,存在非英文,在第9个字符\n  }\n}\n```\n\n## 字符串截取\n**1、`slice()`：截取指定范围的字符串**，可传入负值，代表倒数第几个字符（截取时包括该字符）\n\n```js 两个参数都是索引值。正数时包左不包右\n新字符串 = str.slice(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.slice(2));//chuckle,从下标2开始截取到最后\nconsole.log(str.slice(2,str.length));//chuckle\nconsole.log(str.slice(2, -1));//chuckl,从下标2开始截取到倒数第一个字符，包括，-0无效\nconsole.log(str.slice(5, 2));//无效范围，返回空字符串\n```\n\n**2、`substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换。\n\n```js 两个参数都是索引值。包左不包右\n新字符串 = str.substring(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substring(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substring(2,str.length)); //chuckle\nconsole.log(str.substring(5, 2)); //chu，自动交换位置，相当于截取下标2到5\nconsole.log(str.substring(2, -1)); //qx，-1看作0，然后自动交换位置\n```\n\n**3、`substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n\n```js\n新字符串 = str.substr(开始索引, 截取的长度);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substr(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substr(2,100)); //chuckle，截取长度超过剩余长度时，只会截取剩余的字符\nconsole.log(str.substr(100, 10)); //空字符串，截取不到任何字符\n```\n\n## 其它方法\n\n**`String.fromCharCode()`：据字符的 Unicode 编码获取字符**\n\n```js\nvar a = String.fromCharCode(97);\nconsole.log(a);//a\n```\n\n**`concat()`：拼接两个字符串，不如直接用+号**，数组中也有此方法，用于两个数组的拼接，那边常用\n\n```js\nvar str1 = \"qx\";\nvar str2 = \"chuckle\";\nstr2 = str1.concat(str2);//qxchuckle\n```\n\n**`split()`：字符串转换为数组 【重要】**\n\n**功能**：通过指定的分隔符，将字符串拆分成数组，分隔符不会出现在数组中。不传入参数则将整个字符串作为数组的一个元素存入。\n\n```js\nvar str = \"qx,chuckle,轻笑\";\nconsole.log(str.split(',')); //['qx', 'chuckle', '轻笑']\nconsole.log(str.split('')); //['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split()); //['qx,chuckle,轻笑']\n```\n\n**`replace()`：替换字符串内容**\n\n**功能**：将字符串中的指定内容，替换为一段字符串，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则。\n\n```js\n新的字符串 = str.replace(被替换的子串，新的子串);\n```\n\n```js\nvar str = \"生活就像海洋，只有咕噜咕噜\";\nstr = str.replace('咕噜咕噜','意志坚强的人才能到达彼岸');\nconsole.log(str);//生活就像海洋，只有意志坚强的人才能到达彼岸\n```\n\n**`repeat()`：重复该字符串指定次数**\n\n```js\nvar str = \"chuckle!\"\nstr = str.repeat(2);//重复两次\nconsole.log(str);//'chuckle!chuckle!'\n```\n\n**`trim()`：去除字符串头尾的空格**\n\n```js\nvar str = '   a   b   c   ';\nconsole.log(str);//'   a   b   c   '\nconsole.log(str.length);//15\n\nconsole.log(str.trim());//'a   b   c'\nconsole.log(str.trim().length);//9\n```\n\n**`toUpperCase()` 和 `toLowerCase()`：大小写转换**\n\n```js\nvar str = 'abcdEFG';\n//转换成小写\nconsole.log(str.toLowerCase()); //abcdefg\n//转换成大写\nconsole.log(str.toUpperCase()); //ABCDEFG\n```\n\n**html方法**：不常用，多数是拼接成模板字符串返回\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.anchor('chuckle'));//<a name=\"chuckle\">chuckle</a>\nconsole.log(str.big());//<big>chuckle</big>\nconsole.log(str.sub());//<sub>chuckle</sub>\nconsole.log(str.sup());//<sup>chuckle</sup>\nconsole.log(str.link('https://www.qcqx.cn/'));//<a href=\"https://www.qcqx.cn/\">chuckle</a>\nconsole.log(str.bold());//<b>chuckle</b>\n```\n\n# 数值对象Number\n[Number数值型介绍--JavaScript基础笔记(1)](/article/3f7cd15d.html#Number数值型)\n\n1. `Number.isInteger()`：判断是否为整数\n2. `toFixed(num)`：保留小数点后num位（四舍五入），返回字符串\n\n**`Number.isInteger()`：判断是否为整数**\n\n```js\n布尔值 = Number.isInteger(数字);\n```\n\n```js\nvar a = 10;\nconsole.log(Number.isInteger(a));//true\na = -10;\nconsole.log(Number.isInteger(a));//true\na = 1.00;\nconsole.log(Number.isInteger(a));//true,虽然有小数点，但后面都是0，所以会被当做整数\na = 3.14;\nconsole.log(Number.isInteger(a));//false\n```\n\n**`toFixed(num)`：保留小数点后num位（四舍五入）**，返回字符串，将字符串转为整数可用**Number()**，详见[数据类型转换--JavaScript基础笔记(1)](/article/3f7cd15d.html#数据类型转换)\n\n```js 注意返回字符串！\n字符串 = nb.toFixed(num);\n```\n\n```js\nvar nb = 3.1415926;\nconsole.log(nb.toFixed(1));//3.1\nconsole.log(nb.toFixed(3));//3.142\nconsole.log(nb.toFixed(4));//3.1416\n```\n\n# 数学对象Math\n**Math**不是一个构造函数，无需创建对象即可直接使用其属性和方法，它是一个工具类，里面封装了数学运算相关的属性和方法。\n\n1. `Math.PI`：圆周率\n2. `Math.abs()`：获取绝对值\n3. `Math.random()`：生成0-1之间的随机浮点数，[0,1)\n4. `Math.floor()`：向下取整（往小取值）\n5. `Math.ceil()`：向上取整（往大取值）\n6. `Math.round()`：四舍五入取整（正数四舍五入，负数五舍六入）\n7. `Math.max(x, y, z)`：返回多个数中的最大值\n8. `Math.min(x, y, z)`：返回多个数中的最小值\n9.  `Math.pow(x,y)`：乘方：返回 x 的 y 次幂\n10. `Math.sqrt()`：开方：对一个数进行开方运算\n\n**`Math.abs()`：获取绝对值**，可传入字符串，自动做隐式转换。\n\n```js\nconsole.log(Math.abs(10));//10\nconsole.log(Math.abs(-10));//10\nconsole.log(Math.abs('-10'));//10\nconsole.log(Math.abs(-3.14));//3.14\nconsole.log(Math.abs('123abc'));//NaN\n```\n\n**`Math.random()`：生成0-1之间的随机浮点数，[0,1)**\n\n```js 一些技巧\n//生成 [0, x) 之间的随机整数\nMath.round(Math.random()*x);\n//生成 [x, y) 之间的随机整数\nMath.round(Math.random()*(y-x)+x)\n//生成 [x, y]之间的随机整数\nMath.floor(Math.random()*(y-x+1))+x;\n```\n\n# 时间对象Date\n**Date**用于处理日期和时间，Date是一个**构造函数**，需要**new实例化**后才能使用。\n\n**无参时获取系统时间**\n\n```js\nvar date = new Date();\nconsole.log(date);//Wed Mar 29 2023 15:08:02 GMT+0800 (中国标准时间)\nconsole.log(typeof date);//object\n```\n\n**传递参数**,意思是给时间对象Date设定一个具体的时间，基准时间为**1970年1月1日 00:00:00**，具体小时差别要看时区，东八区+8小时。\n\n```js 使用方法\nvar date = new Date(传入毫秒数（时间戳）);//表示基准时间加上这个毫秒数\n//至少要两个参数，不能缺少年，会自动进位，其余默认都是首时间\nvar date = new Date(年,月,日,时,分,秒,毫秒);//月份是0到11之间的整数值，表示从一月到十二月\n//传入时间字符串，有格式要求，星期 月 日 年 时:分:秒\nvar date = new Date(时间字符串);\n//Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)\n```\n\n```js\n//传入2000毫秒，表示基准时间过2s\nvar date = new Date(2000);//Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)\n//设定日期为2023年3月，传入2代表3月\nvar date = new Date(2023,2);//Wed Mar 01 2023 00:00:00 GMT+0800 (中国标准时间)\n//传入时间字符串，有格式要求，分隔符任意,可以看到，星期不对会自动修正\nvar date = new Date('Wed Apr 21 2023');//Fri Apr 21 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date = new Date(\"2023/3/29 11:11:11\");//Wed Mar 29 2023 11:11:11 GMT+0800 (中国标准时间)\n```\n\n**常用方法**\n1. `getFullYear()`：获取年份\n2. `getMonth()`：获取月，0到11之间的整数值，表示从一月到十二月\n3. `getDate()`：获取日：1-31\n4. `getDay()`：获取星期：0-6，0代表星期日\n5. `getHours()`：获取小时：0-23\n6. `getMinutes()`：获取分钟：0-59\n7. `getSeconds()`：获取秒：0-59\n8. `getMilliseconds()`：获取毫秒\n9. `setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒。返回时间戳\n10. `toUTCString()`：将当日的日期（根据 UTC）转换为字符串\n11. `toJSON()`：将日期转为json格式\n12. `getTime()`：获取时间戳\n13. `toLocaleString()` 格式化输出 2023/4/12 09:39:49\n\n```js 举例：\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nconsole.log(date.getFullYear());//2023\nconsole.log(date.getMonth());//2\nconsole.log(date.getDate());//29\nconsole.log(date.getDay());//3\nconsole.log(date.getHours());//15\nconsole.log(date.getMinutes());//52\nconsole.log(date.getSeconds());//6\nconsole.log(date.getMilliseconds());//495\n\n```\n\n**`toUTCString()`：将当日的日期（根据 UTC）转换为字符串**\n\n```js\nvar d = new Date();//Wed Mar 29 2023 16:11:02 GMT+0800 (中国标准时间)\nd.toUTCString()//'Wed, 29 Mar 2023 08:11:02 GMT'\n```\n\n**`setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒**,返回时间戳\n\n```js\nvar d = new Date(2023,0);\nvar t = d.setFullYear(2020,10);\nconsole.log(t);//1604160000000\nconsole.log(new Date(t));//Sun Nov 01 2020 00:00:00 GMT+0800 (中国标准时间)\n```\n\n**`toJSON()`：将日期转为json格式**\n\n```js\nvar d = new Date(2023,0);\nvar t = d.toJSON();\nconsole.log(t);//2022-12-31T16:00:00.000Z\n```\n\n## 获取时间戳\n\n**`getTime()`：获取时间戳**，也就是返回从基准时间至今的毫秒数(时间戳也可以是秒数，但函数返回的是毫秒数)。\n\n```js\nvar date = new Date(2023,0);\nconsole.log(date);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\nvar time = date.getTime();//1672502400000\nvar date = new Date(time);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\n```\n\n还有其它方法可以获取时间戳：\n\n```js\nvar time1 = +new Date();\nconsole.log(time1);//1680076996003\n\nvar time2 = new Date().getTime();\nconsole.log(time2);//1680076996003\n\nvar time3 = new Date().valueOf();\nconsole.log(time3);//1680076996003\n\nvar time4 = new Date() * 1;\nconsole.log(time4);//1680076996003\n\nvar time5 = Number(new Date());\nconsole.log(time5);//1680076996003\n\n```\n\n获取**当前时间的时间戳**可以用这种方法\n\n```js\nconsole.log(Date.now());//1680077268109\n```\n\n## 转为指定格式\n使用 `toLocaleString()` 简单格式化输出\n\n```js\nnew Date().toLocaleString();\n// 2023/4/12 09:39:49\n```\n\n也可以通过Date的**prototype属性**在原型上添加自定义的属性和方法，给Date对象添加**format()**方法，该方法封装如下：\n\n```js\nDate.prototype.format = function(fmt) { \n  var o = { \n    \"M+\" : this.getMonth()+1,                 //月份 \n    \"d+\" : this.getDate(),                    //日 \n    \"h+\" : this.getHours(),                   //小时 \n    \"m+\" : this.getMinutes(),                 //分 \n    \"s+\" : this.getSeconds(),                 //秒 \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \n    \"S\"  : this.getMilliseconds()             //毫秒 \n  }; \n  if(/(y+)/.test(fmt)) {\n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); \n  }\n  for(var k in o) {\n    if(new RegExp(\"(\"+ k +\")\").test(fmt)){\n      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));\n    }\n  }\n  return fmt; \n}        \n\n```\n\n```js 使用案例,分隔符任意\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nvar time = date.format(\"yyyy-MM-dd hh:mm:ss\");\nconsole.log(time);// 2023-03-29 15:52:06\ntime = date.format(\"yyyy/MM/dd\");\nconsole.log(time);// 2023/03/29\ntime = date.format(\"yyyy年MM月dd日 hh时mm分ss秒\");\nconsole.log(time);// 2023年03月29日 15时52分06秒\n\n```\n\n还可引入各种**时间库**来处理，如[momentjs](http://momentjs.cn/)、[Day.js](https://day.js.org/)\n\n# 数组对象Array\n下面是一个普通对象和数组对象：\n\n```js\nvar obj = {name: 'chuckle' , age: 19 };\nvar arr = [\"chuckle\",\"19\"];\n```\n\n普通对象使用字符串作为属性名，而数组使用**数字作为索引**，数组适合用于存储同类型的一组数据，如列表数据。\n\n数组中的元素可以是**任意的数据类型**，可以是对象、函数、数组。也可以同时存储**不同类型数据**。\n\n**1、使用字面量创建数组：**\n\n```js\nvar arr = []; // 创建空数组\narr = [1, 2, 3]; // 带初始值的数组\n```\n\n**2、使用构造函数创建数组对象：**\n\n```js\nvar arr = new Array(); // 创建空数组\narr = new Array(4); // 创建大小为4的数组，初始值都为空属性\narr = new Array(1,2,3); // 带初始值的数组\n```\n\nJS中的数组会**自动扩容**，当我们访问数组大小以外的下标时，会返回undefined，但可以直接给超过数组大小的下标赋值，并自动给扩容的下标赋空属性，但注意，**空属性不计入数组的长度 arr.length**。\n\n```js\nvar arr = [1, 2, 3];\nconsole.log(arr); // [1, 2, 3]\nconsole.log(arr.length); // 3\nconsole.log(arr[6]);// undefined\n\narr[6] = 7;\nconsole.log(arr); // [1, 2, 3, 空属性 × 3, 7]\nconsole.log(arr[4]); // undefined\nconsole.log(arr.length); // 4\n```\n\n## 解构赋值\n解构赋值是ES6中新增的一种赋值方式。可以方便地把数组中的元素按顺序赋值给其他多个变量。\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b, c] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\n```\n\n先指定变量的默认值，**会被覆盖**\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b = 0, c = 0, d = 0] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\nconsole.log(d);// 0,数组中无第四个元素，保持原值\n```\n\nES6中新增的**扩展运算符**`...`打包**剩余的数据**作为一个**新数组**。**打包时**扩展运算符只能写在最后。\n\n```js\nvar [a, ...b] = [1, 2, 3];\nconsole.log(a); // 1\nconsole.log(b); // [2, 3]\n```\n\n## 数组属性和方法\n`arr.length`：**数组的长度**，数组中元素的个数\n\n**数组的方法：**\n1. **类型相关方法：**\n   1. `Array.isArray()`：判断是否为数组\n   2. `toString()`：将数组转换为字符串\n   3. `join()`：将数组转换为字符串,可以指定分隔符\n   4. `Array.from()`：将**伪数组**或可遍历对象转为真数组\n   5. `Array.of(a,b,c)`：将多个值按顺序转为字符串\n   6. 字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组\n2. **元素的添加和删除：**\n   1. `push()`：从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   2. `pop()`：删除数组中**最后一个**元素，返回被删除的元素，**改变原数组**\n   3. `unshift()`：从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   4.  `shift()`：删除数组中**第一个**元素，返回被删除的元素，**改变原数组**\n   5.  `splice()`：从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n   6.  `slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n   7.  `concat()`：合并多个数组，返回合并后的新数组，**不改变原数组**\n   8.  `fill()`：用固定的值**填充数组**，返回新数组，**改变原数组**\n3.  **数组排序：**\n    1.  `reverse()`：反转数组，返回反转后的数组，**改变原数组**\n    2.  `sort()`：排序，元素默认按照**Unicode编码**，从小到大进行排序，**改变原数组**\n4.  **查找数组元素：**\n    1.  `indexOf()`：**从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    2.  `lastIndexOf()`：**从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    3.  `includes()`：判断数组是否包含一个指定的值，返回**布尔**\n    4.  `find(function())`：返回**第一个**符合传入测试（函数）条件的数组元素。\n    5.  `findIndex(function())`：返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n    6.  `every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**\n    7.  `some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**\n    8.  `valueOf()`：返回数组本身，意义不大，数组名就代表该数组了\n5.  **遍历数组：**\n    1.  `for循环`遍历，大多数语言对于数组通用的遍历方法\n    2.  `forEach()`传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n    3.  `for of`，ES6新增循环遍历数组方法\n    4.  `map()`，遍历数组，并对数组中的每一项进行加工。\n    5.  `filter()`：数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n    6.  `reduce()`：参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n### 类型相关方法\n**`Array.isArray()`：判断是否为数组**\n\n```js\nvar a = [];\nconsole.log(Array.isArray(a));//true\na = {};\nconsole.log(Array.isArray(a));//false\n```\n\n**`toString()`：将数组转换为字符串**，每一项用逗号分割。\n\n大多数的数据类型都可以使用.toString()方法，将其转换为字符串。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.toString());//1,2,3,[object Object],function(){}\n```\n\n还可以使用`String()`将数组转换为字符串\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(String(a));//1,2,3,[object Object],function(){}\n```\n\n**`join()`：将数组转换为字符串,可以指定分隔符**，默认为逗号分割。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.join());//1,2,3,[object Object],function(){}\nconsole.log(a.join(' '));//1 2,3 [object Object] function(){}\nconsole.log(a.join('|'));//1|2,3|[object Object]|function(){}\n```\n\n可以使用`JSON.stringify()`将某个对象转换成 JSON 字符串形式，数组中的空属性会转为null。\n\n```js\nvar arr = [];\narr[5] = 6;\nconsole.log(arr); // [空属性 × 5, 6]\nconsole.log(JSON.stringify(arr)); // [null,null,null,null,null,6]\n```\n\n**字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组**，默认为逗号分割，找不到指定分隔符时也会用逗号分割\n\n```js\nvar str = \"qx,chuckle,轻笑\"\nconsole.log(str.split());//['qx,chuckle,轻笑']\nconsole.log(str.split(''));//['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split('-'));//['qx,chuckle,轻笑']\nconsole.log(str.split('c'));// ['qx,', 'hu', 'kle,轻笑']\n```\n\n**`Array.from()`：将伪数组或可遍历对象转为真数组**\n\n**伪数组**也有length属性，可以使用索引对数据进行操作，但是没有**真数组**的方法，因为该对象的原型不指向Array，需要将伪转真才能调用数组的方法。\n\n伪数组一般不会直接创建，而是通过一些js操作得到，通过浏览器方法获取标签、字符串、接受实参的函数arguments得到参数的伪数组，因为伪数组具有长度和索引，所以可以使用循环语句遍历。\n\n```js\nvar str = \"chuckle\";\nstr.push('qx');//报错str.push is not a function\nvar a = Array.from(str);\nconsole.log(a);//['c', 'h', 'u', 'c', 'k', 'l', 'e']\na.push('qx')\nconsole.log(a);// ['c', 'h', 'u', 'c', 'k', 'l', 'e', 'qx']\n```\n\n**`Array.of(a,b,c)`：将多个值按顺序转为字符串**，和`new Array()`差不多，区别是只有一个参数时，在**new Array()**表示数组的长度，而在**of()**仍然代表数组的元素\n\n```js\nvar arr = Array.of(1, [2,3], 'qx');\nconsole.log(arr);// [1, Array(2), 'qx']\narr = Array.of(3);\nconsole.log(arr);// [3]\narr = new Array(3);\nconsole.log(JSON.stringify(arr));// [null,null,null]\n```\n\n### 元素的添加和删除\n**`push()`：**从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.push(4,5,'123'));// 6\nconsole.log(JSON.stringify(arr));// [1, 2, 3, 4, 5, '123']\n```\n\n**`pop()`：**删除数组中**最后一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.pop());// 3\nconsole.log(JSON.stringify(arr));// [1,2]\n```\n\n**`unshift()`：**从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.unshift('0123',0));// 5\nconsole.log(JSON.stringify(arr));// [\"0123\",0,1,2,3]\n```\n\n**`shift()`：**删除数组中**第一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.shift());// 1\nconsole.log(JSON.stringify(arr));// [2,3]\n```\n\n**`splice()`：**从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n\n```js 语法，索引值为负代表从倒数第几个开始删\n新数组 = 原数组.splice(起始索引);\n新数组 = 原数组.splice(起始索引, 需要删除的个数);\n新数组 = 原数组.splice(起始索引, 需要删除的个数, 新的元素1, 新的元素2...);\n```\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(1));// 删除下标1后的所有元素，[2, 3, 4, 5]\nconsole.log(JSON.stringify(arr));// [1]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2));// 从下标1开始删两个元素，包括下标1，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2,'a','b'));// 删完后再从删除的起始位置插入'a','b'元素，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,\"a\",\"b\",4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(-2));// 从倒数第2个元素开始删后面的所有元素，[4, 5]\nconsole.log(JSON.stringify(arr));// [1,2,3]\n```\n\n搭配`indexOf()`，删除指定内容的元素\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(arr.indexOf(3), 1));// 删除3这个元素，[3]\nconsole.log(JSON.stringify(arr));// [1,2,4,5]\n```\n\n\n\n`slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n\n```js 语法，负数代表倒数索引\n新数组 = 原数组.slice(开始位置的索引);\n新数组 = 原数组.slice(开始位置的索引, 结束位置的索引);//提取的元素中，包含开始位置，不包含结束位置\n```\n\n```js\nvar arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.slice()); // 不带参数提取所有元素,['a', 'b', 'c', 'd']\nconsole.log(arr.slice(2)); // 从下标2提取后面所有元素，['c', 'd']\nconsole.log(arr.slice(-2)); // 提取最后两个元素,['c', 'd']\nconsole.log(arr.slice(1,3)); // 提取[1,3)索引的元素,['b', 'c']\nconsole.log(arr.slice(3,1)); // 范围内无元素，提取为空数组,[]\n```\n\n**`concat()`：**合并多个数组，返回合并后的新数组，**不改变原数组**\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar arr3 = [7, 8, 9];\nconsole.log(arr1.concat(arr2,arr3));// [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(arr1);// 不改变原数组 [1, 2, 3]\n```\n\n**数组合并的另一种方式：**使用扩展运算符`...`\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar a = [0, ...arr1, ...arr2, 7];//[0, 1, 2, 3, 4, 5, 6, 7]\n```\n\n**`fill()`：**用固定的值**填充数组**，返回新数组，**改变原数组**\n\n```js\n// 数组中每一个元素都替换为该值\n新数组 = 数组.fill(固定值);\n//从起始位置开始填充\n新数组 = 数组.fill(固定值, 起始索引);\n//从起始位置到结束位置填充，左闭右开\n新数组 = 数组.fill(固定值, 起始索引, 结束索引);\n```\n\n```js\nvar arr = new Array(6).fill(0)//创建一个元素均为0，长度为6的数组\nconsole.log(arr);// [0, 0, 0, 0, 0, 0]\narr.fill('a',2);//索引2后的所有元素填充为'a'\nconsole.log(arr);// [0, 0, 'a', 'a', 'a', 'a']\narr.fill('b',2,4);//索引[2,4)的元素填充为'b'\nconsole.log(arr);// [0, 0, 'b', 'b', 'a', 'a']\n```\n\n### 数组排序\n\n`reverse()`：反转数组，返回反转后的数组，**改变原数组**\n\n```js\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nconsole.log(arr.reverse());// ['e', 'd', 'c', 'b', 'a']\nconsole.log(arr);// ['e', 'd', 'c', 'b', 'a']\n```\n\n`sort()`：排序，元素默认按照**Unicode编码**（逐个字符比较，非字符串先隐式转换为字符串），从小到大进行排序，返回排序后的新数组，**改变原数组**\n\n```js\nvar arr = ['c', 'e', 'a', 'd', 'b'];// 乱序\nconsole.log(arr.sort());// ['a', 'b', 'c', 'd', 'e']\nconsole.log(arr);// ['a', 'b', 'c', 'd', 'e']\n```\n\n当数组内元素是数字时，不能直接使用sort()排序，因为默认是按逐个字符的Unicode编码进行排序\n\n```js\nvar arr = [7, 3, 11, 4, 1, 5];\n//11排到了3的前面，没有按我们所想的从小到大排\nconsole.log(arr.sort());//[1, 11, 3, 4, 5, 7]\n```\n\n对于非字符串排序（**数字的排序**），需要传入一个比较函数，有两个参数 a 和 b（可以是数组中**任意元素**）\n\n`arr.sort(Fun(a, b))`，a：**第一个**用于比较的元素，b：**第二个**用于比较的元素，数组按照**比较函数的返回值**进行排序，而不是Unicode编码。\n\nJS规定了**Fun(a, b)返回值**的效果：\n\n1. 返回值**小于0**，让a排b**前面**\n2. 返回值**大于0**，让a排b**后面**\n3. 返回值**等于0**，a,b的相对位置**不变**\n\n对于[7, 3, 11, 4, 1, 5]这个数组，比较11和4时，不带比较函数，会按Unicode编码从小到大排序，11会排在4前面，带比较函数后，因为a-b=7大于零，所以会让4排11前面。\n\n```js\n//实现整体升序(小到大)\narr.sort((a, b) => a - b);\n//实现整体降序(大到小)\narr.sort((a, b) => b - a);\n```\n\n```js 实际用用\nvar arr = [7, 3, 11, 4, 1, 5];\narr.sort();//[1, 11, 3, 4, 5, 7]\narr.sort((a, b) => a - b);// [1, 3, 4, 5, 7, 11]\narr.sort((a, b) => b - a);// [11, 7, 5, 4, 3, 1]\n```\n\n**Fun(a, b)**具体比较什么，什么情况返回大于0的数，什么时候返回小于0，需要自己去编写，所以可以实现商品的按价格排序：\n\n```js\n//这个数组中存放了几个商品对象，试着让它们按价格升序排序\nvar commodityList = [\n  {\n    name: 'biscuit',\n    price: 10,\n  },\n  {\n    name: 'Coke',\n    price: 3,\n  },\n  {\n    name: 'toy',\n    price: 8,\n  },\n  {\n    name: 'bread',\n    price: 5,\n  },\n];\n\ncommodityList.sort((a, b) => {\n  // 比较价格，规范起见，都进行parseInt()转换，也可以用parseFloat()，看业务需要\n  return parseInt(a.price) - parseInt(b.price);\n});\n\nconsole.log(JSON.stringify(commodityList));\n\n```\n\n```js 输出如下\n[ \n  {\"name\":\"Coke\",\"price\":3},\n  {\"name\":\"bread\",\"price\":5},\n  {\"name\":\"toy\",\"price\":8},\n  {\"name\":\"biscuit\",\"price\":10}\n]\n```\n\n### 查找数组元素\n**`indexOf()`：** **从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n**`lastIndexOf()`：** **从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n\n找到元素返回其索引，没找到返回**-1**，**严格类型约束**，类似===。\n\n```js\nvar arr = ['1', 2, 1, '2'];\nconsole.log(arr.indexOf(1));// 2\nconsole.log(arr.indexOf('1'));// 0\nconsole.log(arr.indexOf('2'));// 3\nconsole.log(arr.indexOf(2));// 1\nconsole.log(arr.indexOf(3));// -1\n```\n\n可以指定第二个参数，指定查找的起始位置，包括该位置\n\n```js\nvar arr = [1, 2, 3, 4, 3, 2, 1];\n//正着从数组一半开始找\nconsole.log(arr.indexOf(1, parseInt(arr.length/2)));// 6\n//倒着从数组一半开始找\nconsole.log(arr.lastIndexOf(1, parseInt(arr.length/2)));// 0\n```\n\n**`includes()`：**判断数组是否包含一个指定的值，**严格类型约束**，返回**布尔**，可以加上第二个参数规定查找的起始位置。\n\n```js\nvar arr = [1, 2, '3', '4'];\nconsole.log(arr.includes(1)); // true\nconsole.log(arr.includes('1')); // false\nconsole.log(arr.includes(2, 2)); // false\nconsole.log(arr.includes('3', 2)); // true\n```\n\n**`find(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素。\n**`findIndex(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n\n找到符合条件的第一个元素就停止查找，没找到返回**find()返回undefined**，**findIndex()返回-1**\n\n```js 找到大于30的第一个元素\nvar arr = [10, 20, 30, 40, 50, 60];\n//用find\nvar result = arr.find((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 40\n//用findIndex\nvar result = arr.findIndex((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 3\n\n```\n\n`every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**，有一项返回 false 立刻停止遍历。\n`some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**，有一项返回 true 立刻停止遍历。\n\n**every()：**全部真，才为真，**some()：**一个真，就为真，\n\n```js every举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.every((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 0;// 判断数组中元素是否都大于0，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n```js some举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.some((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;// 判断是否有大于0的元素，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n### 遍历数组\n**`for循环`遍历**，大多数语言对于数组通用的遍历方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n//1 2 3 4 5\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]\n```\n\n这不够优雅，JS有更简单便捷遍历数组的方法\n\n**`forEach()`**传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n\n```js\narr.forEach(function (item, index, array) {\n\t//做些事情\n});\n```\n\n**回调函数中传递三个参数：**\n1. **参数1（item）：**当前正在遍历的元素\n2. **参数2（index）：**当前正在遍历的元素的索引\n3. **参数3（array）：**正在遍历的数组\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tconsole.log(`${index}:${item}`);\n});\n//0:1 1:2 2:3 3:4 4:5\n```\n\n在**forEach()**的回调函数中**不能通过参数1（item）直接修改数组中的元素**，但元素是一个对象时，可以访问并修改该对象的属性，这是因为数组中存放的是该对象的引用（地址）\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\titem += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"qx\",\"age\":19}]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem.name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]很显然，这是可以的\n\n```\n\n如果要修改数组中的元素，需**通过参数2（index）和3（array）**，`array[index]`来访问数组元素并修改\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tarray[index] += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[2,3,4,5,6]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index] = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index].name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\n```\n\n纯粹只是遍历数组，可以用forEach()，但同时要修改元素时，最好使用**map()**，避免一些低级错误\n\n**`for of`**，ES6新增循环遍历数组方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor(let item of arr) {\n  //item是元素的拷贝，无法直接修改item来修改元素值\n\tconsole.log(item);\n}\n// 1 2 3 4 5\n```\n\n**`for in`**用于遍历无序的对象的属性，而不是有序的数组\n\n```js\nvar obj = {\n  name: 'chuckle',\n  age: '19'\n};\nfor(let key in obj) {\n  //key是属性名，obj[key]可以修改属性值\n\tconsole.log(`属性名：${key}，值：${obj[key]}`);\n}\n//属性名：name，值：chuckle\n//属性名：age，值：19\n\n```\n\n**`map()`**，遍历数组，并对数组中的每一项进行加工。\n\n对数组中每一项运行回调函数，返回每一项加工后的结果，组成的新数组，**不改变原数组**。\n\n```js 语法\nvar newArr = arr.map((item, index, array) => {\n    // item是元素内容，index是该元素索引，array是该数组\n    return newItem;//返回该项加工后的结果\n});\n```\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar newArr = arr.map((item, index, array) => {\n    return item += 1;//返回每一项加一\n});\nconsole.log(JSON.stringify(newArr));//[2,3,4,5,6]\n```\n\n**常用案例：**将 A 数组(通常存对象)中某个属性的值，存储到 B 数组中。\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n\n//把属性name都提取出来\nvar newArr = arr.map((item) => item.name);//返回每个item的name属性\nconsole.log(JSON.stringify(newArr));//[\"张三\",\"李四\",\"王五\"]\n\n//重新组一个对象，改键名\nnewArr = arr.map((item) => ({\n  myName: item.name,\n  myAge: item.age,\n}));//把属性拿出来重新组一个对象\nconsole.log(JSON.stringify(newArr));\n//[{\"myName\":\"张三\",\"myAge\":19},{\"myName\":\"李四\",\"myAge\":18},{\"myName\":\"王五\",\"myAge\":20}]\n\n```\n\n**`filter()`：**数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n\n```js\nvar arr = [7, 2, 3, 6, 7, 4];\nvar newArr = arr.filter(item => {\n    return item > 4;//item > 4回调函数返回true，filter()就把该元素放进新数组里\n});\nconsole.log(JSON.stringify(newArr));//[7,6,7]\n```\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n//筛选出年龄大于18的同学\nvar newArr = arr.filter((item) => item.age > 18);\nconsole.log(JSON.stringify(newArr));//[{\"name\":\"张三\",\"age\":19},{\"name\":\"王五\",\"age\":20}]\n//再用map()筛选出名字\nvar resultArr = newArr.map((item) => item.name);\nconsole.log(JSON.stringify(resultArr));//[\"张三\",\"王五\"]\n\n```\n\n**`reduce()`：**参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n**reduce() 对于空数组不会执行回调函数**\n\n```js 语法\nvar result = arr.reduce((prev, item, index, array) => {}, initialValue);\n```\n\n**回调函数参数解释：**\n1. **prev**：必填，**上一次**调用回调函数时的**返回值**\n2. **item**：必填，当前正在处理的**数组元素**\n3. **index**：可选，当前正在处理的数组元素**下标**\n4. **array**：可选，**该数组**\n5. **initialValue**：可选，作为第一次调用回调函数时**传给prev**的值，最好手动初始化为0\n\n**举例 1、数组求和：**\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6];\nvar result = arr.reduce((prev, item) => {\n    return prev + item;// 累计求和\n});\nconsole.log(`总和:${result}`); // 总和:21\n```\n\n**举例 2、统计某个元素出现的次数：**\n\n```js\nvar arr = [5, 2, 6, 4, 3, 6];\n\n//统计函数，传入数组arr和要统计的value，返回value出现的次数\nfunction arrCount(arr, value){\n  return arr.reduce((prev, item)=>{\n    //判断当前项item是否等于value，是则让prev计数加一并返回\n    return prev += item === value ? 1 : 0;\n  }, 0);\n}\n\nconsole.log(arrCount(arr, 6)); // 2\nconsole.log(arrCount(arr, 7)); // 0\n\n```\n\n**举例 3、找到最大的元素：**\n\n```js\nvar arr = [5, 2, 6, 7, 3, 6];\n\n//传入数组arr,返回最大元素(首次找到)的下标\nfunction maxValue(arr){\n  return arr.reduce((prev, item, index, arr) => {\n    //prev初始值为0，默认下标0的元素最大，每一项与arr[prev]比较，大于就更新prev为当前下标index\n    return prev = item > arr[prev] ? index : prev;\n  }, 0)\n}\n\nconsole.log(maxValue(arr));// 3\nconsole.log(arr[maxValue(arr)]);// 7\n\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(1)","url":"/article/3f7cd15d.html","content":"\n# 这是JavaScript\nHTML描述页面的结构，CSS展现页面的样式，**JS**在页面中描述行为、控制交互。\n\n~~JavaScript里没有Java，就像老婆饼里没有老婆。~~\n\nJavaScript是解释型语言，既是前端语言，又是后端语言，当它运行在浏览器中时是**前端语言**，**后端语言**运行在服务器中也称为服务端语言，NodeJS可以让JS运行在服务端。\n\nJavaScript基础由三部分组成，ECMAScript是语法，DOM和BOM是浏览器提供的API：\n1. **ECMAScript**: JavaScript的语法标准，至少要学习到**ES6**，它规定了JS最基础的语句、变量、函数、运算等等。\n2. **DOM**: 文档对象模型（Document Object Model），JS**操控网页元素**的API。\n3. **BOM**: 浏览器对象模型（Browser Object Model），JS**操控浏览器**的API。\n\n# 使用JS\n1. **行内**: 写在标签属性中。<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```js\n<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```\n2. **内嵌**: 写在`<script></script>`标签中。\n```html\n<script type=”text/javascript”>\n  alert('你好');\n</script>\n```\n3. **外链**: 在`<script></script>`标签的src属性中写上js文件的链接。\n```html\n<script type=\"text/javascript\" src=\"main.js\"></script>\n```\n\n# 执行顺序\n浏览器默认从**上至下**解析网页，JS的加载默认会阻塞网页的解析，通过JS操控网页元素，需待网页解析完后执行、写在html的最后或写在对应元素后，否则就可能因为DOM树不完整，要操控的对象还未被加载而报出undefined错误。\n\n```html\n<!-- 不等待后续网页的解析，到此就加载JS并执行 -->\n<script src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，但JS在网页解析完后执行 -->\n<script defer src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，JS加载完后立即执行 -->\n<script async src=\"main.js\"></script>\n```\n\n```js\n//待网页解析完、网页中所有资源（图片、css）都加载完毕，执行其中的代码\nwindow.onload  = function () {\n  //js代码\n  alert('你好');\n}\n```\n\n# 输出语句\n1. `console.log()`: 在控制台输出内容\n```js\nconsole.log('日志'); //普通打印\nconsole.warn('警告'); //警告打印\nconsole.error('出错了'); //错误打印\n```\n2. `alert()`: 警告对话框 <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"alert('这是一个警告')\" />\n3. `confirm()`: 确认对话框，返回true或false <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = confirm('确认吗');if(a){alert('你确认了')}else{alert('未确认')}\" />\n```js\nvar a = confirm('确认吗');\nif(a){\n  alert('你确认了')\n}else{\n  alert('未确认')\n}\n```\n4. `prompt()`: 输入对话框，返回输入内容或空字符串，点取消返回NULL <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = prompt('输入内容');if(a){alert('你输入了：'+a)}else if(a==''){alert('你没输入任何东西')}else{alert('取消')}\" />\n```js\nvar a = prompt('输入内容');\nif(a){\n  alert('你输入了：'+ a)\n}else if(a==''){\n  alert('你没输入任何东西')\n}else{\n  alert('取消')\n}\n```\n\n# 常量、变量、标识符\n数字常量、字符串常量、布尔常量\n```js\nconsole.log(123); //123是数字\nconsole.log('123'); //'123'是字符串，''空字符串\nconsole.log('你好'); //''包裹起来的都是字符串\nif(true){ //true、false布尔常量\n  console.log('true'); \n}\n```\n\n自定义常量const\n```js\nconst a = '123'; //定义a为常量\na = '321'; //不允许修改常量\nconst a = '321'; //不允许重新声明\n```\n\n定义变量var、let(ES6)\n```js\nvar a = '123';\nlet b = 321;\n//重新定义\nvar a = '321'; //var允许重新定义\nlet b = 123; //let不允许重新定义\n//不允许var和let之间重新定义\nvar c = 123;\nlet c = 123;\n```\n\nvar可以在声明前使用，值为undefined，而let必须先声明再使用。\n\nvar是**函数作用域**，let是**块作用域**。\n\n**标识符**（一切可自主命名的，如变量名、函数名）命名规则：\n1. 区分大小写\n2. 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成\n3. 不能以数字开头、不允许出现空格\n4. 不能出现中划线 -\n\n# 数据类型\nJavaScript是**弱类型语言**（动态语言），无需声明变量的类型，在程序运行过程中，会根据**等号右边的值**自动确定类型。\n\n```js\nvar a = 123;\nconsole.log(typeof a);//输出number\na = '123'//强制将变量a数据类型转换为字符串\nconsole.log(typeof a);//输出string\na = Number(a);//强制将字符串'123'转换为数字123\nconsole.log(a);//输出123\n```\n\nJS中数据类型分为**基本数据类型**和**引用数据类型**\n1. **基本数据类型**（值类型）: String字符串、Number数值、BigInt(ES6)大型数值、Boolean布尔值、Null空值、Undefined未定义、Symbol(ES6)。\n2. **引用数据类型**（引用类型）：Object 对象(除了基本数据类型之外，都可称之为Object类型)。\n\n基本数据类型**传数值**，引用数据类型**传地址**。\n\n```js\nvar a = 23;\nvar b = a;//将a的值23传给b\na++;\nconsole.log(a); //24\nconsole.log(b); //23，改变a的值不影响b\n```\n\n```js\nvar a = new Object();//a、b都是引用数据类型\nb.name = '123';\nvar b = a;//传的是a的地址，a和b是同一个东西\na.name = '321';\nconsole.log(a.name); //321\nconsole.log(b.name); //321，修改a对象的属性也会修改b\n```\n\nJS中，所有的变量都保存在**栈内存**中的。\n\n基本数据类型直接保存在**栈内存**中。值与值之间独立存在。\n\n对象Object保存在**堆内存**中，创建一个新的对象，在堆内存中开辟一个新的空间，变量在**栈内存**中保存了对象的**内存地址**（对象的引用）。\n\n# String字符串\n字符串是双引号和单引号中的文本，不同类型引号可以嵌套使用。\n\n```js\nvar a = '123';\nconsole.log(a);//123\nvar b = '1\"2\"3';\nconsole.log(b);//1\"2\"3\nvar c = '12    3';\nconsole.log(c);//12    3不忽略连续多个空格\n```\n\n加入字符串进行拼接，可以被同化为字符串\n\n```js\nconsole.log(typeof(123+''));//string\n```\n\n转义字符: `\\`\n* 双引号: `\\\"`，单引号 `\\'`\n* `\\\\` 表示\\\n* `\\r` 回车，`\\n` 换行\n* `\\t` 缩进\n* `\\b` 空格\n\n字符的数量就是**字符串的长度**，获取字符串的长度`.length`：\n\n```js\nvar a = \"abc\";\nconsole.log(a.length);//3\na = \"你好\";\nconsole.log(a.length);//2\n```\n\n使用 **+** 进行**字符串拼接**：\n\n```js\nvar a = \"你好\"+\"世界\";\nconsole.log(a);//你好世界\na = \"你好\"+ 1;\nconsole.log(a);//你好世界1\na = \"你好\"+ null;\nconsole.log(a);//你好null\na = \"你好\"+ true;\nconsole.log(a);//你好true\n```\n\nES6新增**模板字符串**：**``**，可以使用`${变量名}`将其嵌入字符串，使用时需要反引号 **``** 包裹。\n```js\nvar a = 2022;\nvar b = '2023';\nconsole.log(`去年是${a}，今年是${b}`); //去年是2022，今年是2023，注意使用反引号\n```\n\n模板字符串中可以换行，不忽略连续的多个空格，保留原有格式。\n\n可以调用函数：\n\n```js\nfunction getHtml() {\n    return `<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>`;\n}\nconsole.log(`1${getHtml()}2`);\n/*\n1<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>2\n*/\n```\n\n可以嵌套使用，进行运算：\n\n```js\nvar a = 1;\nvar b = 2;\nconsole.log(`${a+`${b}`}`);//12\nconsole.log(`${a+b}`);//3\n```\n\n# Number数值型\nJS中整数和浮点数等所有的数值都是Number类型。\n\n```js\nvar a = 1;\nvar b = 1.2;\nconsole.log(typeof a);//number\nconsole.log(typeof b);//number\n```\n\n数值范围:\n\n```js\nconsole.log(Number.MAX_VALUE);//1.7976931348623157e+308\nconsole.log(Number.MIN_VALUE);//5e-324\n```\n\n数值变量超过了最大值，则会返回**Infinity**，Infinity也是一种数值，代表无穷大。\n\n```js\nvar a = Number.MAX_VALUE;\nvar b = Number.MIN_VALUE;\nconsole.log(a*2);//Infinity\nconsole.log(b/2);//0\nconsole.log(a*(-2));//-Infinity\nconsole.log(typeof Infinity);//number\n```\n\n**NaN**是一个特殊的数字，表示不是数值(Not a Number)，当运算不出数值时就会返回NaN。\n\n```js\nconsole.log(typeof NaN);//number\nconsole.log('abc' / 2);//NaN\nconsole.log('a' * '2');//NaN\n```\n\nUndefined和任何数值计算的结果均为NaN。NaN与任何值都不相等，包括NaN本身。\n\n```js\nconsole.log(undefined + 1);//NaN\nconsole.log(null + 1);//1\nconsole.log(NaN==NaN);//false\n```\n\n**隐式转换**，当有字符串介入的运算，且字符串可被转换为数值，除了+表示字符串连接，其余都会自动将字符串转为数值后进行运算。\n\n```js\nconsole.log('1' + '2');//12\nconsole.log('1' * '2');//2\nconsole.log('1' / 2);//0.5\nconsole.log('1' - 2);//-1\nconsole.log('1' + '2' * '3');//16\n```\n\n浮点数的**运算精度**并不足够准确，当需要进行高精度运算时，最好引入可靠的数学库。\n\n```js\nvar a = 0.1 + 0.2;\nconsole.log(a); //0.30000000000000004\n```\n\n# Null与Undefined\nundefined实际上是由null衍生出来的。\n\n**undefined**表示未定义，应该有值但还未赋值，连null这个值都没有赋予给它。\n**null**代表空值，本身是一个具体的值或空引用。\n\nnull和undefined值上**相等**，但类型不一样。\nnull是引用类型Object，代表空对象，存的地址为空，而undefined的类型是undefined，代表未定义的值。\n\n```js\nconsole.log(null == undefined);//true\nconsole.log(null === undefined);//false\n\nconsole.log(typeof null);//object\nconsole.log(typeof undefined);//undefined\n```\n\nnull转为数值是0，undefined转为数值是NaN。\n任何值和null运算，null可看做0。任何数据类型和undefined运算，结果都是NaN。\n\n```js\nconsole.log(Number(null));//0\nconsole.log(Number(undefined));//NaN\n\nconsole.log(null+1);//1\nconsole.log(undefined+1);//NaN\n```\n\n**出现undefined的情况**：\n1. 变量被声明了，但是没有被赋值\n2. 变量未声明（未定义）时\n3. 调用函数时，未传参\n4. 函数无返回值时\n5. 访问一个对象中没有的属性\n\n```js\nconsole.log(a);//undefined\nvar a;\nconsole.log(a);//undefined\n\nfunction Fun(item) {\n  console.log(item);\n}\nconsole.log(Fun());//undefined\nFun();//undefined\n```\n\n**出现null的情况**：\n1. 访问一个不存在的dom节点\n2. 作为对象原型链的终点出现\n\n# 数据类型转换\n变量的**数据类型转换**：将一种数据类型转换为另外一种数据类型。（通常在基本数据类型中互相转换）\n\n1. **显式类型转换**\n  1. `toString()` 转换为字符串\n  2. `String()` 强制转换为字符串\n  3. `Number()` 转为数值，保留小数\n  4. `parseInt()` 字符串转整数,**直接舍去小数部分**\n  5. `parseFloat()` 在parseInt()的基础上可以获得小数部分\n  6. `Boolean()` \n2. **隐式类型转换**\n  1. `isNaN()` \n  2. 自增/自减\n  3. 正号/负号\n  4. 加号(字符串拼接)\n  5. 其它数值运算符\n  6. 逻辑运算符：会先非布尔值转换为布尔值，再运算\n  7. 关系运算符：运算结果都是布尔值\n\n## 转为字符串\n\n`toString()`:\n\n```js\nvar a = 123;\nconsole.log(a.toString());//\"123\"\na = true;\nconsole.log(a.toString());//\"true\"\na = [1, 2, 3];\nconsole.log(a.toString());//\"1,2,3\"\na = { name: 'qx', age: 18 };\nconsole.log(a.toString());//\"[object Object]\"\n```\n\nnull和undefined这没有toString()方法，调用会报错\n\n```js\nvar a = null; \nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\na = undefined;\nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\n```\n\nNumber类型的变量，在调用toString()时，可以传入一个整数，把数字转换为指定的进制，默认转换为10进制。\n\n```js\nvar a = 8;\na = a.toString(2); //转换为二进制\nconsole.log(a); //\"1000\"\nconsole.log(typeof a);//string\n```\n\n数字不允许直接调用toString()\n```js\n1.toString()//不允许，会把.看成小数点，小数点后面出现非数字是不允许的\n1..toString()//允许\n(1).toString()//允许\n```\n\n使用`String()`强制转换为字符串。\n对于**非**null和undefined的数据类型而言，实际上就是调用toString()。\n对于null和undefined，直接转换为\"null\"和\"undefined\"。\n\n```js\nvar a = 123;\nconsole.log(String(a));//\"123\"\na = null;\nconsole.log(String(a));//\"null\"\na = undefined;\nconsole.log(String(a));//\"undefined\"\n```\n\n字符串拼接，隐式转换：\n\n```js\nvar a = 123;\nconsole.log(a+'');//\"123\"\n```\n\n## 转为数值\n\n`Number()`转为数值类型\n1. **字符串转数字**\n  1. 字符串中是纯数字，直接将其转换为数字\n  2. 空字符串或全是空格，转换为0\n  3. 字符串中包含了非数字的内容，转为NaN\n2. **布尔值转数字**：true --> 1，false --> 0\n3. **null --> 0，undefined --> NaN**\n\n加上**正负号隐式转换**。规则和Number()一样，但是改变正负性，0也会带上负号：\n\n```js\nvar a = '123';\nconsole.log(+a); //123\nconsole.log(-a); //-123\nconsole.log(typeof +a);//number\na = null\nconsole.log(+a); // 0\nconsole.log(-a); // -0\n```\n\n`parseInt()` **字符串转整数**，布尔、null等非字符串、非数值类型都转为NaN，逐个字符转，碰见非数字字符就停止，没有提取到数值，就返回NaN。\n\n```js\nparseInt('123abc'); //123\nparseInt('abc123'); //NaN\nparseInt(''); //NaN\nparseInt('       '); //NaN\nparseInt(null); //NaN\nparseInt(undefined); //NaN\nparseInt(true); //NaN\n```\n\nparseInt()会自动截断、舍弃小数，而Number()不会。\n\n```js\nvar a = parseInt('5.1') + parseInt(5.9);\nconsole.log(a);//10\na = Number('5.1') + Number(5.9);\nconsole.log(a);//11\na = parseInt(5.1 + 5.9);\nconsole.log(a);//11\n```\n\nparseInt()可以多带一个进制参数，把数值**看成对应进制**，再转成10进制返回。无论parseInt()里面的进制参数是多少，最终的转换结果是十进制。\n\n```js\nvar a = parseInt('101', 2);\nconsole.log(a);//5 二进制101就是十进制的5\n\na = parseInt('3', 2);\nconsole.log(a);//二进制中没有3，所以转换失败返回NaN\n```\n\n`parseFloat()` 字符串转小数，与parseInt()相似。\n\n```js\nparseFloat('123.321abc'); //123.321\nparseFloat('12.1a3.321'); //12.1\nparseFloat('12.13.321'); //12.13\n```\n\n## 转为Boolean\n任何数据类型都可以转为 Boolean 布尔型。\n1. **数值型**: 0 和 NaN的转为 false，其它都是 true\n2. **字符串**: 空串转为 false，其它都是 true。全是空格的字符串，转换结果也是 true。\"0\"也是 true。\n3. **null 和 undefined** 都转为 false\n4. **引用数据类型**都转为 true，因为地址永不为空或0。空数组[]和空对象{}，也是 true\n\n```js\nvar a;\nBoolean(a);//false,a未赋值，undefined\na = '';\nBoolean(a);//false\na = [];\nBoolean(a);//true\na = {};\nBoolean(a);//true\n```\n\n使用`!!`或`!`显式转换为 Boolean 类型：\n\n```js\nvar a = 1;\na = !a\nconsole.log(a);//false\na = !!2;\nconsole.log(a);//true\n```\n\n`isNaN()`判断是否是**非数值类型**，任何**不能直接转为数值类型**的数据类型都可以让这个函数返回true\n\n```js\nisNaN('123');//可以转为123，返回false\nisNaN(null);//转为0，false\nisNaN('123abc');//true\nisNaN(undefined);//true\n```\n\n# 运算符和运算\n各种编程语言的运算符功能都大差不差，只介绍JS中比较特殊的运算或特例。\n\n浮点数值的最高精度是 17 位小数，会有丢失精度的风险，**不要直接判断两个浮点数是否相等**\n\n**Boolean + 数字 = 数字**，true按1来算，false按0。\n**null + 数字 = 0 + 数字**\nundefined + 数字 = NaN\n任何值和 NaN 运算的结果都是 NaN\n任何**非数值类型**进行除加法以外的运算`-、*、/、%`时，都会**自动用Number()转成数值类型**再参与运算\n\n```js\ntrue + 1; //2\nnull + 1; //1\nvar a = 2 - '1'; //1\nvar a = '2'/'1'; //2\n```\n\n非布尔值进行与或运算(`&&、||`)时，会先将其转换为布尔值，然后再运算，但返回结果是原值。\n\n**与运算 &&**的返回结果：从左到右依次运行语句，找到第一个为 false 的值，返回原值，不再往后执行。如果所有的值都为 true，则返回最后一个值。\n\n```js\nvar a = '' && 123;\nconsole.log(a);//'',空字符串转为布尔型为false，只执行第一条语句并返回原值\nvar a = [] && 0;\nconsole.log(a);//0，[]转为布尔型为true，直接返回第二个语句的值\nvar a = \"0\" && 0 && 1;\nconsole.log(a);//0\n```\n\n**或运算 ||**的返回结果：从左到右依次运行语句，找到第一个为 true 的值，返回原值，不再往后执行。如果所有的值都为 false，则返回最后一个值。\n\n```js\nvar a = '' || null;\nconsole.log(a);//null\nvar a = 0 || [];\nconsole.log(a);//[]\nvar a = \"0\" || 0 || 1;\nconsole.log(a);//\"0\"\n```\n\n**比较运算符** `>、<、==、!= 等`，得到的结果都是布尔值：要么是 true，要么是 false，非数值进行比较，会将其转换为数值类型。\n\n**特殊情况**：如果参与比较的**都是字符串**，则不会将其转换为数字进行比较，比较的是字符串的Unicode编码。\n比较字符编码时，从**左到右逐位**进行比较，一样大则继续比较下一位，直到比较出大小。\n\n```js\nconsole.log('100' > 9 );//true,将'100'转为数值100进行比较\nconsole.log('100' > '9' );//false,两个字符串逐位比较，9比1大，返回false\n```\n\n`== 、===` ==进行比较时，会做**隐式转换**，将不同的数据类型，转为相同类型进行比较，而全等符号===不会进行转换，不同类型的数据比较一定是false。\n\n```js\nconsole.log('1' == 1); //true\nconsole.log('1' === 1); //false\n\nconsole.log(1 == true); //true\nconsole.log(1 === true); //false\n\nconsole.log(undefined == null); //true\nconsole.log('1a' > 1); // false。'1a'转成NaN\n\n//NaN不和任何值相等，包括它本身\nconsole.log(NaN == NaN); //false\nconsole.log(NaN === NaN); //false\n```\n\nnull与数字进行比较有一个Bug，不必在意，当特性就行：\n\n```js\nconsole.log(null < 0); //false\nconsole.log(null == 0); //false\nconsole.log(null > 0); //false\n\nconsole.log(null <= 0); //true。这是一个bug\nconsole.log(null >= 0); //true。同上\n```\n\n日期大小比较\n\n```js\nvar date1 = new Date(2023, 3, 28)\nconsole.log(date1);//Fri Sep 08 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date2 = '2023-03-27';\nvar date3 = '2023/03/29';\nconsole.log(date1 > date2);//false，date1和date2字符串格式很不相同，比较无意义\nconsole.log(date3 > date2);//true,格式基本相同，分割位置一样，字符串逐位比较大小\n```\n\n# if和switch\n这部分各大语言也大差不差，只记录值得注意的点。\n\ncase的判断逻辑是**===**，不是**==**\n\nswitch中的default无论放到什么位置，都会等到所有case都不匹配再执行，但一般放在最后\n\n当case或default匹配到一个值后，会执行后续所有的case，除非遇到break或执行到switch的末尾。\n\n# 循环\n这部分各大语言也大差不差，只记录值得注意的点。\n\n**break**会立即终止离它最近的**循环语句**，**continue**跳过当次循环，继续下一次循环。\n\n可以为循环语句创建一个**label**，来标识当前的循环。使用break、continue语句时，break label将会结束指定的循环，而不是最近的。\n\n```js\none: for (var i = 0; i < 100; i++) {\n    for (let j = 0; j < 100; j++) {\n        if(i>j) {\n          break one;\n        }\n    }\n}\nconsole.log(i);//1\n```\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"博客添加待办清单页","url":"/article/9875347c.html","content":"\n# 前言\n&emsp;&emsp;要做的事还有很多，想做的事源源不断，那就都记录在博客里吧，[ToDoList](/todolist/)。\n\n<img src=https://cdn.chuckle.top/images/40-1.webp width=\"90%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\page\\todolist.pug`\n\n```pug\n#todolist-box\n    .page-top-card(style='background-image: url(/img/todo.webp);')\n        .content-item-tips 想做清单\n        span.content-item-title ToDoList\n        .content-bottom\n            .tips 要做的事还有很多，想做的事源源不断\n    #todolist-main\n        #todolist-left\n            each i in site.data.todolist\n                if i.seat == 'left'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n        #todolist-right\n            each i in site.data.todolist\n                if i.seat == 'right'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n\n```\n\n&emsp;&emsp;修改`\\layout\\page.pug`\n\n```pug\ncase page.type\n    when 'tags'\n        include includes/page/tags.pug\n        include includes/page/default-page.pug\n    when 'link'\n        include includes/page/flink.pug\n    when 'categories'\n        include includes/page/categories.pug\n        include includes/page/default-page.pug\n    when 'essay'\n        include includes/page/essay.pug\n+    when 'todolist'\n+        include includes/page/todolist.pug\n    default\n        include includes/page/default-page.pug\n\n```\n\n&emsp;&emsp;新建`\\source\\_data\\todolist.yml`\n\n```yml seat控制清单在左栏还是右栏显示，completed控制是否已完成\n- class_name: 想做的项目\n  seat: left\n  todo_list:\n    - content: 个人主页\n      completed: false\n    - content: 公众号\n      completed: false\n\n- class_name: 想看的书\n  seat: left\n  todo_list:\n    - content: 《毛泽东选集》\n      completed: false\n    - content: 《86不存在的战区》\n      completed: false\n\n- class_name: 想买的东西\n  seat: left\n  todo_list:\n    - content: 小米平板5pro\n      completed: true\n    - content: 致态固态硬盘\n      completed: true\n\n- class_name: 想学的技术\n  seat: right\n  todo_list:\n    - content: Vue2/Vue3\n      completed: false\n    - content: Electron\n      completed: false\n\n- class_name: 想去的地方\n  seat: right\n  todo_list:\n    - content: 桂林\n      completed: true\n    - content: 杭州\n      completed: false\n\n```\n\n&emsp;&emsp;添加CSS:\n\n```css\n#todolist-box{\n    margin: 0 10px;\n}\n#todolist-main{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin: 16px 0 10px;\n}\n#todolist-main li{\n    list-style:none;\n    font-size: 17px;\n}\n#todolist-main ul{\n    margin: 0;\n    padding: 0;\n}\n#todolist-left{\n    width: 50%;\n    padding: 0 8px 0 0;\n}\n#todolist-right{\n    width: 50%;\n    padding: 0 0 0 8px;\n}\n.todolist-item{\n    position: relative;\n    background: #fae4df;\n    border-radius: 12px;\n    padding: 10px 1rem 1.2rem;\n    border: 2px dashed #f7a796;\n    margin-bottom: 1rem;\n}\n[data-theme=dark]\n.todolist-item{\n    background: #242424;\n    border: 2px dashed #51908b;\n}\nli.todolist-li i{\n    margin-left: 10px;\n}\nh3.todolist-title{\n    margin: 0!important;\n    border-bottom: var(--todo-border);\n}\nli.todolist-li{\n    border-bottom: var(--todo-border);\n    font-weight: normal;\n}\n.todolist-li span{\n    margin-left: 5px;\n}\n@media screen and (max-width:700px){\n    #todolist-left,#todolist-right{\n        width: 100%;\n        padding: 0;\n    }\n  }\n.page-top-card{\n  background-size: cover;\n  background-position: center;\n  height: 20.5rem;\n  padding: 10px 2.7rem;\n  border-radius: 20px;\n  color: white;\n  position: relative;\n}\n.page-top-card span.content-item-title{\n  font-size: 2.3em;\n  font-weight: bold;\n  line-height: 1.2;\n  font-family: STZhongsong,'Microsoft YaHei';\n}\n.page-top-card .content-bottom{\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: absolute;\n  width: calc(100% - 5.4rem);\n  bottom: 1rem;\n}\n[data-theme='dark'] .page-top-card{\n  opacity: .92;\n}\n\n```\n\n&emsp;&emsp;新建页面\n\n```markdown\n---\ntitle: ToDoList\ndate: 2023-03-18 14:07:13\ncomments: false\naside: false\ntype: todolist\n---\n\n```\n\n# 后记\n&emsp;&emsp;无\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"网站添加点赞、踩功能","url":"/article/5de26c08.html","content":"\n# 前言\n&emsp;&emsp;看[@Shine](https://blog.shineyu.cn/)在博客里整了个点赞功能[Qexo添加点赞功能](https://blog.shineyu.cn/qexo-postlike.html)，心动，那就行动。\n\n<img src=https://cdn.chuckle.top/images/39-2.webp width=\"30%\">\n\n&emsp;&emsp;懒得整一个Qexo系统，那就看看有木有现成的点赞系统拿来改改用。找到力[orlike-vercel](https://github.com/caibingcheng/orlike-vercel)\n\n&emsp;&emsp;最终效果：\n\n<img src=https://cdn.chuckle.top/images/39-3.webp width=\"70%\">\n\n# 实现\n\n## 部署OrLike\n\n&emsp;&emsp;注册登录[leancloud](https://leancloud.app/)，最好是国际版，创建一个应用，名称随意。在侧栏找到**数据存储->结构化数据**，点击创建Class，名称为**OrLike**，默认ACL权限修改为所有用户。\n\n&emsp;&emsp;接着在侧栏找到**设置->应用凭证**，复制AppID和AppKey，后续用到。\n\n&emsp;&emsp;数据库设置完成，点击下面链接部署后端到Vercel。\n\n{% link Vercel部署OrLike点赞系统,https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fcaibingcheng%2Forlike-vercel%}\n\n&emsp;&emsp;部署完成后，在该Vercel项目的设置中找到环境变量，填入名为APPID（值对应之前复制的AppID）和APPKEY（对应AppKey）的环境变量，然后**重新部署**。\n\n&emsp;&emsp;由于vercel默认域名被墙，最好绑定自己的二级域名，该域名链接即为api。\n\n## 前端部署\n&emsp;&emsp;以Hexo-butterfly主题框架为例：\n\n&emsp;&emsp;修改`layout\\includes\\post\\reward.pug`，在末尾添加以下代码。\n\n```js\n#orlike-box.orlike-box\n  script.\n    (() => {\n      function loadOrLike () {\n        new OrLike({\n          serverUrl: \"你的api\",\n          el: \".orlike-box\",\n          days: 30,\n        });\n      }\n      window.pjax ? loadOrLike() : window.addEventListener('load', loadOrLike)\n    })()\n\n```\n\n&emsp;&emsp;修改`layout\\includes\\header\\post-info.pug`，在末尾添加以下代码，注意缩进在**.meta-firstline**内。\n\n```pug\nspan.post-meta-orlike\n    i.iconfont.icon-aixin.fa-fw.post-meta-icon\n    span.post-meta-label= '点赞数:'\n    a(href=url_for(page.path) + '#orlike-box')\n        span.orlike-count\n```\n\n&emsp;&emsp;在配置文件中全局引入该js和JQ：\n\n```js orlike.js(对OrLike项目源码仓库的orlike.min.js有修改，以适配业务)\nconst version = \"V0.1.33\"; function setCookie(cname, cvalue, exdays) { var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toGMTString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires; }\nfunction getCookie(cname) {\n    var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name) == 0) { return c.substring(name.length, c.length); } }\n    return \"\";\n}\nfunction createLink(url) { let link = $(document.createElement('link')); link.attr('href', url); link.attr('rel', 'stylesheet'); link.attr('type', 'text/css'); $('link').last().after(link); }\nfunction OrLike({ serverUrl = \"\", el = \"\", days = 30, style = \"\", ifont = \"\", icon = { like: \"fa fa-thumbs-up\", dislike: \"fa fa-thumbs-down\" }, } = {}) { this.serverUrl = serverUrl; this.el = el; this.style = style; this.ifont = ifont; this.days = days; this.icon = icon; this.ckid = \"\"; this.prepare(); this.init(); }\nOrLike.prototype.prepare = function () {\n    $(this.el).addClass(\"orlike-loading\"); if (this.style != \"\") { createLink(this.style); }\n    if (this.ifont != \"\") { createLink(this.ifont); }\n}\nOrLike.prototype.init = function () {\n    server_url = this.serverUrl; obj = this; $.ajax({\n        type: 'GET', url: server_url + '/tmp', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: true, crossDomain: true, success: function (data) {\n            let template = $(data.template); let icon_like = template.siblings(\"a.likeit.orlike\").children(\"i\"); let icon_dislike = template.siblings(\"a.dislikeit.orlike\").children(\"i\"); icon_like.attr('class', obj.icon.like); icon_dislike.attr('class', obj.icon.dislike); if (obj.icon.like == false)\n                icon_like.remove(); if (obj.icon.dislike == false)\n                icon_dislike.remove(); $(obj.el).removeClass(\"orlike-loading\"); $(obj.el).html(template); obj.ckusr(obj); $('a.likeit.orlike').click({ obj: obj }, obj.like); $('a.dislikeit.orlike').click({ obj: obj }, obj.dislike);\n        },\n    });\n}\nOrLike.prototype.ckusr = function (obj) {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/ckusr', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: false, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok' && data.uid != \"\") {\n                obj.ckid = data.ckid; if (!getCookie(data.ckid)) { setCookie(data.ckid, data.uid, obj.days); }\n                obj.query();\n            }\n            else { console.error('connect orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.query = function () {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/qry?link=' + window.location.pathname, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok') { \n                $('a.likeit.orlike i span').text(data['like']);\n                $('span.post-meta-orlike a span').text(data['like']);\n                $('a.dislikeit.orlike i span').text(data['dislike']);\n            }\n            else { console.error('query orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.orl = function (obj, method) { server_url = obj.serverUrl; req_url = server_url + '/orl?method=' + method + '&link=' + window.location.pathname + '&' + obj.ckid + '=' + getCookie(obj.ckid); $.ajax({ type: 'GET', url: req_url, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) { obj.query(); }, }); }\nOrLike.prototype.like = function (event) { obj = event.data.obj; obj.orl(obj, 'like'); }\nOrLike.prototype.dislike = function (event) { obj = event.data.obj; obj.orl(obj, 'dislike'); }\n\n```\n\n```yml\ninject:\n  head:\n  bottom:\n    - <script defer=\"true\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\n    - <script defer=\"true\" src=\"/js/orlike.js\"></script>\n```\n\n&emsp;&emsp;引入CSS：\n\n```css\n.orlike {\n  color: rgba(255, 255, 255);\n  font-size: 26px!important;\n  line-height: 2;\n  text-shadow: 5px 5px 5px #2ed0d9fc;\n}\n[data-theme=dark]\n.orlike {\n    color: rgba(255, 255, 255, 0.85);\n    text-shadow: 4px 4px 4px #23a8af99;\n}\n.orlike:first-child{\n    margin-right: 36px;\n}\n.orlike span {\n  margin-left: 0.3rem;\n}\n.orlike-box{\n    margin: 15px 0 0 0;\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n    height: 52px;\n}\n.orlike:hover{\n    color: #f07e7e!important;\n}\n[data-theme=dark]\n.orlike:hover{\n    color: #e87373e8!important;\n}\n.orlike-loading {\n    display: block;\n    height: 39px;\n    width: 10px!important;\n    border-radius: 50%;\n    border: 2px solid #acacac;\n    border-bottom-color: transparent;\n    -webkit-animation: orlike-loadingRotate 0.75s linear infinite;\n    animation: orlike-loadingRotate 0.75s linear infinite;\n}\n@-webkit-keyframes orlike-loadingRotate {\n  0% {\n    -webkit-transform: rotate(0deg);\n  }\n  50% {\n    -webkit-transform: rotate(180deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n  }\n}\n@keyframes orlike-loadingRotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n```\n\n\n&emsp;&emsp;完毕。\n\n# 后记\n&emsp;&emsp;无\n\n***\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"体验ChatGPT 不仅是搜索的革命","url":"/article/b19faa1c.html","content":"\n# 前言\n&emsp;&emsp;**本文由ChatGPT辅助编写文案**\n\n&emsp;&emsp;最近ChatGPT热度火爆，见多了小爱同学和siri，但哪见过这种ai，于是我也注册了个账号开始体验。\n\n&emsp;&emsp;ChatGPT的强大不仅在于它搜索答案的能力，而是它背后的模型分析问题的能力，它的回答不一定对，但它对于并不抽象的问题的分析与理解，已经与人无异了。\n\n***\n\n# 什么是ChatGPT\n\n&emsp;&emsp;什么是ChatGPT：ChatGPT是由OpenAI训练的大型语言模型，用于自然语言处理任务，如对话生成、文本摘要、机器翻译等。它是目前最先进的对话生成模型之一，可以根据给定的文本提示生成连贯、有逻辑的回复。\n\n&emsp;&emsp;所用到的技术：ChatGPT是一种基于自然语言处理（NLP）技术的对话生成模型，它使用了深度学习中的变压器（Transformer）网络结构，并通过对大量文本数据的预训练来学习语言模型。下面是一些ChatGPT使用的技术和方法：\n\n1. 变压器网络结构：变压器是一种序列到序列（seq2seq）模型，能够处理变长的输入和输出序列，适用于自然语言处理任务。ChatGPT使用了包含多个编码器和解码器的变压器结构，通过编码用户输入的文本并解码生成回复。\n2. 预训练：ChatGPT使用了大量的文本数据进行预训练，学习了语言模型中的单词嵌入、语法结构、上下文信息等。这些预训练模型可以被微调到特定的对话生成任务中，从而提高模型的表现。\n3. 无监督学习：ChatGPT是一种无监督学习模型，不需要人工标注数据就可以学习对话生成任务。它可以从大量的未标注文本数据中自动学习上下文信息、语言模式和语法结构，从而生成连贯的对话回复。\n4. 控制生成：ChatGPT可以通过添加特定的控制信息来控制对话的生成，例如指定回复的情感、主题或风格。这可以通过在输入中添加相应的标记或特定的控制向量来实现。\n\n&emsp;&emsp;总之，ChatGPT是一种基于深度学习和自然语言处理技术的先进对话生成模型，具有高度的可扩展性和灵活性，可以用于多种对话生成场景。\n\n***\n\n# 搜索答案的能力\n\n&emsp;&emsp;向ChatGPT问21年之前信息的问题，它几乎都能回答，但其回答并不一定对。下面是一些例子。\n\n&emsp;&emsp;先来点医学方面的，连花清瘟对于治疗新冠有效果吗?并列举相关的研究论文。\n\n<img src=https://cdn.chuckle.top/images/38-2.webp width=\"100%\">\n\n&emsp;&emsp;再来点物理方面的，就问问它宇宙微波背景辐射吧。\n\n<img src=https://cdn.chuckle.top/images/38-3.webp width=\"100%\">\n\n&emsp;&emsp;最后问几个关于鸿蒙系统的问题。\n\n<img src=https://cdn.chuckle.top/images/38-4.webp width=\"100%\">\n\n&emsp;&emsp;这些问题可以看出ChatGPT对于搜索内容的整合，语言再组织能力非常强，条理清晰，结合上文回答问题也非常自然，可以理解“它”对于事物的指代，问题没有主语时也能根据前文的主语来回答后文的问题，当有它无法回答的问题时也能给出合理的建议。\n\n***\n\n# 编写程序的能力\n&emsp;&emsp;ChatGPT是一个自然语言处理模型，如果你需要让ChatGPT辅助你编写代码，可以通过以下几种方式：\n1. 与 ChatGPT 进行对话：你可以与 ChatGPT 进行对话，让它为你提供编码建议或解决编程问题的思路。\n2. 利用 ChatGPT 生成代码：你可以向 ChatGPT 提供关于你需要实现的功能或任务的自然语言描述，让 ChatGPT 帮你生成对应的代码。\n3. 利用 ChatGPT 进行代码搜索：你可以向 ChatGPT 提供一些关键字或问题描述，让它搜索互联网上的代码资源，并为你提供相关的代码片段或链接。\n4. 需要注意的是，虽然 ChatGPT 可以提供辅助，但它并不是一个完全的编程工具，它不能替代人类程序员的职责和责任，仍然需要开发人员自己进行实际的编程工作和质量控制。\n\n&emsp;&emsp;让ChatGPT使用js写一个获取网页指定文本并高亮的程序，这看其来是可行的。因为问题的限定较少所以代码也较简单，可以加一些限定，比如需要一层层遍历html结构，比如必要的报错提示，跨标签时分段处理等等。\n\n<img src=https://cdn.chuckle.top/images/38-12.webp width=\"70%\">\n\n&emsp;&emsp;运行测试\n\n<img src=https://cdn.chuckle.top/images/38-13.webp width=\"100%\">\n\n&emsp;&emsp;ChatGPT有vscode插件，这个插件的模型对于编程支持度更好，速度也更快，且当你问其它话题时，还会催你聊编程相关的话题（\n\n&emsp;&emsp;安装插件后，选中任意代码片段，右键即可添加测试、让ChatGPT帮你找BUG、让ChatGPT帮你优化代码等等。\n\n<img src=https://cdn.chuckle.top/images/38-14.webp width=\"100%\">\n\n&emsp;&emsp;难以想象这是一个免费的服务，以后看不懂的代码就让ChatGPT解释一遍。让机械式、重复性高、通用性强的代码都交给ai做，\n\n***\n\n# 对于情景分析的能力——以俄亥俄化学事故为例\n&emsp;&emsp;此次事故发生在2023年，而ChatGPT只学习到了2021年，通过设立它从来没有接触过的情景可以看到它的强大之处。\n\n&emsp;&emsp;设立和实际相符的大致情景：有一辆运载火车，有10节载有危险的有机物化学物品，其中5节载着液态氯乙烯大约320吨，剩下的车厢载着乙二醇单丁醚、异丁烯、丙烯酸异辛酯、丙烯酸丁酯，且还有适量的含苯或者含酚的阻聚剂，不幸的是这辆火车脱轨了，里面的剧毒化学物质都已发生泄露，而且还着火爆炸了，附近有水源已被火车上化学物质污染，露天的不完全燃烧已经持续了10天，接下来的1年内该地区和全球会发生什么？可能发生化学反应产生哪些物质？\n\n<img src=https://cdn.chuckle.top/images/38-5.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT说明可能产生的反应和产出的化学物质。\n\n<img src=https://cdn.chuckle.top/images/38-6.webp width=\"90%\">\n\n&emsp;&emsp;回答不够详细，让ChatGPT详细地说明这些有机物之间发生相互作用和反应，可能产生的所有的有毒有害的物质。\n\n<img src=https://cdn.chuckle.top/images/38-7.webp width=\"90%\">\n\n&emsp;&emsp;再让ChatGPT定量地分析，产生的有毒有害物质可能的体积和质量。\n\n<img src=https://cdn.chuckle.top/images/38-8.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT分析此次事故可能造成的后果\n\n<img src=https://cdn.chuckle.top/images/38-9.webp width=\"90%\">\n\n&emsp;&emsp;有些人提出扔氢弹销毁所有的有化学机物，实际上福岛事故俄罗斯好像也提出过扔核弹，于是我向ChatGPT询问解决事故的办法，并尝试诱导它分析扔氢弹是否是可行的方案。\n\n<img src=https://cdn.chuckle.top/images/38-10.webp width=\"90%\">\n\n&emsp;&emsp;它拒绝使用氢弹，继续尝试诱导。\n\n<img src=https://cdn.chuckle.top/images/38-11.webp width=\"90%\">\n\n&emsp;&emsp;拒绝使用氢弹，且分析得有道理，不知道是这个语言模型是有对于核武等关键词的额外处理，还是ai自己通过学习分析出来的。\n\n&emsp;&emsp;虽然一堆有机物混在一起鬼都不想算，但大多都是准确的，特别是对于反应可能产生的物质分析，不过后面的200吨二噁英过于理想和夸张了，有机反应产率不可能这么高，二噁英会产生，但就算是不完全燃烧也只占产物的一小部分，氯乙烯没长链要生成二噁英得靠自聚形成聚氯乙烯，但是长途运输肯定要添加阻塑剂不然运过去都废一半了。所以氯乙烯自己产生大量二噁英难度有点大，但是阻塑剂本身有大部分带苯环，这就又有了产生二噁英或者别的难降解有毒物质的概率。\n\n\n***\n\n# 总结\n&emsp;&emsp;ChatGPT训练集主要是英文，但它对于中文问题的理解和回答速度不慢，准确性也相当可观，这毫无疑问是搜索引擎的一个革命性技术，一个用钱砸出来的语言模型和ai，通过俄亥俄化学事故的分析，这个语言AI的情景结合能力我认为与人在理性的方面已经无异了。\n\n&emsp;&emsp;NewBing也逐步开始内测，它是bing与ChatGPT的联合产物，与ChatGPT不同的是，它的模型比gpt3.5更加高级，且联网，每时每刻都在学习互联网上的信息，尽管这样可能导致一定危险，比如在水军泛滥的话题充满虚假信息却让ai学习了。\n\n","tags":["瞎折腾","ChatGPT"],"categories":["其它"]},{"title":"页面链接二维码(扫一扫)卡片","url":"/article/59995f0e.html","content":"\n# 前言\n&emsp;&emsp;[@Heo](https://blog.zhheo.com/)博客的侧边栏有个可以hover旋转的公众号二维码卡片，我很想抄过来，冻手！\n\n<img src=https://cdn.chuckle.top/images/37-2.webp width=\"60%\">\n\n&emsp;&emsp;但Heo是直接放了个ps改好的图，我没有公众号，打算放博客链接的二维码，把图片p个二维码就用不上，自己做个图又嫌麻烦（弱弱的ps技术），还是用div+css去实现吧。\n\n<img src=https://cdn.chuckle.top/images/37-3.webp width=\"60%\">\n\n&emsp;&emsp;**效果：**因为不是图片，所以二维码可以根据页面的链接动态生成。\n\n<img src=https://cdn.chuckle.top/images/37-4.gif width=\"40%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\widget\\card_tuijian.pug`，放入以下内容。\n\n```\n.card-widget#card-tuijian\n    #tj-box\n        #tj-box1\n            #tj-left\n                <p>扫一扫</p>\n                <span>快速打开移动端➤</span>\n            #tj-right\n                #tj-img-box\n                    if is_home()\n                        img(src=qrcode(full_url_for(page.current_url),{margin:4}))\n                    else\n                        img(src=qrcode(full_url_for(page.path),{margin:4}))\n                        \n        #tj-box2\n            #tj-left\n                <p>扫一扫</p>\n                <span>下载移动端APP➤</span>\n            #tj-right\n                #tj-img-box\n                    img(src=qrcode(\"https://cdn.chuckle.top/blog/app/chuckle.apk\",{margin:4}))\n\n```\n\n&emsp;&emsp;安装二维码生成插件。\n\n```\nnpm i -S hexo-helper-qrcode\n```\n\n&emsp;&emsp;修改`\\layout\\includes\\widget\\index.pug`,在合适位置加入。\n\n```\n!=partial('includes/widget/card_tuijian', {}, {cache: false})\n```\n\n&emsp;&emsp;CSS：\n\n```css\n#card-tuijian#card-tuijian#card-tuijian#card-tuijian {\n    background: linear-gradient(to right, #35bb99db, #2dbcc4db) !important;\n    padding: 15px 0;\n    height: 118px;\n    -moz-user-select: none;\n    -khtml-user-select: none;\n    user-select: none;\n}\n\n#card-tuijian #tj-box {\n    width: 100%;\n    height: 100%;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    transition: cubic-bezier(0, 0, 0, 1.29) 0.4s;\n}\n\n#card-tuijian #tj-box2 {\n    transform: rotateY(180deg);\n    -webkit-transform: rotateY(180deg);\n}\n\n#card-tuijian #tj-box1,\n#card-tuijian #tj-box2 {\n    display: flex;\n    justify-content: center;\n    flex-wrap: nowrap;\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n#card-tuijian #tj-img-box {\n    border-radius: 12px;\n    margin-left: 10px;\n    height: 85px;\n}\n\n#card-tuijian #tj-img-box img {\n    height: 85px;\n    border-radius: 12px;\n    filter: brightness(0.95) !important;\n}\n\n#card-tuijian #tj-left {\n    color: #fff;\n    height: 85px;\n}\n\n#card-tuijian #tj-left p {\n    font-family: monospace, Arial;\n    margin: 10px 0 0;\n    font-size: 32px;\n    line-height: normal;\n    font-weight: 800;\n    color: rgba(255, 255, 255, 0.9);\n    text-shadow: -0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px -0.5px 0 rgba(255, 255, 255, 0.9), -0.5px -0.5px 0 rgba(255, 255, 255, 0.9);\n}\n\n#card-tuijian #tj-left span {\n    font-size: 15px;\n    font-weight: 800;\n}\n\n#card-tuijian:hover #tj-box {\n    -webkit-transform: rotateY(180deg);\n    transform: rotateY(180deg);\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n```\n\n# 后记\n&emsp;&emsp;2023-2-22：修改CSS，修复火狐浏览器下未能正确隐藏背面元素的bug\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"给文章添加自定义文本锚点","url":"/article/6f237a88.html","content":"\n# 前言\n&emsp;&emsp;起因是群里有人提出，搜索关键词后只能跳转到对应文章，而不能自动再跳转至关键词处，当然，本文不是实现这个(实际上已经实现了)，这给了我一个想法，为啥不弄个文本锚点呢，把选中的文本都保存起来，点击就滚动页面过去，这是一个不错的主意。\n\n&emsp;&emsp;**功能：**选中页面文字保存锚点，点击锚点，页面滚动到对应文本处并背景高亮，当一个锚点对应多处文本时，多次点击锚点，页面能循环地逐个滚动到对应位置。\n\n&emsp;&emsp;**效果：**\n\n<img src=https://cdn.chuckle.top/images/36-2.gif width=\"88%\">\n\n# 实现\n&emsp;&emsp;首先是右侧悬浮栏的锚点按钮和容器，修改`\\layout\\includes\\rightside.pug`,对应着原有缩进添加。\n\n```js\nwhen 'anchor'\n    if is_post()\n        button#post-anchor\n            i.fas.fa-book\n            #post-anchor-after\n            #post-anchor-rom\n              #post-anchor-box\n                #no-anchor 没有锚点\n                script.\n                  var anchor_back = '';\n                  var anchor_length = 0;\n                  var anchor_node = '';\n                  function toAnchor(obj) {\n                    var anchor = $(obj).text();\n                    $(\"anchorbox\").parent().each(function(){ \n                      $(this).html($(this).html().replace(/(<\\/?anchorbox.*?>)/g,''));\n                    }) \n                    \n                    if(anchor_back == anchor){\n                      i++;\n                      if(i>=anchor_length){\n                        i = 0;\n                      }\n                    }else{\n                      i = 0;\n                      anchor_back = anchor;\n                      anchor_node = $('#article-container *:contains('+anchor+')').not(\".highlight *,.mini-sandbox *,.tag.link *,.folding-tag *\");\n                      anchor_length = anchor_node.length;\n                    }\n                    if(anchor_length>0){\n                      btf.snackbarShow(\"该锚点对应有 \"+anchor_length+\" 处文本,当前：\"+(i+1));\n                      btf.scrollToDest(anchor_node.eq(i).offset().top-200);\n                    }else{\n                      btf.snackbarShow(\"文章内没有对应文本或出现致命错误，请避免选中跨标签跨行文本。\");\n                    }\n                    let input = anchor;\n                    let textNodes = [];\n                    (function getTextNodes(node) {\n                      if (node.nodeType === Node.TEXT_NODE) {\n                        textNodes.push(node);\n                      } else {\n                        for (let i = 0; i < node.childNodes.length; i++) {\n                          getTextNodes(node.childNodes[i]);\n                        }\n                      }\n                    })(document.getElementById(\"article-container\"));\n                    for (let i = 0; i < textNodes.length; i++) {\n                      let node = textNodes[i];\n                      let text = node.nodeValue;\n                      let index = text.indexOf(input);\n                      if (index !== -1) {\n                        let newNode = document.createElement(\"anchorbox\");\n                        newNode.appendChild(document.createTextNode(text.substring(index, index + input.length)));\n                        node.nodeValue = text.substring(0, index);\n                        node.parentNode.insertBefore(newNode, node.nextSibling);\n                        node.parentNode.insertBefore(document.createTextNode(text.substring(index + input.length)), newNode.nextSibling);\n                      }\n                    }\n                  }\n…………\n\n#rightside\n  - const { enable, hide, show } = theme.rightside_item_order\n  - const hideArray = enable ? hide && hide.split(',') : ['refresh','translate','enlargePage','narrowPage','bg','darkmode','hideAside']\n  //在下面添加个'anchor'\n  - const showArray = enable ? show && show.split(',') : ['toc','anchor','chat','comment', 'share']\n\n```\n\n&emsp;&emsp;然后是右键选中文字添加锚点按钮`rightside.pug`\n\n```js\na.rightMenu-item(href=\"javascript:addAnchor();\")\n    script.\n        function addAnchor () {\n            if($(\"#no-anchor\").length > 0){\n                $(\"#no-anchor\").remove();\n            }\n            var txt = window.getSelection().toString();\n            txt = txt.replace(/<[^>]*>/g, \"\");\n            $(\"#post-anchor-box\").prepend('<a class=\"anchor-item\" href=\"javascript:void(0);\" onclick=\"toAnchor(this)\" data-pjax-state=\"\">'+txt+'</a>');\n            btf.snackbarShow(\"成功添加一个文本锚点\");\n        }\n    i.fa.fa-book\n    span='添加锚点'\n\n```\n\n&emsp;&emsp;当然没有右键就把js拿去，监听下选中文字后弹出个按钮触发一下`addAnchor()`就行。右键教程可看[自定义右键菜单](https://blog.dorakika.cn/p/20220118.html)\n\n&emsp;&emsp;添加CSS：\n\n```css\n#post-anchor{\n    z-index: 10!important;\n}\n#post-anchor-rom{\n    position: fixed;\n    width: auto;\n    overflow: hidden;\n    border-radius: 12px;\n    bottom: 20px;\n    right: -241px;\n    border: var(--anchor-border);\n    transition: all .27s;\n    opacity: 0;\n    max-height: 380px;\n    height: 100%;\n    width: 240px;\n    z-index: 9;\n}\n#post-anchor-box{\n    display:flex;\n    background: #fff;\n    max-height: 380px;\n    height: 100%;\n    flex-wrap: nowrap;\n    flex-direction: column;\n    justify-content: flex-start;\n    border-radius: 12px;\n    overflow: auto;\n}\n#post-anchor-after{\n    display: none;\n    position: fixed;\n    bottom: 20px;\n    right: 0px;\n    background: transparent;\n    max-height: 380px;\n    height: 100%;\n    width: 100px;\n}\n#post-anchor-box a{\n    padding: 5px 10px;\n    width: 100%;\n    border-bottom: 1px solid rgb(8, 148, 235);\n    font-weight: 800;\n}\n#post-anchor:hover #post-anchor-rom{\n    opacity: 1;\n    right: 70px;\n    transition: all .25s;\n}\n#post-anchor:hover #post-anchor-after{\n    display:block;\n}\n#article-container anchorbox{\n    color: black!important;\n    font-weight: 800!important;\n    border-radius: 6px!important;\n    background-color: rgb(253 253 20 / 70%)!important;\n}\na.anchor-item{\n    font-size: 16px;\n    line-height: 17px;\n    text-align: left;\n}\na.anchor-item:hover{\n    background-color: #16b2ef;\n    color: #fff;\n}\n#no-anchor{\n    color: rgb(140, 140, 140);\n    font-size: 30px;\n    line-height: 375px;\n    opacity: 0.8;\n}\n[data-theme=dark]\n#post-anchor-box{\n    background: #000;\n}\n[data-theme=dark]\n#article-container anchor{\n    color: rgb(255, 255, 255);\n}\n@media screen and (max-width:768px){\n    #rightside #post-anchor{\n        display: none!important;\n    }\n}\n\n```\n\n# 后记\n&emsp;&emsp;因为是文章页才用到的JS，不是全局的，量也不多，就直接写在pug里了，还能避免pjax的适配问题。\n\n&emsp;&emsp;已知BUG：选中锚点跨标签的话，可以跳转，但是没法套标签使背景高亮，这就emm有点烦。当选中的文本只包含半个右半边英文括号时，锚点会无法跳转和高亮，原因未知。","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Ventoy多系统移动硬(U)盘","url":"/article/a41cefd.html","content":"\n# 认识Ventoy\n&emsp;&emsp;Ventoy是一个制作可启动U盘的开源工具，可以直接启动iso等镜像、vhd虚拟磁盘等等，支持大部分操作系统，同一个U盘可以同时支持Legacy BIOS、IA32、UEFI等模式。\n{% link Ventoy文档官网,https://www.ventoy.net/cn/,/images/ventoy.webp%}\n\n<img src=https://cdn.chuckle.top/images/35-1.webp width=\"70%\">\n\n***\n\n# 安装Ventoy\n&emsp;&emsp;普通U盘只适合运行pe镜像，运行win(vhd)或者linux需要4k性能较好的U盘，推荐使用移动硬盘。\n&emsp;&emsp;我的移动硬盘：致钛5000+itgz(9210b)硬盘盒。\n&emsp;&emsp;下载[Ventoy安装包](https://www.ventoy.net/cn/download.html)，运行**Ventoy2Disk.exe**，选择移动硬盘(U)盘，配置选项中选择分区类型MBR或GPT，默认为MBR，点击安装，等待几分钟即可。\n\n<img src=/images/35-2.webp width=\"50%\">\n\n&emsp;&emsp;安装完成后，移动硬盘(U)盘会被分成两个区，VENTOY隐藏分区和ventoy分区，ventoy分区可正常存储文件，**接下来的操作无特殊说明都在此分区**。\n&emsp;&emsp;将ventoy分区格式化为**NTFS**格式(默认为exFAT)\n\n***\n\n# 配置Ventoy\n&emsp;&emsp;在根目录新建ventoy文件夹，在该文件夹内新建**images**文件夹、**ventoy.json**，打开ventoy.json填入以下配置。具体介绍在此处查看[Ventoy 全局控制插件](https://www.ventoy.net/cn/plugin_control.html)\n\n```json\n{\n  \"control\":[\n      { \"VTOY_HELP_TXT_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MENU_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MAX_SEARCH_LEVEL\": \"max\" },\n      { \"VTOY_DEFAULT_SEARCH_ROOT\": \"/ventoy/images\" }\n  ]\n}\n\n```\n\n***\n\n# 配置安全启动\n&emsp;&emsp;windows默认开启Secure Boot(安全启动【垄断启动】)，Ventoy1.0.07版本开始支持Secure Boot，但需要手动配置KEY，或者进bios关闭Secure Boot才能使用Ventoy。\n&emsp;&emsp;如已关闭Secure Boot，跳过下面步骤。\n\n&emsp;&emsp;启动电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入一个ERROR界面，按照文档[UEFI模式安全启动操作说明](https://www.ventoy.net/cn/doc_secure.html)，配置Enroll Key或Enroll Hash。\n\n&emsp;&emsp;配置好后会重启电脑，一般无需操作会正常回到电脑主系统。\n\n***\n\n# 运行PE\n&emsp;&emsp;ventoy运行pe非常简单，下载或生成好PE的iso镜像，放入/ventoy/images内即可。\n&emsp;&emsp;重启电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入ventoy界面，选择pe的iso镜像即可进入pe系统\n\n&emsp;&emsp;推荐pe：[微pe](https://www.wepe.com.cn/)、[firpe](http://www.firpe.cn/)、[Hikari PE](https://hikaricalyx.com/)\n\n***\n\n# 运行windows(vhd)\n&emsp;&emsp;准备好一个windows镜像。\n&emsp;&emsp;在ventoy中挂载运行vhd(x)虚拟磁盘可以和正常系统一样升级系统、安装驱动、安装软件等等，能保存对系统的修改和操作。所以推荐使用vhd运行windows。如果使用iso则与pe操作一样。\n\n&emsp;&emsp;下载[Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)，6.1版本即可。运行软件，点击新建(虚拟机)。\n\n<img src=https://cdn.chuckle.top/images/35-3.webp width=\"75%\">\n\n&emsp;&emsp;进入专家模式，名称任意，文件夹选择**移动硬盘里的**任意一个文件夹(新建)，选择镜像对应的win版本，点击创建。\n\n<img src=https://cdn.chuckle.top/images/35-4.webp width=\"60%\">\n\n&emsp;&emsp;文件大小50g以上，即系统C盘大小。虚拟硬盘文件类型选vhd，动态大小。\n\n<img src=https://cdn.chuckle.top/images/35-5.webp width=\"60%\">\n\n&emsp;&emsp;选择虚拟光盘，进入后点击注册，选择windows的iso镜像。\n\n<img src=https://cdn.chuckle.top/images/35-6.webp width=\"75%\">\n\n&emsp;&emsp;选择好镜像后，点击启动虚拟机。\n\n<img src=https://cdn.chuckle.top/images/35-7.webp width=\"75%\">\n\n&emsp;&emsp;进入安装引导界面，一直下一步，选择创建好的虚拟硬盘继续下一步。\n\n<img src=https://cdn.chuckle.top/images/35-8.webp width=\"70%\">\n\n&emsp;&emsp;等待系统安装完成，移除iso镜像，即可正常启动系统，务必在虚拟机中启动一次系统，进入桌面，否则虚拟硬盘无法给ventoy使用。\n\n&emsp;&emsp;关闭虚拟机，在硬盘中找到vhd文件，移动进/ventoy/images文件夹。\n\n<img src=https://cdn.chuckle.top/images/35-9.webp width=\"40%\">\n\n&emsp;&emsp;重启电脑，在ventoy中选择此vhd即可启动winodws。\n\n***\n\n# 运行Linux\n\n***\n\n# 测试ventoy\n&emsp;&emsp;修改了配置或者镜像，想测试一下，无需每次都重启电脑进入ventoy，可以使用VMware Workstation创建本地磁盘虚拟机。\n\n<img src=https://cdn.chuckle.top/images/35-10.webp width=\"80%\">\n\n***\n\n# 配置主题\n\n\n***\n\n# 注意事项\n1. 虚拟硬盘创建的大小不要超过母盘。\n\n***\n\n\n\n\n\n\n","tags":["教程","Ventoy"],"categories":["教程"]},{"title":"BF添加输入页数跳转","url":"/article/8e0b4c43.html","content":"\n# 前言\n&emsp;&emsp;以后文章多了页数也会多起来，bf没有输入页码跳转实在不方便，现在就加上这个功能好。\n\n<img src=https://cdn.chuckle.top/images/34-2.webp width=\"65%\">\n\n***\n\n# 实现\n&emsp;&emsp;修改`\\layout\\includes\\pagination.pug`替换else后的源码，或者对应着修改。\n\n```js\nelse\n  nav#pagination\n    .pagination\n      if is_home()\n        - options.format = 'page/%d/'\n      !=paginator(options)\n      if is_home()\n        input#textnumer(oninput=\"value=value.replace(/[^0-9]/g,'')\" maxlength=\"3\" onkeyup='this.value=this.value.replace(/[^u4e00-u9fa5w]/g,\"\")')\n        a#textbtn(onclick='textbtn()') 跳转\n    if is_home()\n      .js-css\n        script.\n          function textbtn(){var e=document.querySelectorAll(\".page-number\"),t=e[e.length-1].innerHTML,n=Number(t),a=document.getElementById(\"textnumer\"),o=Number(a.value);if(\"\"!=o&&!isNaN(o)&&o%1==0)if(1==o)document.getElementById(\"textbtn\").href=\"/\";else if(o>n){var d=\"/page/\"+n+\"/\";document.getElementById(\"textbtn\").href=d}else d=\"/page/\"+a.value+\"/\",document.getElementById(\"textbtn\").href=d}\n        style.\n          #pagination .pagination .extend{display: none!important}\n\n```\n\n&emsp;&emsp;css的话，没有通用的，怎么好看怎么改。\n\n***\n\n# 后记\n&emsp;&emsp;暂无\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"阳了个🐑","url":"/article/4154609f.html","content":"\n# 没想到咋🐑的\n&emsp;&emsp;2022年12月17号，作为全国高校跑毒的最后一批，我戴上3M有呼吸阀的N95，经过广州南，坐高铁几百公里回家都没有阳，但就在前几天，喉咙发干，头有些发紧，腰有点酸，我意识到可能中招了，但还是嘴硬觉得没阳，并且愉快地**洗了个澡**。\n\n&emsp;&emsp;自我隔离5天后才真正回家，之后出门戴口罩，随身带酒精消毒，这四天千防万防，还是难逃一🐑。\n\n***\n\n# 2022-12-27\n&emsp;&emsp;也许因为昨天洗了个澡，27号凌晨突然39度高烧，还有全身不舒服发冷，头皮发麻脑袋要裂开等等，好在高烧在短短一小时就结束了，但这整晚在身体各种不适下还是难以入眠，退烧后的凌晨2点头特别疼、喉咙干。\n\n&emsp;&emsp;早上7点早早起来，一量38.5度，也听到了我爸的咳嗽声，多半也🐑了。虽然整天都是38.5度，但白天并没感觉发冷，到了晚上，冷到两层被子裹四层睡。并且晚上开始有了咳嗽，一咳整个脑袋要裂开。显然，这一晚又没睡好。\n\n***\n\n# 2022-12-28\n&emsp;&emsp;整天体温37.5，第两天半也该降温了，但各种新症状也来了，一咳嗽肚子到胸口处就酸痛，导致咳到一半总无力，开始有了黄绿色浓痰、鼻涕。味觉倒还在，就是没啥食欲，耳朵感觉被堵住一样，听力和低频声音分别有明显下降。\n\n&emsp;&emsp;这天，我妈也阳了，症状都差不多，第一天38.5度。\n\n***\n\n# 2022-12-29\n&emsp;&emsp;整天37.3，降温聊胜于无，在前几天症状的叠加延续下，这天也是感觉特别地累，腰酸背痛，精神不振。下午测了下抗原，果然两道扛。\n\n<img src=https://cdn.chuckle.top/images/33-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;家里其他人也阳了。我好了一些，下楼去买些食物和药品，跑了四家规模还算大的药店，体温计、小柴胡、抗病毒口服液啥都没有。去超市提了9.8一斤的雪梨润润喉，30块钱四个真滴贵。\n\n***\n\n# 2022-12-30\n&emsp;&emsp;凌晨睡觉出现了明显的耳鸣，感觉远处有上万只苍蝇在飞。\n\n&emsp;&emsp;白天精神好了些，体温在36.9度，低频听力回来了一些，不多，但有用，咳嗽稍微没这么频繁了，但一咳还是头疼难受，鼻涕流得更多了。\n\n***\n\n# 2022-12-31\n&emsp;&emsp;往后就是漫长的后遗症了，咳嗽和感觉乏力，注意力下降，精神状态不好。\n\n***\n\n# 2023-01-11\n&emsp;&emsp;总算不咳嗽了，算是阳康了，至于累嘛，也许是干家务加熬夜的锅。\n\n***\n# 后记\n&emsp;&emsp;比受冻感冒、季节性流感难受多了。没咋吃西药，含完了一盒金嗓子，没买到喉风散只好喷西瓜霜，泡了柠檬红枣水喝，还有一些老人家的秘方汤。\n\n&emsp;&emsp;**一个链接：**[上海新冠疫情大样本数据研究](https://mbd.baidu.com/newspage/data/landingsuper?isBdboxFrom=1&pageType=1&urlext=%7B%22cuid%22%3A%22YiHGuguCSu_6aB8RjavRigaC2i0Nu2fQ_u2lflu2vu_Iav8C_aHC8lf51O5FiHPy9M1mA%22%7D&context=%7B%22nid%22%3A%22news_9139130449349147433%22%7D)\n\n\n&emsp;&emsp;**一些图片：**\n\n{% gallery %}\n![](https://cdn.chuckle.top/images/33-2.webp)\n![](https://cdn.chuckle.top/images/33-3.webp)\n![](https://cdn.chuckle.top/images/33-4.webp)\n![](https://cdn.chuckle.top/images/33-5.webp)\n![](https://cdn.chuckle.top/images/33-6.webp)\n{% endgallery %}\n\n***\n","tags":["新冠","疫情"],"categories":["其它"]},{"title":"前后端交互初步概念","url":"/article/709b5ecb.html","content":"\n# 前言\n&emsp;&emsp;前后端交互本来是一个简单明了的概念，发请求与响应以及所用到的技术，但如百度等搜索结果大部分都抛出一堆菜鸟如我看不懂的概念与操作，上来就是用vue，或者新建一个MVC项目，实在不友好。\n&emsp;&emsp;本文旨在建立一个初步的、以前端为视角的前后端交互概念。\n\n***\n\n# 为什么要前后端交互\n&emsp;&emsp;以前的网页，用户在浏览器输入链接访问后，服务器一顿操作，渲染出页面扔给浏览器显示。而当页面内某段话，某个数字需要变，服务器又得重新渲染整个网页。\n&emsp;&emsp;这很麻烦，像PHP、JSP，代码写在HTML中,也就是前后端不分离的表现。下面就是一个JSP的表格。\n```jsp\n<tbody class=\"book-body\">\n\t<c:forEach items=\"${bookList}\" var=\"book\">\n\t\t<tr class=\"book-tr\">\n\t\t\t<td>${book.bId}</td>\n\t\t\t<td>${book.bName}</td>\n\t\t\t<td>${book.auName}</td>\n\t\t\t<td>${book.bType}</td>\n\t\t\t<td>${book.bPress}</td>\n\t\t</tr>\n\t</c:forEach>\n</tbody>\n\n```\n\n***\n\n## 表单\n&emsp;&emsp;在这个前后端不分离的时代，所谓前端实现单纯的登录操作JS都不用写。弄个表单，点击表单内`type=\"submit\"`的按钮，就能对`action=\"doLogin\"`发起登录的`get`/`post`请求，然后再由服务器去处理，登录失败就渲染`${errorMsg}`。\n```html\n<form action=\"doLogin\" method=\"get\">\n    <p>用户名</p>\n    <input name=\"userName\" type=\"text\" placeholder=\"输入用户名/邮箱\" />\n    <p>密码</p>\n    <input name=\"password\" type=\"password\" placeholder=\"输入密码\" />\n    <button type=\"submit\" class=\"btn1\">登录</button>\n\t<span>${errorMsg}</span>\n</form>\n\n```\n\n&emsp;&emsp;有时候需要触发事件而提交表单，比如删除操作，可以使用JQ伪造表单提交\n```js\nbtn.bind(\"click\", function () {\n\tvar id = btn2.parent().parent().children(\"td\").get(0).innerHTML;\n\tvar form = $(\"<form method='get'></form>\");\n\tform.attr({ \"action\": \"/myBatisDemo/deleteBooksById\" });\n\tform.append($(\"<input type='hidden'>\").attr(\"name\", \"bId\").val(id));\n\t$(\"body\").append($(form));\n\tform.submit();\n});\n\n```\n\n&emsp;&emsp;面对越来越复杂的网页页面，以及无刷更新内容提升体验的需求，后端提供数据前端去使用成了主流，这也大大减轻了服务器的压力，随着Ajax的出现，JS可以使用json来与服务器进行数据交互，真正的前后端分离出现了。\n\n***\n\n# 前端如何与后端交互\n&emsp;&emsp;和以前一样，后端会提供一个接口，就像是表单属性`action=\"/myBatisDemo/deleteBooksById\"`里的一样。JS本身没有网络通信能力，但使用浏览器提供的对象和方法，遵循一定的规范协议(**http**)，就可以通过这些接口与后端交互，也就是发请求和处理响应。\n&emsp;&emsp;后端响应后，拿到后端返回的内容(JSON)，我们可以判断密码是否正确，或者通过DOM操作改变网页内容等等。\n\n***\n\n## Ajax\n&emsp;&emsp;**Ajax**是最早出现的向后端发送请求的技术，其核心是浏览器提供的**XMLHttpRequest(xhr)**对象。我们可以直接原生地使用它。\n```js\n//既然xhr是个对象，当然要先new再使用里面的方法\nlet xhr = new XMLHttpRequest();\n//定义我们的请求，与一个url建立连接，true代表异步请求\nxhr.open('GET', '/url', true);\n//readyStated，它一共有五个值，当等于4时代表请求已完成\n//readyStated的变化会触发onreadystatechange事件\nxhr.onreadystatechange = function(){\n    //当readyState为4以及http状态码为200代表请求成功，响应已就绪\n    if(this.readyState === 4 && this.status==200){\n        //对DOM的操作，比如替换个P标签的内容\n        console.log(this.responseText);//打印响应返回的文本\n    }\n}\n//把请求发送一下\n//因为没有请求体的所以为null\nxhr.send(null);\n\n```\n\n&emsp;&emsp;利用Ajax进行前后端交互看起来非常简单，拿到响应后进行DOM操作即可，当然，在实际的开发中，很少写原生的Ajax，而是使用封装好的第三方库和框架，比如**jQuery**、**axios**\n```js 使用jQuery封装好的Ajax\n $.ajax({\n    //获取数据url地址\n    url: \"/url\",\n    //获取数据的方式\n    type: \"GET\",\n    //获取数据类型\n    dataType: \"JSON\",\n    //接口所需参数\n    data:{\"id\":1},\n    beforeSend: function () {\n        console.log(\"发起请求之前在控制台打印\");\n    },\n    //请求数据成功调用的方法\n    //传参data代表请求成功的数据\n    success:function(data){\n        console.log(data);\n    },\n    //请求失败\n    error: function(err) {\n\t\tconsole.log(err);\n\t},\n    complete: function () {\n        console.log(\"请求完成时在控制台打印\");\n    }\n})\n\n```\n\n&emsp;&emsp;可以看到，使用已经封装好的Ajax更加方便、简单。\n\n>一个非常好的Ajax基础教程：[Ajax基础](https://zhuanlan.zhihu.com/p/474914790)\n\n***\n\n## Fetch\n&emsp;&emsp;在**ES6**中，新增了一种HTTP数据请求的方式：**Fetch**。\n&emsp;&emsp;不同于Ajax是一种技术，使用**XMLHttpRequest**去实现，Fetch从定义上本身就是一个真实存在的API，它使用了ES6提出的**promise**对象(链式处理解决回调地狱)。关于Ajax、Fetch区别，说法五花八门，还是以后再深入了解吧。也可先看此知乎问题的第二个回答[fetch底层也是基于XMLHttpRequest吗](https://www.zhihu.com/question/335786718)\n\n&emsp;&emsp;如何使用Fetch发请求，以登录为例：\n```js\nfetch('/login', {\n\tmethod: \"POST\",\n    //请求的主体，转换为json对象\n\tbody: JSON.stringify({ username: account.value, password: password.value }),\n    //http头部的内容类型\n\theaders: {\n\t\t\"Content-Type\": \"application/json\"\n\t},\n})\n.then(response => {\n    //判断响应是否成功\n\tif (response.ok) {\n        //转换成js可操作的json数据并返回对象\n\t    return response.json();\n\t} else {\n\t    return Promise.reject('QAQ出错啦');\n\t}\n})\n.then(data => {\n    //拿到json对象后进行处理\n\tconsole.log(data);\n    //这里的data是服务器返回的json\n});\n\n```\n\n***\n\n## axios\n&emsp;&emsp;[axios官方文档](https://www.axios-http.cn/)\n&emsp;&emsp;Ajax只是一种技术，最开始单纯通过xhr去实现，而当**promise**出现后，出现了**axios**，它通过promise实现对ajax技术的一种封装，底层仍然是xhr，但支持了promise等一系列新功能与API。\n&emsp;&emsp;与Ajax(xhr版)、Fetch不同的是，axios是第三方库，所以需要npm安装或者cdn引入后才可使用。\n\n&emsp;&emsp;简单的get：\n```js\naxios.get('/url', {\n    params: {\n        username: 'chuckle'\n    }\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;简单的post:\n```js\naxios.post('/url', {\n    username: 'chuckle',\n    password: '123456'\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;相较于Ajax的老旧，Fetch的稚嫩，axios是目前最流行的网络请求库，vue、react都使用它，但如果简单发个请求获取个一言啥的，还是用fetch方便，毕竟能少引用一个库。\n\n***\n\n# 实战一下\n\n<div id=\"get-example\"></div>\n\n***\n\n# 后记\n&emsp;&emsp;本文只简单概述了下前后端交互(前端发请求)的概念与实现方式，让有可能需要的人建立一个初步的、以前端为视角的前后端交互概念，也就是Ajax、Fetch和axios的初步认识。具体的HTTP、ES6、JSON、Promise等等，再说，在学（。\n\n>参考文章：\n>[Ajax(XMLHTTPRequest)和Fetch的认识以及利用promise和ts实现一个Ajax](https://zhuanlan.zhihu.com/p/366458405)\n>[简单通俗来讲ajax与axios的区别](https://www.cnblogs.com/bingcola/p/16499188.html)\n>[fetch底层也是基于XMLHttpRequest吗？](https://www.zhihu.com/question/335786718)\n>[XMLHttpRequest—必知必会](https://www.jianshu.com/p/918c63045bc3)\n>[AJAX基础](https://zhuanlan.zhihu.com/p/474914790)\n>[你知道Ajax、Fetch、Axios三者的区别吗](https://juejin.cn/post/7086325194934976519)\n\n***\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/32.js?1\"></script>\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"使用MiniSandbox前端代码可视化","url":"/article/b827db53.html","content":"\n# 前言\n&emsp;&emsp;官方文档:[Mini Sandbox](https://buuing.github.io/mini-sandbox/#/),Github仓库:[mini-sandbox](https://github.com/buuing/mini-sandbox)\n\n&emsp;&emsp;这也算是一篇安利文，markdown本身的代码框直接显示代码，对于前端的代码来说，样式效果全靠截图，动不起来，也没交互，虽然可以复制到我另一个单页[HTML/CSS/JS 在线工具](/hjc/)，但切换页面和复制终究不直观，影响阅读体验。\n\n&emsp;&emsp;前段时间看到这个新的前端代码、组件可视化方案，兼容任意js环境，就计划弄到Hexo上试试，其纯前端部署,不依赖服务器,静态页即可实现编辑和预览功能也十分契合Hexo静态站，手动适配了下Hexo的夜间模式以及pjax，效果非常不错。\n\n***\n\n# 安装\n>首先推荐先看[官方文档](https://buuing.github.io/mini-sandbox/#/)。\n\n&emsp;&emsp;我将其保存在本地引入，并且稍微根据需要对`mini-sandbox.js`作了一点修改，由于这个js压缩后还有450kb，我建议是在有使用需要的单页通过cdn引入。\n```html \n<script src=\"https://unpkg.com/mini-sandbox@0.3.11\"></script>\n```\n\n***\n\n# 使用\n&emsp;&emsp;在Hexo中使用也很方便\n```html 在markdown中需要的地方插入div,并在文末引入一个js\n<div id=\"my-sandbox\"></div>\n···\n<script src=\"index.js\"></script>\n```\n\n```js index.js中按文档这样写\nnew MiniSandbox({\n    el: '#my-sandbox',//注意id和上面的一致\n    files: {//要几个页面就仿照写法加几个\n        'index.html': {//html\n            title: 'HTML',//tab上实际显示的名字\n            defaultValue: `<button>点击</button>`,//HTML的内容/代码\n            cssLibs: ['index.css'],//html引入的css\n            jsLibs: ['index.js'],//html引入的js\n        },\n        'index.css': {\n            title: 'CSS',\n            //CSS的内容/代码,写起来排版有点怪，但熟悉了也还好\n            defaultValue: `button {\n  width: 100%;\n  color: red;\n}\n        `},\n        'index.js': {\n            title: 'JS',\n            //JS的内容/代码\n            defaultValue: `const btn = document.querySelector('button')\nbtn.addEventListener('click', () => {  \n    alert('这是一个按钮')\n})\n        `}\n    },\n    //用来设置一些Sandbox的默认配置\n    defaultConfig: {\n        height: '330px',//Sandbox的高度,默认为 '300px'\n        autoRun: true,//每次修改后是否自动运行, 默认等于 true\n        autoRunInterval: 1000,//每次自动运行的时间间隔,单位为毫秒,默认等于300\n        editorRange: '55%',//编辑区域默认占比,默认情况下编辑区域占50%\n        draggable: true,//是否可以左右拖动布局, 默认为true\n        direction: 'row',//控制上下/左右布局,默认为'row','row' | 'row-reverse' | 'column' | 'column-reverse'\n      }\n})\n\n```\n\n&emsp;&emsp;效果如下:\n<div id=\"my-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox不仅让我能方便展示前端的代码、组件，同时也允许读者直接修改代码框中的内容并运行（自动的，实时的），试着改改下面的代码，看看效果吧。\n<div id=\"myAuthorBox-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox还对CSS有补全和提示，F12可以直接用浏览器的。\n<img src=https://cdn.chuckle.top/images/30-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;当然，如果单纯展示,不希望读者修改，也可以将css、js写在resource中:\n```js\nnew MiniSandbox({\n  el: '#exhibition-sandbox',\n  files: {\n    'index.html': {\n      title: 'HTML',\n      defaultValue: `<input type=\"text\" value=\"0\"><br><br>\n<input type=\"submit\" value=\"加一\">\n<input type=\"submit\" value=\"清除\">  \n    `}\n  },\n  resource: {\n    cssLibs: [],\n    jsLibs: [],\n    css: `\n      input {\n        color: blue;\n      }\n    `,\n    js: `\n      var text = document.getElementsByTagName('input')[0];\n      var add = document.getElementsByTagName('input')[1];\n      var clear = document.getElementsByTagName('input')[2];\n      add.onclick = function numberadd(){\n        text.value++;  \n      }\n      clear.onclick = function clearnumber(){\n        text.value = 0; \n      }\n    `,\n  }\n})\n```\n\n&emsp;&emsp;效果:\n<div id=\"exhibition-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox左上角按钮点击后有一些可自定义的功能\n<img src=https://cdn.chuckle.top/images/30-2.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;除了上述的一些基本功能,Mini Sandbox还有很多功能，如直接放置CDN链接展示组件库，如Sandbox事件的触发回调函数，如支持vue、react等，并且在持续更新。\n\n***\n\n# 更多示例\n官方文档提供了一些示例：[Examples & 示例](https://buuing.github.io/mini-sandbox/#/docs/html)\n\n***\n\n# Hexo夜间适配\n```css\n  .mini-sandbox{\n    box-shadow: none!important;\n    border-radius: 7px;\n  }\n  [data-theme=dark]\n  .mini-sandbox{\n    background-color: #151515!important;\n  }\n  [data-theme=dark]\n  .cm-activeLine{\n     background-color: #252525!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head{\n    background: #202020!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .cm-gutters{\n    background: #202020!important;\n  }\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    box-shadow: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .cm-activeLineGutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .sandbox-body .sandbox-gutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-gutter{\n    border-left: 1px solid #404040!important;\n    border-right: 1px solid #404040!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::after{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::before{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-render{\n    background: #E1E1E1!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼd{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼc{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼb{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼf{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼh{\n    color: #ff5370!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼa{\n    color: #FF00FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼi{\n    color:#5F9EA0!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼl{\n    color:#969896!important;\n  }\n  .mini-sandbox{\n    margin-bottom: 10px;\n  }\n\n```\n\n***\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/30.js?2\"></script>","tags":["教程","瞎折腾"],"categories":["教程"]},{"title":"HTML基础笔记","url":"/article/1475187a.html","content":"\n# HTML\n&emsp;&emsp;一个最基本的H5骨架长这样：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <meta name=\"Author\" content=\"\">\n    <meta name=\"Keywords\" content=\"123\" />\n    <meta name=\"Description\" content=\"123456\" />\n    <title>Document</title>\n</head>\n<body>\n  \n</body>\n</html>\n\n```\n\n>标准的div+css页面，只会用到种类很少的标签：div、p、h1、span、a、img、ul、ol、dl、input、i等\n\n***\n\n## 头标签head\n&emsp;&emsp;head标签表示的是页面的配置，有字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等\n\n1. **文档声明头：**`<!DOCTYPE html>`，DocType Declaration，简称DTD,DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n2. **页面语言lang：**`<html lang=\"en\">`，指定页面的语言类型，en、zh-CN。\n3. **meta标签：**提供相关页面的元信息（meta-information）\n\n```html\n<!--必要，网页标题-->\n<title>轻笑Chuckle</title>\n<!--必要，网页的编码方式,文件格式要与其声明相符-->\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n<!--视口viewport，适配移动端-->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<!--网页关键词，SEO用-->\n<meta name=\"Keywords\" content=\"轻笑,Chuckle\" />\n<!--网页描述-->\n<meta name=\"Description\" content=\"漫天倾尘,风中轻笑\" />\n<!--网页作者-->\n<meta name=\"Author\" content=\"轻笑Chuckle\">\n<!--3s后跳转百度-->\n<meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\">\n<!--指定基础的路径，a链接以此为基准-->\n<base href=\"/\">\n\n```\n\n***\n\n## body标签\n* div、section、article、aside、header、footer\n* p\n* span、em、strong\n* 表格元素：table、thead、tbody、tr、td\n* 列表元素：ul、ol、dl、dt、dd\n* a\n* 表单元素：form、input、select、textarea、button\n\n&emsp;&emsp;**HTML标签分为两种：**\n1. 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input）\n2. 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。\n\n***\n\n## 排版标签\n1. `<h1>`标题使用`<h1>`至`<h6>`标签定义,有align属性(对齐方式)：left、center、right。\n2. `<p>`段落标签，单独成段，分割网页。有align属性。\n3. `<hr/>`水平分割线线标签。\n4. `<br/>`\n5. `<div>`可以把标签中的内容分割为独立的区块。必须单独占据一行,DIV+CSS来实现各种样式,**div标签负责布局、结构、分块，css负责样式**\n6. `<span>`和div的作用一致，但不换行\n7. `<center>`让元素居中，H5中不使用\n8. `<pre>`预格式化，让文本不空格和空行，几乎用不着\n9. `<!-- 我是 html 注释  -->`\n\n***\n\n## 字体标签\n1. 特殊字符（转义字符），需要时百度，`&nbsp;`空格,`&lt;`小于号<,`&gt;`大于号>，等\n2. `<u>`下划线,`<s>`或`<del>`中划线,`<i>`或`<em>`斜体\n3. **弃用:**`<b>` `<strong>`粗体，`<font>`字体标签\n4. `<sup>`上标，`<sub>`下标\n\n***\n\n## 超链接a\n&emsp;一个文本级标签\n1. 外部链接:`<a href=\"02页面.html\">点击进入另外一个文件</a>`**href**超文本地址\n2. 锚链接:\n\n```html\n<!--设置锚点，必须是a标签-->\n<!--name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的-->\n<a name=\"a1\" id=\"a1\">a1点</a>\n<!--触发锚点-->\n<a href=\"#a1\">去a1点</a>\n<!--跳转到a.html页面的a1锚点中去-->\n<a href=\"a.html#a1\">去a1</a>\n\n```\n\n&emsp;通常p包裹a  \n{% folding cyan, 超链接的属性 %}\n**href**：目标URL  \n**title**：悬停文本。  \n**name**：主要用于设置一个锚点的名称。  \n**target**：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值：  \n&emsp;**_self**：在同一个网页中显示（默认值）  \n&emsp;**_blank**：在新的窗口中打开。  \n&emsp;**_top**：在顶级窗口中显示  \n{% endfolding %}\n\n***\n\n## 图片标签\n&emsp;`<img src=\"图片的URL\" />`src中写图片路径\n\n&emsp;标签属性：\n1. **width**、**height**\n在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比\n可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行**等比缩放**\n2. **alt**：当图片无法显示时，代替图片的文本\n3. **title**：鼠标悬停时出现的文本\n4. align属性，默认bottom\n\n***\n\n### 相对路径\n&emsp;`.`当前目录,`..`上一层目录\n```html\n<!-- 当前目录中的图片 -->\n<img src=\"img.jpg\">\n<img src=\"./img.jpg\">\n<!-- 上一级目录中的图片 -->\n<img src=\"../img.jpg\">\n<!-- ../要么不写，要么就写在开头 -->\n\n```\n\n***\n\n### 绝对路径\n&emsp;`<img src=\"C:\\img.jpg\">`C盘图片\n&emsp;`<img src=\"http://img.baidu.com/head.png\">`网络路径\n\n***\n\n## 列表标签\n\n1. 无序列表`<ul>`,type=\"属性值\";disc(实心原点，默认)，square(实心方点)，circle(空心圆)\n2. 有序列表`<ol>`,type=\"属性值\";1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始\n`<ul>`、`<ol>`里放`<li>`,li是容器级\n3. 定义列表`<al>`,没有属性,子元素`<dt>`、`<dd>`\n\n<div id=\"list-example\"></div>\n\n&emsp;&emsp;从语义上来说，dt表示名称，dd表示对其的描述，dt、dd都是容器级标签，想放什么都可以。用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。\n\n***\n\n## 表格标签table\n\n&emsp;&emsp;网页中表格由每行`<tr>`组成，每一行由一个个单元格`<td>`组成\n&emsp;&emsp;`<th>`加粗的单元格。相当于`<td>` + `<b>`\n```html 一个表格\n<table>\n\t<tr>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t</tr>\n</table>\n\n```\n\n{% folding cyan, table的属性 %}\n* **border** 边框\n* **style=\"border-collapse:collapse;\"**单元格的线和表格的边框线合并（表格的两边框合并为一条）\n* **width**、**height**\n* **bordercolor** 表格的边框颜色\n* **align** 表格的水平对齐方式left right center，注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签`<td>`进行设置）\n* **cellpadding** 单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\n* **bgcolor** 背景颜色，**background** 背景图片。背景图片的优先级大于背景颜色。\n* **bordercolorlight** 表格的上、左边框，以及单元格的右、下边框的颜色,**bordercolordark** 表格的右、下边框，以及单元格的上、左的边框的颜色 这两个属性的目的是为了设置3D的效果\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n* **bgcolor** 设置这一行的单元格的背景色\n* **height**\n* **align** 一行的内容水平居中显示，取值：left、center、right\n* **valign** 一行的内容垂直居中，取值：top、middle、bottom\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **bgcolor** 单元格的背景色，**background** 设置这个单元格的背景（图片）\n* **height** 单元格的高度\n* **width** 绝对值或者相对值(%)\n* **align** 内容的横向对齐方式，取值：left right center\n* **valign** 内容的纵向对齐方式。取值：top middle bottom\n{% endfolding %}\n\n***\n\n### 单元格的合并\n1. **colspan**：横向往右合并\n2. **rowspan**：纵向往下合并\n\n<div id=\"table1-example\"></div>\n\n***\n\n### thead、tbody、tfoot\n&emsp;&emsp;表格优先按照thead、tbody、tfoot的顺序依次来显示内容（三个标签无需同时存在），如果不写，表格按代码从上到下的顺序来显示\n&emsp;&emsp;当表格非常大内容非常多的时候，用thead、tbody、tfoot标签，数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。\n&emsp;&emsp;tr和tbody同级，按代码从上到下的顺序来显示\n\n<div id=\"table2-example\"></div>\n\n***\n\n## *框架标签\n&emsp;&emsp;框架标签用于在一个网页中显示多个页面（html）\n>1. `<frameset>`和`<body>`只能二选一。框架标签不能放在`<body>`标签里面，因为`<body>`标签代表的只是一个页面，而框架标签代表的是多个页面\n>2. 框架的集合用`<frameset>`表示，然后在`<frameset>`集合里放入一个一个的框架`<frame>`\n>3. **frameset和frame已经从 Web标准中删除，使用iframe代替**\n\n***\n\n### *frameset\n&emsp;&emsp;`<frameset>` 框架的集合,一个框架的集合可以包含**多个框架**或**框架的集合**\n\n{% folding cyan, frameset的属性 %}\n* **rows** 水平分割，将框架分为上下部分\n* **cols** 垂直分割，将框架分为左右部分。\n写法有两种：\n1. 绝对值写法：`rows/cols=\"200,*\"` *代表剩余的。包含了两个框架：一个占200个像素，另一个占剩下的部分。\n2. 相对值写法：`rows/cols=\"30%,*\"` *代表剩余的。包含了两个框架：一个占30%，另一个占70%。\n\n&emsp;如果想将框架分成很多个，在属性值里用多个逗号隔开。\n{% endfolding %}\n\n```html\n<frameset rows=\"20%,*\">\n    <frame src=\"1.html\"></frame> \n    <frameset cols=\"30%,*\">\n        <frame src=\"1.html\"></frame> \n        <frame src=\"1.html\"></frame> \n    </frameset>      \n</frameset>\n\n```\n\n***\n\n### *frame\n&emsp;&emsp;`<frame>`是`<frameset>`的子标签，一个框架显示一个页面。\n\n{% folding cyan, frame的属性 %}\n* **scrolling=\"no\"** 是否要滚动条,默认值是true。\n* **noresize** 不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的,用了这个属性值，框架大小将固定。\n* **bordercolor** 框架边框颜色,仅IE生效\n* **frameborder=\"0\"**或**\"1\"** 隐藏或显示边框（框架线）。\n* **name** 框架名字，用于框架内的超链\n{% endfolding %}\n\n***\n\n## 内嵌框架\n&emsp;&emsp;内嵌框架用`<iframe>`表示。`<iframe>`写在`<body>`中，在其中嵌入html页面\n\n{% folding cyan, iframe的属性 %}\n* **src=\"\"** 嵌入html页面的路径\n* **height**,**width**\n* **scrolling=\"no\"** 是否需要滚动条。默认值是true。\n* **name** 名称\n{% endfolding %}\n\n<div id=\"iframe-example\"></div>\n\n***\n\n## 表单标签\n&emsp;&emsp;表单标签用`<form>`表示，收集用户信息，用于与服务器的交互。\n{% folding cyan, form的属性 %}\n* **name**，**id** 表单的名称，JS来操作或控制表单时使用\n* **action** 指定表单数据的处理程序\n* **method** 表单数据的提交方式，一般取值：get(默认)和post\n{% endfolding %}\n\n***\n\n### input输入标签\n&emsp;&emsp;`<input>`是一个输入标签，用于接收用户输入或选择\n\n{% folding cyan, input的属性 %}\n* **type=\"属性值\"** 文本类型\n***text*** 文本框，默认\n***password*** 密码框\n***radio*** 单选按钮\n***checkbox*** 多选按钮，name属性值相同的按钮作为一组进行选择，但id必须唯一。\n***hidden*** 隐藏框，在表单中包含不希望用户看见的信息\n***button*** 普通按钮，结合js代码进行使用。\n***submit*** 提交按钮，提交当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字，点击按钮后，整个表单就会被提交到form标签的action属性中指定的那个页面中去\n***reset*** 重置按钮，清空当前表单的内容，并设置为最初的默认值\n***image*** 图片按钮，和submit提交按钮的功能完全一致，图片按钮可以显示图片。\n***file*** 文件选择框，配合JS对文件进行限制和检查\n* **checked** 将单选按钮或多选按钮默认处于选中状态。当`<input>`标签设置为**type=\"radio\"**或者**type=checkbox**时，可用此属性\n* **value=\"内容\"** 文本框里的默认内容（已经被填好了的）\n* **size=\"50\"** 表示文本框内可以显示**五十个字符**。一个英文或一个中文都算一个字符\n* **readonly** 文本框只读\n* **disabled** 文本框只读\n{% endfolding %}\n\n<div id=\"input1-example\"></div>\n\n***\n\n### select下拉列表\n&emsp;&emsp;`<select>`列表中每一选项为`<option>`\n\n{% folding cyan, select、option的属性 %}\n`<select>`的属性:\n* **multiple** 多选(ctrl加左键点击)\n* **size=\"3\"** 属性值大于1，则列表为滚动视图，默认属性值为1，即下拉视图。\n\n`<option>`的属性:\n* **selected** 预选中\n{% endfolding %}\n\n<div id=\"select1-example\"></div>\n\n***\n\n### textarea多行文本框\n&emsp;&emsp;`<textarea>`不会省略空格和换行\n{% folding cyan, textarea的属性 %}\n* **rows=\"4\"** 文本框行数\n* **cols=\"20\"** 文本框列数\n* **readonly** 文本框只读\n{% endfolding %}\n\n<div id=\"textarea1-example\"></div>\n\n***\n\n### fieldset表单分组\n&emsp;&emsp;`<fieldset>`子标签`<legend>`定义组的标题\n{% folding cyan, fieldset的属性 %}\n* **disabled** 表单仍然显示，但是禁用\n* **form=\"另一个表单的id\"** 让此fieldset也属于该表单一部分\n* **name** fieldset的名称\n{% endfolding %}\n\n<div id=\"fieldset1-example\"></div>\n\n***\n\n### label\n&emsp;&emsp;`label`使其中文字内容与`<input>`绑定，点击文字也能选择选项等\n{% folding cyan, fieldset的属性 %}\n* **for=\"[id]\"** label要绑定的input的id\n{% endfolding %}\n\n<div id=\"label1-example\"></div>\n\n***\n\n# HTML5\n&emsp;&emsp;HTML5是新一代开发Web富客户端应用程序整体解决方案。包括：HTML5,CSS3，Javascript API在内的一套**技术组合**。富客户端具有很强的**交互性**和体验。\n\n***\n\n## 新增的语义标签\n&emsp;&emsp;相较于使用`class=\"header\"`给网页做语义化处理，HTML5本身提供了一些语义化的标签。强调了HTML的职责是描述一块内容是什么（或其意义）。\n\n&emsp;&emsp;常见的HTML结构：\n```html\n<!-- 头部 -->\n<div class=\"header\">\n    <ul class=\"nav\"></ul>\n</div>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <div class=\"article\"></div>\n    <!-- 侧边栏 -->\n    <div class=\"aside\"></div>\n</div>\n\n<!-- 底部 -->\n<div class=\"footer\">\n\n</div>\n\n```\n\n&emsp;&emsp;HTML5中这样写\n```html\n<!-- 头部 -->\n<header>\n    <ul class=\"nav\"></ul>\n</header>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <article></article>\n    <!-- 侧边栏 -->\n    <aside></aside>\n</div>\n\n<!-- 底部 -->\n<footer>\n\n</footer>\n\n```\n\n{% folding cyan, HTML5语义标签 %}\n* **section** 区块\n* **article** 表示主体内容，如文章\n* **header** 页眉\n* **footer** 页脚\n* **nav** 导航栏\n* **aside** 侧边栏\n* **figure** 媒介内容分组\n* **mark** 标记\n* **progress** 进度\n* **time** 日期\n{% endfolding %}\n\n***\n\n## H5中的表单\n{% folding cyan, HTML5表单中input新增的类型 %}\n* **email** 只能输入email格式，自带格式验证\n* **tel** 手机号码\n* **url** 只能输入url格式\n* **number** 只能输入数字。\n* **search** 搜索框\n* **range** 滑动条\n* **color** 拾色器\n* **time** 时间\n* **date** 日期\n* **datetime** 时间日期\n* **month** 月份\n* **week** 星期\n{% endfolding %}\n\n<div id=\"h5-input-example\"></div>\n\n***\n\n## 新表单标签\n* `<datalist>` 数据列表,用于数据自动提示\n\n<div id=\"datalist-example\"></div>\n\n* `<keygen>` 用于验证用户，本质是密钥对生成器，当提交表单时，会生成两个键：一个公钥，一个私钥，私钥存储于客户端，公钥则被发送到服务器。公钥可用于之后验证用户的客户端证书。\n\n***\n\n## 新表单属性\n{% folding cyan, 新表单属性 %}\n* **placeholder** 占位符（提示文字）\n* **autofocus** 自动获取焦点\n* **multiple** 文件上传多选或多个邮箱地址\n* **autocomplete** 自动完成（填充的）on开启（默认）off取消。效果是会记住之前的提交，可以快速选择\n* **form** 指定表单项属于哪个form，处理复杂表单时会需要\n* **novalidate** 关闭默认的验证功能（只能加给form）\n* **required** 表示必填项\n* **pattern** 自定义正则，验证表单。\n{% endfolding %}\n\n<div id=\"new-form-example\"></div>\n\n***\n\n## 表单事件\n1. `oninput()` 用户输入内容时触发，可用于输入字数统计。\n2. `oninvalid()` 验证不通过时触发\n\n***\n\n## audio音频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n{% endfolding %}\n\n<div id=\"audio-example\"></div>\n\n***\n\n## video视频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n* **width**、**height**\n{% endfolding %}\n\n```html\n<video src=\"video/movie.mp4\" controls  autoplay ></video>\n<video controls autoplay>\n  <source src=\"video/movie.mp4\"/>\n  <source src=\"video/movie.ogg\"/>\n  <source src=\"video/movie.webm\"/>\n  抱歉，不支持此视频\n</video>\n\n```\n\n***\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/31.js?3\"></script>","tags":["前端"],"categories":["学习笔记"]},{"title":"老旧浏览器弹窗提醒","url":"/article/e61f6567.html","content":"\n# 前言\n&emsp;&emsp;在今年IE终于从半身入土到彻底寄寄，谷歌也做了个违背祖宗的决定，版本号破百。\n&emsp;&emsp;但像夸克、UC、百分等浏览器，仍然用着老旧的谷歌内核，也有不少人还用着老版本的谷歌浏览器、Edge。像我学校的机房，仍用着老旧的44版Edge。\n\n&emsp;&emsp;老旧的浏览器不仅让兼容性较低的网站样式爆炸（没错，说的就是我站（bushi）），更不是大势所趋。样式爆炸也会给访客留下不好的印象，为了避免这种情况，合理甩锅（嗯对没错）给浏览器非常双赢。可以每天检测一次浏览器版本号然后弹窗。\n<img src=https://cdn.chuckle.top/images/29-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;把这JS找个地方塞进去，弹窗调用butterfly自带的，用其它的替换即可。\n```JS 老旧浏览器弹窗提醒\nfunction browserTC() {\n    btf.snackbarShow(\"\");\n    Snackbar.show({\n        text: '浏览器版本较低，网站样式可能错乱',\n        actionText: '关闭',\n        duration: '6000',\n        pos: 'bottom-right'\n    });\n}\nfunction browserVersion() {\n    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串\n    var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1; //判断是否IE<11浏览器\n    var isIE11 = userAgent.indexOf('Trident') > -1 && userAgent.indexOf(\"rv:11.0\") > -1;\n    var isEdge = userAgent.indexOf(\"Edge\") > -1 && !isIE; //Edge浏览器\n    var isFirefox = userAgent.indexOf(\"Firefox\") > -1; //Firefox浏览器\n    var isOpera = userAgent.indexOf(\"Opera\")>-1 || userAgent.indexOf(\"OPR\")>-1 ; //Opera浏览器\n    var isChrome = userAgent.indexOf(\"Chrome\")>-1 && userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Chrome浏览器\n    var isSafari = userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Chrome\")==-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Safari浏览器\n    if(isEdge) {\n        if(userAgent.split('Edge/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isFirefox) {\n        if(userAgent.split('Firefox/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isOpera) {\n        if(userAgent.split('OPR/')[1].split('.')[0]<80){\n            browserTC()\n        }\n    } else if(isChrome) {\n        if(userAgent.split('Chrome/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isSafari) {\n        //不知道Safari哪个版本是该淘汰的老旧版本\n    }\n}\n//2022-10-29修正了一个错误：过期时间应使用toGMTString()，而不是toUTCString()，否则实际过期时间在中国差了8小时\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\nif(getCookie('browsertc')!=1){\n    setCookies({\n        browsertc: 1,\n    }, 1);\n    browserVersion();\n}\n\n```\n\n***\n\n# 后记\n&emsp;&emsp;样式爆炸首先甩锅（\n\n","tags":["Butterfly","教程"],"categories":["教程"]},{"title":"写个网页版电子木鱼","url":"/article/904a2780.html","content":"\n# 前言\n&emsp;&emsp;Heo写了个ios版电子木鱼，最近电子木鱼确实挺火。\n&emsp;&emsp;必须也给博客安排上，一个养生的互联网小站不能没有电子木鱼！\n{% link 电子木鱼,/muyu/,%}\n&emsp;&emsp;1.0写得比较粗糙，简单的积功德，敲敲敲，还有功德+100。等以后再完善什么见初音未来、随机弹涩图减功德的功能吧，咕咕咕咕。\n\n***\n\n# 实现\n```html\n<div class=\"muyu-layout\">\n    <div id=\"jishu-box\">\n        <p id=\"jishu\">功德：0</p>\n    </div>\n    <div id=\"muyu-box\">\n        <p id=\"gongde\">功德+100</p>\n        <img id=\"muyu\" class=\"no-lightbox entered loaded\"\n            src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQIAAADCCAMAAACVDjxiAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABaUExURUxpcfn5+fHw8fHx8fv6++3q7vv6+/n4+vr6+vf29/Ly8vn4+eDd4fj4+MjEyff39+bk55CLkNXU1s7NzkZARv7//v///woCC/38/R4YHlFMUjQuNayorXNudNqgV+MAAAAVdFJOUwAYV0TZ/bb4CoNtm/gl/THQ/MCY48f2/+sAAA/JSURBVHja7F2JYuK6Dp0sjrNBgF6rKsv//+azLTkJECCBLAaeaem0nbboWNYu+d+//y+fVrCqqiriFYah/VhVq+ALaF9FYZ5lRRLrJUUp9JtERGmW/lJSZHkerT6U+DSIsqKIpaHYLAD9ZpbSD7Cfo/4HaDji5CePgvTD6F+FRWKIt9S2lkJpnlAp+4l5GGyk0ByRhVXwQfRvhKUUmVjDBfZNPykNiyVeswN9Sf8XZb6t2SGLVm/PDUGUF5tS2s03lPIbPymi2HwkVuDvOLgAyt1PGL0zM1R5EhPtZrebhTUGVwubb1gmkUJoKZm/JzOkVbaRlrUtZ19SStReP2peILnA4kPDEL4bDGmUbQQ4Rgfo2O5bbHD2CVhusDIy1ii8EQJRoQWAIqlnVV+/hWcIWHFgYACSDSC1fHwTVqiKmCUaOkl3vuDWQvvOkgOtrlD08/Z3AcgifAPpuMpie4jRKrlOjrdk3nhgjQGgYpXJOsPylExyz0FI85h2/y7Dd9DunszHmz9ovyl2XoMQFRKY8VENWfwz8FhaGE258RYEfQaIY4cC0HcBmU3alUhCLwVjmNBZ7pDuIy3LJWi1hCwq/4zhLK7dn9oQHh0DdJIRMM49Y4RqJ2qxraZa7GczDDLzSiJEiZaDaogd9BQEbGmzxymLwCNVuJGKvT1UsyyKPCS+2MzpT+ncXVBzLaN8JXiCwaogBOBMCsLU7EAhKC/OQqSdYquvsK29phUJzAXgBQZGDHBEjK23xpSdFAWywzUIxcK6McgEkjtjtVXjA8CUPICNtahXli6sC812NzvuNMKkmuHM8NK6cUkMwh35A/PpgU7lKBbDIM1LUcd2loNAvwSxkK2cZqIOcC7HBvT3y3wRQVhQKsia67DoQcBlMGAEFCWEljsILk8Xh/MjgLgc3R2sAHE0NwKcIvICBrQycRPNzgPwRIhwykACJtXMPIDoDQAcQFBJMK8c8EUUoKpT9rO5TKnWBeyswYLa8CwHCZRsmstlygh38IgJXHRiJnchlx5pwyvVIPM5EFB+IXCejIbpTaQwRn+ZgDCY2DyIYvQZghmiyqtEIfoiCG/mWqY0D8go9PkcAEVUJ1MLaWbzWR4zAddkYDaZMhAKAXzHwJgIU4lEIwp9J59TGHK3mkYUIs6UJ3pdKIopjoL2DLgq0ntGMDZzXE0gCgW4OkqflaILJ8psCqtQof/bz9ujMdiNrRir2KsIyW2NCA6MZGQIgsSGiuENlAHHEnFkCNJMUlTCf41Y28kjQxCWnDTx/RxQKBnHh6AyNRSA4L885ECifowbOgl2wqWz/RUGWPMp/SMe1TzMhJL+60PO8FM0WY7LBGGp3kIQItWcUMxg1Gj6aoP4FpKQKlMtCuOWZJqkgf9egYsU2Ey3TMYtuMiFR4mjRxgYBOJk5NadaONnqAzPFSHVGEgRj9/SaPXhUp4h3I5QWalHrVzcBYey3GUTdPHZaqKlEDiTQNi07gD1LjoDwHbvlZtioi7vUKIEUEu5iHab601XdSrX9WVQvFjGyXTN/qsYpFq0mAwbm7f2Aqglw3K/LE1f94SdvGlBGWsf7P46XmOZwPZ+iPK4/Zm4hzeUsLxR1KafrR+Dglif9of/pm7fXdkK80V4wE07aEnCmnrA8nja7w+/v78/F1xLK7DPY4VJcCEMwI28oDgNz3PQe18ej9v94e/XrkP0jylNg1UV5llRJEmy2SRmFXn1MgxRCTR9YbkYYD3Wg1hfb76j3kFgTJcqyopNHMv2hBBbi/lqc3PArSZLWIbs7jD/a87X1J/2bert+ttGUZglsTyfEdOs11pabQa1bqNf5hzw2V+fDn9X5BsEDqdjKbA9JAecGOF2/5dKj8IYUC0WNndyX+r93+4vKP87HPZ6bdel5A4tWwiL0MzLaUbCPN+xYo4Bm6AwMbGtETfY7L4lXgv+v4uN35+2x7V2XiU7EFj7CHUAvTEhzO+W4dPa4HXKsUlr4JWudyYu1rEurKMeINfbc8FnN/9vbxjfuU49DBZC5snkYlTyKJqXQxhdzm3b6mlzL73ktd78Qwf167Ugj/DxhIj233yy3GK1kyNYhegcLLwBALfZES+A5f5LvWdO/n7rNh/qk94zqWCPymb1jG8g1BiW8R0uQGcDIrd6S2HO/gX5dPJlTX093WaAcaF9iSekgSkvHdE7uGKDesYb27vXgu/PyHwj95h6RZICuCOyt26lvza8+CqKB/HboEhXS93rnZdCW7xXWp/0vRA157O6sLoJsH9SCxTpjMEnIUhGswdsdoM2UvEYO2J6vfFHa+9eC/79icReTf7LGdbhJyEXrp4GX9f5Z1KMLf0tibwOi88I/mbzsVfs9LFKgKGNnNWGhg+OEDbGC0vXkL/vtHUZAEs/4k0NijfVyx2gtBrdDHOXMuHqdWAEu8DRjx36rguAcVtfWe/AMOtotXHSZwQXkekX6+198rXfe1ozAIzBGHaJs5ZhWBtnLtg9oiFcryW7a+b/vb8O2zWy7sNWuBivzF2AQcWvLt5U/qSDmIAiBAhDHWXAGnmWgzbC9Yh8fQROaxKAYBnAzXVTV7Mgn+MEE2YfIgxy0UwnvXcmgUMp2AxbUqo298nTuzT2bgBw2IoOfwSb8aD44mkYJgy0c6DwcX0t1gBgi2VtiMLSr7l/34d8awaVCq4ilNg6za+CAMMalmypeZ+IaR1Pw2ZUKdTCb9+LfDoDHOPBzizKSNkYhGyIOujniWKLXesYnzn8V57u7109KFkLTDz6BYtB7Xc4pNAcW4Eu0Zf7HQccBdS1C1NBwN5F3wq8VcwRyJ6qwM6toe51Y/nuB9CvDYEjDYjmRtNJE9T968+ygfYIOz6GBdangQCwITBHKYaxb3pGEFfxkBeFbv6kBeAwgP6//bYEmKucl+erh32ZYNgRA5piIrZDANCmYAlzpmtpPmIvrcjl9n0VjZtbq4XgsCNQtuMgsySmzR/sBUE2JGTK08WGA7CuLwCYiw0oCJj1ZIIBnjidgfL0N0gIrCW4RA/XNE9dwMHZ6V4QZAPjVM8IAdESgrMl6qCveUiSoKdFQPHfQYaAVgPrBoA5E5U0YLvokToAVL3LKWwH2HYQABwSmnM4asMF0Mc8tI2o/cPTWtEe/54AYInSLXsQHveomDQqDJhgPAQBAkBinfvFmQ+CNcMeQhCVOGRMDww4BXtnCTV3Bcx8EHpBkNpISR+flXxbtT4MMwWVcybU/OKQxPcjcRit3czWfuZWTyYwWgCdFlis6Z/s+KJX+1UfCCjA2YsJmsxIX3Qnsw7hoWkUrmEIFwA+ZgLDAALaQcHFILBJgQcQBDuJvV+nncL9EIK/U9mUBHRlmeY+Cw/62E32BHpCQJeePTgI2hmSgG1/sCUGZpcJdNFO9jhw3hMCMp/uQ7Bfk4veigwvCQFFDO5BkP6IARWmFgEs93fdQfCqwZtKErO7ClEOMFwtBCBv+shaDArwavAPp/juhUx+hKKW7L6ROPN+yzx2pqA3EHAM/W46KTza6z2wt4axDmW3MGiigh61dlKU806tzWpb0ijj3gEj632LfWdUsC6G9ekYWFlQhrdl4bG54LO3bNE/cDx0hEXBFZB6Ng9Rv6oyuuMcNHfVDTI1tudlgid2Bp74ZdOzgT6+NyEIfp7ryzdH4VTXTZkyQb40mLwSz5q8jfi6VXqYmgsunnrBJnxO1eLEADQgX7Ur4b3hAvvCboULjI/8VMMBRdBNKtWWCLvrcOG8rdKTZm8r64pblvGz1daufpzrKsFekszjA5qiT58so+KGIBBPd500VfRXd4c2tVG+tPwbLdZtH+clBRPwBXhdH1n7ihj0aR4ee2vdxmEUTzPPeNKakWdh6MytVzFdbYSfC4CL2UN3kUmww4kuOPCJAcAVA3ZMBab5jQCTAODNlQnuhtOuwX9pXjbJnSlkgS9coLgVJOuYVwXg90jnMSWTVghhVzMufD4AjUK4KkGOYu7g+46l+f2yEL3aSPwWDiBT7bI3KUjwSxBw1dGXUTMzpQa/SAzY6Y/RVaX1VyGgLg2jqHRu3efjAG4MaH4pCNT3CEMKnZ6fg4yaoL5EHJLxd961vYp56M3X8IA2kc9jBVYWAuCXWEVmDp5UZ/fnpAm6GXnfwQP2PbsoslWv9D2+pTQ49w/yb9IFigPd5yMsMlDfhIHNgsvost4evooJNAYXc0yyLzsI6jpSkMG3CYNLJiAu+Crr+Dpc9C2xElfxfh02DeKvCZbQFJWODErxNbLAekJdabSvOQnkB3QN9gqS73ASqRO0e3pHKPE7joGZ4RLemF8Gb3H/0UuSkOdn3prqFcpP95W5CwpvXjGbFuqjg+joxircGeNj5zTgh0uCB1duh/GHM4G1icJHY2s+11MwolAq8WhgQy4/mQ1M08zjkRVhDK35q2eD1GmofBeXQHt5dfTr18SjpOM+F0dVhWyma3L9PJzNV7+6PxKh/fBp392Lctow7je8Jo2KmH9GynhjVyxEM/m2Q3O2MfDNFnTtMv0RMCBUGV0mkYXVahXoVYU/uySOpUSer981vdlPh4CHSsB1Iv0RCsHlnSJpGqzC/Ge3WYvzyeNvoEOsGJPJSBdMp1WY7+iSjHpyvcfsAPRkVEE26h2CVZglstV4jM2AR09AoLnYfDeEeZWb8N//2jsDHQdBGICCgCDoaTQQ/v9Lj0qLbjuTu+SceLkuWZbFZCkrbam277eFi66VmVGXexlpMHktEQGNdHVcWnbnUKQ40GgUdrHFyp4yj5QKaK97J9hpkrcETliniSSVbAS8UR60O5ujxQZh3dQroOqFegoOuaUkaHn+AmRjGFLeMH+oilizGaU4Le9ZgLInlhQmaHL1Y1h6Swq0/7E1uZXdyN4tvLFO0uBamiPn/VfcyXAoPz9/YRyK+CEPZNOtHdglYgaIlimTJlzREVYkHr6Orjo8DOLkhA0nGkJyAZxdKMk1dPOE/C5PDWmnOIn1+B6eEEO67UbDLhdwDXOvS7fiaXMLyNwQ6wb6iwr0L7kTuAZE+MWTOr1CJNwGhECAybK6xEDWICU+0Piwp7833P/4Kuqsyd4f1E9ne8OqFMNH69pcbNgQZ/TENwE7VqTA+h5o3MXWL4uNz57AeESVy0lw0j5Z/8BZ1WLMWmxI6ZOCPJLgoJhLouZblY6KXbEMQIqBgAs7qliMapoX24zcsJtI8pHNsswfvVJxK0b6QpVAxXyhKCEcJU+VKRzZXNTrp9bZRtxH+52THEVjZyi7RNKrwNFp5MmuWhvoosxYAOWlnED5kbM7Cx9GAQ5CKqXjzvI3XjjZQcCAopWSEuqZVozDHf/6pw3xUI5MK5HLkdm3Rb+3BK3B2TnXdbDlubm97oeRs7HWdi+SvmxeDf6PrsK/XC6fOxtGHo6ERP4AAAAASUVORK5CYII=\">\n    </div>\n</div>\n\n```\n\n```css\n.muyu-layout {\n        background: black;\n        display: flex;\n        width: 100%;\n        border-radius: 20px;\n        position: relative;\n        justify-content: center;\n        height: 90vh;\n        align-items: center;\n    }\n    #muyu-box img {\n        width: 250px;\n    }\n     #jishu-box{\n        top: 55px;\n        position: absolute;\n     }\n    #muyu-box p {\n        color: white;\n        opacity: 0;\n        font-size: 25px;\n    }\n    #jishu-box p {\n        color: white;\n        font-size: 30px;\n    }\n\n```\n\n```js\nvar gongde = document.getElementById(\"gongde\");\nvar muyu = document.getElementById(\"muyu\");\nvar jishu = document.getElementById(\"jishu-box\");\nvar mp3Url = \"/music/muyu.mp3\";\nvar player = new Audio(mp3Url);\nvar num = 0;\nmuyu.addEventListener(\"click\", function () {\n    num+=100;\n    player.load();\n    player.play();\n    muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500);\n    gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600);\n    jishu.innerHTML = \"<p id='jishu'>功德：\"+num+\"</p>\";\n});\n\n\n```\n\n&emsp;&emsp;当然想和我一样博客单页放电子木鱼，也只需新建个单页，直接cv下面的内容进去即可\n```html\n{% raw %}\n<div class=\"muyu-layout\">\n        <div id=\"jishu-box\">\n             <p id=\"jishu\">功德：0</p>\n        </div>\n        <div id=\"muyu-box\">\n            <p id=\"gongde\">功德+100</p>\n            <img id=\"muyu\" class=\"no-lightbox entered loaded\"\n                src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQIAAADCCAMAAACVDjxiAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABaUExURUxpcfn5+fHw8fHx8fv6++3q7vv6+/n4+vr6+vf29/Ly8vn4+eDd4fj4+MjEyff39+bk55CLkNXU1s7NzkZARv7//v///woCC/38/R4YHlFMUjQuNayorXNudNqgV+MAAAAVdFJOUwAYV0TZ/bb4CoNtm/gl/THQ/MCY48f2/+sAAA/JSURBVHja7F2JYuK6Dp0sjrNBgF6rKsv//+azLTkJECCBLAaeaem0nbboWNYu+d+//y+fVrCqqiriFYah/VhVq+ALaF9FYZ5lRRLrJUUp9JtERGmW/lJSZHkerT6U+DSIsqKIpaHYLAD9ZpbSD7Cfo/4HaDji5CePgvTD6F+FRWKIt9S2lkJpnlAp+4l5GGyk0ByRhVXwQfRvhKUUmVjDBfZNPykNiyVeswN9Sf8XZb6t2SGLVm/PDUGUF5tS2s03lPIbPymi2HwkVuDvOLgAyt1PGL0zM1R5EhPtZrebhTUGVwubb1gmkUJoKZm/JzOkVbaRlrUtZ19SStReP2peILnA4kPDEL4bDGmUbQQ4Rgfo2O5bbHD2CVhusDIy1ii8EQJRoQWAIqlnVV+/hWcIWHFgYACSDSC1fHwTVqiKmCUaOkl3vuDWQvvOkgOtrlD08/Z3AcgifAPpuMpie4jRKrlOjrdk3nhgjQGgYpXJOsPylExyz0FI85h2/y7Dd9DunszHmz9ovyl2XoMQFRKY8VENWfwz8FhaGE258RYEfQaIY4cC0HcBmU3alUhCLwVjmNBZ7pDuIy3LJWi1hCwq/4zhLK7dn9oQHh0DdJIRMM49Y4RqJ2qxraZa7GczDDLzSiJEiZaDaogd9BQEbGmzxymLwCNVuJGKvT1UsyyKPCS+2MzpT+ncXVBzLaN8JXiCwaogBOBMCsLU7EAhKC/OQqSdYquvsK29phUJzAXgBQZGDHBEjK23xpSdFAWywzUIxcK6McgEkjtjtVXjA8CUPICNtahXli6sC812NzvuNMKkmuHM8NK6cUkMwh35A/PpgU7lKBbDIM1LUcd2loNAvwSxkK2cZqIOcC7HBvT3y3wRQVhQKsia67DoQcBlMGAEFCWEljsILk8Xh/MjgLgc3R2sAHE0NwKcIvICBrQycRPNzgPwRIhwykACJtXMPIDoDQAcQFBJMK8c8EUUoKpT9rO5TKnWBeyswYLa8CwHCZRsmstlygh38IgJXHRiJnchlx5pwyvVIPM5EFB+IXCejIbpTaQwRn+ZgDCY2DyIYvQZghmiyqtEIfoiCG/mWqY0D8go9PkcAEVUJ1MLaWbzWR4zAddkYDaZMhAKAXzHwJgIU4lEIwp9J59TGHK3mkYUIs6UJ3pdKIopjoL2DLgq0ntGMDZzXE0gCgW4OkqflaILJ8psCqtQof/bz9ujMdiNrRir2KsIyW2NCA6MZGQIgsSGiuENlAHHEnFkCNJMUlTCf41Y28kjQxCWnDTx/RxQKBnHh6AyNRSA4L885ECifowbOgl2wqWz/RUGWPMp/SMe1TzMhJL+60PO8FM0WY7LBGGp3kIQItWcUMxg1Gj6aoP4FpKQKlMtCuOWZJqkgf9egYsU2Ey3TMYtuMiFR4mjRxgYBOJk5NadaONnqAzPFSHVGEgRj9/SaPXhUp4h3I5QWalHrVzcBYey3GUTdPHZaqKlEDiTQNi07gD1LjoDwHbvlZtioi7vUKIEUEu5iHab601XdSrX9WVQvFjGyXTN/qsYpFq0mAwbm7f2Aqglw3K/LE1f94SdvGlBGWsf7P46XmOZwPZ+iPK4/Zm4hzeUsLxR1KafrR+Dglif9of/pm7fXdkK80V4wE07aEnCmnrA8nja7w+/v78/F1xLK7DPY4VJcCEMwI28oDgNz3PQe18ej9v94e/XrkP0jylNg1UV5llRJEmy2SRmFXn1MgxRCTR9YbkYYD3Wg1hfb76j3kFgTJcqyopNHMv2hBBbi/lqc3PArSZLWIbs7jD/a87X1J/2bert+ttGUZglsTyfEdOs11pabQa1bqNf5hzw2V+fDn9X5BsEDqdjKbA9JAecGOF2/5dKj8IYUC0WNndyX+r93+4vKP87HPZ6bdel5A4tWwiL0MzLaUbCPN+xYo4Bm6AwMbGtETfY7L4lXgv+v4uN35+2x7V2XiU7EFj7CHUAvTEhzO+W4dPa4HXKsUlr4JWudyYu1rEurKMeINfbc8FnN/9vbxjfuU49DBZC5snkYlTyKJqXQxhdzm3b6mlzL73ktd78Qwf167Ugj/DxhIj233yy3GK1kyNYhegcLLwBALfZES+A5f5LvWdO/n7rNh/qk94zqWCPymb1jG8g1BiW8R0uQGcDIrd6S2HO/gX5dPJlTX093WaAcaF9iSekgSkvHdE7uGKDesYb27vXgu/PyHwj95h6RZICuCOyt26lvza8+CqKB/HboEhXS93rnZdCW7xXWp/0vRA157O6sLoJsH9SCxTpjMEnIUhGswdsdoM2UvEYO2J6vfFHa+9eC/79icReTf7LGdbhJyEXrp4GX9f5Z1KMLf0tibwOi88I/mbzsVfs9LFKgKGNnNWGhg+OEDbGC0vXkL/vtHUZAEs/4k0NijfVyx2gtBrdDHOXMuHqdWAEu8DRjx36rguAcVtfWe/AMOtotXHSZwQXkekX6+198rXfe1ozAIzBGHaJs5ZhWBtnLtg9oiFcryW7a+b/vb8O2zWy7sNWuBivzF2AQcWvLt5U/qSDmIAiBAhDHWXAGnmWgzbC9Yh8fQROaxKAYBnAzXVTV7Mgn+MEE2YfIgxy0UwnvXcmgUMp2AxbUqo298nTuzT2bgBw2IoOfwSb8aD44mkYJgy0c6DwcX0t1gBgi2VtiMLSr7l/34d8awaVCq4ilNg6za+CAMMalmypeZ+IaR1Pw2ZUKdTCb9+LfDoDHOPBzizKSNkYhGyIOujniWKLXesYnzn8V57u7109KFkLTDz6BYtB7Xc4pNAcW4Eu0Zf7HQccBdS1C1NBwN5F3wq8VcwRyJ6qwM6toe51Y/nuB9CvDYEjDYjmRtNJE9T968+ygfYIOz6GBdangQCwITBHKYaxb3pGEFfxkBeFbv6kBeAwgP6//bYEmKucl+erh32ZYNgRA5piIrZDANCmYAlzpmtpPmIvrcjl9n0VjZtbq4XgsCNQtuMgsySmzR/sBUE2JGTK08WGA7CuLwCYiw0oCJj1ZIIBnjidgfL0N0gIrCW4RA/XNE9dwMHZ6V4QZAPjVM8IAdESgrMl6qCveUiSoKdFQPHfQYaAVgPrBoA5E5U0YLvokToAVL3LKWwH2HYQABwSmnM4asMF0Mc8tI2o/cPTWtEe/54AYInSLXsQHveomDQqDJhgPAQBAkBinfvFmQ+CNcMeQhCVOGRMDww4BXtnCTV3Bcx8EHpBkNpISR+flXxbtT4MMwWVcybU/OKQxPcjcRit3czWfuZWTyYwWgCdFlis6Z/s+KJX+1UfCCjA2YsJmsxIX3Qnsw7hoWkUrmEIFwA+ZgLDAALaQcHFILBJgQcQBDuJvV+nncL9EIK/U9mUBHRlmeY+Cw/62E32BHpCQJeePTgI2hmSgG1/sCUGZpcJdNFO9jhw3hMCMp/uQ7Bfk4veigwvCQFFDO5BkP6IARWmFgEs93fdQfCqwZtKErO7ClEOMFwtBCBv+shaDArwavAPp/juhUx+hKKW7L6ROPN+yzx2pqA3EHAM/W46KTza6z2wt4axDmW3MGiigh61dlKU806tzWpb0ijj3gEj632LfWdUsC6G9ekYWFlQhrdl4bG54LO3bNE/cDx0hEXBFZB6Ng9Rv6oyuuMcNHfVDTI1tudlgid2Bp74ZdOzgT6+NyEIfp7ryzdH4VTXTZkyQb40mLwSz5q8jfi6VXqYmgsunnrBJnxO1eLEADQgX7Ur4b3hAvvCboULjI/8VMMBRdBNKtWWCLvrcOG8rdKTZm8r64pblvGz1daufpzrKsFekszjA5qiT58so+KGIBBPd500VfRXd4c2tVG+tPwbLdZtH+clBRPwBXhdH1n7ihj0aR4ee2vdxmEUTzPPeNKakWdh6MytVzFdbYSfC4CL2UN3kUmww4kuOPCJAcAVA3ZMBab5jQCTAODNlQnuhtOuwX9pXjbJnSlkgS9coLgVJOuYVwXg90jnMSWTVghhVzMufD4AjUK4KkGOYu7g+46l+f2yEL3aSPwWDiBT7bI3KUjwSxBw1dGXUTMzpQa/SAzY6Y/RVaX1VyGgLg2jqHRu3efjAG4MaH4pCNT3CEMKnZ6fg4yaoL5EHJLxd961vYp56M3X8IA2kc9jBVYWAuCXWEVmDp5UZ/fnpAm6GXnfwQP2PbsoslWv9D2+pTQ49w/yb9IFigPd5yMsMlDfhIHNgsvost4evooJNAYXc0yyLzsI6jpSkMG3CYNLJiAu+Crr+Dpc9C2xElfxfh02DeKvCZbQFJWODErxNbLAekJdabSvOQnkB3QN9gqS73ASqRO0e3pHKPE7joGZ4RLemF8Gb3H/0UuSkOdn3prqFcpP95W5CwpvXjGbFuqjg+joxircGeNj5zTgh0uCB1duh/GHM4G1icJHY2s+11MwolAq8WhgQy4/mQ1M08zjkRVhDK35q2eD1GmofBeXQHt5dfTr18SjpOM+F0dVhWyma3L9PJzNV7+6PxKh/fBp392Lctow7je8Jo2KmH9GynhjVyxEM/m2Q3O2MfDNFnTtMv0RMCBUGV0mkYXVahXoVYU/uySOpUSer981vdlPh4CHSsB1Iv0RCsHlnSJpGqzC/Ge3WYvzyeNvoEOsGJPJSBdMp1WY7+iSjHpyvcfsAPRkVEE26h2CVZglstV4jM2AR09AoLnYfDeEeZWb8N//2jsDHQdBGICCgCDoaTQQ/v9Lj0qLbjuTu+SceLkuWZbFZCkrbam277eFi66VmVGXexlpMHktEQGNdHVcWnbnUKQ40GgUdrHFyp4yj5QKaK97J9hpkrcETliniSSVbAS8UR60O5ujxQZh3dQroOqFegoOuaUkaHn+AmRjGFLeMH+oilizGaU4Le9ZgLInlhQmaHL1Y1h6Swq0/7E1uZXdyN4tvLFO0uBamiPn/VfcyXAoPz9/YRyK+CEPZNOtHdglYgaIlimTJlzREVYkHr6Orjo8DOLkhA0nGkJyAZxdKMk1dPOE/C5PDWmnOIn1+B6eEEO67UbDLhdwDXOvS7fiaXMLyNwQ6wb6iwr0L7kTuAZE+MWTOr1CJNwGhECAybK6xEDWICU+0Piwp7833P/4Kuqsyd4f1E9ne8OqFMNH69pcbNgQZ/TENwE7VqTA+h5o3MXWL4uNz57AeESVy0lw0j5Z/8BZ1WLMWmxI6ZOCPJLgoJhLouZblY6KXbEMQIqBgAs7qliMapoX24zcsJtI8pHNsswfvVJxK0b6QpVAxXyhKCEcJU+VKRzZXNTrp9bZRtxH+52THEVjZyi7RNKrwNFp5MmuWhvoosxYAOWlnED5kbM7Cx9GAQ5CKqXjzvI3XjjZQcCAopWSEuqZVozDHf/6pw3xUI5MK5HLkdm3Rb+3BK3B2TnXdbDlubm97oeRs7HWdi+SvmxeDf6PrsK/XC6fOxtGHo6ERP4AAAAASUVORK5CYII=\">\n        </div>\n    </div>\n<style>\n    .muyu-layout {\n        background: black;\n        display: flex;\n        width: 100%;\n        border-radius: 20px;\n        position: relative;\n        justify-content: center;\n        height: 90vh;\n        align-items: center;\n    }\n    #muyu-box img {\n        width: 250px;\n    }\n     #jishu-box{\n        top: 55px;\n        position: absolute;\n     }\n    #muyu-box p {\n        color: white;\n        opacity: 0;\n        font-size: 25px;\n    }\n    #jishu-box p {\n        color: white;\n        font-size: 30px;\n    }\n</style>\n    <script>\n        var gongde = document.getElementById(\"gongde\");\n        var muyu = document.getElementById(\"muyu\");\n        var jishu = document.getElementById(\"jishu-box\");\n        var mp3Url = \"/music/muyu.mp3\";\n        var player = new Audio(mp3Url);\n        var num = 0;\n        muyu.addEventListener(\"click\", function () {\n            num+=100;\n            player.load();\n            player.play();\n            muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500);\n            gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600);\n            jishu.innerHTML = \"<p id='jishu'>功德：\"+num+\"</p>\";\n        });\n    </script>\n\n{% endraw %}\n\n```\n\n***\n\n# 后记\n&emsp;&emsp;用Animations控制CSS动画比用js模拟动画好用多了。\n\n\n\n\n\n\n\n","tags":["教程","瞎折腾"],"categories":["项目"]},{"title":"CodeFA×Hexo体验","url":"/article/cf571182.html","content":"\n# 前言\n&emsp;&emsp;Hexo是一个无后端的静态博客框架，但不妨碍各路大佬基于Github Action自动化部署实现假后端，为的就是随时随地可以通过假后端来写or修改文章，当然也可以改源码和配置。\n\n&emsp;&emsp;流行的假后端有Qexo、Wexa等，博主尝试过Wexa，但还是习惯于Vscode上的体验，假后端就凉一旁吃灰了，也关掉了Github Action自动化部署，本地Bat双击实现推送也很快。\n```bat\n@echo off\ncd C:\\chuckle\\blog\nhexo clean&&hexo g&&gulp&&hexo d\n```\n\n&emsp;&emsp;不过，随时修改文章，或者在外闲着无事给博客写个单页的需求也还是客观存在的，于是我又尝试了github.dev，这个github提供的在线vscode，启动很方便，仓库地址在把com改成dev后跳转即可，但它不能装插件、没有终端，浏览器打开需要等上一会，并且这是一个在线服务离不开网络。\n\n&emsp;&emsp;我将目光转向了早些年捣鼓过的Termux，可以配合CodeServer实现一个本地Vscode，但还是得配合VNC或者浏览器，依旧麻烦笨重。\n\n&emsp;&emsp;最终，我找到了它[CodeFA](https://www.coolapk.com/apk/com.nightmare.code)，[github地址：vscode_for_android](https://github.com/nightmare-space/vscode_for_android)，使用LinuxArm64启动一个code-server，ubuntu版本22.04，然后使用WebView进行加载，WebView加载的内容完全来自本地，并非套壳在线的网站。安装在平板上再合适不过（生产力MAX？）\n\n# 上手体验\n&emsp;&emsp;因为其本质就是一个ubuntu，且贴心地集成好了不少东西，上手非常轻松。第一件事当然是安装好环境跑几个代码玩玩（啊，不对，是先美化），`apt install gcc`、`apt install g++`、`apt install openjdk-17-jdk`等，没空去配置调试环境，也用不上，装上Coderunner插件，C、JAVA都可以运行了。和win端一样，支持智能提示和补全，java也支持psvm、sout等快捷方式。\n<img src=https://cdn.chuckle.top/images/27-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;当然，我们的重点不是跑代码，而是部署Hexo。\n\n## 部署Hexo\n>并不是完整教程，只是记录，实际上和ubuntu下部署hexo没啥大区别。\n\n&emsp;&emsp;首先，安装NodeJs、git、npm、vim，`pkg install nodejs`，`pkg install git`，`pkg install vim`，`apt install npm`。\n&emsp;&emsp;然后安装Hexo和gulp，`npm install hexo-cli -g`，`npm install --global gulp-cli`，`npm install gulp --save`。\n&emsp;&emsp;配置一下git，然后`git clone`博客源码，cd进去运行`npm install`，让它慢慢安装完依赖和我用到的插件。\n\n&emsp;&emsp;现在hexo三连，nodejs会报错：**System limit for number of file watchers reached**，问题不大，在`/etc/sysctl.conf/`中加上`fs.inotify.max_user_watches=524288`，然后运行`sysctl -p`。\n\n&emsp;&emsp;再次三连，不出意外的话，浏览器访问`http://localhost:4000/`就可以看到自己的hexo网站啦~。四连也可以推送网站到github和服务器端（当然前提是配置好了git，这就不赘述了，openssh自带无需安装）。\n<img src=https://cdn.chuckle.top/images/27-4.webp width=\"60%\" height=\"60%\">\n\n## 多端协作\n&emsp;&emsp;得益于vscode便利的git管理，一个文件或者文章，电脑端写完，推送push上github，平板端pull下来，就能继续写。得益于hexo的高性能，即使在虚拟环境下跑，hexo g也能在几秒内完成。\n<img src=https://cdn.chuckle.top/images/27-2.webp width=\"60%\" height=\"60%\"><img src=https://cdn.chuckle.top/images/27-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;配合小米平板的pc模式，还不错。\n<img src=https://cdn.chuckle.top/images/27-5.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;完全体。\n<img src=https://cdn.chuckle.top/images/27-6.webp width=\"60%\" height=\"60%\">\n\n# 后记\n\n暂无\n","tags":["Hexo","VScode"],"categories":["Hexo"]},{"title":"CSS/JS备忘录","url":"/article/2ec41fd7.html","content":"\n# CSS备忘录\n\n## 元素水平和垂直居中\n```css 水平居中\n.example{/* 父元素的宽度是确定的 */\n    margin: 0 auto;\n}\n.example{/* 文本水平居中 */\n    text-align: center;\n}\n\n```\n\n```css 垂直居中(元素父级添加flex)\n.example{\n    display: flex;\n    -webkit-box-align: center;\n    align-items: center;\n}\n\n```\n\n## 文本自动换行\n```css \n.example{\n    white-space: normal;\n    word-break: break-all;\n    word-wrap: break-word;\n    text-overflow: ellipsis;\n}\n\n```\n\n## 隐藏浏览器滚动条\n```css \n.example::-webkit-scrollbar{\n    display:none\n    /* or */\n    width:0;\n}\n\n```\n\n## 水平镜像旋转元素\n```css \n.example{\n    -moz-transform:scaleX(-1);\n    -webkit-transform:scaleX(-1);\n    -o-transform:scaleX(-1);\n    transform:scaleX(-1);\n}\n\n```\n\n## 媒体自适应css\n```css \n@media screen and (min-width: 1000px) and (max-width: 1300px){\n    .example{\n    }\n}\n\n```\n\n***\n\n# JS备忘录\n\n## Cookie操作\n```js 设置Cookie\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nsetCookies({\n    browsertc: 1,\n}, 1);\n\n```\n\n```js 读取Cookie\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\ngetCookie('browsertc');\n\n```\n\n\n***","tags":["前端","JS","CSS"],"categories":["学习笔记"]},{"title":"给网站增加悬浮伸缩侧边栏","url":"/article/fab5c3df.html","content":"\n# 前言\n&emsp;&emsp;看到了不！看到了不！[@Heo](https://blog.zhheo.com/)的网站又双叒变好看了，还增加了个音乐灵动球！\n<img src=https://cdn.chuckle.top/images/25-2.webp width=\"80%\" height=\"80%\">\n\n&emsp;&emsp;开抄开抄~我也有了思路，魔改原来的悬浮aplayer，但一问，噢《新写了一个》，尝试抄了下却不能播放。但问题不大，按之前思路结合一下刚弄好的侧边栏，非常好。\n<img src=https://cdn.chuckle.top/images/25-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;很快成品完工~（但是还是好馋那个灵动乐球~）\n<img src=https://cdn.chuckle.top/images/25-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;aplayer怎么开启看butterfly的文档。\n&emsp;&emsp;在`layout.pug`里加上：\n```pug 记得修改网易云歌单id\ninclude ./rightside.pug\n!=partial('includes/third-party/search/index', {}, {cache: true})\n!=partial('includes/dorakika/rightmenu',{}, {cache:true})\ninclude ./additional-js.pug\n//- 上面的是本来就有的，对齐上面的缩进，加上下面的内容\n.contact-info\n  .option\n    i.fas.fa-rocket\n    .bloktop\n    .text 还不造有啥用滴悬浮模块\n      .strip\n  .option\n    i.fas.fa-cube\n    .blok\n    .text\n      .strip\n      <div class=\"post-reward\"><button class=\"tip-button reward-button\"><span class=\"tip-button__text\">投喂</span><div class=\"reward-main\"><ul class=\"reward-all\"><li class=\"reward-item\"><a class=\"about-reward\" href=\"/img/weixin.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"/img/weixin.webp\" alt=\"微信\"></a><div class=\"post-qr-code-desc\">微信</div></li><li class=\"reward-item\"><a class=\"about-reward\" href=\"/img/alipay.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"/img/alipay.webp\" alt=\"支付宝\"></a><div class=\"post-qr-code-desc\">支付宝</div></li></ul></div></button></div>\n  .option\n    i.fas.fa-music\n    .blokbottom\n    .text.aplayertext\n      .strip\n      .aplayer.no-destroy(mutex='true', listfolded='true', data-id='你的网易云歌单id', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n&emsp;&emsp;引入css：\n```css 不生效就在对应属性加上!important\n.contact-info{\n    position: fixed;\n    top: 22%;\n    z-index: 200;\n    left: -51px;\n    transition: 0.4s;\n  }\n  .contact-info:hover{\n    left: 0px;\n  }\n  .contact-info .option{\n    cursor: pointer;\n    position: relative;\n  }\n  \n  .contact-info .option i{\n    display: block;\n    width: 50px;\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n    background: rgb(255, 255, 255);\n    color: #b9b9b9;\n    font-size: 20px;\n    transition: 0.4s;\n    border-radius: 0 10px 10px 0;\n  }\n  \n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n  .contact-info .text{\n    border-radius: 15px;\n    position: absolute;\n    height: 60px;\n    width: 200px;\n    background: rgba(255,255,255,.85);\n    top: 0;\n    z-index: -1;\n    left: -136px;\n    color: rgb(0, 0, 0);\n    line-height: 60px;\n    text-align: center;\n    transition: 0.4s;\n  }\n  .contact-info .aplayertext{\n    transition: none!important;\n  }\n  .aplayer{\n    position: absolute!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-body{\n    left: -60px;\n    position: absolute!important;\n    width: 370px!important;\n    transition: none!important;\n    border-radius: 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    left: -300px;\n  }\n  .contact-info .option:hover .aplayer.aplayer-fixed .aplayer-body,.contact-info .option:hover .aplayer.aplayer-fixed{\n    left: 0px;\n  }\n  .contact-info .option:hover .text{\n    left: 60px;\n  }\n  .contact-info .blok{\n    position: absolute;\n    height: 60px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .bloktop{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    bottom: 0px;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .blokbottom{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .option:hover .blok,.contact-info .option:hover .bloktop,.contact-info .option:hover .blokbottom{\n    left: 0px;\n  }\n  .contact-info .option:hover .aplayertext{\n    left: 60px!important;\n    width: 370px!important;\n    background: transparent!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-miniswitcher{\n    border-radius: 0 10px 10px 0!important;\n  }\n  .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{\n    transition: 0.28s!important;\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    height: 60px!important;\n  }\n  .aplayer .aplayer-info{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px;\n  }\n  .aplayer .aplayer-list.aplayer-list-hide{\n    margin-bottom: 59px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    margin-bottom: 62px!important;\n    max-height: 240px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-info{\n    transition: none!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic{\n    border-radius:  10px 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    border-radius:  0 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    border-radius: 10px 10px 0 0!important;\n  }\n  [data-theme=dark]\n  .contact-info .option i{\n    background: rgb(22, 22, 22);\n    color: #b9b9b9;\n  }\n  [data-theme=dark]\n  .contact-info .text{\n    background: rgba(23, 23, 23, 0.85);\n    color: rgba(255, 255, 255, 0.92);\n  }\n  @media screen and (max-width:1300px){\n    .contact-info{\n        display: none!important;\n      }\n  }\n  .aplayer{\n    opacity: .93!important;\n  }\n  [data-theme=dark]\n  .aplayer{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer.aplayer-fixed .aplayer-body{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li:hover{\n    background: #3b3b3b;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li.aplayer-list-light{\n    background: #686868;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-index{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-author{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{\n    fill: #d4d4d4;\n  }\n\n.contact-info .text .strip{\n    border-radius: 5px;\n    position: absolute;\n    height: 36px;\n    width: 5px;\n    background: rgba(20, 163, 230, 0.8);\n    top: 12px;\n    z-index: -1;\n    right: 4px;\n    transition: 0.4s;\n  }\n  .aplayertext .strip{\n    transition: none!important;\n  }\n  .contact-info .option:hover .aplayertext .strip{\n    background: transparent;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-miniswitcher{\n    background: rgba(23, 23, 23, 0.85);\n  }\n  .aplayer .aplayer-miniswitcher .aplayer-icon:hover path{\n    fill: #3498db;\n  }\n  [data-theme=dark]\n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n.contact-info .option .text .post-reward .tip-button__text{\n  margin: 25px!important;\n}\n.post-reward .reward-button .reward-main .reward-all{\n  border-radius: 12px!important;\n}\n.contact-info .option .text .post-reward .reward-button .reward-main .reward-all{\n  z-index: 999!important;\n}\n[data-theme=\"dark\"]\n.contact-info .option .text .post-reward .tip-button{\n  border: solid 2px rgba(236, 233, 233, 0.8);\n  background: #043749d0;\n}\n```\n\n> 还缺着两个空位不知道该放些啥\n\n***\n\n# 后记\n&emsp;&emsp;2022年9月26日，Meting挂了，原因是ssl证书到期。\n&emsp;&emsp;为了aplayer的稳定，还是播放本地音乐吧。\n```pug #aplayer后加上js,并在配置文件关闭meting\n#aplayer.aplayer.no-destroy(mutex='true', listfolded='true', data-id='6609736315', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n  script.\n    const ap = new APlayer({\n      container: document.getElementById('aplayer'),\n      fixed: true,\n      order: 'random',\n      preload: 'none',\n      volume: 0.25,\n      audio: [\n        {\n        name: '越权访问-崩坏：星穹铁道',\n        artist: 'Hanser',\n        url: '/music/songs/1.mp3',\n        lrc: '/music/lrc/1.lrc',\n        cover: '/music/images/songs/1.webp'\n        }\n      ]\n    });\n    \n```\n\n&emsp;&emsp;10月18日，侧边栏增加打赏，好耶，又利用了一个模块，已更新上方的代码。\n\n&emsp;&emsp;2023年1月24日，Meting又挂了，原因是api过期，可以用vercel自建api，或者播放本地音乐。\n&emsp;&emsp;自建api地址：[vercel-meting](https://github.com/ladjeek-actions/vercel-meting)\n\n```pug\n.option\n  i.fas.fa-music\n  .blokbottom\n  .text.aplayertext\n+    script.\n+      var meting_api='<你的api>';\n    .strip\n    .aplayer.no-destroy(mutex='true', listfolded='true', data-id='11111111', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"添加音乐页面","url":"/article/3322c8a8.html","content":"\n# 前言\n&emsp;&emsp;没有音乐页面怎么行，花里胡哨的都安排上，本来想摆烂直接上aplayer，但考虑到网站速度以及aplayer的稳定性（和卜算子日常歇菜），还是弄个音乐播放器放自己本地的音乐好，又快又稳定。\n&emsp;&emsp;在网上找了个能用的h5播放器源码(找不到原作者)，适配下pjax和hexo，再改改样式就完成啦：[查看音乐页面](/music/)\n<img src=https://cdn.chuckle.top/images/24-1.webp width=\"50%\" height=\"50%\">\n\n***\n\n# 实现\n&emsp;&emsp;让指定单页的背景透明可以看此教程：[控制指定单页的背景样式](/article/eb3a4679.html)\n&emsp;&emsp;新建music单页，cv以下内容覆盖原内容：\n```html\n---\ncomments: false\naside: false\n---\n{% raw %}\n<!-- 播放器 -->\n<div class=\"music-player\">\n\t<!-- audio标签 -->\n\t<audio class=\"music-player__audio\" ></audio>\n\t<!-- 播放器主体 -->\n\t<div class=\"music-player__main\">\n\t\t<!-- 模糊背景 -->\n\t\t<div class=\"music-player__blur\"></div>\n\t\t<!-- 唱片 -->\n\t\t<div class=\"music-player__disc\">\n\t\t\t<!-- 唱片图片 -->\n\t\t\t<div class=\"music-player__image\">\n\t\t\t\t<img width=\"100%\" src=\"\" alt=\"\">\n\t\t\t</div>\n\t\t\t<!-- 指针 -->\n\t\t\t<div class=\"music-player__pointer\"><img width=\"100%\" src=\"/img/cd_tou.png\" alt=\"\"></div>\n\t\t</div>\n\t\t<!-- 控件主体 -->\n\t\t<div class=\"music-player__controls\">\n\t\t\t<!-- 歌曲信息 -->\n\t\t\t<div class=\"music__info\">\n\t\t\t\t<h3 class=\"music__info--title\">...</h3>\n\t\t\t</div>\n\t\t\t<!-- 控件... -->\n\t\t\t<div class=\"player-control\">\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player-control__btns\">\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--prev\"><i class=\"iconfont icon-prev\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--play\"><i class=\"iconfont icon-play\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--next\"><i class=\"iconfont icon-next\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--mode\"><i class=\"iconfont icon-random\"></i></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"player-control__volume\">\n\t\t\t\t\t\t<div class=\"control__volume--icon player-control__btn\"><i class=\"iconfont icon-volume\"></i></div>\n\t\t\t\t\t\t<div class=\"control__volume--progress progress\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player__song--progress progress\"></div>\n\t\t\t\t\t<div class=\"player__song--timeProgess nowTime\">00:00</div>\n\t\t\t\t\t<div class=\"player__song--timeProgess totalTime\">00:00</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<!-- 歌曲列表 -->\n\t<div class=\"music-player__list\">\n\t\t<ul class=\"music__list_content\">\n\t\t</ul>\n\t</div>\n</div>\n<script src=\"/js/utill.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js\"></script>\n<script src=\"/js/player.js?10\"></script>\n<div style=\"text-align:center;margin:-100px 0; font:normal 14px/24px 'MicroSoft YaHei';color:#ffffff\"></div>\n\n{% endraw %}\n\n```\n\n&emsp;&emsp;在`blog\\source\\music`下新建`songs`和`images`文件夹，`songs`内直接放入歌曲。再在`images`文件夹内新建`songs`文件夹，里面放歌曲封面。\n&emsp;&emsp;在`blog\\source\\img`内放入这两张图片[cd.png](https://blog.chuckle.top/img/cd.png)，[cd_tou.png](https://blog.chuckle.top/img/cd_tou.png)。\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`player.js`。\n```js\n//创建一个音乐播放器的类 单例模式\nclass Player {\n    constructor() { //类的构造函数\n        //如果没有实例化，就去构造一个实例\n        return this.getInstance(...arguments);\n    }\n\n    //构建实例\n    getInstance() {\n        let instance = new PlayerCreator(...arguments);\n        //让实例可以使用到Player的原型的属性方法\n        // instance.__proto__=Player.prototype;\n        // instance.constructor=Player;\n        //把构建好的实例挂在Player类上\n        Player.instance = instance;\n        return instance;\n    }\n}\n\n//歌曲信息\nclass Musics {\n    //歌曲\n    constructor() {\n        this.songs = [{\n                id: 1,\n                title: '越权访问-崩坏：星穹铁道 - Hanser',\n                singer: '越权访问-崩坏：星穹铁道 - Hanser',\n                songUrl: './songs/1.mp3',\n                imageUrl: './images/songs/1.webp'\n            },\n            {\n                id: 2,\n                title: '妄想Reality（翻自 洛天依） - 炎祾',\n                singer: '妄想Reality（翻自 洛天依） - 炎祾',\n                songUrl: './songs/2.mp3',\n                imageUrl: './images/songs/2.webp'\n            },\n\t\t\t{\n                id: 3,\n                title: '人间失宠 - 昔诺',\n                singer: '人间失宠 - 昔诺',\n                songUrl: './songs/3.mp3',\n                imageUrl: './images/songs/3.webp'\n            },\n            {\n                id: 4,\n                title: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                singer: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                songUrl: './songs/4.mp3',\n                imageUrl: './images/songs/4.webp'\n            },\n\t\t\t{\n                id: 5,\n                title: '玛德琳娜电塔 - 花玲',\n                singer: '玛德琳娜电塔 - 花玲',\n                songUrl: './songs/5.mp3',\n                imageUrl: './images/songs/5.webp'\n            },\n        ]\n    }\n    //根据索引获取歌曲的方法\n    getSongByNum(index) {\n        return this.songs[index];\n    }\n}\n\n//真正的构建播放器的类\nclass PlayerCreator {\n    constructor() {\n        this.audio = document.querySelector('.music-player__audio') // Audio dom元素, 因为很多api都是需要原生audio调用的，所以不用jq获取\n        // this.audio.muted = true; // 控制静音\n        this.audio.volume = 0.2;\n\n        //工具\n        this.util = new Util();\n        this.musics = new Musics(); //歌曲信息\n        this.song_index = 0; // 当前播放的歌曲索引\n        this.loop_mode = 1; // 1 2\n        // 下方歌曲列表容器\n        this.song_list = $('.music__list_content');\n\n        this.render_doms = { //切换歌曲时需要渲染的dom组\n            title: $('.music__info--title'),\n            singer: $('.music__info--singer'),\n            image: $('.music-player__image img'),\n            blur: $('.music-player__blur')\n        }\n        this.ban_dom = { //禁音时需要渲染的dom组\n            control__btn: $('.control__volume--icon')\n        }\n\n        // 时间显示容器\n        this.render_time = {\n            now: $('.nowTime'),\n            total: $('.totalTime')\n        }\n\n        // 唱片\n        this.disc = {\n            image: $('.music-player__image'),\n            pointer: $('.music-player__pointer')\n        };\n        //播放器初始化\n        this.init();\n    }\n    //初始化函数\n    init() {\n        this.renderSongList();\n        this.renderSongStyle();\n        this.bindEventListener();\n    }\n    //生成播放列表\n    renderSongList() {\n        let _str = '';\n        this.musics.songs.forEach((song, i) => {\n            _str += `<li class=\"music__list__item\">${song.title}</li>`\n        });\n        this.song_list.html(_str);\n    }\n\n    //根据歌曲去渲染视图\n    renderSongStyle() {\n        let {\n            title,\n            singer,\n            songUrl,\n            imageUrl\n        } = this.musics.getSongByNum(this.song_index);\n        this.audio.src = songUrl;\n        this.render_doms.title.html(title);\n        this.render_doms.singer.html(singer);\n        this.render_doms.image.prop('src', imageUrl);\n        this.render_doms.blur.css('background-image', 'url(\"' + imageUrl + '\")');\n\n        //切换列表中的item的类名 play\n        this.song_list.find('.music__list__item').eq(this.song_index).addClass('play').siblings().removeClass('play');\n    }\n    //绑定各种事件\n    bindEventListener() {\n        //播放按钮\n        this.$play = new Btns('.player-control__btn--play', {\n            click: this.handlePlayAndPause.bind(this)\n        });\n        //上一首\n        this.$prev = new Btns('.player-control__btn--prev', {\n            click: this.changeSong.bind(this, 'prev')\n        });\n        //下一首\n        this.$next = new Btns('.player-control__btn--next', {\n            click: this.changeSong.bind(this, 'next')\n        });\n        //循环模式\n        this.$mode = new Btns('.player-control__btn--mode', {\n            click: this.changePlayMode.bind(this)\n        });\n        //禁音\n        this.$ban = new Btns('.control__volume--icon', {\n            click: this.banNotes.bind(this)\n        })\n        //列表点击\n        this.song_list.on('click', 'li', (e) => {\n            let index = $(e.target).index();\n            this.changeSong(index);\n        })\n\n        //音量控制 audio标签音量 vlouem 属性控制0-1\n\n        new Progress('.control__volume--progress', {\n            min: 0,\n            max: 1,\n            value: this.audio.volume,\n            handler: (value) => { //更改进度时\n                this.audio.volume = value;\n            }\n        })\n        //歌曲进度 this.audio.duration\n        //可以播放的时候触发（歌曲的基本信息都已经获取到了）\n        this.audio.oncanplay = () => {\n            //避免重复实例化\n            if (this.progress) {\n                this.progress.max = this.audio.duration; //切换歌曲后更新时长\n                this.render_time.total.html(this.util.formatTime(this.audio.duration));\n                return false;\n            };\n            this.progress = new Progress('.player__song--progress', {\n                min: 0,\n                max: this.audio.duration,\n                value: 0,\n                handler: (value) => {\n                    this.audio.currentTime = value;\n                }\n            })\n            //调整总时长\n            this.render_time.total.html(this.util.formatTime(this.audio.duration));\n        }\n\n        //会在播放的时候持续触发\n        this.audio.ontimeupdate = () => {\n            this.progress.setValue(this.audio.currentTime);\n            //调整当前时长\n            this.render_time.now.html(this.util.formatTime(this.audio.currentTime));\n        }\n\n        //当歌曲播放完成的时候\n        this.audio.onended = () => {\n            this.changeSong('next');\n            //播放完，换歌后，重新播放\n            this.audio.play();\n        }\n\n    }\n\n    //播放暂停控制\n    handlePlayAndPause() {\n        let _o_i = this.$play.$el.find('i');\n        //this.audio.pauseed值为true 说明目前是不播放\n        if (this.audio.paused) { //现在是暂停的 要播放\n            this.audio.play();\n            _o_i.removeClass('icon-play').addClass('icon-pause');\n            this.disc.image.addClass('play');\n            this.disc.pointer.addClass('play')\n        } else {\n            this.audio.pause();\n            _o_i.addClass('icon-play').removeClass('icon-pause');\n            this.disc.image.removeClass('play');\n            this.disc.pointer.removeClass('play');\n        }\n    }\n\n    //更改循环模式\n    changePlayMode() {\n        this.loop_mode++;\n        if (this.loop_mode > 2) this.loop_mode = 0;\n        this.renderPlayMode();\n    }\n    //更改按钮样式\n    renderPlayMode() {\n        let _classess = ['loop', 'random', 'single'];\n        let _o_i = this.$mode.$el.find('i');\n        //prop 改一些标签的自有属性 attr改一些标签的自定义属性\n        _o_i.prop('class', 'iconfont icon-' + _classess[this.loop_mode])\n    }\n    //更改歌曲索引\n    changeSongIndex(type) {\n        if (typeof type === 'number') {\n            this.song_index = type;\n        } else {\n            if (this.loop_mode === 0) {\n                //列表循环\n                this.song_index += type === 'next' ? 1 : -1;\n                if (this.song_index > this.musics.songs.length - 1) this.song_index = 0;\n                if (this.song_index < 0) this.song_index = this.musics.songs.length - 1;\n            } else if (this.loop_mode === 1) {\n                //随机播放\n                let _length = this.musics.songs.length;\n                let _random = Math.floor(Math.random() * _length);\n                for (let i = 0; i < 10000; i++) { //随机的数为本身则继续随机\n                    if (this.song_index == _random) {\n                        _random = Math.floor(Math.random() * _length);\n                    } else {\n                        this.song_index = _random;\n                        break;\n                    }\n                }\n            } else if (this.loop_mode === 2) {\n                this.song_index = this.song_index;\n            }\n        }\n    }\n    //歌曲时长\n    songTime() {\n        let totalMinute = parseInt(this.audio.duration / 60) < 10 ? \"0\" + parseInt(this.audio.duration / 60) : parseInt(this.audio.duration / 60);\n        let totalSecond = parseInt(this.audio.duration % 60) < 10 ? \"0\" + parseInt(this.audio.duration % 60) : parseInt(this.audio.duration % 60);\n        $('.totalTime').text(totalMinute + ':' + totalSecond);\n    }\n    //切换歌曲\n    changeSong(type) {\n        //更改索引\n        this.changeSongIndex(type);\n        //记录切歌前的状态\n        let _is_pause = this.audio.paused;\n        //切歌后更改视图显示\n        this.renderSongStyle();\n        //如果切歌前是在播放，就继续播放\n        if (!_is_pause) this.audio.play();\n    }\n    //禁音\n    banNotes() {\n        let _o_i = this.$ban.$el.find(\"i\");\n        if (this.audio.muted == true) { //如果禁音则开启\n            this.audio.muted = false;\n            _o_i.removeClass('icon-muted').addClass('icon-volume');\n        } else {\n            this.audio.muted = true;\n            _o_i.removeClass('icon-volume').addClass('icon-muted');\n        }\n    }\n}\n\n//进度条\nclass Progress {\n    constructor(selector, options) {\n        $.extend(this, options);\n        ///给this挂载传入的参数\n        this.$el = $(selector);\n        this.width = this.$el.width();\n        this.init();\n    }\n\n    //进度条初始化\n    init() {\n        this.renderBackAndPointer();\n        this.bindEvents();\n        this.drag();\n        this.value;\n        this.changeDOMStyle(this.width * this.value);\n    }\n    //为进度条渲染back和pointer\n    renderBackAndPointer() {\n        this.$back = $('<div class=\"back\">');\n        this.$pointer = $('<div class=\"pointer\">');\n\n        this.$el.append(this.$back);\n        this.$el.append(this.$pointer);\n    }\n\n    setValue(value) { //主动调用，传入value值，设置进度条样式\n        let _distance = this.width * value / (this.max - this.min);\n        this.changeDOMStyle(_distance);\n    }\n\n    drag() {\n        let ele = this.$pointer;\n        let father = this.$el;\n        let flag = false; //鼠标是否点击\n        ele.mousedown((e) => {\n            flag = true;\n            let mousePos = {\n                x: e.offsetX\n            }\n            $(document).mousemove((e) => {\n                if (flag === true) {\n                    let _left = e.clientX - father.offset().left - mousePos.x;\n                    let _distance = Math.max(0, Math.min(_left, father.outerWidth(false) - ele.outerWidth(false)))\n                    let _ratio = _distance / father.outerWidth(false);\n                    let _value = _ratio * (this.max - this.min); //当前的音量值\n                    this.changeDOMStyle(_distance);\n                    this.handler(_value); //更改进度之后，执行回调\n                }\n            })\n        })\n        $(document).mouseup(() => {\n            flag = false;\n        })\n\n    }\n\n    bindEvents() { //鼠标点击时更改\n        this.$el.click((e) => {\n            let _x = e.offsetX; //鼠标距离元素左边的距离\n            let _ratio = _x / this.width;\n            let _value = _ratio * (this.max - this.min); //当前的音量值\n            this.changeDOMStyle(_x);\n            this.handler(_value); //更改进度之后，执行回调\n        })\n    }\n    //更改pointer和back\n    changeDOMStyle(distance) {\n        this.$back.width(distance + 7 == 7 ? 0 : distance + 7);//进度为0时将进度条背景改为0否则加上进度按钮的长度\n        this.$pointer.css('left', distance + 'px');\n    }\n}\n\n\n//按钮类 \nclass Btns {\n    constructor(selector, handlers) {\n        this.$el = $(selector); //元素\n        this.bindEvents(handlers);\n    }\n    bindEvents(handlers) { //绑定事件\n        for (const event in handlers) {\n            //使用值的时候保证键值对在对象中是存在的\n            if (handlers.hasOwnProperty(event)) {\n                this.$el.on(event, handlers[event]);\n            }\n        }\n    }\n}\nnew Player();\ndocument.addEventListener('pjax:complete', (e) => {\n    new Player();\n})\n\n```\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`utill.js`。\n```js\nclass Util {\n    constructor() {\n        if (Util.instance) return Util.instance;\n        return this.getInstance(...arguments);\n    }\n\n    getInstance() {\n        var instance = {\n            /*\n             *   formatTime 格式化时间（s）为 hour:minutes:seconds\n             *   @params  time  required number (s)\n             *   \n             *   return hour:minutes:seconds string\n             */\n\n            formatTime(time) {\n                //没有传time的时候\n                if (time === undefined) {\n                    this.handlerError(123, {\n                        method: 'formate',\n                        param: 'time'\n                    });\n                    return false;\n                }\n                let _time = Math.floor(time);\n                let _minutes = Math.floor(_time / 60);\n                let _hours = Math.floor(_minutes / 60);\n                let _seconds = _time - (_minutes * 60);\n\n                return (_hours ? this.fillZero(_hours) + ':' : '') + this.fillZero(_minutes - (_hours * 60)) + ':' + this.fillZero(_seconds);\n            },\n            /*\n             *   fillZero 为小于10的数字补0\n             *   @params  num  required number\n             *   return '01'.. string\n             */\n            fillZero(num) {\n                //当没有传time的时候\n                if (num === undefined) {\n                    this.handlerError(123, {\n                        method: 'fillZero',\n                        param: 'num'\n                    });\n                    return false;\n                }\n                //这个函数只是让我们在渲染/显示的时候有一个不同的效果，不要操作原数据\n                return num > 9 ? num : '0' + num;\n            },\n            errors: {\n                123: ({\n                    method,\n                    param\n                }) => {\n                    return method + 'function need a param ' + param;\n                }\n            },\n            handlerError(code, options) { //处理报错\n                console.error('[until error] message' + this.errors[code](options));\n            }\n        }\n        Util.instance = instance;\n        return instance;\n    }\n}\n\n//为了这个工具以后在模块化环境中依然可以使用，需要判断一下，如果是在模块化环境，就将其暴露出去\n//commonJs\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = Util;\n}\n\n//AMD\nif (typeof define === 'function' && define.amd) {\n    define('util', [], function () {\n        return Util;\n    });\n}\n\n```\n\n&emsp;&emsp;引入css（一些高度和细节按需自行调整）：\n```css\n/* 播放器大小 */\n.music-player {\n  width: 570px;\n  height: 500px;\n}\n.music-player h3{\n  margin: 0px 0 1px!important;\n}\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1537976418058'); /* IE9*/\n  src: url('iconfont.eot?t=1537976418058#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAmcAAsAAAAADgwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY8lGHxY21hcAAAAYAAAACUAAACBGvSDaxnbHlmAAACFAAABUMAAAbwatoOAWhlYWQAAAdYAAAALwAAADYSwtboaGhlYQAAB4gAAAAcAAAAJAfeA4tobXR4AAAHpAAAAA8AAAAoKAAAAGxvY2EAAAe0AAAAFgAAABYIpgZ4bWF4cAAAB8wAAAAdAAAAIAEYAGNuYW1lAAAH7AAAAUUAAAJtPlT+fXBvc3QAAAk0AAAAZQAAAJSspZ5ZeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeyf3/z9zwv4EhhrmBoQEozAiSAwD0fA0ZeJztkcENwjAQBMdxCAQhQgU88qYeesBKGoh48aLSS7oIa1+QKIKzxtKedWdpF9gBUdxEDeFNINdL3VD6kWPp19ylzxyoaOxqvSUb57RM6wqbHr76p4Jm/Fx0oNGfUVtabdzrueFfp3I/N9VmPx25hfVOzsqSkzOzwZGX2Ojk2Tk5Oc9lcuR0x6OQE+lIBag+4Pgp1HicbVVrjBNVFJ5z796Zvu482plOH0tLZ9rp7hba0m5bZLuUhwZNQEB2F7airBDlERd5/IX4b+MPE3/wUhMTEkLEQAwkhpAIgcCaGI3xpyQqwb/orgsmGs129Ex3UWJoJufec+43PfN955wZgQjC37/SL6giGEKvIESgHjWNHBpNhnzOQAPOILCaH2psI9xP9BNQ4gNACqb7kBRi7lKVbnEvuU2YhhG4ADuUUOn0bUUpdl4e0JU7J9HAuFYEZ3bWveNOz8wI+PtfTj+ITr7G0GirwWQ1NBDVIWf4wcjRz9ylsQJxH5oFAgNxUEh/Au6r85cx3bTbdC/BdvdjRR84eQcNOV9UlNunSyHFvRAuut/PzEAThmdnMWcP5nxA99F9giZkhKIwJAhmEbyMjYoJKdBFCUQqg6mJUbPegLqDxCOWU29BPQWiAqL0pHO3UAGoFJZaRE2l0+nOo2w6IQPICS1K5CxYnTmj45Noj48FRMKknq8854Ou835PFJoVcrbSBN29rJXqpbB7RacbSJ/cmVD6CIRgs1HWYWuw82UwSBmlgQBl5DjuJyj1oyWLGn5Na7QhKEJaEMCWwdD0qFlFQqh3Dn1JS8Fjn/zeStp2spWwAWy3vDrprcmFhTZw2wl3jxJkduHoSd+rGcV8f9Cb1C/khPXCGGbEBHjZljNYb3hZ8Krm0amksXooER60wHQsUU+DjVI7MkTNFAyBJOrRCio5mIcqPmHUrKDYCMBH1qPkkfPuuolPnx+KxGKRofJHG9sfDq9s8oQtT4VCU7KV5E0i2wneXNn70nLZjgNf/3oJAUnLA8x/PmTvHOBqJA5y662a9yekxI6v3fUejediwN7ZOP42XcUzidAUz/KpUCLLV//EE1l5GNYUOCSzvPXsKm4lOB6HYC9dlw9Bb5YPbQCI5eKLOqDZT34RkqjEWk95SxIlz3j6D0Eam6mKa72hOdQpga1VReynRn3QsRRUoavHogRmtIIqEE44v+HfG+FKIrK/NhGLAeckLkmWOvrasWNkxyFg45KsSuNtSeViuy1yVWqPS6oskZ/95wIhVXUfRBKlrRHD39NLTvd2dskvjEAv2bzbnW6LGpfGxyWueTf+u+/Ow4/0IrVxHvqFljCKTLCeBSzrEvB4VKJpwKoUACuDI4mBegPfC0hSzDfEIvLDghc9CM5rCgxdNBejtf+iJs5E5x5HDcLxeLiq2fzenz7DX82VcXrsqt/wAZUjEfmKTwtSKdsH0JeTIKhJy1as0LuxTaMwuqkbGnkV4BVy91owBHHtejjGg9feZz4oZ6/bFZ/4XdAfnp8L+4M/MKJobMnW4rIXU6ImEzG7q/7M7m9wtjWxeXH3zvMtjAJ77uobb95YnKNb9BZdIzjCJkHIZbAfZawpVq4ILWRR7XJTIIN0a9jd0SUoEWTyDopS9URKgYIR7HA8bUEGZwLxljOM95KrLi8rQAzFp7LJAAlNMtWn6D7WD3NjB4mW0ugp14K5sroI8ZPggccQV912eAEysDwQUTQfmwj0BvYwBroicZanh0bGFE1TxiZPkE+eimBHxtpyOCxvP3qmO783uzzzwubu/Fqix0TKeBUbdPKW91rr0qlipZH+AmGHVeoelUYGu8PQvWHF0e2qY1uihL28wDjKNFsyGxo9q2jk4Jir9jOf3uUUhECXtoFfjjL8duQU1eavIOjwNph7DDoQJP5FkFp2VQ8D35a3qMNwDgmOHKJ5xiVFB8b2IMMJ5tOUSGA5PTGJCmwJy+2xI+ypCHLm6HY5fBTWrOrvd//Ccv8D5gQugwB4nGNgZGBgAOJ0oeli8fw2Xxm4WRhA4PrFk0kI+v9+FgbmDCCXg4EJJAoAItUKtAB4nGNgZGBgbvjfwBDDwgACQJKRARVwAQBHEAJzeJxjYWBgYCECAwADmAApAAAAAAAAOgB0ANwBFAGYAfwCgAL0A3gAAHicY2BkYGDgYghnYGEAASYwjwtI/gfzGQASMwF8AAAAeJxlj01OwzAQhV/6B6QSqqhgh+QFYgEo/RGrblhUavdddN+mTpsqiSPHrdQDcB6OwAk4AtyAO/BIJ5s2lsffvHljTwDc4Acejt8t95E9XDI7cg0XuBeuU38QbpBfhJto41W4Rf1N2MczpsJtdGF5g9e4YvaEd2EPHXwI13CNT+E69S/hBvlbuIk7/Aq30PHqwj7mXle4jUcv9sdWL5xeqeVBxaHJIpM5v4KZXu+Sha3S6pxrW8QmU4OgX0lTnWlb3VPs10PnIhVZk6oJqzpJjMqt2erQBRvn8lGvF4kehCblWGP+tsYCjnEFhSUOjDFCGGSIyujoO1Vm9K+xQ8Jee1Y9zed0WxTU/3OFAQL0z1xTurLSeTpPgT1fG1J1dCtuy56UNJFezUkSskJe1rZUQuoBNmVXjhF6XNGJPyhnSP8ACVpuyAAAAHicbcrBCoNADATQjLau3dWPjBTdaInINqD9+gb06MBc3gxVdCbSfSIq1HjgiQYBLV6ISJRKZp0OKXm1sBjLLNoM6+gYfqxf0SkVc73MZ39r6/2IQ7+bZmM95+7NutlFRH+UdSMxAAAA') format('woff'),\n  url('iconfont.ttf?t=1537976418058') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1537976418058#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.icon-prev:before { content: \"\\f0069\"; }\n\n.icon-next:before { content: \"\\f006a\"; }\n\n.icon-play:before { content: \"\\e66a\"; }\n\n.icon-pause:before { content: \"\\e76a\"; }\n\n.icon-random:before { content: \"\\e622\"; }\n\n.icon-muted:before { content: \"\\e61e\"; }\n\n.icon-volume:before { content: \"\\e87a\"; }\n\n.icon-loop:before { content: \"\\e66c\"; }\n\n.icon-single:before { content: \"\\e66d\"; }\n\n\n/* 播放器位置 */\n.music-player {\n  position: relative;\n  margin: 0px auto;\n}\n\n/* 歌曲列表 */\n\n.music-player__list {\n  width: 100%;\n  padding: 10px;\n  margin-top: 30px;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 5px;\n  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n}\n\n.music__list__item {\n  padding-left: 25px;\n  color: #ccc;\n  position: relative;\n  margin-bottom: 10px;\n  font-size: 14px;\n  cursor: pointer;\n}\n\n.music__list__item:last-of-type {\n  margin: 0;\n}\n\n.music__list__item.play {\n  color: #fff;\n}\n\n.music__list__item.play:before {\n  font-family: 'iconfont';\n  content: \"\\e87a\";\n  position: absolute;\n  left: 0px;\n  top: 4px;\n}\n/* 播放器主体 */\n.music-player__main {\n  height: 180px;\n  padding: 25px;\n  box-shadow: 0 0 10px rgb(0 0 0 / 20%);\n  border-radius: 10px;\n  position: relative;\n  overflow: hidden;\n}\n\n/* 播放器主体模糊背景 */\n.music-player__blur {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-size: 100%;\n  left: 0;\n  top: 0;\n  z-index: -1;\n  -webkit-filter: blur(20px);\n  filter: blur(20px);\n}\n/* 播放器唱片效果 */\n.music-player__disc {\n  float: left;\n  width: 130px;\n  height: 130px;\n  background: url(/img/cd.png) no-repeat center;\n  background-size: 100%;\n  position: relative;\n}\n\n/* 唱片指针 */\n.music-player__pointer {\n  width: 25px;\n  position: absolute;\n  right: -10px;\n  top: 0;\n  -webkit-transform-origin: right top;\n  -ms-transform-origin: right top;\n  transform-origin: right top;\n  -webkit-transform: rotate(-15deg);\n  -ms-transform: rotate(-15deg);\n  transform: rotate(-15deg);\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n}\n\n/* 唱片指针播放状态 加play类名 */\n.music-player__pointer.play {\n  -webkit-transform: rotate(0deg);\n  -ms-transform: rotate(0deg);\n  transform: rotate(0deg);\n}\n\n/* 唱片歌曲图片 */\n.music-player__image {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n/* 播放器控件 */\n.music-player__controls {\n  width: 330px;\n  height: 130px;\n  float: right;\n}\n\n/* 歌曲信息 */\n.music__info {\n  width: 100%;\n  height: 50px;\n  margin-bottom: 15px;\n}\n\n.music__info .music__info--title {\n  color: #fff;\n}\n\n.music__info .music__info--title {\n  font-size: 16px;\n}\n/* 控件 */\n\n.player-control {\n  width: 100%;\n}\n\n.player-control__content {\n  overflow: hidden;\n}\n\n/* 播放暂停按钮 */\n.player-control__btns {\n  float: left;\n  overflow: hidden;\n}\n\n.player-control__btn {\n  float: left;\n  margin: 0 5px;\n  font-weight: bolder;\n  color: #fff;\n  cursor: pointer;\n}\n\n.player-control__volume {\n  float: right;\n  overflow: hidden;\n}\n\n.control__volume--progress {\n  float: left;\n  width: 100px;\n  position: relative;\n  top: 8px;\n}\n\n.player__song--timeProgess{\n  font-size: 12px;\n  color: #fff;\n  padding: 0px 3px;\n  background: rgba(0, 0, 0, 0.3);\n  border-radius: 5px;\n}\n\n.player-control__content .nowTime{\n  float: left;\n}\n.player-control__content .totalTime{\n  float: right;\n}\n\n.music-player .progress {\n  background: rgba(0, 0, 0, 0.3);\n  height: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  overflow: hidden;\n  margin: 0.5rem 0!important;\n  border-radius: 2px;\n  position: relative;\n  cursor: pointer;\n}\n\n.music-player .progress .back {\n  width: 0px;\n  height: 100%;\n  border-radius: 2px;\n  background: rgb(12, 182, 212);\n}\n\n.music-player .progress .pointer {\n  width: 7px;\n  height: 7px;\n  background: #fff;\n  border-radius: 50%;\n  opacity: 0;\n  -webkit-transition: opacity 0.3s;\n  -o-transition: opacity 0.3s;\n  transition: opacity 0.3s;\n  position: absolute;\n  top: -1px;\n  left: 0;\n}\n\n.music-player .progress:hover .pointer {\n  opacity: 1;\n}\n\n\n/* 播放 画片 动画 */\n\n@-webkit-keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n\n@keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n.music-player__image.play {\n  -webkit-animation: disc 5s linear 0s infinite;\n  animation: disc 5s linear 0s infinite;\n}\n/*  播放进度  */\n.player__song--progress {\n  width: 100%;\n  margin-top: 15px;\n}\n.music-player h1, .music-player h2, .music-player h3,.music-player h4, .music-player h5, .music-player h6, .music-player p {\n  margin: 0; padding: 0;\n}\n.music-player li { list-style: none; }\n\n```\n\n&emsp;&emsp;修改`player.js`里`this.songs`的歌曲信息，把音乐换成自己的，接着三连即可。\n>本地浏览可能音乐的进度条无法拖动或者一拖动音乐就回到最开头，问题不大，推送上去就正常了。\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"归档、分类、标签页文章卡片加上所属分类和标签","url":"/article/a19bb7fb.html","content":"\n# 前言\n&emsp;&emsp;如图，上面修改前，下面修改后。\n<img src=https://cdn.chuckle.top/images/23-2.webp width=\"90%\" height=\"90%\">\n\n# 实现\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug`\n```\n.article-sort-item-info\n    .article-sort-item-time\n        time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n        a.article-sort-item-title(href=url_for(article.path) title=title)= title\n+    .article-meta-wrap\n+        if (theme.post_meta.page.categories && article.categories.data.length > 0)\n+            span.article-sort-item-categories\n+                i.iconfont.icon-fenlei//- 记得改成自己的图标\n+                each item, index in article.categories.data\n+                    a(href=url_for(item.path)).article-meta__categories #[=item.name]\n+                    if (index < article.categories.data.length - 1)\n+                       i.fas.fa-angle-right\n+        if (theme.post_meta.page.tags && article.tags.data.length > 0)\n+            span.article-sort-item-tags\n+                i.iconfont.icon-biaoqian//- 记得改成自己的图标\n+                each item, index in article.tags.data\n+                    a(href=url_for(item.path)).article-meta__tags #[=item.name]\n+                    if (index < article.tags.data.length - 1)\n+                        span.article-meta__link #[='•']\n+        .article-sort-item-time\n+            time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n\n```\n\n&emsp;&emsp;增加css：根据自己的实际样式情况进行微调，没有通用css。\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"控制指定单页的背景样式","url":"/article/eb3a4679.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客单页，无论是哔哔，友链，还是关于页，page的背景都是透明的，一开始我以为是在单页的index.md里单独引入css，后来才知道，是直接`#page{background:transparent;}`,这只会让所有非文章、归档、分类、标签的单页背景透明。\n\n&emsp;&emsp;这好啊，果断抄走，然后不出意外，有些单页变得很难看，因为没关侧边栏（侧边栏没透明，page透明了），或因为背景透明后字看不清（友链页），反正，我需要能单独控制单页page的背景样式，说干就干，让不同单页加上不同class，css控制这些class即可。\n<img src=https://cdn.chuckle.top/images/22-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n# 实现\n## 方案一\n&emsp;**让指定单页背景样式相同(如透明)**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制哪些单页的背景就加上is_current('<单页路径>')\nblock content\n+  - let transparent = (is_current('/bb/') || is_current('/charts/')) ? true : false\n-  #page\n+  #page(class= (transparent === true) ? 'transparentpage' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug 这里是让指定单页的背景都透明\n.transparentpage{\n    background:transparent!important;\n}\n\n```\n\n## 方案二\n&emsp;**控制不同单页有不同背景样式**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制更多单页就仿照格式写\nblock content\n+  - let bb = is_current('/bb/') ? true : false\n+  - let charts = is_current('/charts/') ? true : false\n-  #page\n+  #page(class= (bb === true) ? 'bb-transparent' : '')(class= (charts === true) ? 'charts-transparent' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug\n.bb-transparent{\n    background:transparent!important;\n}\n.charts-transparent{\n    background:blue!important;\n}\n\n```\n\n&emsp;&emsp;此方法存在一个问题：\n&emsp;&emsp;hexo g和hexo s时，会提示:You should not have pug tags with multiple attributes.（您不应该使用具有多个属性的pug标记）\n&emsp;&emsp;这是因为我尝试多次class=()，但实际上，因为路径是唯一的，这不会导致出问题，对hexo渲染没有影响。\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly给首页首个文章卡片加个class","url":"/article/dbde845d.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客首页，他的第一个文章卡片是其余卡片宽度的两倍，F12可知是首页的首个文章卡片多了一个class，虽然我的文章卡片暂时没这需求，但刚好有人问怎么才能控制首页第一个文章卡片的样式，也刚好我有思路，就实现一下吧\n&emsp;&emsp;关键就是怎么给首个文章卡片加一个class，我想到了和之前[给文章卡片加上最新文章标志](/article/2ed7d622.html)差不多的操作\n<img src=https://cdn.chuckle.top/images/21-2.webp width=\"100%\" height=\"100%\">\n***\n\n# 实现\n&emsp;&emsp;先看原来post-ui的结构:``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    .recent-post-item//要在这里加个calss\n    //后面就是文章卡片的具体的内容\n\n```\n\n&emsp;&emsp;可以改成这样，就能将首页第一个文章卡片和其余卡片分开渲染成html，自然，加个class就轻而易举了\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    if (firstpost !== 1 && is_current('/'))\n      - var firstpost = 1\n      .recent-post-item.firstpost-item\n      //首页首个文章卡片的具体的内容（cv原来的就行）\n    else\n      .recent-post-item\n      //其余文章卡片的具体的内容（cv原来的就行）\n\n```\n\n&emsp;&emsp;这样，首页第一个文章卡片就会多一个``firstpost-item``class，控制这个class就能控制样式了\n<img src=https://cdn.chuckle.top/images/21-1.webp width=\"40%\" height=\"40%\">\n\n&emsp;&emsp;而且这样改完pug，首页第一个文章卡片有更多的操作空间，可以完全和其余卡片长得不一样，修改具体内容里的源码即可\n***\n\n# 优化\n&emsp;&emsp;[@heo](https://blog.zhheo.com/)的代码结构优化版本（适合无需对首页第一个卡片进行定制化）\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    - let lastPost = firstpost !== 1 && is_current('/') ? true : false\n    - var firstpost = 1\n    .recent-post-item(class= (lastPost === true) ? 'firstpost-item' : '')\n    \n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly文章卡片加上最新文章标志","url":"/article/2ed7d622.html","content":"\n# 前言\n&emsp;&emsp;昨天[@Leonus](https://blog.leonus.cn/)大佬用js给首页最新的文章卡片加上了``最新``标志:[几行代码实现最新文章标志 | Leonus](https://blog.leonus.cn/2022/newpost.html)\n&emsp;&emsp;不过每次切换到首页都要执行这个js，不然最新标志就不显示，开启了pjax之后,怎么让这js每次切换到首页都执行是个问题，而且每次都执行也会多吃一些性能\n\n&emsp;&emsp;因为butterfly是按创建时间顺序排序的，最上面的卡片就是最新文章，直接修改文章卡片源码，给第一个卡片加上``最新``标志就行了（当然还要排除手动置顶的文章）\n&emsp;&emsp;这样pug渲染成html时，``最新``标志就写死在那了\n<img src=https://cdn.chuckle.top/images/20-1.webp width=\"30%\" height=\"30%\">\n***\n\n# 实现\n>我这实现看起来挺笨，有大佬有更好的实现方式不\n\n1. 修改``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``&emsp;加上三行：\n```pug\n.recent-post-info\n+    if (numberone !== 1 && is_current('/') && (!article.top || (article.new && article.top)))\n+        span.newPost 最新\n+        - var numberone = 1\n```\n\n2. 在你的自定义css文件中，添加如下代码：\n```css\n/* 最新文章图标 */\n.newPost {\n    position: absolute;\n    top: 0;\n    color: rgba(255, 255, 255, 0.92);\n    padding: 0 15px;\n    background-color: #49b0f5b9;\n    border-radius: 0 0 10px 10px;\n    right: 40px;\n}\n@media screen and (max-width:600px){\n  .newPost {\n    right: 0px;\n    padding: 0 12px;\n    border-radius: 0 10px 0px 10px;\n}\n}\n```\n\n***\n\n# 使用\n&emsp;&emsp;当首页没有置顶时，会给第一个卡片加上最新标志\n&emsp;&emsp;当首页有置顶时，会给非置顶的第一个卡片加上最新标志\n\n&emsp;&emsp;显然，这里有bug，如果置顶里的文章就是最新的咋办？\n&emsp;&emsp;只需要在文章头部加上``new: true``就行了\n\n&emsp;&emsp;稍微有点麻烦，所以，建议最新的文章就没必要置顶了，反正不置顶也在第一个\n```\n---\ntitle: aaaaaaaaaa\ntop: 1\n+ new: true\n---\n```\n\n***\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"小米妙享--MIUI的生态互联","url":"/article/eb38f645.html","content":"\n# 引言\n&emsp;&emsp;不少人去年就听说了这个功能，作为小米产品生态构建的重要一环（全局设备互联互通），这个功能我却迟迟没去更新使用，因为它与miui+的割裂导致使用起来比较繁琐，也因为它把平板排除于外，当然最主要是我实在没有这么多设备需要去``流转``。\n&emsp;&emsp;但在最近的更新中，``小米妙享``不仅将miui+给整合进了`妙享中心`，还带上了小米平板5系列，为平板与电脑的互联互通增加了几个重要的功能。\n\n# 如何安装\n&emsp;&emsp;我喜欢小米的一点，就是它将系统功能都作为一个个软件的形式打包，不同批次的软件之间兼容性也不错，除非跨安卓版本才能实现的功能（例如米版的全局手写，这个基于安卓12，自然安卓11用不了），都可以通过安装或更新软件来使用新功能，正好，小米妙享就是这样一个安装即用的系统功能。  \n\n## 平板/手机端\n&emsp;&emsp;我的平板还在13.0.6这个稳定版养老，下载安装最新的`miui+`、`投屏`、`小米互联通信`,手机端就搞定了(没有资格就刷个`Miui解锁小米妙享模块`)。\n\n## 电脑端\n&emsp;&emsp;目前电脑端软件有限制，只有小米电脑上才能使用，但这难不倒酷友们，跟着此帖即可在电脑端安装好妙享中心：[最新miui+（小米妙享）PC版安装及配置教程](https://www.coolapk.com/feed/38357299?shareKey=MzdiMWMzNjNmMTgwNjJmYTcyYmI~&shareUid=4137393&shareFrom=com.coolapk.market_12.0.2)。\n\n# 使用体验\n\n## 互联\n&emsp;&emsp;电脑打开蓝牙，平板打开蓝牙、wifi、小米互传，让设备处于同一网络下，电脑端点击连接，等待`1-2秒`，很快即可连接上。且蓝牙wifi我一般保持常开，平板使用时也是手机或电脑给平板开热点，基本能做到需要就点击连接。\n<img src=https://cdn.chuckle.top/images/19-1.webp width=\"60%\" height=\"60%\"><img src=https://cdn.chuckle.top/images/19-3.webp width=\"60%\" height=\"60%\">\n\n## 平板作为电脑副屏\n&emsp;&emsp;这个功能是这次妙享更新后给米版上的新功能，在连接成功后可以看到两种副屏方式，作为镜像屏，或者扩展屏。选择任意一种副屏方式，同样等待2秒，就可完成副屏的启动。\n&emsp;&emsp;作为一个`无线可触摸`的副屏，使用起来非常舒适。\n<img src=https://cdn.chuckle.top/images/19-2.webp width=\"60%\" height=\"60%\">&emsp;&emsp;侧边栏有一些快捷键：“返回桌面”“多任务”“保存”“返回/撤销上一步操作”“保存截图”“屏幕键盘”“退出”。\n\n### 作为镜像屏\n&emsp;&emsp;利用秒表测试有0.04s延迟（屏幕一半播视频，一半秒表计时，拍照算时差，确保符合正常使用的延迟），实际体验下延迟确实可忽略不计，分辨率1920*1080（等同电脑屏幕分辨率），但帧率在40到60之间波动，习惯了120帧确实有点不舒服，不过也远胜我之前用的spacedesk。\n<img src=https://cdn.chuckle.top/images/19-4.webp width=\"60%\" height=\"60%\">&emsp;&emsp;小米妙享实际上是一个软件，那当然可以上滑挂在后台，或者挂个小窗在前台。  \n\n<img src=https://cdn.chuckle.top/images/19-5.webp width=\"60%\" height=\"60%\">&emsp;&emsp;在电脑端还可以设置侧边栏的位置、使用米板作为电脑的音频输出等。\n\n<img src=https://cdn.chuckle.top/images/19-6.webp width=\"60%\" height=\"60%\">\n\n### 作为扩展屏\n&emsp;&emsp;作为扩展屏时与镜像屏时差不多，同样有低延迟、高分辨率（作为扩展屏时分辨率1920*1200），同样可以挂后台挂小窗，设置侧边栏的位置、使用米板作为电脑的音频输出等。\n&emsp;&emsp;但此时帧率在30到50之间波动，可以感觉到鼠标拖动的略微不顺畅的卡顿，且窗口在平板与电脑直接拖动时，大小变化还有待优化，经常拖到平板还得再手动调小窗口大小。\n<img src=https://cdn.chuckle.top/images/19-7.webp width=\"60%\" height=\"60%\">\n&emsp;&emsp;无论是作为镜像还是扩展屏，吃电脑资源都不多。\n<img src=https://cdn.chuckle.top/images/19-10.webp width=\"70%\" height=\"70%\">\n\n## 平板投屏到电脑\n&emsp;&emsp;应用流转仅限于小米的设备，自然投屏也需要小米笔记本才行，不过酷友[@迷璐](https://www.coolapk.com/u/1189245)的模块可以让其它品牌的电脑也出现在妙享界面，只需要将平板画面拖到电脑的气泡上，1-2秒后，电脑上就有平板的投屏窗口了，投屏后平板可关闭屏幕。\n<img src=https://cdn.chuckle.top/images/19-11.webp width=\"60%\" height=\"60%\">&emsp;&emsp;投屏窗口可最大化可最小化，利用秒表测试有0.07s延迟（主界面播视频，小窗秒表计时，拍照算时差，确保符合正常使用的延迟），分辨率至少有1080p以上，帧数稳稳50-60帧。\n\n<img src=https://cdn.chuckle.top/images/19-12.webp width=\"60%\" height=\"60%\">&emsp;&emsp;值得注意的点是，这不是简单的投屏，投屏后，不仅平板的画面会在电脑上出现个窗口，平板上的所有音频也会用电脑的喇叭输出，而且可以直接使用电脑的键盘、鼠标去控制、操作平板。\n\n## 互通\n&emsp;&emsp;平板端截图，电脑会弹出有图和保存按键的小悬浮窗。\n<img src=https://cdn.chuckle.top/images/19-8.webp width=\"40%\" height=\"40%\">&emsp;&emsp;平板端或电脑端复制文字内容，另一个设备会同步这个内容到剪切板，并弹窗提示，且电脑端的弹窗会显示复制的文字内容。当任意一设备复制的是网址时，悬浮窗还会有直接打开网站的按键。\n\n<img src=https://cdn.chuckle.top/images/19-9.webp width=\"60%\" height=\"60%\">\n\n### 电脑与平板互传文件\n&emsp;&emsp;平板长按文件点分享，选择电脑即可；电脑端使用用小米互传向平板传文件，两种操作都非常方便且快速。\n<img src=https://cdn.chuckle.top/images/19-13.webp width=\"70%\" height=\"70%\">\n\n# 使用感受\n&emsp;&emsp;在简单上手平板与电脑之间的妙享后，可以确定，我以后将经常用到它的功能，实际上我还体验了平板-手机-电脑的三方互联互通，不过任意两个设备互联后，另一个设备就会断开连接（虽然重连很快，但还是很影响体验），所以三方互联的体验并不好，但平板-手机、手机-电脑之间的妙享体验也不错。\n&emsp;&emsp;可以看得出来MIUI还是有认真去做互联互通生态的，未来可期。\n\n# 不足之处\n1. 多设备同时互联体验差。\n2. 作为扩展屏与电脑之间拖动软件窗口，窗口大小自适应效果不好。\n3. 虽然博主安装起来较轻松，但不少酷友倒在了电脑硬件或其它配置上。\n4. 依赖核显（考虑考虑没核显或核显弱的笔记本？）。\n5. 平板投屏到电脑不能像手机与电脑的互联那样，直接拖文件传输。\n6. 手机应用流转到平板居然开倒车！直接全屏，而不是像之前那样在平板上弹出小窗。","tags":["小米妙享","MIUI"],"categories":["其它"]},{"title":"JavaWeb笔记--寄途的初始","url":"/article/7c1f73d5.html","content":"\n咕咕咕（\n","tags":["JavaWeb","JAVA"],"categories":["学习笔记"]},{"title":"JavaSE查缺补漏笔记","url":"/article/3c6a38d9.html","content":"\n>跟着翁恺或者学校的进度学完的JavaSE，如泛型、I/O、线程、映射、反射等等大部分没有提到或只是简略介绍，想要从JavaSE衔接上JavaEE，这些知识不可跳过。\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"超星学习通数据泄露事件记录","url":"/article/af84a159.html","content":"\n# 事件时间轴\n{% timeline 时间轴 ,blue %}\n<!-- timeline 2022-06-20 -->\n1. 学习通被爆有`1.7亿`师生账号信息`数据泄露`  \n包括手机号码、邮箱、姓名、学校、班级、明文密码等信息  \n随后，热搜词条`#学习通数据库疑发生信息泄露#`被撤,词条内容被屏蔽\n<div><img src=https://cdn.chuckle.top/images/13-1.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 上午-->\n`#学习通#`词条登顶微博热搜第一\n很多人发现自己学习通的使用量多达上万、几十万次（图为博主的次数，2万次）\n<div><img src=https://cdn.chuckle.top/images/13-2.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 15:45-->\n学习通就泄露事件做出声明：`目前还未发现数据泄露，确认不存在明文密码泄露。`\n<div><img src=https://cdn.chuckle.top/images/13-3.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 16:17-->\n学习通就异常使用量做出声明：`正常现象。`\n<div><img src=https://cdn.chuckle.top/images/13-4.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n***\n\n# 事件相关\n1. 2020年超星学习通就被[国家信息安全漏洞共享平台(cnvd)](https://www.cnvd.org.cn/)警告存在`信息泄露漏洞`\n{% link 超星学习通App存在信息泄露漏洞, https://www.cnvd.org.cn/flaw/show/CNVD-2020-61119, %}\n<div><img src=https://cdn.chuckle.top/images/13-5.webp width=\"40%\" height=\"40%\"></div>\n\n2. 著名蓝色机器人发通知与投票：\n<div><img src=https://cdn.chuckle.top/images/13-6.webp width=\"40%\" height=\"40%\"></div>\n\n3. 博主已中招\n<div><img src=https://cdn.chuckle.top/images/13-7.webp width=\"40%\" height=\"40%\"></div>\n\n4. 学习通的一些`免责条款`：总之，无责\n<div><img src=https://cdn.chuckle.top/images/13-8.webp width=\"40%\" height=\"40%\"></div>\n\n\n***\n","tags":["其它"],"categories":["其它"]},{"title":"记一次超声波避障小车比赛","url":"/article/81935dcb.html","content":"\n>去年第一次红外循迹比赛的时候我还没整博客，第二次便记录一下吧\n\n# 比赛简介\n学校机械院举办的智能小车比赛，一学期一次，上次是红外循迹，这次是超声波避障  \n小车是学院统一采购的，第一次去比赛时拿到的是散件，51单片机、电阻、其它芯片等，都得自己焊  \n\n***\n\n# 关于队伍\n一位机械院的同学在酷安私信我参不参加智能小车比赛，我那时还不认识他，但想着反正闲着也是闲着，参加点活动也好，便一拍即合，后面他又拉来了商学院的一位男同学和两位女同学  \n第一次比赛，我们也是唯一有商学院同学的队伍（其它队伍队均两机械两计科），不过我们队也是女同学最多的，Buff加满   \n\n队名我提议是秋名山车队，又是一拍即合  \n\n***\n\n# 关于比赛\n小车在上次比赛时就已搞好，所以这次重点在写个超声波避障程序烧进去  \n作为队里唯一的计科同学，这个程序当然得我搞了  \n但我倒也摸鱼，程序不难，测试过一次没毛病，剩下就是数值的微调（这就是我比赛前一天晚上才去调的原因么（误））\n\n***\n\n# 比赛过程\n过程简单，就是一遍一遍测试，然后改改数值，调调机制，然后队伍抽签轮流上，看谁跑的时间短  \n上午7个队（本来12个队，弃权了5个，新报名的队伍焊坏小车的不少），取前三进入下午复赛  \n\n***\n\n# 结果\n第一次的比赛我们第二，这次还是第二，属于万年老二了  \n上次有初赛复赛都有奖册，我拿了一本，这次只有复赛一本册子，给了队里一位女同学，争取以后人手一本  \n\n***\n\n# 一些图片\n<div><img src=https://cdn.chuckle.top/images/12-1.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-2.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-3.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-4.webp width=\"100%\" height=\"100%\"></div>\n\n***","tags":["Chuckle"],"categories":["Chuckle"]},{"title":"FakeLocation模拟校园跑教程","url":"/article/c5d354fd.html","content":"\n# 前言\n**本文未在任何平台出售，本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用，如有发现倒卖行为欢迎向博主反馈**\n\n我们学校用的是运动世界校园，所以就用这个软件为例，其他软件差不多  \n博主测试设备：红米k40安卓11、红米6pro安卓9  \n>吐槽：这软件，什么都往里塞，天天更新加广告（一指禅干掉）  \n\n**2023-03-17**这学期校园跑软件换成小步点了，软件使用手册里明确指出root和xp框架:\n<img src=https://cdn.chuckle.top/images/11-5.webp width=\"45%\">\n\n问题不大，照样。\n<img src=https://cdn.chuckle.top/images/11-6.webp width=\"30%\">\n\n# 准备工作\n1、首先是有面具**Root**，而非小米官方等残废root  \n2、下载万恶之源：运动世界校园  \n3、下载安装[FakeLocation1.3.0.2版本](https://wwm.lanzoul.com/iMHUo057ibyb)  \n4、下载安装[隐藏应用列表xp模块](https://wwm.lanzoul.com/iQ6lq057irkd)我使用的版本1.6较老，但能稳定用我也没去升级  \n5、安装lsp/xp框架  \n6、下载安装[Godvip](https://wwm.lanzoul.com/i8RYM057ibzc)  \n\n***\n\n# 隐藏防检测\n\n## 运动世界校园权限设置\n确保权限设置与图一致，关闭miui的模糊定位  \n<div><img src=https://cdn.chuckle.top/images/11-1.webp width=\"75%\"></div>\n\n## 隐藏root\n面具本身随机包名安装  \n面具hide对运动世界校园全勾选（如果是24版本的面具，自行去酷安找shamiko模块隐藏root教程，我还没升到24，因为我用hide就能很好地隐藏root）  \n\n## 隐藏应用列表设置\n推荐先看酷安详细图文：[隐藏应用列表使用教程 Pro](https://www.coolapk.com/feed/34458057?shareKey=YjBlYzcxNDgwMzYwNjI4OGIzZmM~)  \n\n简单速通：  \n1、lsp/edxp启用**隐藏应用列表**  \n2、也许需要重启手机  \n3、点击模板管理，启用所有隐藏方式  \n4、选择要隐藏的应用，将FakeLocation、面具、lsp等搞机应用勾选  \n5、对运动校园应用模板  \n<div><img src=https://cdn.chuckle.top/images/11-2.webp width=\"100%\" height=\"100%\"></div>\n\n## 破解FakeLocation\nlsp启用Godvip，模块对FakeLocation起作用  \n\n## FakeLocation设置\n给FakeLocation软件Root权限  \nFakeLocation设置页只打开**模拟GPS信号**  \n<div><img src=https://cdn.chuckle.top/images/11-3.webp width=\"50%\" height=\"50%\"></div>\n\n## 如何模拟跑\n首先到一个较空旷，能接收到gps信号的地方（宿舍阳台、宿舍走廊），拿个椅子坐下，手机关闭wifi（可以开启蓝牙和数据）  \nFakeLocation选择**要模拟的位置**到跑道，当然具体在哪无所谓  \n打开运动软件，**待运动软件接收到gps信号**提示可以开始跑，返回FakeLocation软件，点击**启动模拟**（第一次打开需要等待一会，建议在模拟跑前先开关一次预热），并**打开摇杆**  \n\n摇杆设置：  \n摇杆里的**模拟gps信号**和**步频模拟**都得关掉，不能打开！不能打开！不能打开！   \n<div><img src=https://cdn.chuckle.top/images/11-4.webp width=\"100%\" height=\"100%\"></div>\n\n接着返回运动软件，你会发现显示的位置瞬移到了之前选择的模拟位置处，然后开始运动，要去哪就**用摇杆摇**到哪，步频可以使用其它软件模拟，但**建议抖手**  \n跑完后先结束运动，关闭运动软件，再停止位置模拟  \n\n***\n\n# 可能出现的问题\n1、当摇杆回到中间时（速度为0），运动软件会提示gps信号弱，这是正常现象  \n2、启动模拟后，运动软件上显示的位置没变：杀掉运动软件和FakeLocation，重新操作一次  \n3、启动模拟后，运动软件上显示的位置变了，但一开始运动位置就变回原来位置：杀掉运动软件和FakeLocation，重新操作一次  \n4、被检测到环境异常4：FakeLocation没隐藏好、运动软件检测到gps信号长期未变。请自查有无和教程操作不同的地方  \n\n# 温馨提示\n\n>如有问题可在评论区回复或在酷安找我\n>本教程虽然目前还可行，博主自用了两个学期也没被检测到一次，但安卓设备众多，系统繁杂，不确保教程的通用性\n>Root手机导致手机变砖、假跑被检测到影响体育成绩等后果，博主不承担任何责任\n\n***\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(3)","url":"/article/8636f786.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)\n\n# Swing\n**Swing**是一个为Java设计的GUI工具包，是java的基础类（import javax.swing.*;）  \n在Swing中，所有我们在界面中看到的东西都是**部件**（组件）  \n\n其中容器是一种特殊的部件\n部件可以被放进容器中，当然容器也能放进容器中  \n\nSwing提供了一个底层容器类JFrame，即整个窗口    \n```java JFrame中常用的方法\n//创建一个无标题的窗口\nJFrame()\n//创建标题为s的窗口\nJFrame(String s)\n//设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\npublic void setBounds(int a,int b,int width,int height)\n//设置窗口的大小。\npublic void setSize(int width,int height)\n//设置窗口的位置，默认位置是(0,0)。\npublic void setLocation(int x,int y)\n//设置窗口是否可见，窗口默认是不可见的。\npublic void setVisible(boolean b)\n//设置窗口是否可调整大小，默认可调整大小。public voiddispose()撤销当前窗口，并释放当前窗口所使用的资源。\npublic void setResizable(boolean b)\n//撤销当前窗口，并释放当前窗口所使用的全部资源\npublic void dispose()\n//设置窗口的扩展状态\npublic void setExtendedState(int state)\n//其中参数state取JFrame类中的下列类常量:\nMAXIMIZED_HORIZ (水平方向最大化)，\nMAXIMIZED_VERT (垂直方向最大化)，\nMAXIMIZED_BOTH (水平、垂直方向都最大化)。\n//该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，\npublic void setDefaultCloseOperation(int operation)\n//其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\nDO_NOTHING_ON_CLOSE(什么也不做)，\nHIDE_ON_CLOSE (隐藏当前窗口)，\nDISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\nEXIT_ON_CLOSE (结束窗口所在的应用程序)\n```\n\n## add\n通过add把一个部件加到一个容器中  \n部件被加到容器后，就受这个容器所管理  \n容器管理部件的方式叫**布局管理器**  \nJFrame默认采用的布局管理器叫**BorderLayout**,默认把部件放到CENTER  \n```java\ntheView = new View(theField);//theView是一个容器\nJFrame frame = new JFrame();//创建一个底层容器\nframe.add(theView);//把theView容器加到底层容器中。默认为中间\nJButton btnstep =new JButton(\"单步\");//btnstep是一个按钮部件\nframe.add(btnstep, BorderLayout.SOUTH);//把btnstep部件加到底层容器中，且放到南边（窗口最下面）\n```\n\n## BorderLayout\nBorderLayout把整个容器划分为五个部分  \n<div><img src=https://cdn.chuckle.top/images/7-13.webp width=\"60%\" height=\"60%\"></div>\n\n后面放进去的部件会替换掉相同位置的部件（这就是为什么之前界面中只剩下一个按钮了）  \n当有部分没有部件时，其他部分会膨胀，将那个位置所占据  \n\nBorderLayout会根据部件里面的东西来帮我们计算，这个部件需要占据多大的空间 \n\n## 消息机制\n现在我们有了一个按下去没反应的按钮  \n如何让按钮按下去有反应？程序如何知道按钮被按下去了？  \n用户在图形界面做了一些操作，通过一些路径让程序知道，这个路径叫做**消息机制**  \n\nJava的Swing类实现了一个有意思的消息机制  \n```java\nJButton btnstep =new JButton(\"单步\");\nframe.add(btnstep, BorderLayout.SOUTH);\nbtnstep.addActionListener(new ActionListener(){\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(\"成功按下!\");\n\t}\n});\n```\n运行一下，当我们点击一次按钮，控制台都会输出一次“成功按下!”\n\n现在程序已经知道按钮被按下，且在上面的古怪代码中能成功做一些我们期望程序做的事（输出点东西）  \n我们可以把输出点东西换成其它事情，在狐狸和兔子中，step()函数控制单步  \n我们只需要做下面一些动作，就能让按钮控制单步  \n```java\nprivate JFrame frame;//把frame从FoxAndRabbit()中拿出来，让它变为FoxAndRabbit类中的成员变量\n···\n//JFrame frame = new JFrame();\nframe = new JFrame();\n···\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n···\n//fab.start(500);把main里的这句去掉，不让程序主动地开始\n``` \n现在每按一次按钮，程序就会运行一步  \n\n按钮自己有代码，知道自己被按下去了，但按钮作为一个早已经定好的类不可能有代码去调用step()\n但实际效果就是，每按一次按钮，step()就会被调用一次，这是怎么做到的？  \n<div><img src=https://cdn.chuckle.top/images/7-14.webp width=\"90%\" height=\"90%\"></div>\n\nJButton类提供了一个接口，只要实现了这个接口的类的对象，都可以通过**addActionListener()**方法**注册**给JButton，当按钮发现自己被按下去了，就会检查有没有东西注册在按钮那，接着找到重写的**actionPerformed()**，这样JButton就知道step()了  \n注册进去的东西，是运行时候一个动态的对象  \n\n这就是**反转控制**（Swing的消息机制）：\n·由按钮公布一个守听者接口和一对注册/注销函数  \n·你的代码实现那个接口，将守听者对象注册在按钮上  \n·一旦按钮被按下，就会反过来调用你的守听者对象的某个函数   \n\n## 内部类、匿名类\n刚刚实现接口的代码看起来十分奇怪\n```java\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n```\n可以换种写法\n```java\n//在类中新增这个类\nprivate class stepListener implements ActionListener {\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n\t\tframe.repaint();\t\t\t\n\t}\n}\n···\n//原来的代码替换为这句\nbtnstep.addActionListener(new stepListener());\n```\n在一个类的内部，再定义一个类，这个类就叫**内部类**  \n内部类可以**直接访问**其所处类的**所有**成员  \njava的内部类也是类的成员  \n外部是函数时，只能访问那个函数里**final**的变量   \n\n用匿名类实现接口\n```java\nnew ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n}\n```\n在**new对象**的时候给出的**类的定义**形成了匿名类  \n匿名类可以**继承某类**，也可以**实现某接口**  \nSwingl的消息机制广泛使用匿名类  \n外部是函数时，只能访问那个函数里**final**的变量  \n\n为什么需要匿名类？\nSwing的消息机制决定了，每个部件发出的消息，都需要新的类去实现接口，然后去接收消息，当部件很多时，给每个类起名字非常麻烦   \n\n***\n\n# 一个课程表\n做一个课程表程序，它有8行7列，有表头表示7天，每个格子用户能自己编辑内容  \n效果是这样：  \n<div><img src=https://cdn.chuckle.top/images/7-15.webp width=\"60%\" height=\"60%\"></div>\n\n有前面Swing的基础，我们知道想要有一个窗口，需要用到JFrame类，来创建一个底层窗口  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n现在运行，只有一个空空的窗口，一个空空的容器，我们需要往里面放部件  \n想要一个表格，那就放一个表格进去  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n\t\tJTable table = new JTable());//声明一个表格\n        frame.add(table);//把表格放进去\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n运行一下，还是啥都没有，因为我们还没初始化表格，还没给表格它要的数据  \n\n用JTable类可以以表格的形式显示和编辑数据。  \nJTable类的对象并不存储数据，它只是数据的表现。  \nJTable实现了数据与表现的分离  \n\n新建一个KCBData类，作为表格的数据  \n让这个类实现一个叫TableModel的接口  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    @Override\n    public int getRowCount() {\n        return 0;\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 0;\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return false;\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n\n    }\n}\n```\nTableModel接口是由JTable提供给我们的  \nTableModel告诉我们，只要实现了它，就能作为数据交给JTable  \n\n完善一下KCBData  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    private String[] title = {\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"};//表格标题\n    private String[][] data = new String[8][7];//真正放7天8节课的数据结构\n    //这个data数组里面都是String类型的管理者，所以需要初始化每个管理者去管理一个String类型的空数据\n    public KCBData() {\n        //构造方法,初始化数据,每一行的数据都是空的,即没有数据,这样才能显示表格,否则会报错\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                data[i][j] = \"\";//让每一个单元格都是空的\n            }\n        }\n    }\n    @Override\n    public int getRowCount() {\n        return 8;//表格有8行\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 7;//表格有7列\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return title[columnIndex];//返回一个表头\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return String.class;//告诉表格每列的数据类型,每一个都是String类型\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return true;//每个单元格都可以编辑\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return data[rowIndex][columnIndex];//将每一个单元格的数据返回，让表格拿到\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        data[rowIndex][columnIndex] = (String) aValue;//将每一个单元格的数据设置为aValue,即用户输入的数据\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n        //添加监听器\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n        //移除监听器\n    }\n}\n\n```\n现在表格能拿到数据了，它知道该怎么画一个表格  \n但运行一下，还是没有表头  \n\n这是因为JTable组件显示数据时，如果直接将其放置在Frame的contentPane中则表头一行会显示不出来，如果将其放置在JScrollPane中显示数据的话，表头会自动显示出来。  \n暂时无需关心为什么  \n\n再完善下KCB类，一个课程表就完成了  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        JTable table = new JTable(new KCBData());//声明一个表格\n        JScrollPane pane = new JScrollPane(table);//声明一个滚动面板\n        frame.add(pane);//将滚动面板添加到窗口\n        frame.pack();//自动调整窗口大小\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭方式\n        frame.setVisible(true);//显示窗口\n    }\n\n}\n```\n\n## MVC设计模式\n刚刚的课程表结构是这样的  \n<div><img src=https://cdn.chuckle.top/images/7-16.webp width=\"85%\" height=\"85%\"></div>\n\n当JTable决定显示多少列时会调用getColumnCount，当它要显示表头时会调用getColumnName  \n程序运行过程中JTable反过来调用我们自己的KCBData里的方法  \n\n数据由我们自己实现了TableModel的对象来维护，JTable只管表现不管数据  \n\n**MVC**:数据、表现和控制三者分离，各负其责  \n·M=Model（模型)  \n·V=View(表现)  \n·C=Control(控制)  \n\n模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新  \n表现：从模型获得数据，根据数据画出表现  \n控制：从用户得到输入，根据输入调整数据  \n\n<div><img src=https://cdn.chuckle.top/images/7-17.webp width=\"85%\" height=\"85%\"></div>\n\n不是由接收到用户输入的代码去修改界面上的显示，而是去修改内部的数据，内部的数据去触发界面的更新  \n\n这样做的好处：每一部分都很单纯，尤其是View表现，只管拿到想要的数据去表现，至于数据是怎么更新，怎么生成的，它统统不管  \n\n在代码实现中，View和Control通常在同个表达界面的类中实现，因为表现和用户控制都是在界面中完成的，这和MVC并不矛盾，只是在具体实现MVC模式时的技巧  \n\n***\n\n# Exception异常\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。  \n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。  \n\n写出下面的程序，idea的编辑器不会指出数组越界的错误，但运行程序控制台会抛出异常  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n}\n```\n\n```java 异常\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat ArrayIndex.main(ArrayIndex.java:4)\n```\n在main里面有Exception异常，问题出在在ArrayIndex的第四行，问题叫做ArrayIndexOutOfBoundsException，即数组越界  \n\n## 两种类型的异常与错误\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。  \n运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。  \n错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  \n\n异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  \n\n## 捕获异常\n当代码某一处可能出现问题、可能出现异常，就可以将这块代码放在一个用于捕捉异常的代码块中  \n```java\ntry\n{\n   // 可能出现异常的程序代码\n}catch(ExceptionName e1)//可以多个catch\n{\n   //处理异常的代码\n}catch(ExceptionName e2)\n{\n   //处理异常的代码\n}finally{\n  //无论是否发生异常，finally 代码块中的代码总会被执行。\n  // 程序代码\n}\n```\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码  \n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。  \n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样.  \n\n将刚刚数组越界的代码用捕捉异常处理  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n        a[10] = 10;\n        System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n运行一下\n```java\nerror\n```\n\n异常是程序运行过程中可能出现的问题，现在这个代码是一定会出错的，我们改造一下  \n```java\nimport java.util.Scanner;\n\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        int idx = 0;\n        Scanner in = new Scanner(System.in);\n        idx = in.nextInt();\n        try{\n            a[idx] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n\n```java 输出\n输入：2\nhello\n输入：12\nerror\n```\n\n## 异常处理机制\n把可能发出异常的代码放到try里，在try后面用catch去匹配可能出现的异常类型。  \n当try里的代码没有异常，catch里的代码不会被运行，当try里的代码出现异常，try里后续的代码都不会被执行，会直接调到catch里，在catch里处理完异常，会继续往下运行整个程序，而不会回到try。   \n当匹配到一个catch之后，异常就已经被处理完了，不会再去匹配另一个异常。  \n\n运行下面的代码  \n```java\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n    public static void main(String[] args) {\n        try{\n            f();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n当给数组赋值出现异常后，f方法后面的代码都不会被执行，然后回到调用f方法的地方，try会捕捉到f方法的异常，然后传递给catch  \n\n当有异常被抛出时，可以遵循下面的图来判断该在哪个地方处理这个异常  \n<div><img src=https://cdn.chuckle.top/images/7-18.webp width=\"92%\" height=\"92%\"></div>\n\n```java 示例\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;//抛出ArrayIndexOutOfBoundsException异常\n        System.out.println(\"hello\");//异常后面的代码不会被执行\n    }\n\n    public static void g(){\n        f();//f方法抛出异常，异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void h(){\n        int i = 10;\n        if(i < 100){\n            g();//所处不是函数，跳出一层\n        }//异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void k(){\n        try{\n            h();//有try捕捉异常\n        }catch(NullPointerException e){//没有对应catch匹配，退出到外层\n            System.out.println(\"k error\");\n        }//所处是函数\n        //返回调用者\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();//有try捕捉异常\n        }catch(ArrayIndexOutOfBoundsException e){//有对应catch匹配\n            System.out.println(\"error\");//处理异常\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n\n## Java 内置异常类\n\n| 异常  | 描述    |\n| -----    | ------ |\n| ArithmeticException  |当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例|\n|ArrayIndexOutOfBoundsException|用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引|\n|ArrayStoreException|试图将错误类型的对象存储到一个对象数组时抛出的异常|\n|ClassCastException|当试图将对象强制转换为不是实例的子类时，抛出该异常|\n|IllegalArgumentException|抛出的异常表明向方法传递了一个不合法或不正确的参数|\n|IllegalMonitorStateException|抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程|\n|IllegalStateException|在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下|\n|IllegalThreadStateException|线程没有处于请求操作所要求的适当状态时抛出的异常|\n|IndexOutOfBoundsException|指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出|\n|NegativeArraySizeException|如果应用程序试图创建大小为负的数组，则抛出该异常|\n|NullPointerException|当应用程序试图在需要对象的地方使用 null 时，抛出该异常|\n|NumberFormatException\t|当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常|\n|SecurityException|由安全管理器抛出的异常，指示存在安全侵犯|\n|StringIndexOutOfBoundsException|此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小|\n|UnsupportedOperationException|当不支持请求的操作时，抛出该异常|\n|下面是Java 定义在 java.lang 包中的检查性异常类：||\n|ClassNotFoundException|应用程序试图加载类时，找不到相应的类，抛出该异常|\n|CloneNotSupportedException|当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常|\n|IllegalAccessException|拒绝访问一个类的时候，抛出该异常|\n|InstantiationException|当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常|\n|InterruptedException|一个线程被另一个线程中断，抛出该异常|\n|NoSuchFieldException|请求的变量不存在|\n|NoSuchMethodException|\t请求的方法不存在|\n\n## 异常方法\n当catch匹配到了异常，实际上是拿到了一个异常类型的对象，我们可以让对象做事情  \n```java\npublic class a {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n            a[10] = 20;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n            System.out.println(e.getMessage());\n            System.out.println();\n            System.out.println(e);\n            System.out.println();\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nerror\nIndex 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat a.main(a.java:5)\n\n```\n\n| 异常方法  | 描述    |\n| -----    | ------ |\n|String getMessage()|返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了|\n|Throwable getCause()|返回一个 Throwable 对象代表异常原因|\n|String toString()|返回此 Throwable 的简短描述|\n|void printStackTrace()|将此 Throwable 及其回溯打印到标准错误流|\n|StackTraceElement [] getStackTrace()|返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底|\n|Throwable fillInStackTrace()|用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中|\n\n## throw再度抛出\n当一个异常已经被处理了，将不会再次被捕捉  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){//k中已经处理了异常\n            System.out.println(\"k error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){//不会再次处理\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nmain\n```\n但可以通过throw主动地再次抛出这个异常  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"k error\");\n            throw e;//捕捉到后在此抛出该异常\n        }\n    }\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nerror\nmain\n```\n\n## 为什么要异常机制\n我们希望程序能够根据运行过程中可能出现的各种情况进行处理  \n早期，函数都有特定的返回值，通过函数内很多的if-else来判断返回什么，以返回值来做相应处理  \n\n函数内出现很多与功能无关的if-else，会导致函数可读性很差，而且不利于增加新的功能  \n异常机制将业务逻辑与异常处理在代码上分开  \n```java\ntry{\n    //业务逻辑都放在一起\n    open the file;\n    determine its size;\n    allocate that much memory;\n    read the file into memory;\n    close the file;\n    //如果上面的业务逻辑出了问题，就用下面的catch去处理对应的问题\n}catch(fileOpenFailed){\n    doSomething;\n}catch(sizeDeterminationFailed){\n    doSomething;\n}catch(memoryAllocationFailed ){\n    doSomething;\n}catch(readFailed ){\n    doSomething;\n}catch(fileCloseFailed ){\n    doSomething;\n}\n```\n异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码  \n\n## 异常的抛出和声明\n在Java中可以自定义异常。  \n1、所有异常都必须是 Throwable 的子类。  \n2、如果希望写一个检查性异常类，则需要继承 Exception 类。  \n3、如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。  \nRuntimeException继承自Exception  \n\n```java 声明一个异常类型\nclass MyException extends Exception{\n}\n```\n```java 声明一个可能会抛出异常的方法\npublic void f() throws MyException{\n    throw new MyException();//抛出一个MyException异常\n}\n```\n所有调用这个方法的地方都必须套上try-catch，来处理可能发生的异常  \n```java\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"error\");\n    }\n}\n```\n\n可以声明并不会真的抛出的异常,但调用该方法的地方必须处理全部可能抛出的异常  \n```java\npublic void f() throws MyException,YouException{\n    throw new MyException();//抛出一个MyException异常\n}\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"MyError\");\n    }catch(YouException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"YouError\");\n    }\n}\n```\n\n任何继承了Throwable类的对象都可以被throw  \nException类继承了Throwable，我们通常让自定义的异常类从Exception类得到继承  \n\n```java Exception类的两种构造\n//我们在自定义异常类时也通常会有这两种构造\nthrow new Exception();  \nthrow new Exception(\"HELP\");//可以用这个字符串来表达一些东西  \n```\n\n## catch的匹配机制\n抛出子类的异常会被捕捉父类异常的catch给捉到  \n```java\n//声明两个异常类，YouException继承自MyException\nclass MyException extends Exception{}\nclass YouException extends MyException{}\n\npublic class Test{\n\n    public static void f() throws MyException, YouException {\n        throw new YouException();//抛出一个YouException异常\n    }\n\n    public static void main(String[] args) {\n        try{\n            throw new YouException();\n        }catch(MyException e){//MyException匹配到了它的子类YouException\n            System.out.println(\"YouException\");\n        }\n    }\n}\n```\n如果同时捕捉父类子类两个异常，子类catch要写在父类前面，否则会报错  \n```java\ntry{\n    throw new YouException();\n}catch(YouException e){\n    System.out.println(\"YouException\");\n}catch(MyException e){\n    System.out.println(\"YouException\");\n}\n```\n\n捕捉任何异常\n```java\ncatch(Exception e){\n}\n```\n\n### 运行时刻异常\n像ArrayIndexOutOfBoundsException这样java本身提供的异常是不需要声明的，如果需要去声明这些异常，那么每个方法都将带上一长串的声明    \n但是如果没有适当的机制来捕捉，就会最终导致程序终止  \n\n## 异常遇到继承\n当覆盖一个方法的时候，子类不能声明抛出比父类的版本更多的异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public static void f() throws MyException {}\n    public static void main(String[] args) {}\n}\nclass NewClass extends Test{\n    //NewClass'中的f()'与' Test'中的'f()'冲突；重写的方法未抛出NewException'\n    public void f() throws NewException {}\n    //正确的\n    public void f() throws YouException {}\n    public void f() throws MyException {} \n    public void f() {} \n}\n```\n\n在子类的构造方法中，必须声明父类可能抛出的全部异常，可以抛出更多异常,可以是父类抛出异常的父类异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public Test() throws YouException{}\n    public static void main(String[] args) {}\n}\n\nclass NewClass extends Test {\n    //允许\n    public NewClass() throws YouException{}\n    public NewClass() throws MyException{}\n    public NewClass() throws MyException,NewException{}\n    //不允许\n    public NewClass(){}\n    public NewClass() throws NewException{}\n}\n```\n\n***\n\n# Stream流\n任何程序都有输入输出，会向用户那读点东西，也会向用户那输出点东西  \n所以，任何一个编程语言都给程序员提供了输入输出的方式，让这个程序可以和外界打交道  \n\n对于java语言，以及之后的新语言，处理输入输出的手段叫做**流**  \n\n流是一个抽象、动态的概念，是一连串连续动态的数据集合。  \n流给数据源和程序之间提供了数据信息传输的通道，编程语言提供了多种流用于数据传输  \n\n## Hallo World\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n这个程序就用到了输出流，把Hallo World输出给用户看  \n**System**是一个类，**out**是这个类的一个静态成员，**println**是这个成员能做的事情  \n实际上，**out**这个成员就是用于做输出的流  \n\n## 流的基础\n在java的基础类库中，所有的输出都基于**OutputStream**类，所有的输入都基于**InputStream**类，这两个类构成了输入和输出的基础  \n\n但这两个类是抽象的，具体使用时应该用它们的子类  \n在这里可以看到java系统类库中所有的包[Java®平台、标准版和Java开发工具包第18版API规范](https://docs.oracle.com/en/java/javase/18/docs/api/index.html)  \n在其中的java.base中有[java.io](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)，这里面有java输入输出所有相关的东西  \n在里面可以找到**InputStream**和**OutputStream**类，当然这里面还有很多的类，以及其它的东西  \n\n点击InputStream，可以看到这个类的描述，以及它所有的方法  \n<div><img src=https://cdn.chuckle.top/images/7-19.webp width=\"100%\" height=\"100%\"></div>\n\n**InputStream**把外界的输入当做**字节**的流来看待，**OutputStream**也同理，当我们使用这两个类，只能做字节层面上的读和写  \n\n尝试一下：  \n```java\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        byte[] buffer = new byte[1024];//一个1k字节的butter\n        int len = 0;//让系统读取输入流，并将读取到的内容存储到buffer中，返回读取到的字节数\n        try {//所有io的操作都存在风险，所以要捕获异常\n            len = System.in.read(buffer);\n            String s = new String(buffer, 0, len);//将buffer中从0开始到len的这么多个字节构造一个字符串\n            System.out.println(\"读到了：\"+len+\"字节\");//输出读取到的字节数\n            System.out.println(s);//输出字符串\n            System.out.println(\"s的长度：\"+s.length());//输出字符串有多少个字符\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nHello World!\n输入:123abc\n读到了：7字节\n123abc\n\ns的长度：7\n\n```\n123abc是6个字节，但后面还有个回车，所以读到7个字节，且输出s时，把回车也输出了  \n\n换个输入：\n```java 输出\nHello World!\n输入：123汉字abc\n读到了：13字节\n123汉字abc\n\ns的长度：9\n\n```\n在UTF-8编码中,一个中文字符等于三个字节，所以一共读到13个字节  \n\n## 文件流\n**System.in**和**System.in**是标准输入和标准输出的流  \n如果想要直接写文件，就需要使用到**文件流**：**FileInputStream**、**FileOutputStream**  \n\n实际工程中已经较少直接对文件进行读写（除了在造轮子）  \n更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信  \n具体的文件读写往往有更专业的类，比如配置文件和日志文件  \n\n尝试一下**FileOutputStream**：  \n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            FileOutputStream out = new FileOutputStream(\"a.dat\");//如果文件不存在，则创建，存在则覆盖\n            out.write(buf);//将buf中的数据写入文件\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n用**Hexdump**打开这个16进制文件  \n```\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: 00 01 02 03 04 05 06 07 08 09                      ..........\n\n```\n1到9都已经被写入  \n\n## 流过滤器\n无论是System.in和out还是文件流，都只能处理单个字节，一个个字节地读，一个个字节地写  \n如果要把一个10进制地整数写入到一个文件中，就要同时读写4个字节，显然前面介绍的流无法做到  \n\n**流过滤器**可以在已存在的流的基础上，去增加一层层的过滤器，每一层的过滤器都可以做点事情，其中一些过滤器就可以做int、double这些基础类型数据的读和写  \n\n尝试一下：  \n```java\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            DataOutputStream out = new DataOutputStream(\n                    new BufferedOutputStream(//缓冲输出流\n                            new FileOutputStream(\"a.dat\")));\n            //打开这个文件之后，在上面接了一个缓冲流，缓冲流外面还有一个流，最终得到的是一个DataOutputStream的对象\n            //我们可以往DataOutputStream这个流里面写入数据，数据会被缓冲到缓冲流里面，缓冲流里面的数据会被写入到文件里面\n            int i = 0xcafebabe;\n            out.writeInt(i);//写入一个int类型的数据,DataOutputStream流的writeInt方法可以写入一个int类型的数据\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: CA FE BA BE                                        J~:>\n```\n0xcafebabe这个16进制数已经被写入  \n```java 输出\nHello World!\n-889275714\n```\n0xcafebabe这个16进制的数对应的10进制数是-889275714  \n\n每一层过滤器都可以起到一定的作用，在上面的程序中，BufferedOutputStream起到了缓冲垫作用，DataOutputStream起到了读写基本数据类型的作用  \n\n## 文本的输入和输出\n加上了DataOutputStream也只能以二进制处理基本数据类型，如何处理文本？  \n\n二进制数据采用InputStream/OutputStream  \n文本数据采用Reader/Writer  \n\n但Reader/Writer本身是处理Unicode编码的字符的，如果文件是Unicode编码，可以直接用Reader/Writer处理文件，但一般情况下，文件本身并不是Unicode编码，它可能是GBK，可能是UTF-8  \n在这种情况下，我们需要借助Stream，用字节形式打开文件，再在Stream流的基础上，用过滤器的方式去建立Reader/Writer ，来做文本的输入和输出，**StreamReader**可以将字节流转换为字符流，然后交给Reader/Writer，当然中间可以加上Buffered实现缓冲  \n\n尝试一下：  \n```java\nimport java.io.*;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            PrintWriter out = new PrintWriter(//创建一个输出流,PrintWriter可以通过连接BufferedWriter实现的缓冲功能\n                    new BufferedWriter(//创建一个缓冲流\n                            new OutputStreamWriter(//将字节流转换为字符流\n                                new FileOutputStream(\"a.txt\"))));//创建一个文件输出流\n            //我们做了一个文件流，但它只能处理字节\n            // 在此基础上再做一个桥梁：OutputStreamWriter\n            // 它构建起了Stream和Writer的桥梁，它的输入是OutputStream，输出是Writer\n            int i = 123456;\n            out.println(i);//在PrintWriter的基础上，我们可以用println方法来输出数据\n            out.close();\n            //和上面输出一样，如果要读取一个文件，我们需要做一个桥梁：InputStreamReader\n            //它构建起了Stream和Reader的桥梁，它的输入是InputStream，输出是Reader\n            BufferedReader in = new BufferedReader(// BufferedReader类从字符输入流中读取文本并缓冲字符\n                    new InputStreamReader(//将字节流转换为字符流\n                        new FileInputStream(\"src/test.java\")));//创建一个文件输入流，打开这个程序的源码文件\n            //readLine()方法从字符输入流中读取一行，并返回该行。\n            String line;\n            while ((line = in.readLine()) != null){//当读取到的行不为空时，执行循环，就可以读取整个文件\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n运行：在a.tet文件中有123456字符,控制台也将这整个源码输出了出来  \n\n除了BufferedReader，还有LineNumberReader，里面的getLineNumber()可以读取指定的行  \n\n**FileReader**是InputStreamReader类的子类，所有方法都从父类中继承而来，它可以直接读取一个二进制文件，建立起一个流，然后形成一个Reader    \nFileReader(File file)在给定从中读取数据的Fe的情况下创建一个新FileReader  \nFileReader(String fileName)在给定从中读取数据的文件名的情况下创建一个新FileReader  \nFileReader不能指定编码转换方式  \n\n## 汉字编码问题\nFileOutputStream(\"a.txt\")可以以二进制形式打开一个文件  \nOutputStreamWriter(FileOutputStream(\"a.txt\"))将字节流转换为字符流,如果不指定编码，那么它优先使用程序源码文件的编码去转换这个字节流为字符流，这就很容易导致汉字乱码  \n\n我们可以指定编码进行转换OutputStreamWriter(FileOutputStream(\"a.txt\"),\"utf8\")  \n用utf8去将这个字节流转换成字符流 \n\n当然还有其它方法，这里不展开讲\n\n## 格式化输入输出\n格式化输出：使用printf(\"格式\", );用法和C语言的基本一样，这里不展开讲，博主同样有篇C语言学习笔记  \n\n格式化输入：如果想从一个文本中读取出一些数字，可以在流上构建一个Scanner，然后用next系列的方法去读取数字、单词等等  \n\n## Stream/Reader/Scanner的选择\n<div><img src=https://cdn.chuckle.top/images/7-20.webp width=\"92%\" height=\"92%\"></div>\n\n## 流的应用\n现在已经很少有程序需要用流的方式去打开一个文件，裸地去进行文件读和写的操作，更多地是从某个地方得到了一个流  \n\n### 服务器通信\n下面这个程序将从本地服务器得到一个流，并向这个流写入东西  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n当然，直接运行这个程序一定报错，因为本地没有任何服务器程序在12345端口上听着，连接建立不起来  \n\n使用netcat可以实现监听  \n从[netcat](https://eternallybored.org/misc/netcat/)下载netcat1.12  \n解压后把nc.exe移动到C:\\Windows\\System32目录，压缩包内其它东西用不上  \n然后打开cmd，运行nc -l -p -12345\n\n现在再运行程序，cmd窗口就会输出Hello, world!  \n\n还可以接收服务端的数据  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.flush();//刷新缓冲区，将缓冲区中的数据立即发送出去\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(\n                            //getInputStream()方法获取Socket对象的输入流，并构造一个BufferedReader对象\n                            socket.getInputStream()));//创建一个BufferedReader对象，用于接收服务器端的信息\n            String line = in.readLine();//读取服务器端的一行文本\n            System.out.println(line);//输出读取的文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在cmd窗口输入任意文本，idea的控制台也会输出这个文本  \n\n### 对象串行化\n写入和读取一个对象，使用ObjectOutputStream和ObjectInputStream，被读写的类要实现Serializable接口  \n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.Serializable;\nimport java.io.*;\n\nclass Student implements Serializable {//可以串行化的类\n    private String name;\n    private int age;\n    private int grade;\n\n    public Student(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n\n    public String toString() {\n        return \"Student: \" + name + \" \" + age+ \" \" + grade;\n    }\n}\n\npublic class chh {\n    public static void main(String[] args) {\n        try {\n            Student s1 = new Student(\"zhangsan\", 20, 1);\n            ObjectOutputStream out = new ObjectOutputStream(\n                    new FileOutputStream(\"obj.dat\"));\n            out.writeObject(s1);\n            out.close();\n            ObjectInputStream in = new ObjectInputStream(\n                    new FileInputStream(\"obj.dat\"));\n            Student s2 = (Student) in.readObject();\n            System.out.println(s2);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java obj.bat\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: AC ED 00 05 73 72 00 07 53 74 75 64 65 6E 74 98    ,m..sr..Student.\n00000010: 61 28 66 C5 BE 55 BC 02 00 03 49 00 03 61 67 65    a(fE>U<...I..age\n00000020: 49 00 05 67 72 61 64 65 4C 00 04 6E 61 6D 65 74    I..gradeL..namet\n00000030: 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72    ..Ljava/lang/Str\n00000040: 69 6E 67 3B 78 70 00 00 00 14 00 00 00 01 74 00    ing;xp........t.\n00000050: 08 7A 68 61 6E 67 73 61 6E                         .zhangsan\n\n```\n```java 输出\nStudent: zhangsan 20 1\n```\n\n***\n\n>完结撒花！\n>javase的学习暂且告一段落，但学习的步伐永不停歇\n>翁恺老师讲的课循序渐进，简洁明了，好评，但课程上只学到流，刚步入javase的高级部分\n>后面还有一个重要部分：线程\n>过段时间实操一个java的管理系统（万物起源管理系统），暂且咕咕咕吧\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"给Butterfly加上顶部加载条","url":"/article/13d6481a.html","content":"\n>效果已在本站实装，切换页面顶部有加载进度条\n>参考文章[为Hexo博客添加顶部加载条](https://cloud.tencent.com/developer/article/1960734)\n\n# 旧版顶部长条\n\n## 引入css\n```css\n.pace {\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n.pace-inactive {\n  display: none;\n}\n\n.pace .pace-progress {\n  background: #e90f92;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n\n.pace .pace-progress-inner {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;\n  opacity: 1.0;\n  -webkit-transform: rotate(3deg) translate(0px, -4px);\n  -moz-transform: rotate(3deg) translate(0px, -4px);\n  -ms-transform: rotate(3deg) translate(0px, -4px);\n  -o-transform: rotate(3deg) translate(0px, -4px);\n  transform: rotate(3deg) translate(0px, -4px);\n}\n\n.pace .pace-activity {\n  display: block;\n  position: fixed;\n  z-index: 2000;\n  top: 15px;\n  right: 15px;\n  width: 14px;\n  height: 14px;\n  border: solid 2px transparent;\n  border-top-color: #e90f92;\n  border-left-color: #e90f92;\n  border-radius: 10px;\n  -webkit-animation: pace-spinner 400ms linear infinite;\n  -moz-animation: pace-spinner 400ms linear infinite;\n  -ms-animation: pace-spinner 400ms linear infinite;\n  -o-animation: pace-spinner 400ms linear infinite;\n  animation: pace-spinner 400ms linear infinite;\n}\n\n@-webkit-keyframes pace-spinner {\n  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-moz-keyframes pace-spinner {\n  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-o-keyframes pace-spinner {\n  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-ms-keyframes pace-spinner {\n  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@keyframes pace-spinner {\n  0% { transform: rotate(0deg); transform: rotate(0deg); }\n  100% { transform: rotate(360deg); transform: rotate(360deg); }\n}\n/* 在下面修改进度条外观 */\n.pace .pace-progress {\n  background: #1ef4fbec; /*进度条颜色*/\n  height: 3px;/* 进度条厚度 */\n}\n.pace .pace-progress-inner {\n  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/\n}\n.pace .pace-activity {\n  border-top-color: #1edafbe5;\t/*上边框颜色*/\n  border-left-color: #1ef4fbec;\t/*左边框颜色*/\n}\n```\n\n## 引入js\n\n```js\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n```\n\n**然后三连即可**\n\n***\n\n# 新版胶囊\n<img src=https://cdn.chuckle.top/images/10-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;看这个文章即可，虽然实现过程不太一样，但效果差不多：[为你的Butterfly添加顶部加载进度条](https://xlenco.eu.org/posts/769f.html)\n\n***\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"基于UptimeRobot的监控面板","url":"/article/8f1fedc5.html","content":"\n>演示：[轻笑的网站监控面板](https://status.chuckle.top/)\n\n# 注册UptimeRobot\n\n填写邮箱以完成注册  \n>[跳转至注册](https://uptimerobot.com/signUp?ref=website-header)\n\n\n# 新建监视器\n点击左上角Add New Monitor  \n<div><img src=https://cdn.chuckle.top/images/9-1.webp width=\"70%\" height=\"70%\"></div>\n\n在弹出窗口填写需要需要监控的站点的相关信息  \n\n<div><img src=https://cdn.chuckle.top/images/9-2.webp width=\"70%\" height=\"70%\"></div>\n\n点击Create Monitor完成创建   \n\n\n# 创建API密钥\n\n点击My Settings\n<div><img src=https://cdn.chuckle.top/images/9-3.webp width=\"70%\" height=\"70%\"></div>\n为监视器创建一个api密钥（也可选择第三个，为所有监视器创建一个密钥）  \n<div><img src=https://cdn.chuckle.top/images/9-4.webp width=\"70%\" height=\"70%\"></div>\n\n# fork监控面板仓库\n选择其中一个fork  \n[yb/uptime-status](https://github.com/yb/uptime-status)  \n[Ice-Hazymoon/status](https://github.com/Ice-Hazymoon/status)  \n\n# 修改config.js\n\n进入刚fork的仓库，打开/public/config.js  \n添加监视器的api密钥  \n>需要监控的站点较多，也可为所有监控器创建一个api密钥填入\n\n```\n ApiKeys: [\n    '在这里粘贴api密钥',\n  ],\n```\n>还可以选择在ApiDomain修改自定义反代域名，详见https://github.com/yb/uptime-status/\n\n# vercel部署\n\n新建一个项目  \nimport监控面板仓库  \n等待几分钟创建完成，点击vist，一个监控面板就完成了  \n<div><img src=https://cdn.chuckle.top/images/9-5.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/9-6.webp width=\"70%\" height=\"70%\"></div>\n\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(2)","url":"/article/9f2dc6c7.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(1)](/article/bfb663c6.html)\n\n# 城堡游戏（可扩展性）\n整体思路：用Room先初始化5个房间，Room类中有房间名称、四个方向所连接的房间，currentRoom = outside;设置出生点  \n进入goRoom方法，匹配用户输入的方向，让nextroom指向下一个房间，然后让currentRoom = outside;并输出房间信息。  \n大致以此循环  \n \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    public String description;\n    //房间四个方向连接的房间\n    public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = null;//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n```java 输出\n欢迎来到城堡!\n这是一个超级无聊的游戏。\n如果需要帮助，请输入'help'\n\n你在城堡外\n出口有：\neast\nsouth\nwest\n\ngo south\n你在书房\n出口有：\nnorth\neast\n\ngo east\n你在卧室\n出口有：\nwest\n\nhelp\n迷路了吗？你可以做的命令有：go bye help\n如：\tgo east\nbye\n感谢您的光临。再见！\n```\n\n## 消除代码复制\n在printWelcome和goRoom方法中都有一段相同的输出出口方向的代码  \n将这段代码提取出来，做成一个方法，在需要输出房间信息的地方调用即可  \n```java\npublic void showPrompt()\n{\n    // 输出当前房间的描述\n    System.out.println(\"你在\"+ currentRoom);\n    System.out.println(\"出口有：\");\n    if(currentRoom.northExit != null)\n        System.out.println(\"north\");\n    if(currentRoom.eastExit != null)\n        System.out.println(\"east\");\n    if(currentRoom.southExit != null)\n        System.out.println(\"south\");\n    if(currentRoom.westExit != null)\n        System.out.println(\"west\");\n    System.out.println();\n}\n\n```\n\n## 封装\n这个程序没有bug，能正常运行，但不见得是一个好的代码  \n评价一个代码质量的好坏是多元的，尤其是这个代码是否能适应将来的需要  \n\n**可扩展性**：代码是否易于将来增加新的东西\n\n我们想在这个游戏里给每个房间增加两个方向down和up  \n我们需要改的地方很多  \nRoom.java里需要增加两个房间对象public Room downExit;和public Room upExit; setExits方法需要增加两个参数并进行判断  \nGame.java里很多方法也要增加if判断，还要改每个房间的初始化  \n\n总之，想增加一个方向，代码几乎每个地方都要改变  \n\n要想增加可扩展性，首先要降低类和类之间的耦合  \n\n### 用封装来降低耦合\nRoom类和Game类都有大量的代码和出口相关  \n尤其是Game类中大量使用了Room类的成员变量  \n类和类之间的关系称作**耦合**  \n耦合**越低越好**，保持距离是形成良好代码的关键  \n\n我们可以让Room自己告诉Game有哪些出口，出口连接的房间  \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    private String description;\n    //public String description;\n    //房间四个方向连接的房间\n    private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;\n    /*public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;*/\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        /*String returnString = \"Exits:\";\n        if (northExit != null)\n            returnString += \"north \";\n        if (eastExit != null)\n            returnString += \"east \";\n        if (southExit != null)\n            returnString += \"south \";\n        if (westExit != null)\n            returnString += \"west \";\n        return returnString;*/\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n        /*System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();*/\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        /*if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }*/\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n            /*System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();*/\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n        /*System.out.println(\"出口有：\");\n        if(currentRoom.northExit != null)\n            System.out.println(\"north\");\n        if(currentRoom.eastExit != null)\n            System.out.println(\"east\");\n        if(currentRoom.southExit != null)\n            System.out.println(\"south\");\n        if(currentRoom.westExit != null)\n            System.out.println(\"west\");\n        System.out.println();*/\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n\n### 用接口来实现聚合\n原本Room有什么出口，连接着什么房间，Game是能直接获取使用的  \n现在我们在Room中实现了两个接口getExitDesc和getExit,把方向的细节彻底隐藏在Room类内部  \n今后方向如何实现就和外部无关了  \n\n### 用容器来实现灵活性\n在Room当中，有四个Room对象，用于保存这个房间连接着的四个房间（null，或者房间名）  \n这种一一对应的关系，可以使用HashMap去实现  \n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n    /*private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;*/\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    /*public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }*/\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        /*if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");*/\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n        /*if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;*/\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        /*outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);*/\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n//现在当我们想增加出口方向，很简单  \nlobby.setExits(\"up\", pub);  \npub.setExits(\"down\", lobby);  \n\n这里发生了什么？  \n将lobby的出口方向和对应房间传给它的setExits的方法后  \nlobby里面的容器就会多一对出口和房间的对应关系  \nlobby里面的getExitDesc、getExit方法以及未来可能加入的新方法，都遍历这个容器  \n所以，增加出口和连接的房间，只需要调用setExits方法，去往lobby里的容器写入东西即可  \n\n现在，对于增加出口来说，已经具有了可扩展性\n\n### 以框架+数据来提高可扩展性\n我们原来用硬编码去保存room的出口  \n现在我们用容器，HashMap和对应的方法（接口方法）组成了一个框架，数据就是放在HashMap里的东西  \n在这个框架中要增加出口很容易  \n\n启发：  \n命令的解析是否可以脱离if-else  \n定义一个Handler来处理命令  \n用Hash表来保存命令和Handler之间的关系  \n\n现在我们可以用相同的思路去解决用户命令（help，go，bye）的硬编码问题  \n一个字符串对应调用一个方法，这显然也是一一对应的关系  \n但容器**只能放对象**，一个方法不能放进容器中  \n\n### 如何把方法放进容器中\n创建一个Handler类，然后把每个命令创建为Handler的子类  \n将命令字符串和Handler子类的对象一一对应放入HashMap中  \n将功能在Handler的子类的doCmd方法中实现  \n在game中通过父类对象管理者去管理子类对象（从HashMap中获取子类对象），管理者调用doCmd方法即可  \n\n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n    //创建一个HashMap对象，用于保存所有的命令处理器\n    private HashMap<String, Handler> handlers = new HashMap<String, Handler>();\n\n    public Game()//构造函数\n    {\n        //将字符串和命令处理器对应\n        handlers.put(\"go\",new HandlerGo(this));//把game对象作为参数传入HandlerGo类，让HandlerGo能管理game\n        handlers.put(\"help\",new HandlerHelp(this));\n        handlers.put(\"bye\",new HandlerBye(this));\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    /*private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }*/\n\n    public void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public void play(){//游戏开始\n        Scanner in = new Scanner(System.in);\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            Handler handler = handlers.get(words[0]);//获取用户输入的命令,从HashMap中获取对应的子类对象,让handler管理这个对象\n            String value = \"\";//保存命令的字符串\n            if(words.length > 1)//判断是不是bye命令\n            {\n                value = words[1];//获取参数\n            }\n            if(handler != null){//如果命令存在\n                handler.doCmd(value);//调用命令处理器\n                if ( handler.isBye() ) {//如果命令处理器返回true，则退出游戏\n                    System.out.println(\"感谢您的光临。再见！\");\n                    break;\n                }\n            }\n        }\n        in.close();//关闭Scanner\n    }\n\n    public static void main(String[] args) {\n        /*Scanner in = new Scanner(System.in);*/\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n        game.play();\n        /*while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }*/\n        //System.out.println(\"感谢您的光临。再见！\");\n        //in.close();//关闭Scanner\n    }\n}\n```\n```java Handler.java\npackage castle;\n\npublic class Handler {\n    protected Game game;//创建一个Game对象的管理者，为了方便设为protected\n    public Handler(Game game) {\n        this.game = game;//两个game管理者管理同一个Game对象\n    }\n\n    public void doCmd(String word) {}//一个接口，用于运行命令\n    public boolean isBye() { return false; }\n}\n```\n```java HandlerBye.java\npackage castle;\n\npublic class HandlerBye  extends Handler {\n    //必要的构造器\n    public HandlerBye(Game game) {\n        super(game);\n    }\n    @Override\n    public boolean isBye() {\n        return true;\n    }\n}\n```\n```java HandlerHelp.java\npackage castle;\n\npublic class HandlerHelp extends Handler {\n    //必要的构造器\n    public HandlerHelp(Game game) {\n        super(game);\n    }\n    @Override\n    public void doCmd(String word) {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n}\n```\n```java HandlerGo.java\npackage castle;\n\npublic class HandlerGo extends Handler {\n    public HandlerGo(Game game) {\n        super(game);//现在HandlerGo能管理game对象了\n    }\n    //help和bye都与game无关，但go需要调用goRoom方法，所以需要拿到game对象的管理者\n    public void doCmd(String word) {\n        game.goRoom(word);//调用game的goRoom方法\n    }\n\n}\n```\n>HandlerGo在未来有更好的方法去实现，现在还是用管理者吧\n\n如果要加入新的命令，也非常简单  \n创建一个新的Handler子类，在里面实现命令的功能  \n在Game的构造器中将命令字符串和Handler的子类对象放进去  \n\n现在这个城堡游戏已经有极高的可扩展性了  \n>这个城堡游戏例子非常全面，偶尔回来看看这个例子，是个不错的选择\n\n***\n\n# 抽象abstract\n关键字：**abstract**\n```java\npublic abstract class Shape {//抽象类\n    public abstract void draw(Graphics g);//抽象方法不带{}，即不带方法体\n}\n```\n抽象方法：表达概念，但无法实现具体功能（代码）的方法  \n抽象类：表达概念而无法构造出实体（对象）的类  \n\n有抽象方法的类**一定**是抽象类  \n抽象类不能**制造**对象，但是可以**定义**类变量（任何继承了抽象类的非抽象类的对象可以使用赋给这个类变量，即任何抽象类的子类的对象都可以由这个类变量来管理）  \n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  \n\n继承自抽象类的子类必须覆盖父类中的抽象方法，否则自己成为抽象类（即子类必须实现抽象父类的抽象方法）\n\n## 两种抽象\n与具体相对  \n·表示一种概念而非实体  \n与细节相对  \n·表示在一定程度上忽略细节而着眼大局  \n\n*** \n\n# 细胞自动机\n\n死亡：如果活着的邻居的数量小于2或大于3，则死亡  \n新生：如果正好有3个邻居活着，则新生其他情况则保持原状  \n\n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n \npublic class Cell {\n\tprivate boolean alive = false;//默认为死亡状态\n\t\n\tpublic void die() { alive = false; }//让细胞死亡\n\tpublic void reborn() { alive = true; }//让细胞重生\n\tpublic boolean isAlive() { return alive; }//返回细胞状态,判断细胞是否存活\n\t//绘制细胞\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tg.drawRect(x, y, size, size);//画个空心矩形\n\t\tif ( alive ) {//如果细胞存活\n\t\t\tg.fillRect(x, y, size, size);//画个实心矩形\n\t\t}\n\t}\n}\n\n```\n\n```java CellMachine.java\npackage cellmachine;\n\nimport javax.swing.JFrame;\n\nimport cell.Cell;\nimport field.Field;\nimport field.View;\n\npublic class CellMachine {\n\n\tpublic static void main(String[] args) {\n\t\t//数据准备阶段,画出一个细胞网格\n\t\tField field = new Field(30,30);//一个30*30的网格\n\t\t//遍历网格，每个网格都有一个细胞\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tfield.place(row, col, new Cell());//每个细胞都有一个状态，初始状态为死亡\n\t\t\t}\n\t\t}\n\n\t\t//遍历每个细胞，设置初始细胞的生存状态\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t//利用随机数让整个网格的五分之一的细胞生存\n\t\t\t\tif ( Math.random() < 0.2 ) { //Math.random()返回0~1之间的随机数\n\t\t\t\t\tcell.reborn();//reborn()方法设置细胞的生存状态为true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //在窗口中显示细胞网格\n\t\tView view = new View(field);//将网格传入View类中\n\t\tJFrame frame = new JFrame();//创建一个JFrame对象,是java当中的窗口,用来显示细胞网格\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭时的操作\n\t\tframe.setResizable(false);//设置窗口不可改变大小\n\t\tframe.setTitle(\"Cells\");//设置窗口的标题\n\t\tframe.add(view);//将网格添加到窗口中\n\t\tframe.pack();//设置窗口的大小\n\t\tframe.setVisible(true);//设置窗口可见,即显示出来\n\n\t\t//模拟细胞网格的运行\n\t\t//遍历整个网格,取出每个细胞\n\t\tfor ( int i=0; i<1000; i++ ) {//进行1000次模拟\n\t\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t\tCell[] neighbour = field.getNeighbour(row, col);//获取(row,col)位置上的细胞的邻居\n\t\t\t\t\tint numOfLive = 0;//计数器，记录邻居中活细胞的个数\n\t\t\t\t\t//遍历邻居，计算邻居中有多少个细胞是活的\n\t\t\t\t\tfor ( Cell c : neighbour ) {\n\t\t\t\t\t\tif ( c.isAlive() ) {//如果邻居中有一个细胞是活的\n\t\t\t\t\t\t\tnumOfLive++;//让计数器加一\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//控制台输出当前细胞的状态\n\t\t\t\t\tSystem.out.print(\"[\"+row+\"][\"+col+\"]:\");//打印细胞的位置\n\t\t\t\t\tSystem.out.print(cell.isAlive()?\"live\":\"dead\");//打印细胞的状态\n\t\t\t\t\tSystem.out.print(\":\"+numOfLive+\"-->\");//打印细胞的邻居中有多少个细胞是活的\n\t\t\t\t\t//写入下一次的细胞状态\n\t\t\t\t\tif ( cell.isAlive() ) {//如果当前细胞是活的\n\t\t\t\t\t\tif ( numOfLive <2 || numOfLive >3 ) {//判断是否满足让细胞死的条件条件\n\t\t\t\t\t\t\tcell.die();//让细胞死\n\t\t\t\t\t\t\tSystem.out.print(\"die\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( numOfLive == 3 ) {//如果当前细胞是死的，判断是否满足让细胞活的条件条件\n\t\t\t\t\t\tcell.reborn();//让细胞活\n\t\t\t\t\t\tSystem.out.print(\"reborn\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"UPDATE\");\n\t\t\tframe.repaint();//整个Field都更新好后，画出棋盘\n\t\t\t//延时\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Field {\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;//一个二维数组field，存放每个格子（细胞）\n\t//构造器，初始化棋盘\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\tpublic int getWidth() { return width; }\n\tpublic int getHeight() { return height; }\n\t//添加细胞\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\t//获取某个格子\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\t//获取周围细胞\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor ( int i=-1; i<2; i++ ) {\n\t\t\tfor ( int j=-1; j<2; j++ ) {\n\t\t\t\tint r = row+i;\n\t\t\t\tint c = col+j;\n\t\t\t\tif ( r >-1 && r<height && c>-1 && c<width && !(r== row && c == col) ) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        //toArray会自动把一个Cell[]数组装好，让返回这个数组\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\t//清空所有格子\n\tpublic void clear() {\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfor ( int j=0; j<width; j++ ) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -5258995676212660595L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\n\t//构造器\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t//每次当窗口被重绘时调用，被调用时会得到一个Graphics对象，即当前要画的对象\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);//调用父类的paint方法\n\t\t//绘制网格\n\t\tfor ( int row = 0; row<theField.getHeight(); row++ ) {//行\n\t\t\tfor ( int col = 0; col<theField.getWidth(); col++ ) {//列\n\t\t\t\tCell cell = theField.get(row, col);//得到每个格子的对象\n\t\t\t\tif ( cell != null ) {//如果该格子有对象\n\t\t\t\t\tcell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);//绘制该格子\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth()*GRID_SIZE+1, theField.getHeight()*GRID_SIZE+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tField field = new Field(10,10);\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {\n\t\t\t\tfield.place(row, col, new Cell());\n\t\t\t}\n\t\t}\n\t\tView view = new View(field);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(view);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n}\n\n```\n\n## Cell、Field、View的关系\nField只需要管好数据以及提供数据  \nView只管拿到数据之后按数据把整个网格都重新画一遍  \n而Cell只管自己应该画空心还是实心，Field要就提供给它  \n\n不去精心设计哪个局部需要更新，需要更新就整个重画   \n这样简化了程序逻辑，是在计算机运算速度提高的基础上实现的  \n<div><img src=https://cdn.chuckle.top/images/7-8.webp width=\"80%\" height=\"80%\"></div>\n\n## 数据与表现分离\n程序的业务逻辑与表现无关  \n-表现可以是图形的也可以是文本的  \n-表现可以是当地的也可以是远程的  \n\n需要不同表现，那就用不同表现的代码去取数据，然后表现出来  \n\n## 责任驱动的设计\n将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环  \n\n将功能拆分成很多个部分，每个部分只做自己擅长做的、简单的事  \n\n## 网格化\n图形界面本身有更高的解析度，但是将画面网格化以后，数据就更容易处理了  \n\n无需关心x、y轴坐标，只需知道要操作的对象在第几行第几列\n\n***\n\n# 狐狸和兔子\n细胞自动机是细胞在一个网格上，每个细胞都有两种状态  \n\n现在要模拟一个有狐狸和兔子的农场：   \n·狐狸和兔子都有年龄，且有规律增加  \n·当年龄到了一定的上限就会自然死亡  \n·狐狸可以随机决定在周围的兔子中吃一个，吃了后年龄上限会提高  \n·狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里  \n·如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步  \n\n这比只有细胞，细胞只有两种状态要复杂得多  \n\n## 源码\n这个没注释，原理和细胞自动机差不多  \n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\n\n```java Animal.java\npackage animal;\n\nimport java.util.ArrayList;\nimport field.Location;\n\npublic abstract class Animal {\n\n\tprivate int ageLimit;\n\tprivate int breedableAge;\n\tprivate int age;\n\tprivate boolean isAlive = true;\n\n\tpublic Animal(int ageLimit, int breedableAge) {\n\t\tthis.ageLimit = ageLimit;\n\t\tthis.breedableAge = breedableAge;\n\t}\n\n\tprotected int getAge() {\n\t\treturn age;\n\t}\n\n\tprotected double getAgePercent() {\n\t\treturn (double) age / ageLimit;\n\t}\n\n\tpublic abstract Animal breed();\n\n\tpublic void grow() {\n\t\tage++;\n\t\tif (age >= ageLimit) {\n\t\t\tdie();\n\t\t}\n\t}\n\n\tpublic void die() {\n\t\tisAlive = false;\n\t}\n\n\tpublic boolean isAlive() {\n\t\treturn isAlive;\n\t}\n\n\tpublic boolean isBreedable() {\n\t\treturn age >= breedableAge;\n\t}\n\n\tpublic Location move(Location[] freeAdj) {\n\t\tLocation ret = null;\n\t\tif (freeAdj.length > 0 && Math.random() < 0.02) {\n\t\t\tret = freeAdj[(int) (Math.random() * freeAdj.length)];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\" + age + \":\" + (isAlive ? \"live\" : \"dead\");\n\t}\n\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\treturn null;\n\t}\n\n\tprotected void longerLife(int inc) {\n\t\tageLimit += inc;\n\t}\n}\n\n```\n\n```java Fox.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Fox extends Animal implements Cell {\n\n\tpublic Fox() {\n\t\tsuper(20, 4);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));// (int)((20-getAge())/20.0*255)));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.05) {\n\t\t\tret = new Fox();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Fox:\" + super.toString();\n\t}\n\n\t@Override\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\tAnimal ret = null;\n\t\tif (Math.random() < 0.2) {\n\t\t\tret = neighbour.get((int) (Math.random() * neighbour.size()));\n\t\t\tlongerLife(2);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n```\n\n```java Rabbit.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport cell.Cell;\n\npublic class Rabbit extends Animal implements Cell {\n\n\tpublic Rabbit() {\n\t\tsuper(10, 2);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(255, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.12) {\n\t\t\tret = new Rabbit();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Rabbit:\" + super.toString();\n\t}\n}\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\nimport cell.Cell;\n\npublic class Field {\n\n\tprivate static final Location[] adjacent = {\n\t\t\tnew Location(-1, -1), new Location(-1, 0), new Location(-1, 1),\n\t\t\tnew Location(0, -1), new Location(0, 0), new Location(0, 1),\n\t\t\tnew Location(1, -1), new Location(1, 0), new Location(1, 1)\n\t};\n\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;\n\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tint r = row + i;\n\t\t\t\tint c = col + j;\n\t\t\t\tif (r > -1 && r < height && c > -1 && c < width && !(r == row && c == col)) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\n\tpublic Location[] getFreeNeighbour(int row, int col) {\n\t\tArrayList<Location> list = new ArrayList<Location>();\n\t\tfor (Location loc : adjacent) {\n\t\t\tint r = row + loc.getRow();\n\t\t\tint c = col + loc.getCol();\n\t\t\tif (r > -1 && r < height && c > -1 && c < width && field[r][c] == null) {\n\t\t\t\tlist.add(new Location(r, c));\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Location[list.size()]);\n\t}\n\n\tpublic boolean placeRandomAdj(int row, int col, Cell cell) {\n\t\tboolean ret = false;\n\t\tLocation[] freeAdj = getFreeNeighbour(row, col);\n\t\tif (freeAdj.length > 0) {\n\t\t\tint idx = (int) (Math.random() * freeAdj.length);\n\t\t\tfield[freeAdj[idx].getRow()][freeAdj[idx].getCol()] = cell;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Cell remove(int row, int col) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = null;\n\t\treturn ret;\n\t}\n\n\tpublic void remove(Cell cell) {\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tfor (int col = 0; col < width; col++) {\n\t\t\t\tif (field[row][col] == cell) {\n\t\t\t\t\tfield[row][col] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tfor (int j = 0; j < width; j++) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void move(int row, int col, Location loc) {\n\t\tfield[loc.getRow()][loc.getCol()] = field[row][col];\n\t\tremove(row, col);\n\t}\n}\n```\n\n```java Location.java\npackage field;\n\npublic class Location {\n\n\tprivate int row;\n\tprivate int col;\n\n\tpublic Location(int row, int col) {\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t}\n\n\tpublic int getRow() {\n\t\treturn row;\n\t}\n\n\tpublic int getCol() {\n\t\treturn col;\n\t}\n}\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JPanel;\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -2417015700213488315L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\t\tg.setColor(Color.GRAY);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tg.drawLine(0, row * GRID_SIZE, theField.getWidth() * GRID_SIZE, row * GRID_SIZE);\n\t\t}\n\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\tg.drawLine(col * GRID_SIZE, 0, col * GRID_SIZE, theField.getHeight() * GRID_SIZE);\n\t\t}\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tcell.draw(g, col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth() * GRID_SIZE + 1, theField.getHeight() * GRID_SIZE + 1);\n\t}\n}\n```\n\n```java FoxAndRabbit.java\npackage foxnrabbit;\n\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport animal.Animal;\nimport animal.Fox;\nimport animal.Rabbit;\nimport cell.Cell;\nimport field.Field;\nimport field.Location;\nimport field.View;\n\npublic class FoxAndRabbit {\n\n\tprivate Field theField;\n\tprivate View theView;\n\n\tpublic FoxAndRabbit(int size) {\n\t\ttheField = new Field(size, size);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tdouble probability = Math.random();\n\t\t\t\tif (probability < 0.05) {\n\t\t\t\t\ttheField.place(row, col, new Fox());\n\t\t\t\t} else if (probability < 0.15) {\n\t\t\t\t\ttheField.place(row, col, new Rabbit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheView = new View(theField);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(theView);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n\tpublic void start(int steps) {\n\t\tfor (int i = 0; i < steps; i++) {\n\t\t\tstep();\n\t\t\ttheView.repaint();\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void step() {\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tAnimal animal = (Animal) cell;\n\t\t\t\t\tanimal.grow();\n\t\t\t\t\tif (animal.isAlive()) {\n\t\t\t\t\t\tLocation loc = animal.move(theField.getFreeNeighbour(row, col));\n\t\t\t\t\t\tif (loc != null) {\n\t\t\t\t\t\t\ttheField.move(row, col, loc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// eat\n\t\t\t\t\t\t// animal.eat(theField);\n\t\t\t\t\t\tCell[] neighbour = theField.getNeighbour(row, col);\n\t\t\t\t\t\tArrayList<Animal> listRabbit = new ArrayList<Animal>();\n\t\t\t\t\t\tfor (Cell an : neighbour) {\n\t\t\t\t\t\t\tif (an instanceof Rabbit) {\n\t\t\t\t\t\t\t\tlistRabbit.add((Rabbit) an);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!listRabbit.isEmpty()) {\n\t\t\t\t\t\t\tAnimal fed = animal.feed(listRabbit);\n\t\t\t\t\t\t\tif (fed != null) {\n\t\t\t\t\t\t\t\ttheField.remove((Cell) fed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// breed\n\t\t\t\t\t\tAnimal baby = animal.breed();\n\t\t\t\t\t\tif (baby != null) {\n\t\t\t\t\t\t\ttheField.placeRandomAdj(row, col, (Cell) baby);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttheField.remove(row, col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFoxAndRabbit fab = new FoxAndRabbit(50);\n\t\tfab.start(500);\n\t}\n}\n\n```\n\n## 项目结构及分析\n<div><img src=https://cdn.chuckle.top/images/7-9.webp width=\"40%\" height=\"40%\"></div>\n\n在英文中Cell有两种意思，格子、细胞  \n在刚刚到细胞自动机中，Cell类表达细胞，或者没有细胞的空格子，这很合理  \n\n狐狸和兔子类有很多相似的属性和动作，所以它们应该有一个父类  \n但这个父类不应该是Cell，Cell在这个程序中应该表达有东西或没东西的格子才合理  \n所以这个父类应该是Animal  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.chuckle.top/images/7-10.webp width=\"100%\" height=\"100%\"></div>\n\n在细胞自动机中我们通过place(r,c,cell)将Cell放进网格中  \n但现在Fox、Rabbit和Cell没有联系，无法将它们放进网格中  \n如果按照之前的思路，Fox、Rabbit应该也是Cell的子类，但多继承是不被允许的（除了C++）  \n\n如果让Animal从Cell继承，这在语意上是模糊的，动物不应该是一种格子（虽然这样做能实现）  \n\n## 接口\n接口是纯抽象类  \n·所有的成员函数都是抽象函数  \n·所有的成员变量都是public static final  \n\n类表达一个具体的东西，而接口表达一种概念、一种规范  \n接口规定了长什么样，但是不管里面有什么  \n\n我们可以将Cell类改造成接口： \n```java Cell\nimport java.awt.Graphics;\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\nCell现在的作用：所有实现了Cell这个接口的类，都应该有draw这个方法  \n在这个程序中，只要实现了这个方法的类的对象，都可以直接放到Field中  \n\n为什么Cell接口只要求实现draw方法？  \n因为将来View只需要拿Cell去draw，所以只需要要求放到Field里的类的对象实现draw方法  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.chuckle.top/images/7-11.webp width=\"100%\" height=\"100%\"></div>\n\n现在Fox、Rabbit的对象都可以放进Field里（Field需要一个Cell，而Fox、Rabbit都实现了Cell）  \n\n### implements\n用关键字implements让类实现接口  \n```java\npublic class Fox extends Animal implements Cell{\n    //Fox是一种Animal，它实现了Cell\n}\n```\n在Field的place方法中,place需要一个Cell类的对象  \nCell本身是一个接口，它本身是抽象的，不可能有对象  \n但**所有实现了Cell接口**的对象都可以交给Cell对象的管理者  \n```java\npublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n```\n当Fox实现Cell后，就必须重写Cell中的方法  \n把draw方法实际地做出来  \n```java\n@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n```\n类用extends,接口用implements  \n类可以实现很多接口  \n接口可以继承接口，但不能继承类  \n接口不能实现接口  \n\n### interface\n声明一个接口  \n```java\npublic interface Cell{//接口\n}\npublic class Cell{//类\n}\n```\ninterface是一种特殊的class，它替代掉了class  \n\n### 面向接口的编程方式\n在上面的程序中，Field需要一个能draw的类的对象，然后Field提供了一个Cell接口，所有实现了这个接口的东西都可以交给Field，而它不关心这个东西是什么，只需要符合接口即可  \n\n设计程序时先定义接口，再实现类  \n任何需要在函数间传入传出的一定是接口而不是具体的类  \n是Java成功的关键之一，因为极适合多人同时写一个大程序：每个人只需要用接口去提出要求，其他人根据借口实现具体的类   \n也是Java被批评的要点之一，因为代码量膨胀起来很快，显得程序十分臃肿  \n\n## 增加一个按钮\n\n在狐狸与兔子程序的图形界面中增加一个按钮，按一下执行一步   \n\n在FoxAndRabbit.java中，这么一段代码生成了一个窗口  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\nframe.pack();\nframe.setVisible(true);\n```\n首先要在窗口中增加一个按钮  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\n//有一个类叫JButton，做一个叫btnstep的对象\nJButton btnstep =new JButton(\"单步\");\n//把这个按钮加到窗口中\nframe.add(btnstep);\nframe.pack();\nframe.setVisible(true);\n```\n运行一下\n<div><img src=https://cdn.chuckle.top/images/7-12.webp width=\"30%\" height=\"30%\"></div>\n\n整个窗口只剩下了我们加进去的这个按钮,解决这个问题我们需要了解Swing  \n\n***\n\n>下接[JAVA/面向对象学习笔记(3)](/article/8636f786.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"Butterfly魔改","url":"/article/ab2d75d5.html","content":"\n# 最新文章标志\n\n{% link 给首页文章卡片加上最新文章标志,/article/2ed7d622.html,%}\n<img src=https://cdn.chuckle.top/images/20-1.webp width=\"30%\" height=\"30%\">\n\n# 首页第一个卡片加个class\n\n{% link 首页第一个卡片加个class,/article/dbde845d.html,%}\n<img src=https://cdn.chuckle.top/images/21-1.webp width=\"40%\" height=\"40%\">\n\n# 加载进度条\n\n{% link 一个加载进度条,/article/13d6481a.html,%}\n<img src=https://cdn.chuckle.top/images/10-1.webp width=\"40%\" height=\"40%\">\n\n# 控制单页背景样式\n\n{% link 给指定单页加个class以控制其背景样式,/article/eb3a4679.html,%}\n<img src=https://cdn.chuckle.top/images/22-1.webp width=\"40%\" height=\"40%\">\n\n# 归档、分类、标签页文章卡片加上所属分类和标签\n\n{% link 给归档、分类、标签页文章卡片的标题下方加上所属分类和标签,/article/a19bb7fb.html,%}\n<img src=https://cdn.chuckle.top/images/23-2.webp width=\"80%\" height=\"80%\">\n\n# 添加音乐页面\n\n{% link 添加音乐页面,/article/3322c8a8.html,%}\n<img src=https://cdn.chuckle.top/images/24-1.webp width=\"40%\" height=\"40%\">\n\n# 给网站增加悬浮伸缩侧边栏\n\n{% link 给网站增加悬浮伸缩侧边栏,/article/fab5c3df.html,%}\n<img src=https://cdn.chuckle.top/images/25-1.webp width=\"40%\" height=\"40%\">\n\n# 老旧浏览器弹窗提醒\n\n{% link 老旧浏览器弹窗提醒,/article/e61f6567.html,%}\n<img src=https://cdn.chuckle.top/images/29-1.webp width=\"50%\" height=\"50%\">\n\n# 使用MiniSandbox前端代码可视化\n\n{% link 使用MiniSandbox前端代码可视化,/article/b827db53.html,%}\n<img src=https://cdn.chuckle.top/images/30-3.webp width=\"50%\">\n\n# BF添加输入页数跳转\n\n{% link BF添加输入页数跳转,/article/8e0b4c43.html,%}\n<img src=https://cdn.chuckle.top/images/34-2.webp width=\"50%\" height=\"50%\">\n\n# 给文章添加自定义文本锚点\n\n{% link 给文章添加自定义文本锚点,/article/6f237a88.html,%}\n<img src=https://cdn.chuckle.top/images/36-2.gif width=\"70%\">\n\n# 页面链接二维码(扫一扫)卡片\n\n{% link 页面链接二维码(扫一扫)卡片,/article/59995f0e.html,%}\n<img src=https://cdn.chuckle.top/images/37-4.gif width=\"40%\">\n\n# 网站添加点赞、踩功能\n\n{% link 网站添加点赞、踩功能,/article/5de26c08.html,%}\n<img src=https://cdn.chuckle.top/images/39-3.webp width=\"70%\">\n\n# 博客添加待办清单页\n\n{% link 博客添加待办清单页,/article/9875347c.html,%}\n<img src=/images/40-1.webp width=\"60%\">\n\n# 文章添加预设或实时生成的AI简介\n\n{% link 文章添加预设或实时生成的AI简介,/article/17d3383a.html,%}\n\n***\n\n>咕咕咕~~\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"JAVA/面向对象学习笔记(1)","url":"/article/bfb663c6.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n\n# 面向对象\n\n## 什么是面向对象\n面向对象是把**一组数据结构**和**处理他们的方法**组成对象。  \n把具有**相同行为**的对象归纳成**类**  \n通过**封装**隐藏类的内部细节  \n通过**继承**使类得到泛化  \n通过**多态**实现基于对象类型的动态分派 \n\n## 只能操作对象\n一切事物都是调用加封装的结果  \n程序实现的一切功能都是**调用**加**封装**的结果  \n程序调用一个个对象  \n封装的也是一个个对象\n\n## 基于对象编程\n同一个事物，构成它的对象能有多种划分方式  \n机器语言、汇编语言将电路上的开关，由1和0组成的指令作为对象  \n\nc语音将对象界定为一个个**数据**和一个个**算法**  \njava将**数据和算法的结合**作为一个对象    \n\n数据和算法分开的编程：面向过程编程  \n数据和算法结合的编程：面向对象编程  \n\n## 面向过程与面向对象\n面向过程关注如何实现，关注如何做，将一个要实现的、复杂的功能，用一个或多个大函数去实现，再抽丝剥茧，用更多的函数去实现这些函数。  \n面向对象关注数据，方法就在这，处理什么数据（对象）  \n\n面向对象中也有面向过程的代码，只是重点不在如何做，而是对对象的**抽象**与**扩展**  \n对于实现功能的核心算法，面向对象与面向过程并无区别，c语言也可通过结构体与函数指针实现面向对象    \n\n面向对象的**封装**、**继承**和**多态**，使得代码、功能的扩展、复用变得非常容易  \n\n这两种编程思想都是为了解决实际的问题  \n\n{% folding, 如何烧水  %}\n**转自互联网**  \n面向过程的烧水：  \n读取热水壶内水的水温，缓存  \n电热装置将发热量缓存  \n损耗算法读取发热量，并将将水的提升温度缓存  \n与水温相加  \n将这个数值重新赋给水温  \n直到温度达到沸点，完成烧水    \n\n面向对象的烧水：  \n定义热水壶类，继承自盛水容器，温度改变装置，温度计，水温控制接口  \n实例化一个热水壶类对象，命名为「我的热水壶」  \n为终止温度赋值：水.沸点  \n我的热水壶.温度处理(终止温度);  \n\n另：个人实现的烧水方法，仅图一乐：  \n为热水壶类实装烧水接口：实装水温监视事件  \n为热水壶类实装烧水接口：定义一个水温枚举器  \n为热水壶类实装烧水接口：实装温度处理方法  \n执行流程：  \n1.执行继承自盛水容器类的盛水方法  \n2.注册继承自温度改变装置类的温度监视事件  \n3.遍历水温枚举器：如果水温提升，则返回当前水温  \n4.如果返回值接近终止温度，跳出枚举过程，完成烧水。  \n5.否则，继续遍历枚举器。  \n\n你肯定会问这哪里优雅了，确实，看起来是复杂了不少，但再仔细想一想，这一整套流程只要稍加修改，稍加改变接口实现，你就可以直接用这个「热水壶类」实现一个热水器，甚至还可以是一个冰箱。  \n毕竟烧的又不一定是水，又不一定要烧水，又不一定要用壶烧水，又不一样要是个烧水壶  \n{% endfolding %}\n\n***\n\n# 对象与类\n对象是实体，需要被创建，可以为我们做事情    \n类是规范，根据类的定义来创建对象    \n\n一个类可以有多个对象  \n\n动物是一个类，每个对象，猫，狗，都是动物类的实体    \n我们用类制造出对象，再给对象所需要的数据，对象可以利用这些数据去做事情，我们大可无需知道对象是如何利用这些数据的，因为我们只要求，这个对象能实现一些功能  \n\n## 面向对象的思维\n我们看到一个事物  \n它有什么东西？  \n能干什么？  \n\n## 第一个程序：自动售货机\n售货机（VendingMachine）有什么？  \n商品的价格：price  \n显示的余额：balance  \n卖了多少钱：total  \n\n售货机能干什么？  \n输出一些提示：showPromot  \n取得一些钱：insertMomey  \n告诉用户余额：showBalance\n给我们商品（食物）：getFood  \n告诉商家总收入：showTotal\n\n我们需要设计VendingMachine这个类，这个类有3个属性，有5个动作（方法）  \n```java\nimport java.util.Scanner;\n//创建一个类\npublic class VendingMachine {\n    int price = 80;//商品价格(假设就只有一个商品，且价格固定)\n    int balance = 0;//当前余额\n    int total = 0;//总收入\n    int amount = 0;//钱\n    Scanner s=new Scanner(System.in);\n\n    void showPromot() {\n        //输出提示\n        System.out.println(\"欢迎！\");\n    }\n\n    void insertMomey(){\n        // 投入钱，更新余额\n        System.out.print(\"请充值余额：\");\n        amount = s.nextInt();\n        balance = balance + amount;\n    }\n\n    void showBalance(){\n        //输出余额\n        System.out.println(\"现在余额： \"+ balance);\n    }\n\n    void getFood(){\n        //给食物\n        if (balance >= price) {\n            System.out.println(\"给你。\");\n            balance = balance - price;\n            total = total + price;\n        }\n        else{\n            System.out.println(\"没有足够的余额！\");\n        }\n    }\n\n    void showTotal(){\n        System.out.println(\"目前总收入：\"+total);\n    }\n}\n```\n有了这个类，就可以通过类去制造一个对象,并让对象去实现一些功能\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //制作一个对象\n        VendingMachine vm = new VendingMachine();\n        boolean t = true;\n        vm.showPromot();\n        vm.showBalance();\n        while (t) {\n            vm.insertMomey();\n            vm.getFood();\n            vm.showBalance();\n            vm.showTotal();\n        }\n    }\n}\n```\n运行结果：  \n```\n欢迎！\n现在余额： 0\n请充值余额：100\n给你。\n现在余额： 20\n目前总收入：80\n请充值余额：20\n没有足够的余额！\n现在余额： 40\n目前总收入：80\n请充值余额：40\n给你。\n现在余额： 0\n目前总收入：160\n请充值余额：\n```\n\n## 创建对象\n使用new运算符，来创建这个类的一个对象  \n然后将这个对象交给这个类型的一个变量  \nVendingMachine vm = new VendingMachine();  \n\n**对象变量是对象的管理者**  \n\n## 让对象做事情\n使用 . 运算符  \nvm.insertMomey();  \nvm.getFood();  \n通过.运算符调用某个对象的方法  \n\n## 成员变量、成员方法\n类定义了**对象中**所具有的变量，这些变量称作成员变量  \n每个对象有自己的变量，和同一个类的其他对象是分开的  \n在方法中可以直接写成员变量（方法）的名字来访问成员变量（方法）（省去了this关键字）  \n\njava会给成员变量默认0值\n\n成员变量（方法）分为实例变量（方法）和类变量（方法）  \n加了static的就是类变量（方法）  \n\n### 类变量\n声明类变量： **static** <类型> <变量名>  \n\n访问类变量：  \n通过对象访问：<对象名>.<类变量名>  \n通过类访问：<类名>.<类变量名>  \n\n类变量不属于任何一个对象，属于这个类，但任何一个对象都拥有这个变量  \n\n修改类变量的值，所有对象中的该变量的值都会改变  \n\n类变量的初始化只会进行一次（在类的装载时）  \n\n### 类方法\n声明类方法： **static** <返回类型> <方法名>() {  }  \n\nstatic方法只能调用static方法，只能访问static变量   \n\n类方法可以通过类的名字去访问，也可以通过对象去访问  \n\n\n## 本地（局部）变量\n定义在**方法内部**的变量是本地变量  \n本地变量的生存期和作用域都是方法内部  \n\n本地变量没被赋值，会被禁止使用  \n\n成员变量的生存期是对象的生存期，作用域是类内部的成员方法 \n\n### var局部变量\n使用var时必须指出初始值(不可以是null)  \nvar <变量名> = <值>;  \n编译器可以推断出该变量的类型，且之后该变量的类型都是确定的，不可以给该变量赋其它类型的值\n\n## 对象初始化\n可以在定义成员变量的地方直接赋值  \nint price = 80;  \n\n在创建一个对象的过程中，会首先去做各种初始化的动作\n\n### 构造方法\n与类同名的函数，没有返回值  \n在创建一个对象时会自动调用的方法\n应该是public\n```java  \nVendingMachine(){\n    total = 10;\n}\n\nVendingMachine(int price ){\n    this.price = price;\n}\n```\n### 方法重载\n一个类里可以有多个**不同参数**的构造方法  \n创建对象的时候给出不同的参数值，就会自动调用不同的构造方法  \n通过this()还可以在构造方法中调用其他构造方法，写在第一行，且只能使用一次    \n一个类里的同名但参数表不同的方法构成了重载关系  \n\n## 对象的识别\n通过巧妙的思想，识别不同出对象的特点，让类更通用  \n例如，要实现一个时钟  \n可以设计一个类，通过这个类可以制造出时、分、秒三个对象  \n\n## 对象的交互\n时、分、秒三个对象可以共同组成一个时钟对象  \n控制时、分、秒之间的交互在时钟对象的方法中完成  \n```java Display.java\npublic class Display {\n    private int value = 0;\n    private int limit = 0;\n\n    public Display(int limit){\n        this.limit = limit;\n    }\n\n    public void increase(){\n        value++;\n        if(value == limit){\n            value = 0;\n        }\n    }\n\n    public int getValue(){\n        return value;\n    }\n\n}\n```\n\n```java Clock.java\npublic class Clock {\n    Display hour = new Display(24);\n    Display minute = new Display(60);\n    Display second = new Display(60);\n\n    public void start() {\n        while (true) {\n            second.increase();\n            if (second.getValue() == 0) {\n                minute.increase();\n                if (minute.getValue() == 0) {\n                    hour.increase();\n                }\n            }\n            System.out.printf(\"%02d:%02d:%02d\\n\", hour.getValue(), minute.getValue(), second.getValue());\n        }\n    }\n}\n```\n\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Clock clock = new Clock();\n        clock.start();\n    }\n}\n```\n\n***\n\n# 访问属性\n**private**：这个成员是私有的，只有在类的内部（成员方法和定义初始化 ）才能访问  \n一般来说，成员变量都该是private   \n**这个限制是对类的而不是对对象的**：同一个类的不同对象可以互相访问对方的成员变量  \n\n**public**：任何人都可以访问  \n任何人指的是在任何类的方法或定义初始化中可以使用  \n使用指的是调用、访问或定义变量  \n很多的成员方法都是public \npublic的类，类名和文件名要一致，一个编译单元只能有一个public的类  \n\n**protected**：受保护的成员  \n\n**friendly**：默认属性，友好的成员  \n\n| 访问属性  | 本类    | 同包       | 子类      |   其它  |\n| -----    | ------ | --------- | ------   |   ---  |\n| private  |   √    |           |          |        |\n| friendly |     √  |   √       |          |        |\n| protected|   √    |     √     |     √    |        |\n| public   |     √  |     √     |      √   |   √    |\n\n***\n\n# 包package\n包是java管理类的一个机制  \n源文件中同名类要在**不同**包内  \n\n声明该类的指定包名  \npackage <包名>;  \n\n包名中的.代表文件夹的层次  \n\n没有package语句的源程序都将视为在同一个无名包内  \n\n## import\n使用import语句引入包中的类和接口  \n\nimport test.Hallo  \ntest包中的Hallo类  \n\n只要用到的类和本类不在同一个包内，就要import它  \n\n如果不使用import，当要用到类时要给出全名：<包名>.<类名>  \n\n引入一个包内的所有东西：import <包名>.*;（注意同名类的冲突） \n\n***\n# NoteBook例子\n记事本可以做什么？  \n1、能存储记录  \n2、不限制能存储的记录的数量  \n3、能知道已经存储的记录的数量  \n4、能查看存进去的每一条记录  \n5、能删除一条记录  \n6、能列出所有的记录  \n\n确定需求后，进行接口设计  \n```java 接口设计\npublic class NoteBook {\n\n    public void add(String s) {\n        //添加内容\n    }\n\n    public int getSize() {\n        //放了多少个\n        return 0;\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return \" \";\n    }\n\n    public boolean removeNote(int index) {\n        //删除\n        return true;\n    }\n\n    public String[] list() {\n        //返回全部内容\n    }\n\n}\n\n```\n接口设计完，考虑实际功能的实现，首先是数据的存放  \n\n## 顺序容器\n```java\nprivate ArrayList<String> notes = new ArrayList<String>();  \n```\n用来存放String的一个ArrayList  \nArrayList内的东西是有顺序的，是加入数据的顺序，形成对应下标的索引（从0开始）  \n\n这种类型叫做范型类：泛型类封装不特定于特定数据类型的操作  \n这种范型类是一种容器  \n\n容器类有两个类型：容器的类型、元素的类型  \n\n利用容器类的方法可以实现需要的功能  \nnotes.add(s);  //向容器添加数据\nnotes.size();  //容器存了多少个东西\nnotes.get(1); //得到1位置处的数据\n\n完成全部功能接口\n```java NoteBook.java\nimport java.util.ArrayList;\n\npublic class NoteBook {\n    private ArrayList<String> notes = new ArrayList<String>();//容器类\n\n    public void add(String s) {\n        //添加内容\n        notes.add(s);\n    }\n\n    public void add(String s, int location) {\n        //加到指定位置前，后面的内容下标后推\n        notes.add(location, s);\n    }\n\n    public int getSize() {\n        //放了多少个\n        return notes.size();\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return notes.get(index);\n    }\n\n    public void removeNote(int index) {\n        //删除，后面下标前移，因为remove方法自会抛异常，所以无需返回boolean\n        notes.remove(index);\n    }\n\n    public String[] list() {\n        //返回全部内容\n        String[] a = new String[notes.size()];\n\n        //for (int i=0; i< notes.size(); i++){\n        //    a[i] = notes.get(i);\n        //}\n        notes.toArray(a);//会自己把数组按顺序填好\n        //要熟悉系统类库里有的方法，无需重复造轮子\n        return a;\n    }\n\n}\n```\n写出上层程序\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        NoteBook nb = new NoteBook();\n\n        nb.add(\"first\");\n        nb.add(\"second\");\n        System.out.println(nb.getSize());\n        System.out.println(nb.getNote(1));\n\n        nb.add(\"third\", 1);\n        System.out.println(nb.getNote(1));\n        System.out.println(nb.getNote(2));\n        System.out.println(nb.getSize());\n\n        nb.removeNote(1);\n        String[] b = nb.list();\n        for (String s : b) {\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n输出：\n```\n2\nsecond\nthird\nsecond\n3\nfirst\nsecond\n```\n\n## 对象数组\n```java\nString[] a = new String[notes.size()];  \n```\n对象数组中的每个元素都是对象的管理者而非对象本身  \n当创建了一个对象数组，只是管理者们被创建了，但对象还没有，得想办法把每个对象创建出来  \n\n### for-each循环\n对于普通数组：  \n```java\nint[] a = new int[10];\nfor (int i = 0; i < a.length; i++) {\n    a[i] = i;//赋值\n}\nfor ( int k : a ) {\n    System.out.println(k);\n    k++;//每个k都是a中元素的复制品，不会起作用\n}\n```\n对于对象数组：  \n```java\nValue[] a = new Value[10]; \nfor (int i=0; i< 10; i++){\n    a[i] = new Value[];\n    a[i].set(i);\n}\nfor ( Value v : a ){\n    System.out.println(v.get());\n    v.set(0);//起作用，因为对象数组存的是对象管理者，v=a[i]，v也会成为对象管理者\n}\n```\n\n\n## 集合容器\n集合容器内所有元素都不相同  \n而且里面的元素不排序  \n```java\nHashSet<String> s = new HashSet<String>();\ns.add(\"first\");\ns.add(\"second\");\ns.add(\"first\");\nSystem.out.println(s);//容器都可以这样输出\n```\n输出：\n```java\n[second, first]\n```\n\n## public String toString\n在java中只要类中实现了这样一个方法  \n就可以直接用对象名输出这个对象  \n容器当中都有这样一个方法 \n```java\npublic String toString(){  \n    return \"\";  \n}  \n```\n\n## Hash表\n例子：数字与美元硬币名字对应，查找硬币名称  \n1=penny  \n5=nickel  \n10=dime  \n25=quarter  \n50=half-dollar\n\n定义接口：\n```java\npublic class Coin {\n    public String getName(int amount){\n            return  \"\";\n    }\n}\n```\n为什么不用switch-case？  \n体现在代码中的硬编码越少越好  \n\n使用Hash表（一种数据结构）  \n在这个表中，所有东西是以一对值放入的，一个叫做key（键），一个叫做值  \n一个key对应一个值，可以用key取值  \nHash表中的元素没有顺序  \n```java Coin.java\nimport java.util.HashMap;\n\npublic class Coin {\n    //不能使用int，容器当中所有的类型都得是对象,而不能是基本类型\n    //Integer是int的包裹类型\n    private HashMap<Integer, String> coinnames = new HashMap<Integer, String>();\n\n    public Coin(){\n        coinnames.put(1, \"penny\");//1对应penny\n        coinnames.put(10, \"dime\");\n        coinnames.put(25, \"quarter\");\n        coinnames.put(50, \"half-dolar\");\n        \n        System.out.println(coinnames.keySet().size());//keySet()，把所有key做为一个HashSet的集合给你，在这个集合可以得到size\n        System.out.println(coinnames);//也可以直接输出\n        coinnames.put(50, \"五十\");//会替换掉前面的\n        System.out.println(coinnames);\n        for (Integer k : coinnames.keySet()){//遍历Hash表\n            String s = coinnames.get(k);\n            System.out.println(s);\n        }\n    }\n\n    public String getName(int amount){\n        if (coinnames.containsKey(amount))\n            return coinnames.get(amount);\n        else\n            return  \"NOT FOUND\";//不判断的话，不存在会返回null\n    }\n\n\n}\n```\n```java Main.java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int amount = in.nextInt();\n        Coin coin = new Coin();\n        String name = coin.getName(amount);\n        System.out.println(name);\n    }\n}\n```\n输出：\n```java\n10\n4\n{1=penny, 50=half-dolar, 25=quarter, 10=dime}\n{1=penny, 50=五十, 25=quarter, 10=dime}\npenny\n五十\nquarter\ndime\ndime\n```\n\n***\n\n# 继承与子类\n\n## 媒体资料库设计\n和NoteBook一样，需要设计一个类,用类去表达一种媒体（CD,DVD）  \n然后用一个媒体类的容器去装媒体对象，一个资料库就完成了  \n\nCD有什么？  \n名称：title  \n艺术家：artist  \n多少首歌：numofTracks  \n持续时间：playingTime  \n是否被借出：gotIt  \n描述：comment  \n\n能做什么？\n输出一些信息：print\n\n```java CD.java\npublic class CD{\n    private String title;\n    private String artist;\n    private int numofTracks;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        System.out.print(title+\":\");\n        System.out.println(artist);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.list();\n    }\n}\n```\n现在资料库中已经可以存各种CD媒体了  \n但我们还想在资料库中存DVD媒体或者其它媒体类型  \n\n当然，我们可以再创建一个类表示DVD\n```java DVD.java\npublic class DVD{\n    private String title;\n    private String director;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        this.director = director;\n        this.title = title;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        System.out.print(title+\":\");\n        System.out.println(director);\n    }\n}\n```\n设计好类后在Database.java里创建一个放DVD的容器,以及配套的方法    \n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n    //+\n    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n    //+\n    public void add(DVD dvd){\n        listCD.add(dvd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n        //+\n        for(DVD dvd : listDVD){\n            dvd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        //+\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n现在资料库中能存放两种媒体  \n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \n我们创建了一个资料库类  \n资料库类里有两个容器，用来存放两种不同类型的媒体的对象管理者  \n\n<div><img src=https://cdn.chuckle.top/images/7-1.webp width=\"70%\" height=\"70%\"></div>\n\n这样的结构虽然能实现我们需要的功能，但DVD和CD类几乎一模一样   \n出现了很多代码复制，这是代码质量不良的表现  \n当我们需要修改print，add等方法，就得逐个去改  \n当我们需要新增一种媒体，就得为它做很多的工作  \n\n## 继承\nCD和DVD类很相似，我们可以从中提取一些它们共有的东西封装成一个类Item  \nItem可以表达CD或者DVD  \n而Database只需管Item  \n\n```java Item.java\npublic class Item {\n    private String title;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public Item(String title, int playingTime, boolean gotIt, String comment) {\n        this.title = title;\n        this.playingTime = playingTime;\n        this.gotIt = gotIt;\n        this.comment = comment;\n    }\n\n    public Item(){\n\n    }\n\n    public void print() {\n        System.out.print(title+\":\");\n    }\n\n}\n```\n```java CD.java\npublic class CD extends Item{\n//    private String title;\n    private String artist;\n    private int numofTracks;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n//        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        super.print();\n        System.out.println(artist);\n    }\n}\n```\n```java DVD.java\npublic class DVD extends Item{\n//    private String title;\n    private String director;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n        this.director = director;\n//        this.title = title;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        super.print();\n        System.out.println(director);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n//    private ArrayList<CD> listCD = new ArrayList<CD>();\n//    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n    private ArrayList<Item> listItem = new ArrayList<Item>();\n\n//    public void add(CD cd){\n//        listCD.add(cd);\n//    }\n//\n//    public void add(DVD dvd){\n//        listCD.add(dvd);\n//    }\n    public void add(Item item){\n        listItem.add(item);\n    }\n\n    public void list(){\n//        for (CD cd : listCD){\n//            cd.print();\n//        }\n//        for(DVD dvd : listDVD){\n//            dvd.print();\n//        }\n        for (Item item : listItem){\n            item.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \nCD extends Item：CD扩展了Item  \n即CD变成了Item的子类  \n这就是**继承**  \nCD得到了Item里所有的东西  \n\n<div><img src=https://cdn.chuckle.top/images/7-2.webp width=\"70%\" height=\"70%\"></div>\n\n## 子类与父类\n当父类里的东西是private时  \nprivate String title;  \n子类得到了这个东西，但不能用（可以通过父类的方法去用）  \n解决办法：将private改成protect  \n但这样不好，有很多时候父类和子类不在同一个包内  \n\ntitle本来就是父类的东西  \n可以让title在父类中初始化完，再让子类得到title  \n```java\npublic Item(String title) {\n    this.title = title;\n}\n```\n在子类构造器中使用super()来得到父类的title  \n```java\n public CD(String title) {\n    super(title);\n}\n```\n\n### super()\n当程序初始化对象时，会先运行super()  \n然后去运行父类的构造器，再回来继续运行自己的构造器  \n\nsuper():去父类调用一个没有参数的构造器  \nsuper(<参数>):去父类调用一个有对应参数的构造器  \n\n当子类没有super(),会默认去调用父类没有参数的构造器  \n\n通过super关键字来实现对父类成员的访问，用来引用当前对象的父类  \nsuper.<父类成员>  \n\n通过this来区分子类父类中的同名成员  \nthis.aaa();   // this 调用自己的方法  \nsuper.aaa();  // super 调用父类方法  \n\n## 子类和子类型\n类定义了类型  \n子类定义了子类型  \n\n子类的对象可以被当作父类的对象来使用  \n-赋值给父类的变量（父类的对象管理者可以管理子类的对象）  \n<div><img src=https://cdn.chuckle.top/images/7-3.webp width=\"70%\" height=\"70%\"></div>\n\n-传递给需要父类对象的方法  \n\n\n-放进存放父类对象的容器里  \n<div><img src=https://cdn.chuckle.top/images/7-4.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/7-5.webp width=\"35%\" height=\"35%\"></div>\n\n***\n\n# 多态\n## 多态变量\n所有的**对象变量**都是**多态**的（它们能保存不止一种类型的对象，不同时刻可以放不同类型的对象（例如父类的对象变量放子类的对象））  \n它们可以保存的是声明类型的对象，或声明类型的子类的对象  \n\n当把**子类的对象**赋给**父类的变量**的时候，就发生了**向上造型**  \n\n每一个java的对象变量，都具有两个类型  \n一个是**声明类型**  \n一个是**动态类型**  \n有时候两者是一致的，有时候又不一样  \n\n这就是变量的多态（在运行过程中，它所管理的对象类型是会变化的）  \n\n## 造型\n造型：把一个类型的**对象**，赋给另一个类型的**变量**\n\n对象变量的赋值并不是把一个对象赋给另一个对象（注在c++中可以做两个对象之间的赋值）  \n而是让这两个对象的管理者去**管理同一个对象**  \n```java\nString s = \"hello\";\n//原本这个String类型的对象变量s管理着一个对象\n//这个对象里面有个\"hello\"\ns = \"bye\";\n//后来s去管理另一个对象，里面有\"bye\"\n```\n并不是将bye替换掉hello，java不能做这种事  \n\njava中”=“的赋值运算，实际上是在改变指向  \n```java\nString s = \"hello\";\nString t = \"bye\";\ns = t;\n//原本s和t各管理一个对象，现在s和t管理同一个对象，里面有”hello“\n```\n当给一个**对象变量**管理着与它声明（静态）类型**不符**的对象时，就发生了**造型**  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\n//把子类的对象赋给父类的变量，让父类的对象变量去管理子类的对象\n```\n父类对象是不能直接赋给子类对象变量的\n但可以强制把父类对象当成子类的对象，然后去造型  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\nCD cc = item;//不行。父类对象不能直接交给子类对象变量去管理\nCD cc = (CD)item;//行，因为item已经管理着一个CD的对象了\n//强制把item的类型当做CD\n```\n如果没有Item item = cd;\n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\n//Item item = cd;\nCD cc = (CD)item;//编译可以通过，但运行会出错\n```\n将一个变量强制造型成另一个类型，然后赋给另一个变量  \nCD cc = (CD)item;  \n只有当item这个变量**实际管理**着CD类型的对象才不会出错  \n\n在C语言中，有类似写法，但是是类型转换（对于基本类型int、double，java也能强制类型转换）  \nint i = (int)10.2;//强制类型转换\n这与造型是不同的  \n类型转换是将10.2变成了10  \n但造型只是把item当做CD类型来看待  \nitem本身还是Item类型  \n\n(类型名)对象名：将一个对象当做这个类型来看待  \n\n### 向上造型\n向上造型是特殊的造型，无需写(父类类型)  \n拿一个子类的对象，当作父类的对象来用  \n向上造型总是安全的  \n\n## 方法调用的绑定\n```java\npublic void list(){\n    for (Item item : listItem){\n        item.print();\n    }\n}\n```\nitem每次循环管理的对象不一样，甚至管理的对象的类型也不一样，可以是CD或是DVD  \n当item管理CD(DVD)类型的对象时，去调用print方法，调用的是CD(DVD)类型里的print  \n\n\n当通过对象变量调用方法的时候，调用哪个方法这件事情叫做绑定  \n-静态绑定：根据变量的声明类型来决定  \n-动态绑定：根据变量的动态类型来决定  \n在成员函数中调用其他成员函数也是通过this这个对象变量来调用的  \n\njava默认所有的绑定都是动态绑定  \n\n### 覆盖\n子类和父类中存在**名称和参数表**完全相同的函数，这一对函数构成**覆盖**关系  \n通过父类的变量调用存在覆盖关系的函数时，调用变量当时所**管理的对象**所属的类的函数  \n这是一种动态绑定  \n\n## 多态总结\n多态性是对象多种表现形式的体现  \n\n通过一个变量去调用一个函数，我们不去判断变量运行中实际类型是什么，我们只想它能print  \n多态是**同一个行为**具有多个**不同表现形式或形态**的能力  \nitem是CD类型时它这样print，是DVD类型时那样print，但都是print行为  \n\n***\n\n# 类型系统\n\n## Object类\njava中所有类都是Object类型的子类  \n这是一种单根结构  \n<div><img src=https://cdn.chuckle.top/images/7-6.webp width=\"70%\" height=\"70%\"></div>\n\n发生继承时，父类所有public的东西子类都会得到  \n所以java中所有的类，都从Object类中得到了两个函数  \n-toString()  \n-equals()  \n\n## toString()\ntoString()会返回一个字符串，用来表达对象  \n\n当一个类中没有toString()方法时，会调用继承自Object类的toString()  \n```java\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd.toString());\nSystem.out.println(cd);//和上面的效果一个月，编译器会知道这个地方需要调用toString()\n\nString s = \"aa\"+cd;//编译器知道这个地方需要调用toString()\nSystem.out.println(s);\n```\n```java 输出\nCD@3d075dc0\n//类型名+一个类似地址、编号的东西\nCD@3d075dc0\naaCD@3d075dc0\n```\n显然，默认的表达这个对象的toString(),是返回一个类型名+一个类似地址、编号的东西  \n\n我们可以在类中自定义一个toString()  \n即设计一个表达对象的toString()  \n```java\n@Override\npublic String toString() {\n    return \"CD{\" +\n            \"artist='\" + artist + '\\'' +\n            \", numofTracks=\" + numofTracks +\n            '}';\n    }\n```\n```java 输出\nCD{artist='aaa', numofTracks=4}\n```\n\n## equals()\n\n==**无法**比较两个对象的内容是否相同，只能比较这两个对象变量是否管理着同一个对象    \n我们需要使用equals()去比较内容  \n\n当类中没有equals()，会调用继承自Object类的equals()  \n```java\nCD cd1 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nCD cd2 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd1.equals(cd2));\n```\n```java 输出\nfalse\n```\nObject这个公共父类的equals()无法知道它的子类长什么样子，所以也无法比较这两个对象内容是否相等  \nObject的equals()实际上也是在比较两个对象变量是否管理着同一个对象\n\n我们需要使用自定义的equals()去比较内容  \n```java\n@Override\npublic boolean equals(Object o) {\n    CD cc = (CD) o;//将Object o看作是CD类型的\n    return numofTracks == cc.numofTracks && artist.equals(cc.artist);\n}\n```\n```java 输出\ntrue\n```\n\n## @Override\n作用：告诉编译器，这个函数覆盖了父类的同属性、同名、同参方法  \n也可能会在代码界面报错，如果这个函数没有和父类的同名方法有相同属性、参数\n\n不带@Override，如果自定义的equals()和父类的同属性、同名、同参  \n那么也会覆盖掉父类的，@Override只是起帮助检查作用  \n\n***\n\n# 可扩展性\n现在要往Database这个资料库里增加新的媒体类型，是一件非常容易的事情    \n```java VideoGame.java\npublic class VideoGame extends Item {\n    private int numberofPlayers;\n\n    public VideoGame(String title, int playingTime, boolean gotIt, String comment, int numberofPlayers) {\n        super(title, playingTime, gotIt, comment);\n        this.numberofPlayers = numberofPlayers;\n    }\n\n    public void print() {\n        System.out.print(\"VideoGame:\");\n        super.print();\n        System.out.println(numberofPlayers);\n    }\n}\n```\n<div><img src=https://cdn.chuckle.top/images/7-7.webp width=\"70%\" height=\"70%\"></div>\n\n只需要增加一个子类，然后构造一下，覆盖下方法，父类完全不需要去动  \n这种特性叫**可扩展性**：代码无需修改即可扩展去适应新的数据、新的内容  \n\n如果需要修改去适应新的数据、新的内容，则叫**可维护性**  \n\n***\n\n>下接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"C语言单链表菜品管理系统","url":"/article/a696e8fe.html","content":"\n# 简介\n我的大一上学期期末项目，也是C语言的期末大作业。  \n\n使用单链表进行菜品信息的存储，系统有菜品的增删改查、排序、安全输入、统计、随机输出和文件输入输出等功能。 \n\n现在回去看代码想给自己一锤子（误）\n\n***\n\n# 包含文件\n<div><img src=https://cdn.chuckle.top/images/6-8.webp width=\"70%\" height=\"70%\"></div>\n\n***\n\n# 函数说明\n<div><img src=https://cdn.chuckle.top/images/6-9.webp width=\"70%\" height=\"70%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-10.webp width=\"70%\" height=\"70%\"></div>\n\n***\n# 代码\n```c 900行有点长\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\n#define SIZE1 100 //名称，价格等字数\n#define SIZE2 200 //限制评价字数\n\ntypedef struct _node\n{\t\t\t\t\t\t\t//链表的节点结构体\n\tchar name[SIZE1];\t\t//菜品名称\n\tchar restaurant[SIZE1]; //饭店名字\n\tfloat price;\t\t\t//菜的价格\n\tint fraction;\t\t\t//菜的评分\n\tchar comment[SIZE2];\t//菜品评价\n\tstruct _node *next;\n} Node;\ntypedef struct _list //方便对链表操作\n{\n\tNode *head;\n\tNode *pa;\n\tNode *pb;\n\tNode *pc;\n} List;\n//菜单\nvoid menu(void);\t\t\t   //一级菜单\nvoid menu_inquire(List *list); //二级菜单_查询菜单\nvoid help(void);\t\t\t   //二级菜单_帮助菜单\nint menu_sort(List *list);\t   //三级菜单_排序方法\n//对节点操作\nvoid add(List *list);\t  //添加节点\nvoid delete (List *list); //删除节点\nvoid revise(List *list);  //修改节点\n//安全输入\nchar *s_gets(char *st, int n); //安全输入字符\nint get_int(void);\t\t\t   //安全输入int型\nfloat get_float(void);\t\t   //安全输入float型\n//链表的输出和操作\nvoid inquire_all(List *list);\t\t\t//输出链表全部节点\nvoid inquire_one(List *list);\t\t\t//输出链表指定菜名节点\nvoid inquire_restaurant(List *list);\t//输出链表指定饭店节点\nvoid inquire_part_price(List *list);\t//输出一定价格以下的菜品(这功能。。贫穷)\nvoid inquire_part_fraction(List *list); //输出一定评分以上的菜品\nvoid average_percentage(List *list);\t//查询某饭店或食堂的平均价格和评分\nvoid output(Node *p);\t\t\t\t\t//方便输出\nvoid random_menu(List *list);\t\t\t//随机输出一道菜\nvoid empty(List *list);\t\t\t\t\t//清空链表\n//文件操作\nvoid save(List *list);\t   //保存\nvoid read_txt(List *list); //读取文件_初始链表\n//单链表的排序\nvoid sort_ascending(List *list);\t\t //菜品按价格从低到高排序\nvoid sort_descending(List *list);\t\t //菜品按价格从高到低排序\nvoid sort_score(List *list);\t\t\t //菜品按评分从高到低排序\nint calculate(List *list);\t\t\t\t //计算出单链表的节点个数\nvoid swap1(List *list, List *list_swap); //单链表冒泡排序的算法块1\nvoid swap2(List *list, List *list_swap); //单链表冒泡排序的算法块2\n//其他\nint random_number(List *list); //随机生成不大于节点数的整数\nvoid color(int a);\t\t\t   //控制台文本颜色\n//______________________________________________________\n//------------------------------------------------------\nint main() //主函数\n{\n\t//system(\"chcp 65001\");//GB2313\n\t//system(\"chcp 936\");//UTF8\n\t//system(\"cls\");\n\tmenu(); //输出功能菜单\n\t//佛祖开光无bug\n\treturn 0;\n}\n//菜单\nvoid menu() //一级菜单\n{\n\tint options, z = 1;\n\tList list;\n\tlist.head = NULL;\t\t\t\t   //head指向空，链表不存在\n\tFILE *fp = fopen(\"Menu.txt\", \"a\"); //若无Menu.txt文件，则创建一个\n\tfclose(fp);\n\tread_txt(&list); //读入txt中的数据，初始化链表\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(14);\n\t\tprintf(\"|                    菜品信息系统             \\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"|********************系统功能菜单*********************\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|1、使用帮助|                       \\n\");\n\t\tprintf(\"|*******************|2、添加菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|3、删除菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|4、查询菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|5、修改菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|6、今天吃什么|                     \\n\");\n\t\tprintf(\"|*******************|7、清空所有数据|                     \\n\");\n\t\tprintf(\"|*******************|8、保存|\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|0、退出系统|                       \\n\");\n\t\tcolor(12);\n\t\tprintf(\"|!!!前请先保存再退出系统,否则数据会丢失!!!\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0; //跳出循环\n\t\t\tprintf(\"即将退出系统。\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd(&list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdelete (&list);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmenu_inquire(&list);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevise(&list);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trandom_menu(&list);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tempty(&list);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsave(&list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n\tsystem(\"pause\");\n}\nvoid help() //二级菜单_帮助菜单\n{\n\tsystem(\"cls\");\n\tprintf(\"\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tcolor(15);\n\tprintf(\"|使用帮助：\\n\");\n\tprintf(\"|1、本菜品信息系统可供用户自行修改内容\\n\");\n\tprintf(\"|2、因为考虑到不同饭店有同样名称的菜品，本系统允许菜品名称有重复\\n\");\n\tprintf(\"|3、请勿输入错误信息，以免造成程序出错\\n\");\n\tprintf(\"|4、关闭系统前记得保存！否则数据会丢失\\n\");\n\tprintf(\"|5、有bug联系1934009145@qq.com\\n\");\n\tprintf(\"|6、github地址:github.com/qxchuckle/Dishes-Management-System\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tprintf(\"\\n\");\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid menu_inquire(List *list) //二级菜单_查询菜单\n{\n\tint options, z = 1;\n\tList *p = list;\t\t\t//方便传结构体指针\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！无法查询！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn; //为空结束函数\n\t}\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、查询全部菜品信息\\n\");\n\t\tprintf(\"|2、按菜名查询菜品信息\\n\");\n\t\tprintf(\"|3、查询饭店或食堂的全部菜品信息\\n\");\n\t\tprintf(\"|4、查询某价格以下的全部菜品\\n\");\n\t\tprintf(\"|5、查询某评分以上的全部菜品\\n\");\n\t\tprintf(\"|6、查询某饭店或食堂的平均价格、评分和价格区间占比\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_all(p);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tinquire_one(p);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_restaurant(p);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_price(p);\n\t\t\treturn;\n\t\tcase 5:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_fraction(p);\n\t\t\treturn;\n\t\tcase 6:\n\t\t\taverage_percentage(p);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n}\nint menu_sort(List *list) //三级菜单_排序方法\n{\n\tint options, z = 1, n = 1;\n\tList *p = list;\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、按价格从低到高排序\\n\");\n\t\tprintf(\"|2、按价格从高到低排序\\n\");\n\t\tprintf(\"|3、按评分从高到低排序\\n\");\n\t\tprintf(\"|4、不排序\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\treturn z;\n\t\tcase 1:\n\t\t\tsort_ascending(p);\n\t\t\treturn n;\n\t\tcase 2:\n\t\t\tsort_descending(p);\n\t\t\treturn n;\n\t\tcase 3:\n\t\t\tsort_score(p);\n\t\t\treturn n;\n\t\tcase 4:\n\t\t\treturn n;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n}\n//对节点操作\nvoid add(List *list) //添加节点\n{\n\tfloat k = 1;\n\tint n = 0, i = 0;\n\tNode *last = list->head;\n\tNode *p1 = (Node *)malloc(sizeof(Node)), *p; //给节点分配空间\n\tp1->next = NULL;\n\tsystem(\"cls\");\n\tputs(\"开始录入菜品：\\n----------------\\n\");\n\tputs(\"请输入菜品名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->name, SIZE1);\n\t} while (strlen(p1->name) == 0);\n\tputs(\"请输入菜品所属饭店or食堂名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->restaurant, SIZE1);\n\t} while (strlen(p1->restaurant) == 0);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(p1->name, p->name) || strcmp(p1->restaurant, p->restaurant)))\n\t\t{\n\t\t\tcolor(12);\n\t\t\tprintf(\"该饭店/食堂内已存在同名菜品！\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"请输入菜品的价格：\");\n\tp1->price = get_float();\n\tputs(\"请输入0-10的整数对菜品进行评分：\");\n\tdo\n\t{\n\t\tn = get_int();\n\t\tif (n >= 0 && n <= 10) //判断评分是否是0-10\n\t\t{\n\t\t\tp1->fraction = n;\n\t\t\ti = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor(12);\n\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (!i);\n\tputs(\"请对菜品进行评价：\");\n\tdo\n\t{\n\t\ts_gets(p1->comment, SIZE2);\n\t} while (strlen(p1->comment) == 0);\n\tif (last) //如果last有值，则说明head已指向链表第一个节点\n\t{\n\t\twhile (last->next)\n\t\t{\n\t\t\tlast = last->next; //last始终指向最后一个节点\n\t\t}\n\t\tlast->next = p1; //在最后一个节点后面再加一个节点\n\t}\n\telse\n\t{\n\t\tlist->head = p1; //如果last为NULL，则要将head指向第一个节点\n\t}\n\tcolor(11);\n\tputs(\"录入成功！\");\n\tsystem(\"pause\");\n}\nvoid delete (List *list) //删除节点\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL)\n\t{ //判断链表是否为空\n\t\tprintf(\"还未存入任何菜品！删除失败！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入你要删除的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //遍历链表\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要修改的节点\n\t\t{\n\t\t\tn++;   //记录找到了\n\t\t\tif (q) //判断找到的是不是第一个节点\n\t\t\t{\n\t\t\t\tq->next = p->next; //让该节点的前一个节点都next指向后一个节点\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist->head = p->next; //让head的next指向后一个节点\n\t\t\t}\n\t\t}\n\t}\n\tif (!n)\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n删除成功%d道菜。\\n\", n);\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid revise(List *list) //修改节点\n{\n\tfloat k = 1;\n\tint n = 0, m = 0, i = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tprintf(\"还未存入任何菜品！无法修改！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入要修改的菜品的名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要删除的节点\n\t\t{\n\t\t\tn++; //记录找到\n\t\t\tprintf(\"\\n原来的菜品信息:\\n\");\n\t\t\tprintf(\"|菜名:%s\\n\", p->name);\n\t\t\tprintf(\"|所属:%s\\n\", p->restaurant);\n\t\t\tprintf(\"|价格:%.2f\\n\", p->price);\n\t\t\tprintf(\"|评分:%d\\n\", p->fraction);\n\t\t\tprintf(\"|评价:%s\\n\", p->comment);\n\t\t\tprintf(\"\\n\");\n\t\t\tputs(\"请修改菜品的价格：\");\n\t\t\tp->price = get_float();\n\t\t\tputs(\"请输入0-10的整数以修改菜品的评分：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm = get_int();\n\t\t\t\tif (m >= 0 && m <= 10)\n\t\t\t\t{\n\t\t\t\t\tp->fraction = m;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor(12);\n\t\t\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\t\t\tcolor(15);\n\t\t\t\t}\n\t\t\t} while (!i);\n\t\t\tputs(\"请修改对菜品的评价：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts_gets(p->comment, SIZE2);\n\t\t\t} while (strlen(p->comment) == 0);\n\t\t}\n\t}\n\tif (n)\n\t{\n\t\tprintf(\"\\n修改完成。\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\n//安全输入\nchar *s_gets(char *m, int n) //安全输入字符\n{\n\tchar *p;\n\tchar *find;\n\tp = fgets(m, n, stdin);\n\tif (p)\n\t{\n\t\tfind = strchr(m, '\\n'); //查找换行符\n\t\tif (find)\t\t\t\t//如果地址不是NULL\n\t\t\t*find = '\\0';\t\t//在此处放一个空字符\n\t\telse\n\t\t\twhile (getchar() != '\\n')\n\t\t\t\tcontinue;\n\t}\n\treturn p;\n}\nint get_int() //安全输入int型\n{\n\tint n;\n\tchar ch;\n\twhile (scanf(\"%d%*c\", &n) != 1)\n\t{\n\t\twhile ((ch = getchar()) != '\\n')\n\t\t\tputchar(ch);\n\t\tcolor(4);\n\t\tprintf(\" 不是一个正整数！\\n请您重新输入：\\n\");\n\t\tcolor(15);\n\t}\n\treturn n;\n}\nfloat get_float() //安全输入float型\n{\n\tfloat n = 1;\n\tchar ch;\n\tdo\n\t{\n\t\tif (n <= 0)\n\t\t{ //用户输入不是正数输出提示\n\t\t\tcolor(12);\n\t\t\tputs(\"请重新输入一个正数！\");\n\t\t\tcolor(15);\n\t\t}\n\t\twhile (scanf(\"%f%*c\", &n) != 1)\n\t\t{\n\t\t\twhile ((ch = getchar()) != '\\n')\n\t\t\t\tputchar(ch);\n\t\t\tcolor(12);\n\t\t\tprintf(\" 不是一个正数！\\n请您重新输入：\\n\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (n <= 0);\n\treturn n;\n}\n//链表的输出和操作\nvoid inquire_all(List *list) //输出链表全部节点\n{\n\tNode *p;\n\tint n = 1;\n\tsystem(\"cls\");\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tprintf(\"\\n第%d道菜:\", n);\n\t\toutput(p);\n\t\tn++;\n\t}\n\tcolor(11);\n\tprintf(\"\\n所有菜品查询完毕\\n\");\n\tsystem(\"pause\");\n}\nvoid inquire_one(List *list) //输出指定菜名\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->name)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_restaurant(List *list) //输出指定饭店所有菜品\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_price(List *list) //输出一定价格以下的菜品(这功能。。贫穷)\n{\n\tint n = 0;\n\tfloat money, k = 1;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入封顶价格：\");\n\tmoney = get_float();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->price <= money) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_fraction(List *list) //输出一定评分以上的菜品\n{\n\tint n = 0;\n\tint score;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入最低评分：\");\n\tscore = get_int();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->fraction >= score) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid average_percentage(List *list) //查询某饭店或食堂的平均价格和评分\n{\n\tint n = 0;\n\tfloat sum1 = 0, sum2 = 0, b[5] = {0};\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要查的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\tsum1 += p->price;\t //累加价格\n\t\t\tsum2 += p->fraction; //累加评分\n\t\t\tif (p->price <= 5)\n\t\t\t{\n\t\t\t\tb[0]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (p->price <= 10)\n\t\t\t\t{\n\t\t\t\t\tb[1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p->price <= 15)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[2]++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p->price < 20)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[3]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[4]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++; //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tif (n)\n\t{\n\t\tprintf(\"该饭店/食堂的一共有%d道菜\\n平均价格是：%.2f\\t平均评分是：%.2f\\n\", n, sum1 / n, sum2 / n);\n\t\tprintf(\"其中：\\n0~5元占:%.1f%%\\n5~10元占:%.1f%%\\n10~15元占:%.1f%%\\n\", b[0] / n * 100, b[1] / n * 100, b[2] / n * 100);\n\t\tprintf(\"15~20元占:%.1f%%\\n20元以上占:%.1f%%\\n\\n\", b[3] / n * 100, b[4] / n * 100);\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"无该饭店或食堂！\\n\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid output(Node *p) //方便输出\n{\n\tprintf(\"\\n|菜名:%s\\n\", p->name);\n\tprintf(\"|所属:%s\\n\", p->restaurant);\n\tprintf(\"|价格:%.2f\\n\", p->price);\n\tprintf(\"|评分:%d\\n\", p->fraction);\n\tprintf(\"|评价:%s\\n\", p->comment);\n}\nvoid random_menu(List *list) //随机输出一道菜\n{\n\tsystem(\"cls\");\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tList *q = list;\n\tNode *p = list->head;\n\tint n = random_number(q), i = 1; //将随机出来的数赋予n，并初始i等于第一道菜，判断数字是否相等，即可找到那个随机出来的菜\n\twhile (p != NULL)\n\t{\n\n\t\tif (i == n) //借助随机数来随机输出菜\n\t\t{\n\t\t\toutput(p);\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tp = p->next;\n\t}\n}\nvoid empty(List *list) //清空链表\n{\n\tNode *p, *q;\n\tint n;\n\tsystem(\"cls\");\n\tcolor(12);\n\tprintf(\"此操作将清空所有数据！\\n输入 1 继续，输入 0 取消：\\n\");\n\tdo\n\t{\n\t\tn = get_int();\n\t} while (!(n == 0 || n == 1));\n\tif (n == 1)\n\t{\n\t\tfor (p = list->head; p; p = q) //遍历链表\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t}\n\t\tlist->head = NULL;\n\t\tprintf(\"清除完成！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n}\n//文件操作\nvoid save(List *list) //保存\n{\n\tif (list->head == NULL)\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！保存为空！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tNode *p = list->head;\n\tFILE *fp = fopen(\"Menu.txt\", \"w\");\n\tif (fp)\n\t{\n\t\twhile (p)\n\t\t{\n\t\t\tfprintf(fp, \"\\n%s %s %0.2f %d %s\", p->name, p->restaurant, p->price, p->fraction, p->comment);\n\t\t\tp = p->next;\n\t\t}\n\t\tfclose(fp);\n\t\tcolor(11);\n\t\tprintf(\"\\n保存成功\\n\");\n\t\tsystem(\"pause\");\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"保存失败，请自查或联系作者\");\n\t}\n}\nvoid read_txt(List *list) //读取文件_初始链表\n{\n\tint i = 1;\n\tNode *last;\n\tNode *p1;\n\tint a = 1;\n\tchar f[5];\n\tFILE *fp = fopen(\"Menu.txt\", \"r\");\n\tfgets(f, 10, fp); //读取第一行，并进入下一行，防止bug\n\twhile (!feof(fp)) //当读取到文件结束符跳出循环结束读取\n\t{\n\t\tlast = list->head;\n\t\tp1 = (Node *)malloc(sizeof(Node));\n\t\tp1->next = NULL;\n\t\tfscanf(fp, \"%s%s%f%d%s\", p1->name, p1->restaurant, &p1->price, &p1->fraction, p1->comment);\n\t\tif (last)\n\t\t{\n\t\t\twhile (last->next)\n\t\t\t{\n\t\t\t\tlast = last->next;\n\t\t\t}\n\t\t\tlast->next = p1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlist->head = p1;\n\t\t}\n\t}\n\tfclose(fp);\n}\n//单链表的冒泡排序，这指来指去，作者一口气写完到断气的，不想加注释了，应该会有更好的算法，咕咕咕，以后优化\nvoid sort_ascending(List *list) //菜品按价格从低到高排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price > list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_descending(List *list) //菜品按价格从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price < list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_score(List *list) //菜品按评分从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->fraction < list_swap.pc->fraction)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nint calculate(List *list) //计算出单链表的节点个数\n{\n\tint n = 0;\n\tNode *p = list->head;\n\twhile (p->next != NULL)\n\t{\n\t\tn++;\n\t\tp = p->next;\n\t}\n\treturn n + 1;\n}\nvoid swap1(List *list, List *list_swap) //单链表冒泡排序的算法块1\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pb->next = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\telse\n\t{\n\t\tlist->head = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\tlist_swap->pb = list_swap->pc;\n\tlist_swap->pc = list_swap->pa->next;\n}\nvoid swap2(List *list, List *list_swap) //单链表冒泡排序的算法块2\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list_swap->pb->next;\n\t}\n\telse\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list->head;\n\t}\n}\n//其他\nint random_number(List *list) //随机生成不大于节点数的整数\n{\n\tint n = 0, m = 0, sum = 1, i = 0;\n\tList *q = list;\n\tsrand((unsigned)time(NULL) * 12);\n\tm = calculate(q);\n\ti = m;\n\twhile (m > 0)\n\t{\n\t\tsum = sum * 10;\n\t\tm = m / 10;\n\t}\n\twhile (1)\n\t{\n\t\tn = rand() % sum;\n\t\tif (n <= i && n > 0)\n\t\t{\n\t\t\ti = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid color(int a) //控制台文本颜色\n{\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), a); //更改控制台文字颜色\n}\n\n```\n***\n\n# 部分功能截图\n**主菜单**\n<div><img src=https://cdn.chuckle.top/images/6-1.webp width=\"50%\" height=\"50%\"></div>\n\n**查找功能**\n<div><img src=https://cdn.chuckle.top/images/6-2.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-5.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-6.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-7.webp width=\"50%\" height=\"50%\"></div>\n\n**排序**\n<div><img src=https://cdn.chuckle.top/images/6-3.webp width=\"50%\" height=\"50%\"></div>\n\n**修改功能**\n<div><img src=https://cdn.chuckle.top/images/6-4.webp width=\"45%\" height=\"45%\"></div>\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["项目"]},{"title":"C语言学习笔记","url":"/article/13675369.html","content":"\n# 整数运算\n两个整数运算结果也只能是整数  \na+=5等价于a=a+5  \na*=b+5等价于a=a*(b+5)  \na++等a+=1等a=a+1  \na++是a加1以前的值，++a是a加1后的值  \n运算符优先级：算数>关系>赋值，判断是否相等的优先级比大于小于低\n***\n# 所表达的数的范围\nchar< short<int< float<double\n***\n# sizeof()\nsizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数  \nsizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的\n***\n# unsigned\nunsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)  \nunsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位\n***\n# 整数的输入输出\n只有两种形式:int或 long long  \n%d: int  \n%u: unsigned  \n%ld: longlong  \n%lu: unsigned long long\n***\n# 选搔整数类型\n为什么整数要有那么多种?为了准确表达内存,做底层程序的需要  \n没有特殊需要,就选int  \n现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢  \n现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)\n***\nunsigned与否只是输出的不同,内部计算是一样的  \nprintf输出inf表示超过范围的浮点数:±∞  \nprint输出nan表示不存在的浮点数  \n带小数点的字面量是 double而非 float  \nfloat需要用或F后綴来表明身份  \n1.234f\n***\n判断两个浮点数是否相等可能失败  \nfabs(fl-2)< le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等\n***\n# 选浮点类型\n如果没有特殊需要,只使用 double  \n现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢\n***\n# 自动类型转换\n当运算符的两边出现不一致的类型时,会自动转换成較大的类型  \n大的意思是能表达的数的范围更大  \nchar——> short——>int——>long——>long long  \nint——> float——> double  \n对于 printf,任何小于int的类型会被转换成int，float会被转换成 double  \n但是scanf不会,要输入short,需要%hd\n***\n# 强制类型转换\n要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值  \n比如：  \n(int)10.2  \n(short)32  \n注意这时候的安全性,小的变量不总能表达大的量  \n(short)32768  \n只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变  \n强制类型转换的优先级高于四则运算\n***\n# 逻辑运算符优先级:\n!>&&>||\n***\n# 短路\n逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算  \na==6&&b==1  \na==6&&b+=1  \n对于&&,左边是 false时就不做右边了  \n对于‖,左边是true时就不做右边了  \n***\n# tip1\n不要把赋值,包括复合赋值组合进表达式!  \n一个代码内有重复相似段是程序质量不良的表现  \n函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值\n***\n# 数组的大小\nsizeof给出整个数组所占据的内容的大小,单位是字节  \nsizeof(a)/sizeof(a[0])  \nsizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数  \n这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗\n***\n# 数组的操作\n遍历数组：通常都是使用for循环,让循环变量i从0到<数组的长度,这样循环体内最大的正好是数组最大的有效下标  \n数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!  \n数组作为函数参数时,往往必再用另一个参数来传入数组的大小\n# 作为参数的指针\nvoid f(int * p)  \n在被调用的时候得到了某个变量的地址  \nint i=O; f(&i)  \n在函数里面可以通过这个指针访问外面的这个  \n函数参数表中的数组实际上是指针  \nsizeof(a)==sizeof(int *)  \n但是可以用数组的运算符进行运算\n***\n# 指针是const\n表示一旦得到了某个变量的地址,不能再指向其他变量  \nint *const q=&i;//q是 const  \n*q=26;//OK  \nq++; //ERROR\n***\n# 所指是 const\n表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)  \nconst int *p=&i  \n*p= 26; //ERROR!  \ni=26;//OK  \nP=&i;//OK\n***\n# const\nlnt i  \nconst int* p1 =&i  \nint const* p2=&i  \nint *const p3=&i  \n判断哪个被const了的标志是const在*的前面还是后面  \n*const p指针不许动  \nconst *p指针不许动变量\n***\n## 转换\n总是可以把一个非 const的值转換成 const的  \nvoid f(const int* x)  \nint a =15:  \nf(&a);//ok  \nconst int b = a  \nf(&b);//ok  \nb =a+1: // Error  \n当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改\n***\n## const数组\nconst int a[]={1,2,3,4,5,6};  \n数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值\n***\n## 保护数组值\n因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值  \n为了保护数组不被函数破坏,可以设置参数为 const  \nint sum(const int a[], int length);\n***\n# 指针\nint *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元  \nint *p=a[];  \n*p -->a[0]  \n*(p+1)-->a[1]  \n*(p++)可以遍历数组\n***\n给一个指针加|表示要让指针指向下一个变量  \nint a[l0]  \nint *p= a  \n*(p+1)-->a[1]  \n如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义  \n*(p+n)<-->a[n]  \n*p*q两个指针相减p-q，等于q加多少个单元等于p\n***\n*p++  \n取出p所指的那个数据来,完事之后顺便把移到下一个位置去  \n*的优先级然高,但是没有++高  \n常用于数组类的连续空间操作  \n在某些CPU上,这可以直接被翻译成一条汇编指令\n\n指针乘除无意义\n***\n## 指针遍历数组方法 \n```\n*p a[10]\np=a\nfor(i=0;i<sizeof(a)/sizeof(a[0]); i++ ){\nprintf(\"%d\\n\", acri[i]);\n}  \na[9]=-1//在数组末尾放入一个特殊的东西\nwhile(*p!=-1){\nprintf(\"%d\\n\",*p++);\n}\n```\n***\n## 指针比較\n<,<=,==,>,>=,!=都可以对指针做  \n比较它们在内存中的地址  \n数组中的单元的地址肯定是线性从小到大递增的\n***\n## 0地址\n当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址  \n所以你的指针不应该具有0值  \n\n因此可以用0地址来表示特殊的事情:  \n1返回的指针是无效的  \n2指针没有被真正初始化(先初始化为0)  \n\nNULL（必须是大写）是一个预定定义的符号,表示0地址  \n有的编译器不愿意你用0来表示0地址\n***\n## 指针的类型\n无论指向什么类型,所有的指针的大小都是一样的,因为都是地址  \n但是指向不同类型的指针是不能直接互相赋值的  \n这是为了避免用错指针\n## 指针的类型转换\nvoid*表示不知道指向什么东西的指针  \n计算时与char*相同(但不相通)\n\n指针也可以转换类型  \nint*p =&i  \nvoid*p<-->(void *)p  \n这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量  \n我不再当你是int,我认为你就是个void!\n***\n## 用指针来做什么\n需要传入較大的数据时用作参数  \n传入数组后对数组做操作  \n函数返回不止一个结果是  \n需要用函数来修改不止一个变量  \n动态申请的内存\n***\n# 内存操作\n## malloc(跟系统要一块内存)\n```\n#include <stdlib. h>\nvoid*malloc(size_t size)\n//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型\n(int *)malloc(n*sizeof(int))\n```\n如果申请失敗则返回0,或者叫做NULL\n***\n## free()\n把申请得来的空间还给“系统”  \n申请过的空间,最终都应该要还  \n只能还申请来的空间的首地址\n## free常见问题\n申请了没free—>长时间运行内存逐漸下降  \n新手:忘了  \n老手:找不到合的free的时机  \nfree过了再free  \n地址变过了,直接去free\n***\n# 字符串\nchar a[]={'h','a','l','l','o','!'}//字符数组  \nchar a[]={'h','a','l','l','o','!','\\0'}//字符串\n***\n以0(整数0)结尾的一串字符  \n0或'\\0'是一样的,但是和0不同  \n0标志字符串的结束,但它不是字符串的一部分  \n计算字符串长度的时候不包含这个0  \n字符串以数组的形式存在,以数组或指针的形式访问  \n更多的是以指针的形式  \nstring.h里有很多处理字符串的函数\n***\n```\nchar*str=\"Hello\"\nchar word[]=\"Hello\"\nchar linel[10]=\"Hello\"\n```\n***\n## 字符串常量\nChar* s=\"Hello, world\"  \n●s是一个指针,初始化为指向一个字符串常量 \n●由于这个常量所在的地方,所以实际上s是 const  \nchar*s,但是由于历史的原因,编译器接受不带const的写法  \n●但是试图对s所指的字符串做写入会导致严重的后果\n***\nchar S[]=\"Hello, world\"//这个字符串就在我这里  \nChar* s=\"Hello, world\"//指向某个地方的字符串  \n数组:这个字符串在这里(作为本地变量,空间自动被回收)  \n指针:这个字符串不知道在哪里(处理参数,动态分配空间)  \n如果要构造一个字符串一>数组  \n如果要处理一个字符串一>指针\n***\n## 字符串输入输出\n```\nchar string[8];\nscanf(\"%s\", string);\nprintf(\"%s\", string);\n//scanf读入一个単词(到空格、tab或回车为止)\n//scanf是不安全的,因为不知道要该入的内容的长度\nscanf(\"%7s\", string)\n//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小\n```\n***\n## 空字符串\n```\nchar buffer[100]=\"\";\n//这是一个空的字符串, buffer[O]==\"\\0\";\nchar buffer[]=\"\";\n//这个数组的长度只有1\n```\n***\n## 复制一个字符串\n```\nchar*dst=(char*)malloc(strlen(src)+1)\nstrcpy(dst, src)\n```\n***\n# 枚挙\n枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明  \nenum枚挙类型名字{名字0,……,名字n};  \n\n枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：  \nenum colors {red, yellow, green};  \n就创建了三个常量,red的值是0, yellow是1,而 green是2。  \n当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。\n>声明枚挙量的时候可以指定值\n>enum COLOR {RED=1, YELLOW, GREEN =5};\n\n***\n\n# 结构\n## 声明结构的形式\n```\nstruct point{\nint X;\nInt y;\n};\nstruct point p1, p2\n//pl和p2都是 point里面有x和y的值\n\nstruct {\nInt x;\nint y;\n}pl, p2;\n//pl和p2都是一种无名结构,里面有x和y\n\nstruct point {\nInt x;\nint y;\n}pl, p2;\n//pI和p2都是point, 里面有x和y的值t\n```\n>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用  \n>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了\n\n***\n## 结构指针\n和数组不同,结构变量的名字并不是结构变量的地址,必须使用&运算符\n```\nstruct date*pdate= &today;\n```\n***\n## 结构作为函数参数\n```\nint numberofdays(struct date d)\n```\n整个结构可以作为参数的值传入函数  \n这时候是在函数内新建一个结构变量,并复制调用者的结构的值  \n也可以返回一个结构  \n这与数组完全不同\n***\n## 指向结构的指针\n```\nstruct date {\nint month;\nint day;\nint yeari;\n}myday;\nstruct date *p =&myday;\n(*p).month 12;\np->zmonth 12;\n//用->表示指针所指的结构变量中的成员\n```\n***\n# 全局变量初始化\n没有做初始化的全局变量会得到0值  \n指针会得到NULL值  \n只能用编译时刻已知的值来初始化全局变量  \n它们的初始化发生在main函数之前  \n全局变量不应该和另一个全局变量有联系  \n同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量\n***\n# 静态本地变量（全局生存期，本地作用域）\n在本地变量定义时加上 static修饰符就成为静态本地变量  \n当函数离开的时候,静态本地变量会銖存在并保持其值  \n静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值  \n静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域  \n静态本地变量具有全局的生存期,函数内的局部作用域  \nstatic在这里的意思是局部作用域(本地可访问)\n>不要使用全局变量来在函数间传递参数和结果  \n>尽量避免使用全局变量  \n>丰田汽车的案子  \n>使用全局变量和静态本地变量的函数是线程不安全的  \n\n***\n# 返回指针的函数\n返回本地变量的地址是危险的  \n返回全局变量或静态本地变量的地址是安全的  \n返回在函数内 malloc的内存是安全的,但是容易造成问题  \n最好的做法是返回传入的指针\n***\n# 编译预处理指令\n#开头的是编译预处理指令  \n它们不是C语言的成分,但是C语言程序离不开它们\n***\n## #define(纯文本替换)\n#define用来定义一个宏  \n#define<名字><值>  \n注意没有结尾的分号,因为不是C的语句  \n名字必颁是一个单词,值可以是各种东西  \n在C语言的编译器开始编译之前,编译预处理程序  \n(cpp)会把程序中的名字换成值  \n完全的文本替换  \nacc-save-temps\n***\n## 宏\n如果一个宏的值中有其他的宏的名字,也是会被替换的  \n如果一个宏的值超过一行,最后一行之前的行末需要加  \\   \n宏的值后面出现的注释不会被当作宏的值的一部分\n***\n### 预定义的宏\n```\n_LINE_\n_FILE_\n_DATE_\n_TIME_\n_STDC_\n```\n### 带参数的宏\n```\n#define cube(x) ((x)*(x)*(x))\n```\n在大型程序的代吗中使用非常普遍  \n可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下  \n存在中西方文化差异  \n部分宏会被inline函数替代\n***\n# 变量的声明\nint i;是变量的定义  \nextern int i;是变量的声明\n***\n# 声明和定义\n声明是不产生代码的东西  \n函数原型  \n变量声明  \n结构声明  \n宏声明  \n枚挙声明  \n类型声明  \ninline函数  \n定义是产生代码的东西  \n头文件放声明是规则\n***\n# 重复声明\n同一个编译单元里,同名的结构不能被重复声明  \n如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要\"标准头文件结构\"\n***\n# 标准头文件结构(宏的if)\n```\n#ifndef _LIST_HEAD_\n#define _LIST_HEAD_\n#include \"node.h\"\ntypedef struct _list{\n    Node* head\n    Node* tail\n}List\n#endif\n//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次\n#pragma once//也能起到相同的作用,但是不是所有的编译器都支持\n```\n\n# 链表\n>0建一个node结构  \n>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）  \n>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点  \n>3要有一个node结构last，每次要让last从head开始，直到last->next是空的，然后让next等于新的p结构（这样就链起来了）  \n>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last->next是空的，然后然后让next等于新的p结构  \n\n**要在函数内改变指针的指向，就要传指针的指针进去**\n***\n## 遍历链表\n```\nfor(p=list.head; p; p=p->next){}\n//单用一个指针p可以遍历链表\n```\n\n但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点  \n当p找到了要删除的节点，就让q->next等于p->next，然后free(p)  \nfor(q=null，p=list.head; p; q=p，p=p->next){}  \n当然还要判断链表的第一个元素是不是我们要删除的  \n如果是，就不能让q->next等于p->next，因为q一开始是NULL  \n我们应该让head->next等于p->next，然后free(p)  \n>\".\"一般情况下读作\"的”。  \n>\"->\"一般读作\"指向的结构体的\"。  \n\n***\n## 清除整个链表\n```\nfor(p=head;p;p=q){\n     q=p->next;\n     free(p)\n}\n//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点\n```\n\n***\n# main()\nmain(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)  \n操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数  \n在不同操作系统，入口函数可能不是main()\n***","tags":["C语言"],"categories":["学习笔记"]},{"title":"博客搜索挂了解决方法","url":"/article/f8c79a1b.html","content":">省流助手：删除所有local-search.js中下面这行代码\n>window.pjax && window.pjax.refresh($resultContent)\n\n# 遇到的问题\n我使用的是本地搜索，local-search，装好后一直正常使用，也没去动过配置\n前天捣鼓着博客，突然发现博客部署到github上后搜索挂了\n<img src=https://cdn.chuckle.top/images/4-2.webp width=\"60%\" height=\"60%\">\n一直卡在数据库加载中\n\n但是，部署在本地，搜索却一切正常\n<img src=https://cdn.chuckle.top/images/4-3.webp width=\"60%\" height=\"60%\">\n尝试过重装插件，清除浏览器缓存，search.xml改为json，但过一会又挂了\n\n看网上也有不少人遇到这种问题，却找不到解决办法\n\n***\n\n# 解决过程\nlocal-search会请求生成在本地的search.xml，也就是数据库加载中里的“数据库”\n\n部署在本地时正常请求\n<img src=https://cdn.chuckle.top/images/4-8.webp width=\"80%\" height=\"80%\">\n而部署在github时没有请求\n<img src=https://cdn.chuckle.top/images/4-9.webp width=\"65%\" height=\"65%\">\n直接访问search.xml正常，不是search.xml的问题\n<img src=https://cdn.chuckle.top/images/4-5.webp width=\"60%\" height=\"60%\">\n查看报错，看起来是这个js的问题\n<img src=https://cdn.chuckle.top/images/4-6.webp width=\"60%\" height=\"60%\">\n本地找到local-search.js，这三个代码都一样\n<img src=https://cdn.chuckle.top/images/4-7.webp width=\"60%\" height=\"60%\">\njs中只有一处pjax报错\n<img src=https://cdn.chuckle.top/images/4-10.webp width=\"60%\" height=\"60%\">\n类型“Window & typeof globalThis”上不存在属性“pjax”。ts(2339)  \n\n\n看不懂这种报错，但问题多半就是这行代码导致的，查看整个js后，尝试删除此行\n```\nwindow.pjax && window.pjax.refresh($resultContent)\n```\n删除后，搜索挂了的问题解决，博客正常请求search.xml\n<img src=https://cdn.chuckle.top/images/4-8.webp width=\"70%\" height=\"70%\">\n\n但点击搜索结果后pjax失效，具体表现是aplayer停止播放音乐\n\n看来是pjax的bug，不过感知不强，其余地方的pjax仍然生效\n\n暂时先这样，以后找到更好的解决办法再更新\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Hexo博客的基本操作","url":"/article/aa2a7b7e.html","content":"\n> **Hexo官方文档:**[Hexo](https://hexo.io/zh-cn/docs)\n\n# Hexo操作\n\n## 指令\n\n```js 新建文章，在blog\\source\\_posts\nhexo new post (文章名称)\n```\n```js 新建页面，在blog\\source\nhexo new page (页面名称)\n```\n```js 清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo clean\n```\n```js 生成静态文件\nhexo g\n```\n```js 启动服务器，访问网址:http://localhost:4000\nhexo s\n```\n```js 部署网站\nhexo d\n```\n```js hexo三连,四连\nhexo cl && hexo g && hexo s\nhexo cl && hexo g && gulp && hexo d\n```\n```js push三连\ngit add .\ngit commit -m \"github action update\"\ngit push origin master\n```\n<br>\n\n## 文章操作\n\n>**Markdown 教程**\n>[菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n>[官网--Markdown基本语法](http://markdown.p2hp.com/basic-syntax/)\n\n\n> **blog\\scaffolds中修改三种文章模板**\n\n>*斜体文本* &emsp;\\*斜体文本\\* \n>**粗体文本** &emsp;\\*\\*粗体文本\\*\\*\n>***粗斜体文本*** &emsp;\\*\\*\\*粗斜体文本\\*\\*\\* \n>~~横线删除~~ &emsp;\\~\\~横线删除\\~\\~ \n\n>***水平分割线\n\n```html 文字蓝链 \n文字内容[tittle](https://*******)\n```\n```html 文章中自定义文本，size文字大小，face字体，color颜色，&emsp空格\n<font size=\"2\" face=\"verdana\" color=\"blue\" >&emsp;这是一个文本</font>\n\n```\n```html 插入自定义图片,\n\n<div align=left><img src=1.png width=\"25%\" height=\"25%\"></div>\n\n<div align=left><img src=1.png><img src=2.png></div>\n\n![文本](图片地址 \"鼠标悬停弹出文本提示\")\n```\n***\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"测试用文章","url":"/article/d87f7e0c.html","content":"\n米歇潘在不经意间这样说过，生命是一条艰险的峡谷，只有勇敢的人才能通过。这句话语虽然很短，但令我浮想联翩。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 就我个人来说，空对我的意义，不能不说非常重大。 我们不得不面对一个非常尴尬的事实，那就是， 现在，解决空的问题，是非常非常重要的。 所以， 空的发生，到底需要如何做到，不空的发生，又会如何产生。 带着这些问题，我们来审视一下空。 空，发生了会如何，不发生又会如何。 既然如何， 而这些并不是完全重要，更加重要的问题是， 罗曼·罗兰在不经意间这样说过，只有把抱怨环境的心情，化为上进的力量，才是成功的保证。这句话语虽然很短，但令我浮想联翩。 在这种困难的抉择下，本人思来想去，寝食难安。 在这种困难的抉择下，本人思来想去，寝食难安。 笛卡儿曾经说过，阅读一切好书如同和过去最杰出的人谈话。这不禁令我深思。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， 生活中，若空出现了，我们就不得不考虑它出现了的事实。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。我希望诸位也能好好地体会这句话。 空，到底应该如何实现。 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 空，到底应该如何实现。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 带着这些问题，我们来审视一下空。 我们不得不面对一个非常尴尬的事实，那就是， 史美尔斯曾经说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。这句话语虽然很短，但令我浮想联翩。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 查尔斯·史考伯曾经说过，一个人几乎可以在任何他怀有无限热忱的事情上成功。 这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 带着这些问题，我们来审视一下空。 我认为， 总结的来说， 就我个人来说，空对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们都知道，只要有意义，那么就必须慎重考虑。 我们都知道，只要有意义，那么就必须慎重考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 问题的关键究竟为何? 那么， 而这些并不是完全重要，更加重要的问题是， 一般来讲，我们都必须务必慎重的考虑考虑。 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这句话语虽然很短，但令我浮想联翩。 既然如何， 空因何而发生?生活中，若空出现了，我们就不得不考虑它出现了的事实。 我认为， 总结的来说， 空因何而发生?在这种困难的抉择下，本人思来想去，寝食难安。 经过上述讨论带着这些问题，我们来审视一下空。 一般来讲，我们都必须务必慎重的考虑考虑。 亚伯拉罕·林肯曾经说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。 就我个人来说，空对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 空的发生，到底需要如何做到，不空的发生，又会如何产生。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 空，到底应该如何实现。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 我们不得不面对一个非常尴尬的事实，那就是， 既然如此， 空因何而发生?那么， 每个人都不得不面对这些问题。 在面对这种问题时， 卢梭曾经说过，浪费时间是一桩大罪过。带着这句话，我们还要更加慎重的审视这个问题： 了解清楚空到底是一种怎么样的存在，是解决一切问题的关键。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 一般来说， 空，到底应该如何实现。 所谓空，关键是空需要如何写。 既然如何， 生活中，若空出现了，我们就不得不考虑它出现了的事实。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 一般来讲，我们都必须务必慎重的考虑考虑。 空，发生了会如何，不发生又会如何。 要想清楚，空，到底是一种怎么样的存在。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 空，发生了会如何，不发生又会如何。 爱迪生在不经意间这样说过，失败也是我需要的，它和成功对我一样有价值。这启发了我， 问题的关键究竟为何? 德国曾经说过，只有在人群中间，才能认识自己。这启发了我， 而这些并不是完全重要，更加重要的问题是， 米歇潘在不经意间这样说过，生命是一条艰险的峡谷，只有勇敢的人才能通过。带着这句话，我们还要更加慎重的审视这个问题： 空的发生，到底需要如何做到，不空的发生，又会如何产生。 要想清楚，空，到底是一种怎么样的存在。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 既然如何， 孔子在不经意间这样说过，知之者不如好之者，好之者不如乐之者。这句话语虽然很短，但令我浮想联翩。 而这些并不是完全重要，更加重要的问题是， 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 叔本华曾经说过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。这启发了我。"}]