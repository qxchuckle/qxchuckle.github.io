[{"title":"React-记-1","url":"/article/cb488cbf.html","content":"\n# 前言\n[React](https://react.dev/)、[zh-hans](https://zh-hans.react.dev/)\n\n# 开始\n\n```shell\npnpm create vite@latest\n# npm init vite@latest\n```\n\n**项目结构：**\n\n```shell\n├───📁 public/ # 静态资源目录，直接复制到最终的构建输出目录\n├───📁 src/\n│   ├───📁 assets/ # 存放项目中需要构建、打包的资源文件\n│   ├───📄 App.css\n│   ├───📄 App.tsx # App 组件，通常作为根组件\n│   ├───📄 index.css\n│   ├───📄 main.tsx # 入口 tsx 文件，类似 Vue 的 main.js\n│   └───📄 vite-env.d.ts # 类型声明文件，三斜线引入了 vite/client 声明，做了各种文件后缀的类型声明。\n├───📄 .gitignore\n├───📄 eslint.config.js\n├───📄 index.html # vite 入口文件 index.html，拦截 /src/main.tsx 的引入\n├───📄 package.json\n├───📄 pnpm-lock.yaml\n├───📄 README.md\n├───📄 tsconfig.app.json # 源码 tsconfig\n├───📄 tsconfig.json\n├───📄 tsconfig.node.json # node 环境 tsconfig\n└───📄 vite.config.ts\n```\n\n# JSX & TSX 简介\n就像 Vue 有 `.vue` 文件，React 也创造了一种新的文件类型 `.jsx`([JavaScript XML](https://zh-hans.react.dev/learn/writing-markup-with-jsx))。\n\n> JSX 并不仅为 React 服务，其语法没有定义运行时语义，使得它**能被编译成各种不同的输出形式**。Vue 也能使用 JSX([文档](https://cn.vuejs.org/guide/extras/render-function#jsx-tsx))，但语法和 React 略有不同，编译也需要独特的插件 [@vue/babel-plugin-jsx](https://github.com/vuejs/babel-plugin-jsx)。相关文章：[What’s a JSX Transform?](https://zh-hans.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)。后文仅聊 JSX in React。\n\nJSX 被设计为 JS 的**语法扩展**，可以在 JS 中直接写 XML(HTML) 标签，和大多数类 JS 模板文件一样，这是为了将**渲染逻辑**和**标签(视图)**存于同一个地方，独立成为**组件**，承载了 HTML 构建页面的职责。\n\n此外，IDE 对 JSX 支持较好，VSCode 开箱即用地支持 React([文档](https://code.visualstudio.com/docs/nodejs/reactjs-tutorial))，而无需额外安装语言支持插件，~~Vue+TS+Volar，开发性能，emmm，有点吃力~~。\n\n## JSX 与 React\n**vite插件：**\n[@vitejs/plugin-react](https://www.npmjs.com/package/@vitejs/plugin-react) 默认使用 babel 平台转换编译 JSX 文件。\n也可以使用 [@vitejs/plugin-react-swc](https://www.npmjs.com/package/@vitejs/plugin-react-swc) 通过 swc 平台编译。\n\n> [babel](https://www.babeljs.cn/) 是一个 JavaScript 编译器，它将 JS 代码转为 AST 抽象语法树，并根据配置规则转换、生成目标 JS 代码，例如将 ES6 转为 ES5 语法，通过 Polyfill 垫片方式支持新特性，将 JSX 转为 React.createElement 等函数调用。\n> [swc](https://swc.rs/) 是基于 Rust 的 web 可扩展平台，既有 babel 的编译转换功能，也可用于打包（建设中），原生支持 TS，速度比 babel 快很多，配置也更加简单。\n> 这两个东西以后再开个文章学学。\n\n**babel 插件：**\nJSX 的语法实现依赖两个 babel 插件：\n[@babel/plugin-syntax-jsx](https://babeljs.io/docs/babel-plugin-syntax-jsx) 使 babel 能够解析 JSX 语法。\n[@babel/plugin-transform-react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx) 转换 JSX 语法，内部已经调用了 plugin-syntax-jsx。允许自定义配置将 JSX 编译为哪个函数调用，默认为 `React.createElement` 或 `_jsx`（17之后）。\n\n**转换变化：**\n在 React 17 之前，JSX 中的元素节点会被编译成 `React.createElement` 函数调用，所以即使没有使用到 React，也需要在源码中引入它。\n而在 React 17 之后，[介绍全新的 JSX 转换](https://zh-hans.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)，将转换为 `_jsx` 函数调用，并在编译时自动引入 **_jsxRuntime api**。\n\n> 本质上 JSX 只是 React 函数的语法糖，React 本身并不依赖 JSX，仍然可以使用 `React.createElement` 函数手动创建 React 元素节点。\n\n\n\n\n## 初识 React 组件\nReact 应用通过**组件**的嵌套、组合构建而成。\n每个组件都是一个独立的 UI 单元，可以包含**状态**、**生命周期**、**事件处理**等逻辑，也可以接受**属性**、**子组件**等参数。\n但要注意，函数组件本身是纯粹的，只负责与**渲染**相关的逻辑，不应直接产生副作用，其它 React 特性应该通过 Hook 实现。\n\n> 在React中，副作用指的是那些会影响组件外部状态或产生其他不可预期结果的操作，比如数据获取、DOM操作、订阅等。副作用通常通过useEffect钩子处理，以确保在组件生命周期的特定时刻执行这些操作。\n\n组件的本质是一个**函数**（函数组件），或者是继承自 `React.Component` ，至少具有 `render` 方法的**类**（类组件），都需要返回一个 React 元素节点（或者 null），也就是按 JSX 语法编写的标签。\n\n```tsx\n// 函数组件\nfunction App() {\n  return <div>Hello, World!</div>;\n}\n// 类组件\nclass App extends React.Component {\n  render() {\n    return <div>Hello, World!</div>;\n  }\n}\n```\n\n**组件名**(函数 or 类名)，**必须以大写字母开头**，以便 React 能够区分组件和 HTML 标签。\n\n避免嵌套组件定义，这是性能低下且易出 BUG 的。详见：[嵌套和组织组件](https://zh-hans.react.dev/learn/your-first-component#nesting-and-organizing-components)\n\n当子组件需要使用父组件的数据时，需要通过 **props** 进行传递，而不是嵌套定义。\n\n```js\nexport default function Gallery() {\n  // 🔴 永远不要在组件中定义组件\n  function Profile() {}\n}\n```\n\n\n\n# JSX 语法\n\n> 写 JSX 总是离不开原生 JS 的思想，它尽可能避免了传统模板语言的复杂性，具有少量的语法扩展与抽象。\n> HTML 转 JSX 工具：[html-to-jsx](https://transform.tools/html-to-jsx)。\n\n## 标签规则\nJSX 语法中，标签的写法与 HTML 类似，但必须使用**闭合标签**。\n\n**1、部分属性别名：**\nclass 属性需要写成 `className`，for 属性写成 `htmlFor`，因为 class 和 for 是 JS 的保留字。\n\n```tsx\n// JSX\n<div className=\"container\">Hello, World!</div>\n<label htmlFor=\"name\">Name:</label>\n// HTML\n<div class=\"container\">Hello, World!</div>\n<label for=\"name\">Name:</label>\n```\n\n**2、属性驼峰命名法：**\n所有 DOM 属性和特性（包括事件处理程序）都应采用**驼峰命名法**。除了 `aria-*` 和 `data-*` 属性，它们应该保持**小写**。\n\n```tsx\n// JSX\n<input type=\"text\" onChange={handleChange} />\n// HTML\n<input type=\"text\" onchange=\"handleChange()\" />\n```\n\n**3、括号包裹标签：**\n元素节点写成一行时，可以省略外层的括号，但是**多行**时需要使用**括号包裹**。\n\n```tsx\n// JSX\nreturn (\n  <div>\n    <h1>Hello, World!</h1>\n  </div>\n);\nreturn <div><h1>Hello, World!</h1></div>;\n```\n\n**4、Fragment 组件**\nReact 要求组件只能返回**一个根元素**，但有时候我们需要返回多个元素，就需要额外添加一个父标签包裹多个元素。\nReact 16 之后，提供了**Fragment**组件 `<></>`，用于包裹多个兄弟节点，不会在 DOM 中渲染额外的节点。\n\n```tsx\nreturn (\n  <>\n    <h1>Hello, World!</h1>\n    <p>React is awesome!</p>\n  </>\n);\n```\n\n**5、泛型加逗号：**\ntsx 会将泛型写法视为 JSX 标签，加个**逗号**解决。\n\n```tsx\n// <T> -> <T,>\nconst MyComponent = <T,>(props: { value: T }) => {\n  return <div>{props.value}</div>;\n};\n```\n\n\n\n## 插值语法 {}\n`{}` 用于在 JSX 中插入 **JS 表达式**，可以是**变量**、**函数调用**、**三元运算**、**逻辑运算**等。\n\n```tsx\nconst [count, setCount] = useState(0);\nconst flag = true;\nconst jsxXml = <div>一个标签</div>;\nconst classList = [\"a\", \"b\", \"c\"];\n\nreturn (\n  <>\n    {/* 1、表达式 */}\n    <h1>{new Date().getTime()}</h1>\n    <p>{flag ? \"真\" : \"假\"}</p>\n    <p>计数: {count}</p>\n    {/* 2、绑定事件，传参需要使用高阶函数 */}\n    <button\n      onClick={(e) => {\n        setCount(count + 1);\n        console.log(e);\n      }}\n    >\n      增加\n    </button>\n    {/* 3、插入 JSX 标签 */}\n    {jsxXml}\n    {/* 4、绑定 class */}\n    <div className={classList.join(\" \")}>绑定 class</div>\n  </>\n);\n```\n\nstyle 传入**对象**动态绑定**内联样式**，css 属性同样使用**驼峰命名法**，数字类型的属性值会自动添加 px 单位。\n\n```tsx\nconst style = {\n  color: \"red\",\n  fontSize: 20,\n};\nreturn <p style={style}>内联样式</p>;\n```\n\n`dangerouslySetInnerHTML` 属性用于**插入 HTML**，需要传入一个对象，包含 `__html` 属性。和 v-html、innerHTML 类似，小心 XSS 攻击。\n\n```tsx\nconst markup = { __html:'<p>插入的 html</p>' };\nreturn <div dangerouslySetInnerHTML={markup} />;\n```\n\n## 条件与列表渲染\n配合原生 JS 实现类似 v-if 和 v-for 的条件渲染和列表渲染。\n\n```tsx\nconst isShow = true;\nconst dataList = [\n  { id: 1, name: \"张三\" },\n  { id: 2, name: \"李四\" },\n];\nreturn (\n  <>\n    {isShow && (\n      <ul>\n        {dataList.map((item) => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    )}\n  </>\n);\n```\n\n和 Vue 相同，React 也需要 **key** 属性来唯一标识列表中的元素，以便 React 能够更高效地更新 DOM。详见：[用 key 保持列表项的顺序](https://zh-hans.react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)。另外，key 属性不会被当作 props 的一部分。\n\n如果每个列表项需要渲染多个元素，可以使用完整的 **Fragment** 组件包裹，而非简写的 `<></>`。\n\n```tsx\n{dataList.map((item) => (\n  <Fragment key={item.id}>\n    <dt>{item.name}</dt>\n    <dd>{item.id}</dd>\n  </Fragment>\n))}\n```\n\n# 应该先了解的东西\n在正式学习 React 之前，应该知道一些概念。[React 哲学](https://zh-hans.react.dev/learn/thinking-in-react)、[React 规则](https://zh-hans.react.dev/reference/rules)，内容不多，但很重要。\n\n## 使用纯函数\n应该尽量保持组件的**纯函数**特性，不产生**副作用**。\n1. **只负责自己的任务**。它不会更改在该函数调用前就已存在的对象或变量。\n2. **输入相同，则输出相同**。给定相同的输入，组件应该总是返回相同的 JSX。\n\n内容不多，主要是开发时注意点，养成纯函数的思想即可，详见：[保持组件纯粹](https://zh-hans.react.dev/learn/keeping-components-pure)\n\n## 树结构 UI\n和 DOM 树类似，React 抽象出的 UI 也是一个**树形结构**。详见：[将 UI 视为树](https://zh-hans.react.dev/learn/understanding-your-ui-as-a-tree)\n\n这很熟悉，Vue 也是如此，基于模块的依赖关系、实际的渲染逻辑，可以分析出**渲染树**、**组件树**、**fiber树**等，总之树结构体现了各个组件实体之间的关系。\n\nReact 是**跨平台**的 UI 框架，渲染树不仅可以渲染到浏览器 DOM，还可以渲染到**原生应用**等环境。\n\n\n## React 渲染\nReact 渲染指组件将其状态和属性（state 和 props）转化为用户界面元素的过程。在浏览器环境中，React 组件会转化为 DOM 元素。分为三步：**触发**、**渲染**、**提交**。[文档-渲染和提交](https://zh-hans.react.dev/learn/render-and-commit)\n\n**1、触发：**两种情况会触发 React 组件的重新渲染。\n1. 组件的**初次渲染**。`createRoot().render()`。\n2. 组件（或其祖先）的**状态改变**。即调用 set 函数传入新值。\n\n**2、渲染：**调用组件，在内存中创建实际 DOM 节点。\n1. **初次渲染**时，调用根组件。\n2. **重渲染**时，调用内部状态更新触发了渲染的函数组件，通过 diff 算法比较新旧虚拟 DOM，标记需要更新的节点。\n\n都会递归调用所有后代组件。\n\n**3、提交：**修改实际 DOM 树。\n1. **初次渲染**时，将虚拟 DOM 转化为实际 DOM。\n2. **重渲染时** 根据节点的标记，最小更新实际 DOM。\n\n修改完 DOM 树后，就到浏览器的回流和重绘阶段了。\n\n> 实际上的内部渲染过程很复杂，React 会将组件关系转化为**Fiber 树**，并通过**调度器**控制渲染的优先级、时间，还会拆分渲染任务到浏览器每个渲染帧的空闲时刻，后面再深入了解。\n\n\n\n# props 组件传参\nReact 组件使用 `props` 来互相通信。父组件给子组件绑定 props 属性，子组件在函数参数中接收 props 对象。\n\nprops 是组件的唯一参数，它应该保持**只读**，不应该在组件内部更改 props 的值，可以很方便地通过解构赋值获取 props 的属性值，并指定默认值。\n\n```tsx\n// 父组件\n<Props title=\"qcqx\">\n  <div>Props children</div>\n</Props>\n// 子组件\ninterface Props {\n  title: string;\n  children: React.ReactNode;\n}\nfunction PropsTest({ title = \"chuckle\", children }: Props) {\n  return (\n    <div>\n      <p>{title}</p>\n      {children}\n    </div>\n  );\n}\n```\n\n将 JSX 作为标签内容传递给子组件，会作为 props 的 `children` 属性，类似于 Vue 的插槽。\n\n\n# React 事件\n在 React 中，所有的内置浏览器组件，如 `<div>`，都支持一些常见的属性和事件。[普通组件](https://zh-hans.react.dev/reference/react-dom/components/common)、[响应事件](https://zh-hans.react.dev/learn/responding-to-events)。\n\n[React 事件](https://zh-hans.react.dev/reference/react-dom/components/common#react-event-object)虽然和原生 DOM 事件用法、名称类似，但实际上是抽象封装过后的，React 事件是**合成事件**，它是**跨浏览器**的，它符合与底层 DOM 事件相同的标准，但修复了一些浏览器不一致性。\n\n所谓**合成事件**，就是在模拟事件时，可能由多个原生事件组合而成。部分原生事件不会冒泡，如 `focus`、`blur`、`change` 等，但在 React 中，它们都**会被模拟成可冒泡事件**。\n\n**基本原理：**\nReact 通过**事件委托**的方式，将所有事件绑定到**最外层容器**，每个事件各绑定一次冒泡和捕获阶段（原生不冒泡只绑定捕获阶段）。当一个 React 元素节点触发事件后，在 DOM 上会触发两次 React 的事件统一处理函数，先找到事件源，再根据 return 指针向上遍历，收集所有对应事件、**阶段**的处理函数，分别形成事件队列，依次执行。\n\n在命名上采用小驼峰 `on[<name>][Capture]`，加上 Capture 表示捕获阶段执行。\n事件对象也被封装成了**合成事件对象**，但仍然可以通过 `e.nativeEvent` 属性访问原生事件对象。\n\n```tsx\nreturn (\n  <>\n    <div\n      onClick={() => {\n        console.log(\"click\");\n      }}\n    >\n      点击 div\n    </div>\n    <div\n      onChange={(e) => {\n        console.log(e);\n      }}\n    >\n      <div\n        onChangeCapture={(e) => {\n          console.log(e.nativeEvent);\n        }}\n      >\n        <input\n          onChange={(e) => {\n            console.log(e.target.value);\n          }}\n        />\n      </div>\n    </div>\n  </>\n);\n```\n\n使用 `e.stopPropagation()` 和 `e.preventDefault()` 方法，可以阻止事件的冒泡和默认行为，但这两个方法也是**合成事件**的封装，并不是原生事件对象的方法。\n\n> 合成事件与原生 DOM 事件的类型并不一定相同，例如 React 中的 onChange 实际上是 input 事件的封装，其行为也和 onInput 没区别。\n\n\n# state 组件状态\n**纯函数式**的组件不具有**状态**，但 React 内置了多种 [Hook](https://zh-hans.react.dev/reference/react/hooks)，可以让组件更加灵活，使用状态（state）和其他 React 特性，也就是保持**状态**、获取**上下文**、**缓存计算结果**等。\n\n> 很容易可以想到，局部变量无法在多次渲染中持久保存，更改局部变量也不会触发渲染，毕竟 React 没有 像 Vue 那样使用 Proxy 劫持数据。\n\n[useState](https://zh-hans.react.dev/reference/react/useState) 应该是学习 React 首个遇到的 Hook。它允许你向组件添加一个[状态变量](https://zh-hans.react.dev/learn/state-a-components-memory)。\n\n```tsx\nimport { useState } from \"react\";\nconst [count, setCount] = useState(0); // 数组解构赋值\n```\n\n总应该使用 const 变量接收 `useState` 返回的两个东西。\n1. **data：**第一个是当前的数据，实际上就是传入 useState 或 setter 的参数，如果传入了引用数据，它们指向的引用地址是相同的。\n2. **setter：**第二个是 set 函数，用于更新数据，其行为是**异步**的，触发渲染，会标记该组件需要重新渲染，并在下一次渲染周期内重新渲染该组件。\n\n```tsx\nconst obj1 = { num: 0 };\nconst [obj2, setObj] = useState(obj1);\nconsole.log(obj1 === obj2); // true\n```\n\nReact 会在内部维护好当前组件实例的状态，通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来，保证多次渲染间不变，返回的是浅拷贝[快照](https://zh-hans.react.dev/learn/state-as-a-snapshot)。只有在**下一次渲染**后，才能获取到最新的快照。\n\n```tsx 更新了数据无法立即拿到，本质是 setObj 传入了新的对象，需要在下一次渲染时重新赋值获取\nconst [obj, setObj] = useState({ num: 0 });\n// 加个判断，否则会进入无限循环，Too many re-renders\nif (obj.num === 0) {\n  setObj({ ...obj, num: 1 });\n  console.log(obj); // { num: 0 }\n}\n```\n\nState 是组件实例内部的状态，渲染同一个组件两次，每个实例都会有完全隔离的 state。\n\nset 函数会**浅比较**新旧值，如果相同，会认为数据没有变化，不会触发重新渲染。这是 React 的 **Immutable** 思想的体现，这意味这**不能只修改属性**，把原来的对象传入 setter，而是应该传入一个**新对象**，一个新的引用地址。\n\n> 应该将 state 视为**只读**的，无论其是基本类型还是引用类型，都应该通过 set 函数来更新，而不是直接修改 state 的值或属性。\n> [为什么在 React 中不推荐直接修改 state？](https://zh-hans.react.dev/learn/updating-objects-in-state#why-is-mutating-state-not-recommended-in-react)\n\n\n## 函数式更新\n在一个渲染周期中多次调用 set 函数，可能并没有预期的叠加结果。\n\n```tsx\nconst [count, setCount] = useState(0);\nsetCount(count + 1);\nsetCount(count + 1);\n```\n\n以原生 JS 的视角来看，这就是设置了两次 `setCount(1)`，下一次渲染时，count 当然是 1。\n\n如果你需要 set 函数根据最新的 set 结果计算新的 state，可以使用**函数式更新**，传入一个函数，**接收最新的 state**，返回当前 state 值。这是在 React 内部处理的。\n\n```tsx\nsetCount((prevCount) => prevCount + 1);\nsetCount((prevCount) => prevCount + 1);\n```\n\n下一次渲染时，count 就会是 2 了。\n\n> 在学习 React 时，不要忘记原生 JS 的特性，如**闭包**、**异步**、**事件循环**等，React 也是利用了这些特性，实现的功能。\n\n\n## Immer 库\n\n```shell\npnpm i immer use-immer\n```\n\n使用 Immer 库，无需手动创建新对象，而是直接修改 draft 对象，保持代码简洁。\n\n```tsx\nimport { useImmer } from \"use-immer\";\nconst [obj1, setObj1] = useState({ num: 0 });\nconst [obj2, setObj2] = useImmer({ num: 0 });\nreturn (\n  <div>\n    <h2>{obj1.num}</h2>\n    <button\n      onClick={() => {\n        setObj1((obj) => {\n          return { num: obj.num + 1 };\n        });\n      }}\n    >\n      useState 增加\n    </button>\n    <h2>{obj2.num}</h2>\n    <button\n      onClick={() => {\n        setObj2((draft) => {\n          draft.num++; // 通过 Immer 可以很方便的修改属性值\n        });\n      }}\n    >\n      useImmer 增加\n    </button>\n  </div>\n);\n```\n\n实际上 draft 是一个 **Proxy** 对象，这下很熟悉了，通过 Proxy 拦截对象操作，Immer 就可以知道你修改了什么，然后构建一个新的对象给 State。\n\n## 更好地管理状态\n有关 React 如何更好地管理状态，官网的教程非常详细，[状态管理](https://zh-hans.react.dev/learn/managing-state)。\n\n> 随着应用不断变大，更有意识的去关注应用状态如何组织，以及数据如何在组件之间流动会对你很有帮助。冗余或重复的状态往往是缺陷的根源。\n\n## 状态的保留、重置\nReact 在内部维护了每个组件实例的 state。React 在移除一个组件时，也会销毁它的 state。\n\n换句话说，**相同组件被渲染在 UI 树的相同位置，React 就会保留它的 state**。 \n\n```tsx 对 React 来说，这样渲染 Counter 是相同位置，因为是由三元表达式返回一个组件\n{isPlayerA ? (\n  <Counter person=\"Taylor\" />\n) : (\n  <Counter person=\"Sarah\" />\n)}\n```\n\n对 React 来说重要的是组件在 UI 树中的位置，而不是在 JSX 中的位置。\n\n```tsx 这样渲染 Counter 是不同位置，因为是两个组件占了两个位置，尽管代码上他们是互斥的\n{isPlayerA &&\n  <Counter person=\"Taylor\" />\n}\n{!isPlayerA &&\n  <Counter person=\"Sarah\" />\n}\n```\n\n还可以改变 **key** 属性，强制 React 重新渲染组件，即使它们在 UI 树中的位置没有改变。因为 key 属性是 React 用来区分组件的唯一标识，**不同的 key 会被认为是不同的组件**。\n\n```tsx\n{isPlayerA ? (\n  <Counter key=\"Taylor\" person=\"Taylor\" />\n) : (\n  <Counter key=\"Sarah\" person=\"Sarah\" />\n)}\n```\n\n需要注意，key 并不是全局唯一的，它只相对于父元素是唯一的。当设置 key 后，React 会将 key 作为组件**标识**，而不是在父组件 UI 树中的位置。\n\n\n\n## useReducer\n[useReducer](https://zh-hans.react.dev/reference/react/useReducer) 是另一个可以用来管理组件状态的 Hook，它是 useState 的替代方案，用于处理**复杂的状态逻辑**。\n\n下面先写一个简单的 todoList。\n\n```tsx src\\components\\TaskList.tsx\nimport { useState } from \"react\";\nimport \"./TaskList.css\";\n\nexport interface Task {\n  id: string | number;\n  title: string;\n  done: boolean;\n}\ntype TaskList = Task[];\n\ninterface TaskListProps {\n  taskList: TaskList;\n  onChangeTask: (task: Task) => void;\n  onDeleteTask: (task: Task) => void;\n  onAddTask: (task: Task) => void;\n}\n\nexport default function TaskList({\n  taskList,\n  onChangeTask,\n  onDeleteTask,\n  onAddTask,\n}: TaskListProps) {\n  return (\n    <div className=\"task-list\">\n      <AddTask onAddTask={onAddTask}></AddTask>\n      <ul>\n        {taskList.map((task) => (\n          <li key={task.id}>\n            <Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\ninterface TaskProps {\n  task: Task;\n  onChange: (task: Task) => void;\n  onDelete: (task: Task) => void;\n}\n\nfunction Task({ task, onChange, onDelete }: TaskProps) {\n  const [isEdit, setIsEdit] = useState(false);\n  const [title, setTitle] = useState(task.title);\n\n  let taskContent = null;\n  if (isEdit) {\n    taskContent = (\n      <>\n        <input\n          type=\"text\"\n          value={title}\n          onChange={(e) => {\n            setTitle(e.target.value);\n          }}\n        />\n        <button\n          onClick={() => {\n            if (!title.trim()) {\n              return;\n            }\n            setIsEdit(false);\n            onChange({ ...task, title });\n          }}\n        >\n          保存\n        </button>\n        <button\n          onClick={() => {\n            setIsEdit(false);\n            setTitle(task.title);\n          }}\n        >\n          取消\n        </button>\n      </>\n    );\n  } else {\n    taskContent = (\n      <>\n        <span>{task.title}</span>\n        <button\n          onClick={() => {\n            setIsEdit(true);\n          }}\n        >\n          编辑\n        </button>\n      </>\n    );\n  }\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        checked={task.done}\n        onChange={() => {\n          onChange({ ...task, done: !task.done });\n        }}\n      />\n      {taskContent}\n      <button\n        onClick={() => {\n          onDelete(task);\n        }}\n      >\n        删除\n      </button>\n    </div>\n  );\n}\n\ninterface AddTaskProps {\n  onAddTask: (task: Task) => void;\n}\n\nfunction AddTask({ onAddTask }: AddTaskProps) {\n  const [title, setTitle] = useState(\"\");\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={title}\n        onChange={(e) => {\n          setTitle(e.target.value);\n        }}\n      />\n      <button\n        onClick={() => {\n          if (!title.trim()) {\n            return;\n          }\n          onAddTask({ id: Date.now(), title, done: false });\n          setTitle(\"\");\n        }}\n      >\n        添加\n      </button>\n    </div>\n  );\n}\n```\n\n然后使用该组件。\n\n```tsx\nimport { useState } from \"react\";\nimport TaskList, { Task } from \"../Task/TaskList\";\n\nconst initialState = [\n  { id: 1, title: \"任务1\", done: false },\n  { id: 2, title: \"任务2\", done: false },\n  { id: 3, title: \"任务3\", done: false },\n  { id: 4, title: \"任务4\", done: false },\n];\n\nexport default function ReducerTest() {\n  const [taskList, setTaskList] = useState<Task[]>(initialState);\n\n  function handleChangeTask(task: Task) {\n    setTaskList(\n      taskList.map((item) => {\n        if (item.id === task.id) {\n          return task;\n        }\n        return item;\n      })\n    );\n  }\n\n  function handleDeleteTask(task: Task) {\n    setTaskList(taskList.filter((item) => item.id !== task.id));\n  }\n\n  function handleAddTask(task: Task) {\n    setTaskList([task, ...taskList]);\n  }\n\n  return (\n    <div>\n      <TaskList\n        taskList={taskList}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n        onAddTask={handleAddTask}\n      ></TaskList>\n    </div>\n  );\n}\n```\n\n可以看到，handleChangeTask、handleDeleteTask、handleAddTask 三个函数都是对 taskList 的操作。\n\n目前处理逻辑还较为简单，但随着业务逻辑的增加，这些操作可能会变得复杂，可以使用 `useReducer` 将状态操作逻辑提取到 `reducer` 函数中。\n\n首先需要准备一个 `reducer` 函数，接收两个参数，**当前状态**和 **action**。\n\n```tsx\ninterface TaskAction {\n  type: \"add\" | \"delete\" | \"change\";\n  payload: Task;\n}\nfunction taskListReducer(taskList: Task[], action: TaskAction) {\n  switch (action.type) {\n    case \"add\":\n      return [action.payload, ...taskList];\n    case \"delete\":\n      return taskList.filter((item) => item.id !== action.payload.id);\n    case \"change\":\n      return taskList.map((item) => {\n        if (item.id === action.payload.id) {\n          return action.payload;\n        }\n        return item;\n      });\n    default:\n      return taskList;\n  }\n}\n```\n\n将`reducer` 函数和初始状态传给 `useReducer`，返回当前状态和 `dispatch` 函数。\n\n```tsx\nexport default function ReducerTest() {\n  // const [taskList, setTaskList] = useState<Task[]>(initialTasksList);\n  const [taskList, dispatch] = useReducer(taskListReducer, initialTasksList);\n\n  function handleChangeTask(task: Task) {\n    dispatch({ type: \"change\", payload: task });\n  }\n\n  function handleDeleteTask(task: Task) {\n    dispatch({ type: \"delete\", payload: task });\n  }\n\n  function handleAddTask(task: Task) {\n    dispatch({ type: \"add\", payload: task });\n  }\n\n  return (\n    <div>\n      <TaskList\n        taskList={taskList}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n        onAddTask={handleAddTask}\n      ></TaskList>\n    </div>\n  );\n}\n```\n\n传给 `dispatch` 的对象，称为 `action`，它会被 `reducer` 函数的第二个参数接收，是触发动作的描述，可以包含任意字段，通常包含一个 `type` 字段，用来描述动作的类型，以及一个 `payload` 字段，用来传递数据。\n\n使用了 `useReducer` 后，可以将状态操作逻辑提取到 `reducer` 函数中，使组件更加清晰，也更容易测试和复用。\n\n> 可以使用 [useImmerReducer](https://github.com/immerjs/use-immer#useimmerreducer) 继续简化 reducer 函数，不需要手动创建新对象，直接修改 draft 对象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n[react.dev](https://zh-hans.react.dev/)\n[React JSX](https://jonny-wei.github.io/blog/react/#%E8%AE%A4%E8%AF%86-jsx)\n[React技术揭秘](https://react.iamkasong.com/preparation/jsx.html)\n\n\n\n","tags":["前端","React"],"categories":["学习笔记"]},{"title":"闭包与内存泄漏","url":"/article/d186ebdd.html","content":"\n# 前言\n本文只是自己的理解，有错误的话一起讨论吧。\n\n> 不得不承认，GC已经为开发者\"擦好了屁股\"，在浏览器环境中，通过JS写不出正儿八经的传统内存泄露，但是闭包是一个例外，它能导致开发者无法通过代码访问到的对象仍然被引用，不能被GC回收，从而类似内存泄露。\n> 抠字眼不是本文的目的，什么是内存泄露也不是本文的重点，了解闭包、了解作用域才是本文内容。\n\n# 垃圾回收\n像 C 这样的底层语言，通常都提供了管理内存的接口，例如 malloc 和 free 函数，开发者可以精细的使用内存，写出又小又快的程序，但也增加了开发难度和心智负担，容易出现内存泄漏等问题，且往往难以排查。\n\n像 JS 这样的高级语言，为了开发效率和体验，都具有内存管理的功能，自动在合适的地方分配内存，再由垃圾回收器（GC）定期检查内存中的对象，**找出不再使用的对象**，然后释放其内存。\n\n> 本文并不关心 GC 的工作原理、具体算法，不过研究内存泄露又不得不提 GC，所以就先简单了解下 GC 吧。\n\n## GC 在管什么\n在 JS 中，数据分为两种类型：**基本数据类型**和**引用数据类型**。详见：[数据类型与拷贝](/article/6e8f8c6c.html)\n\n基本数据类型存储在栈上，其大小固定，生命周期明确，内存在出栈时自动释放，无需 GC 的管理。而引用数据类型存储在堆上，在栈空间中只保留了数据在堆中的地址，大小不固定，生命周期不确定，需要 GC 来管理。\n\n堆中的数据在不再使用此对象的时候释放。这里的**对象**不单指 JS 的引用数据类型，还包括了**函数作用域**（词法环境）。\n\n现代浏览器使用**标记清除算法**(或其改进)来判断一个对象是否不再使用，该算法从**根对象**（globalThis）开始，标记每一个可以被**触及**的对象(可达性)，最后清除没有被标记的对象。\n\n# 内存泄露\n**不再用到的内存，没有及时释放**，就叫做内存泄漏。\n\nJS 中可以更具体为**不再用到的对象仍然被引用**，导致 GC 无法回收这部分内存。\n\n## 常见的内存泄露\n使用 [FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry) 当注册的对象被 GC 回收时，会调用回调函数。\n\n```js\n// 创建一个回收注册器\nconst cleanup = new FinalizationRegistry((key) => {\n  console.log(\"清理\", key);\n});\n```\n\n**1、全局变量**：全局变量在全局作用域中，其生命周期和页面一样长，除非手动清除引用或页面关闭，否则不会被释放。\n\n```js\nlet arr = [1, 2, 3];\ncleanup.register(arr, \"arr\");\n// arr = null; // 手动清除引用\n```\n\n**2、console.log**：被打印的对象会被引用，无法被 GC 回收。\n\n```js\nlet obj = { a: 1, b: 2 };\ncleanup.register(obj, \"obj\"); // 无输出，即没有被回收\nconsole.log(obj);\nobj = null; // 即使手动清除引用，也无法释放obj，因为其被console.log引用\n```\n\n**3、定时器**：使用完毕的定时器未被清除，会一直占用内存。\n\n```js\nlet timer = setInterval(() => {\n  console.log(\"定时器\");\n}, 1000);\n// clearInterval(timer);\ntimer = null; // 清除的只是定时器ID，定时器还是会继续执行\n```\n\n# 闭包\n闭包是一个很抽象的东西，所以不能光谈概念，应该直接看浏览器（V8引擎）是如何处理闭包的。\n\n[MDN 对其定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)：闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，**闭包让开发者可以从内部函数访问外部函数的作用域**。在 JavaScript 中，闭包会随着函数的创建而被同时创建。\n\n首先实现一个非常经典的闭包：为了方便观察，嵌套三层函数。\n\n```js\nfunction createFoo() {\n  const doms = Array.from({ length: 100000 }, () => {\n    return document.createElement(\"div\");\n  });\n  \n  function foo() {\n    const obj = {};\n\n    function bar() {\n      obj;\n      doms;\n      return \n    }\n    return bar;\n  }\n  return foo();\n}\nlet foo = createFoo();\nconsole.dir(foo)\n```\n\n通过 console.dir 输出 foo 函数对象，可以看到 `[[Scopes]]` 属性，里面赫然就有 **Closure 闭包**。\n\n`[[Scopes]]` 是一个内部属性，**表示函数的作用域链**。它是一个数组，其中的每个元素都是一个对象，表示一个作用域。\n\n```js\nScopes[4]\n  0: Closure (foo) {obj: {…}}\n  1: Closure (createFoo) {doms: Array(100000)}\n  2: Script {cleanup: FinalizationRegistry, foo: ƒ}\n  3: Global {window: Window, self: Window, document: document, name: '', location: Location, …}\n```\n\n## 作用域\n作用域是**定义变量和函数的区域**，它是静态的，在编译时决定。**函数作用域确定了变量的可访问性和生命周期，但并不确定其值**。\n\n全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。\n\n```js\n// 整个脚本的作用域\n2: Script {cleanup: FinalizationRegistry, foo: ƒ}\n// 全局作用域，包含 window、document 等全局变量\n3: Global {window: Window, self: Window, document: document, name: '', location: Location, …}\n```\n\n除了 Script 和 Global，还有两个 Closure 闭包，它们并不等同于函数作用域，看下面的代码：\n\n```js\nfunction createFoo() {\n  const a = {};\n  const b = {};\n\n  function foo() {\n    const c = {};\n    foo;\n    a;\n    return;\n  }\n  return foo;\n}\nlet foo = createFoo();\nconsole.dir(foo);\n```\n\n`Closure (createFoo)` 中只有 a、foo 两个变量，而 b 变量并没有被引用。变量 c 在 foo 函数作用域内，不在闭包中。\n\n```js\nScopes[3]\n  0: Closure (createFoo) {a: {…}, foo: ƒ}\n  1: Script {cleanup: FinalizationRegistry, foo: ƒ}\n  2: Global {window: Window, self: Window, document: document, name: '', location: Location, …}\n```\n\n我们可以得出显而易见的结论，**闭包是其对应函数作用域的子集**。\n\n### 调试查看作用域\n并没有 API 可以获取某个函数作用域的对象，但可以通过浏览器调试来查看作用域内的东西。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-1.webp\"/>\n\n**作用域**区域包含了当前函数可以访问的作用域，其中**本地**就包含了该函数自己作用域的东西。\n\n不过这里的作用域也并不是真正的、静态的函数作用域，而是**执行上下文**。\n\n> 作用域和执行上下文是两个不同但**强相关**的概念，作用域是静态的，执行上下文是动态的，**是函数在执行时创建的环境**。执行上下文包含 this(指向当前函数执行时的上下文对象) 、作用域内变量的引用、作用域链。\n\n正因为是执行上下文，所以此时 foo 并没有执行，自然也无法查看到 foo 的作用域。下面让 foo 执行一下。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-2.webp\"/>\n\n**闭包(createFoo)**出现了。\n\n## 作用域链\nJS 其中一个特性就是允许在函数中定义函数。每个函数都有自己的作用域，而 V8 也会创建全局作用域。这样就形成了**作用域链**。作用域链保证了执行环境里有权访问的变量和函数是有序的。\n\nJS 的作用域是**词法作用域**，作用域链的顺序是按照**函数定义时的位置**来决定的。即始终是**函数作用域–> 脚本作用域 ->全局作用域**。\n\n在调用一个变量时，会在当前函数的作用域中查找，如果没有找到，就会沿着作用域链向上查找，直到找到全局作用域。\n\n闭包的特性也就出现了：开发者可以从内部函数访问外部函数的作用域。\n\n## 解析过程\n一切看起来都很美好，只需要把 JS 代码整体解析一遍，就能确定作用域链，还能进行优化，将用不到的变量清除掉，然后执行即可。\n\n但 JS 是边解析边执行的，并且实现了**惰性解析**。以一段闭包代码为例：\n\n```js\nlet foo = createFoo();\nfoo();\nfunction createFoo() {\n  const a = {};\n  const b = {};\n\n  function foo() {\n    const c = {};\n    a;\n    return;\n  }\n  return foo;\n}\n```\n\n**存在问题的惰性解析过程：**\n1. **提升：**首先进入了当前脚本作用域，在当前作用域进行**变量提升**、**函数提升**，所以能在 createFoo 函数声明之前调用它。\n2. **跳过函数代码：**当解析到 createFoo 函数声明时，因为**惰性解析**，会跳过函数内部的代码，**仅生成一个函数对象**，并不会为其生成 AST 和字节码。\n3. **执行：**生成完脚本顶层代码的抽象语法树后，就开始自上而下执行代码。\n4. 调用 createFoo 函数，从函数对象中取出函数代码，和前面的过程一样，解析代码，跳过内部的 foo 函数代码，只生成其函数对象。\n5. 然后将 createFoo 函数推入调用栈中执行，并**创建执行上下文**。\n6. 执行完成后出栈，返回 foo 函数对象给全局变量 foo，并销毁 createFoo 函数的执行上下文。\n7. 然后调用 foo 函数，同样的过程，会发现找不到变量 a 了，因为 a 在 createFoo 的执行上下文中，已经被销毁了，无法实现闭包。\n\n也就是说，JS 引擎需要知道**一个函数是否引用了外部变量**，而`预解析器`正是负责这个过程。\n\n### 预解析器\n当遇到函数声明时，并不会真的直接跳过函数代码，而是让**预解析器**对函数代码进行一次**快速解析**。用于**检查函数内部是否引用了外部变量**，这里的检查是彻底的、有针对性的，不会跳过任何代码，包括函数内部的函数代码。\n\n预解析器会创建一个**闭包对象**，每当解析到一个变量被内部函数引用时，就将这个变量的引用放入闭包对象中。最后将该闭包对象放入**所有**内部函数对象的 `[[Scopes]]` 数组中。所以**闭包是其对应函数作用域的子集**。\n\n而作用域链的实现也就是遍历 `[[Scopes]]` 数组，按顺序查找变量。\n\n看下面这段代码：\n\n```js\ncreateFoo();\nfunction createFoo() {\n  const a = {};\n  const b = {};\n  console.dir(foo)\n\n  function foo() {\n    a;\n    \n    function bar() {\n      b;\n    }\n    return bar;\n  }\n  return foo;\n}\n```\n\nfoo 函数没有被执行，而在执行 createFoo 函数时，foo 函数已经被**预解析**成函数对象，并且可以看到其 createFoo 函数闭包，包含了 a、b 两个变量的引用。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-3.webp\"/>\n\n由于 a、b 对象仍然被引用，所以在销毁 createFoo 函数执行上下文时，GC 不会在堆中回收 a、b 对象。\n\n## 闭包/作用域链是“继承”的\n子函数会继承父函数的 `[[Scopes]]` 属性。从词法作用域上来讲，这是捕获机制。\n\n```js\nlet foo = createFoo();\nconst bar = foo();\nconsole.dir(bar)\n\nfunction createFoo() {\n  const a = {};\n  const b = {};\n\n  function foo() {\n    a;\n    b;\n    \n    function bar() {}\n\n    return bar;\n  }\n  return foo;\n}\n```\n\n输出：\n\n```js\n[[Scopes]]: Scopes[3]\n  0: Closure (createFoo) {a: {…}, b: {…}}\n```\n\n即使 bar 函数没有引用 createFoo 函数作用域的 a、b 变量，但其父函数 foo 引用了，所以 bar 函数对象的 `[[Scopes]]` 属性中也包含了 createFoo 函数的闭包对象。\n\n> 从 JS 对象上来讲，这类似继承行为，这么说也比较好理解，但实际上是**词法作用域链的捕获机制**。\n> 在函数定义时，所有嵌套函数（即使是更深层的嵌套函数）都会关联到它们的父级作用域链，确保在函数调用时可以访问正确的外部变量，即使子函数并未显式使用这些变量。换句话说，bar 函数的 **[[Scopes]]** 属性在定义时就已经包含了 foo 的作用域链，这样即使 bar 在之后执行，也能正确解析作用域链。\n\n这可能会导致内存泄露，我们后面再说。\n\n## 总结闭包\n闭包可以从两方面说：\n1. 在 JS 规范上，闭包是允许函数访问其外部作用域变量的机制。\n2. 在引擎实现上，闭包是对应函数作用域的子集**对象**，包含了该函数中被其内部函数引用了的变量的**引用**。该闭包对象会放入**所有**内部函数对象的 `[[Scopes]]` 属性中，作为作用域链的一部分。\n3. 子函数对象会继承父函数对象的 `[[Scopes]]` 属性。\n\n脚本作用域和全局作用域总是会在 `[[Scopes]]` 中。而函数作用域只有在其变量被引用时，才会形成闭包对象出现在内部函数的 `[[Scopes]]` 中。\n\n# 闭包与内存泄露\n了解了闭包与作用域，就明白为什么闭包可能会导致内存泄露了。\n\n看下面这个例子，doms 这 10w 个 dom 对象将不会被 GC 回收，如果你完全不明白为什么，应该回去看看上面的内容。\n\n```js\nfunction createFoo() {\n  const doms = Array.from({ length: 100000 }, () => {\n    return document.createElement(\"div\");\n  });\n  cleanup.register(doms, \"doms\");\n\n  // bar没有被返回，只有他通过闭包调用了doms。\n  function bar() {\n    doms;\n  }\n  function foo() {}\n\n  return foo;\n}\nlet foo = createFoo();\nfoo();\n```\n\n如果你不清楚 `[[Scopes]]`，不清楚作用域，不知道闭包的实现，那么看起来就像是 GC 出 BUG 了一样，一个看起来永远也无法触及的 doms 对象居然没有被回收，闭包导致了内存泄露！\n\n## 发生了什么\n在执行 createFoo 函数时，输出一下 foo 函数对象。\n\n```js\nfunction createFoo() {\n  const doms = Array.from({ length: 100000 }, () => {\n    return document.createElement(\"div\");\n  });\n  cleanup.register(doms, \"doms\");\n  console.dir(foo); // 加上这行\n\n  function bar() {\n    doms;\n  }\n  function foo() {}\n\n  return foo;\n}\nlet foo = createFoo();\n```\n\n可以看到 foo 函数对象的 `[[Scopes]]` 中的 createFoo 函数的闭包对象，包含了 doms 对象。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-4.webp\"/>\n\n回顾总结闭包时的话：\n\n> 在引擎实现上，闭包是对应函数作用域的子集**对象**，包含了该函数中被其内部函数引用了的变量的**引用**。该闭包对象会放入**所有**内部函数对象的 `[[Scopes]]` 属性中，作为作用域链的一部分。\n\n注意是**所有**，所以 doms 仍然被引用着，而 foo 是脚本作用域的对象，自然不会被 GC 回收。\n\n> foo 可能并不在全局或脚本作用域中，但只要 foo 函数仍然存在，那么其 [[Scopes]] 也就引用着开发者无法访问的 doms 对象，我认为这就是发生了内存泄露。\n\n## 闭包对象继承导致内存泄露\n子函数会继承父函数的 `[[Scopes]]` 属性，这也会导致内存泄露。\n\n```js\nconst bar = createFoo()();\n\nfunction createFoo() {\n  const a = Array.from({ length: 100000 }, () => {\n    return document.createElement(\"div\");\n  });\n  cleanup.register(a, \"a\");\n\n  function foo() {\n    a;\n    console.dir(bar);\n\n    function bar() {}\n\n    return bar;\n  }\n  return foo;\n}\n```\n\n即使 bar 中没有访问 doms，但 foo 用到了，因为闭包对象继承，所以 bar 函数对象的 `[[Scopes]]` 属性中也包含了 doms 对象。即使再也无法触及 doms，但它仍然被引用，无法被 GC 回收。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-6.webp\"/>\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/103-5.webp\"/>\n\n\n# with 函数（已弃用）\n[with](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with) 函数用于将某个对象添加到作用域链的顶部。\n\n该函数已被弃用，并在严格模式中禁止，但挺有趣的，了解一下也不错。\n\n```js\nvar a, x, y;\nvar r = 10;\nwith (Math) {\n  // 该作用域链中包含了 Math 对象，能直接找到 PI、cos、sin 属性。\n  a = PI * r * r;\n  x = r * cos(PI);\n  y = r * sin(PI / 2);\n}\n```\n\n# 总结\n闭包确实可能导致隐藏的内存泄露，但这并不是闭包本身的问题，闭包这个机制使 JS 语言更加灵活。\n\n\n\n# 参考\n[「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)\n[MDN-闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)\n[MDN-内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management)\n[垃圾回收-现代 JavaScript 教程](https://zh.javascript.info/garbage-collection)\n[JS的垃圾回收机制](https://www.cnblogs.com/luckest/p/16895686.html)\n[JavaScript 内存泄漏教程-阮一峰](https://www.ruanyifeng.com/blog/2017/04/memory-leak.html)\n[C++ 的高性能垃圾回收（GC）-v8](https://v8.js.cn/blog/high-performance-cpp-gc/)\n[js垃圾回收机制](https://liyucang-git.github.io/2019/03/23/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n[Javascript中的垃圾回收（GC）](https://www.shidao.info/posts/frontend/javascript_gc.html)\n[垃圾回收-JavaScript Guidebook](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/memory-management/garbage-collection/)\n[学习Javascript闭包（Closure）-阮一峰](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n[图解 Google V8 -- V8是如何实现闭包的？](https://juejin.cn/post/7063269284876648484)\n[JS-V8引擎的闭包优化-秒懂](https://juejin.cn/post/7093916104233320484)\n[Node.js Memory Leaks: How to Debug And Avoid Them?](https://www.netguru.com/blog/node-js-memory-leaks)\n[Grokking V8 closures for fun (and profit?)](https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html)\n[An interesting kind of JavaScript memory leak](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)\n[Trash talk: the Orinoco garbage collector](https://v8.dev/blog/trash-talk)\n[JS Memory Leak And V8 Garbage Collection](https://fynn90.github.io/2021/01/31/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"Vue3.5 更新了啥","url":"/article/d22c87fc.html","content":"\n# 前言\n2024 年 9 月 1 日，[Vue 3.5“天元突破：红莲螺岩”版本发布](https://blog.vuejs.org/posts/vue-3-5)，[完整更新日志](https://github.com/vuejs/core/blob/main/CHANGELOG.md)。\n\n这次更新包含内部改进和实用的新功能，Vue 变得更加好用了！\n\n> 在 3.5 中，Vue 的响应式系统经历了一次重大重构，在行为没有变化的情况下，实现了更好的性能和显著改善的内存使用率（-56%）。重构还解决了 SSR 期间计算值挂起导致的过时计算值和内存问题。\n> 此外，3.5 还优化了大型、深度反应阵列的反应性跟踪，在某些情况下可使此类操作速度提高 10 倍。\n\n# 响应式 Props 解构\n终于能够使用原生 JS 的语法来响应式地解构 props 了！[文档](https://vuejs.org/guide/components/props.html#reactive-props-destructure)\n\n先写一个父组件。\n\n```html src\\App.vue\n<template>\n  <Hello :count=\"num\"></Hello>\n  <button @click=\"add\">增加</button>\n</template>\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\nimport Hello from \"./components/Hello.vue\";\nconst num = ref(0);\nconst add = () => {\n  num.value++;\n};\n</script>\n```\n\n在以前，需要使用 `withDefaults()` 提供默认值，再使用 `toRefs()` 解构 props。\n\n```html src\\components\\Hello.vue\n<template>\n  <div>\n    <h2>{{ count }}</h2>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { toRefs, watchEffect } from \"vue\";\nconst props = withDefaults(\n  defineProps<{\n    count?: number;\n  }>(),\n  {\n    count: 0,\n  }\n);\nconst { count } = toRefs(props);\nwatchEffect(() => {\n  console.log(count.value);\n});\n</script>\n```\n\n而现在，能使用原生 JS 的语法来解构 props，并指定默认值。\n\n```ts src\\components\\Hello.vue\nimport { toRefs, watchEffect } from \"vue\";\n\nconst { count = 0 } = defineProps<{\n  count?: number;\n}>();\n\nwatchEffect(() => {\n  // console.log(count.value);\n  console.log(count);\n});\n\n// const props = withDefaults(\n//   defineProps<{\n//     count?: number;\n//   }>(),\n//   {\n//     count: 0,\n//   }\n// );\n// const { count } = toRefs(props);\n```\n\n## VSC 插件优化\n即使是基本类型，也不需要 `.value`。这个行为或许会带来一定的困惑。\n\n所以 Vue - Official 插件也提供了一个视觉优化 `vue.inlayHints.destructuredProps` 选项，对于从 props 解构的变量，会在其左侧显示 `props.` 提示。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/102-1.webp\" />\n\n\n## 原理\n在 vite 中外化 vue 依赖并取消压缩代码，方便查看构建产物\n\n```ts\nexport default defineConfig({\n  plugins: [vue()],\n  build: {\n    rollupOptions: {\n      external: [\"vue\"],\n    },\n    minify: false,\n  },\n});\n```\n\n在产物中可以看到，在编译时，`count` 会被转换为 `__props.count`，当然就不会丢失响应式了。\n\n```js\nwatchEffect(() => {\n  console.log(__props.count);\n});\n```\n\n所以使用 watch 监视解构的 prop 变量时，需要使用 getter 函数包裹。\n\n```ts\nwatch(count /* ... */) // 编译时会报错\nwatch(() => count /* ... */) // 正确\n```\n\n# useTemplateRef 获取模板引用实例\n可以使用 `useTemplateRef()` 获取模板引用实例，而不需要预先准备一个 ref。这有助于区分模板引用和响应式数据，且更符合原生获取 DOM 元素的语法习惯。[文档](https://vuejs.org/guide/essentials/template-refs.html#accessing-the-refs)\n\n```ts\n// 子组件\nconst data = ref(\"Hello World\");\ndefineExpose({ data });\n\n// 父组件\nimport { useTemplateRef } from \"vue\";\nconst helloRef = useTemplateRef('helloRef');\nonMounted(() => {\n  console.log(helloRef.value?.data); // Hello World\n});\n```\n\n# 内置 Teleport 组件优化\n内置 `<Teleport>` 组件的一个已知限制是，其目标元素必须在 `<Teleport>` 组件挂载时已存在。\n\n在 3.5 中，`<Teleport>` 组件新增了 `defer` 属性，可以在当前渲染周期之后再挂载。\n\n```html\n<Teleport defer to=\"#cont\">\n  <div v-if=\"open\">\n    <span>挂载到id为cont的div上</span>\n    <button @click=\"open = false\">关闭</button>\n  </div>\n</Teleport>\n<!-- Teleport组件传送内容的容器，在 Teleport 之后渲染-->\n<div id=\"cont\"></div>\n<button @click=\"open = true\">打开</button>\n```\n\n因为 #cont 在 `<Teleport>` 之后渲染，所以之前的 `<Teleport>` 无法将内容传送到 #cont。\n\n```\nmain.ts:4 [Vue warn]: Failed to locate Teleport target with selector \"#cont\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree. \n  at <Dialog> \n  at <App>\n```\n\n# watch 函数相关\n之前 watch 函数是和 Vue 组件以及生命周期一起实现的，源码在 `runtime-core` 模块中，有时只需要使用 vue 的响应式功能，即 `reactivity` 模块，但不得不引入 `runtime-core` 模块。\n\n3.5 在 reactivity 模块中实现了一个和原来 watch API 一模一样的 watch，用法没有区别。详见：[Vue3.5新增的baseWatch让watch函数和Vue组件彻底分手-前端欧阳](https://mp.weixin.qq.com/s/Mc_x13D4qWcDy-gc8j9_6g)\n\n## onWatcherCleanup\n`onWatcherCleanup()` 用于在 watch 中注册清理回调。在组件卸载之前或者下一次 watch 回调执行之前会自动调用清理回调。\n\n```ts\nwatch(num, () => {\n  const timer = setInterval(() => {\n    console.log(\"do something\");\n  }, 200);\n  onWatcherCleanup(() => {\n    console.log(\"清理定时器\");\n    clearInterval(timer);\n  });\n});\n```\n\n不必再手动在 `onBeforeUnmount` 钩子中清理 watch 产生的副作用。\n\n## pause 和 resume\n`pause` 和 `resume` 用于暂停和恢复 watch 的执行。\n\n暂停后，watch 回调不会执行，恢复时，**会立即执行一次回调**。\n\n```ts\n<button @click=\"watcher.pause()\">暂停 watch</button>\n<button @click=\"watcher.resume()\">恢复 watch</button>\n\nconst watcher = watch(num, () => {\n  console.log(`num changed: ${num.value}`);\n});\n```\n\n## deep 支持传入数字\n以前 deep 只能传入布尔值，现在支持传入数字，表明监控对象的深度。\n\n```ts\nconst obj1 = ref({\n  x: 0,\n  a: {\n    b: 1,\n  },\n});\nsetTimeout(() => {\n  obj1.value.x = 1;\n  setTimeout(() => {\n    obj1.value.a.b = 2;\n  }, 1000);\n}, 1000);\n\nwatch(\n  obj1,\n  () => {\n    console.log(\"obj1 changed\"); // 只执行一次，因为 obj1.value.a.b 深度为 2。\n  },\n  {\n    deep: 1,\n  }\n);\n```\n\n# SSR服务端渲染优化\n3.5 中，SSR 期间计算值挂起导致的过时计算值和内存问题得到解决。\n\n新增 useId 函数、Lazy Hydration 懒加载水合、data-allow-mismatch 等。\n\n> 没用过 vue 的 SSR 就不看这块了，详见：[文档](https://blog.vuejs.org/posts/vue-3-5#lazy-hydration)\n\n# 参考\n[Announcing Vue 3.5](https://blog.vuejs.org/posts/vue-3-5)\n[这应该是全网最详细的Vue3.5版本解读](https://www.cnblogs.com/heavenYJJ/p/18397413)\n[vue3.5最新发布，这几个新用法还不快来学习一下！](https://juejin.cn/post/7410241410371338240)\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Git lint 相关","url":"/article/93c63660.html","content":"\n# 前言\n在 [集成 lint 代码规范工具](/article/b2086eb9.html) 中，已经集成了对项目代码的检查，但这并不是强制的，可能没有在编辑器中配置 ESLint，或者忽视了命令行中的错误提示，导致错误的代码被提交到仓库中。\n\n我们需要在 Git 提交代码前，通过 [Git Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) 强制对代码进行**增量检查**（每次都进行全量 lint 检查是非常耗时的）。并配置 [commitlint](https://github.com/conventional-changelog/commitlint) 对提交信息也进行检查。\n\n示例仓库：[qxchuckle/monorepo-test](https://github.com/qxchuckle/monorepo-test)\n\n参考：\n[【从 0 到 1 搭建 Vue 组件库框架】3. 集成 lint 代码规范工具](https://juejin.cn/post/7260499321983336509)\n[一文带你彻底学会 Git Hooks 配置](https://juejin.cn/post/6844904194634153992)\n[[Git Hooks] 在代码提交前自动格式化代码](https://juejin.cn/post/7261270802645663804)\n[（前端工程化配置） 使用commitlint校验git commit message](https://juejin.cn/post/7085596614538035236)\n[commit规范+commitlint+CHANGELOG自动生成一条龙服务](https://juejin.cn/post/6934292467160514567)\n[【前端】代码Git提交规范之约定式提交和Commitizen简化提交流程](https://juejin.cn/post/7343905368621596708)\n\n# commitlint\n[commitlint](https://github.com/conventional-changelog/commitlint) 用于规范化 Git 提交信息。\n\n## 安装\n\n```bash\npnpm i -wD @commitlint/config-conventional @commitlint/cli\n```\n\n在根目录创建 `commitlint.config.mjs`，继承默认的 [@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional) 规范集。（这些个 lint 工具的配置文件长得都大差不差）。\n\n安装 [@archoleat/commitlint-define-config](https://www.npmjs.com/package/@archoleat/commitlint-define-config) 以获得配置提示。\n\n```js commitlint.config.mjs\n// @ts-check\nimport { defineConfig } from '@archoleat/commitlint-define-config';\nexport default defineConfig({\n  extends: ['@commitlint/config-conventional'],\n});\n```\n\n`@commitlint/config-conventional` 规定了 [Conventional Commits](https://www.conventionalcommits.org/zh-hans/v1.0.0/) 式的提交信息，详见 [Git 规范与实践](/article/7f942cef.html)。\n\n\n## gitmoji\n如果你使用了 [gitmoji](https://gitmoji.dev/)，可以继承 [commitlint-config-gitmoji](https://www.npmjs.com/package/commitlint-config-gitmoji) 配置。\n\n# Git Hooks\n**commitlint** 无法单独使用。因为提交信息发生在 git commit 阶段，而 git commit 时，控制台已经被占用，我们无法输入其他命令。\n\n但 Git 提供了 [Git Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) 功能，它能在特定的重要动作发生时触发自定义脚本。\n可以在 commit 动作发生时执行 commitlint 脚本，通过 **commit-msg** 钩子判断所提交的信息是否符合规范。\n\n> Hook 就是在执行某个事件之前或之后进行一些其他额外的操作。\n\nGit Hooks 的实现非常简单，就是就 **.git/hooks** 文件下，保存了一些对应阶段的 **shell 脚本文件**，其中默认存在的 `.sample` 文件是示例文件，将该后缀去掉，如 **pre-commit** 文件，就是钩子文件了，**Git 会在特定阶段自动执行对应的脚本文件**。\n\n## Husky\n我们当然可以手动创建这些钩子文件，但是 **.git** 文件夹并不会被提交到仓库中，其他人在 clone 项目时，无法使用这些钩子。\n\n这就需要使用 [Husky](https://github.com/typicode/husky) 来管理、配置钩子了。\n\n```bash\npnpm i -wD husky\nnpx husky init # 初始化 husky\n```\n\n这会在项目根目录创建 `.husky` 文件夹，里面存放了一些和 Git Hooks 同名的钩子文件。并将 **core.hooksPath** 配置为该文件夹。初始化完成时只有 pre-commit 文件。\n\n其原理很清晰明了，操作钩子时，只需在 `.husky` 文件夹中操作对应的文件即可。当然可以使用系统自带的 **echo** 等命令完成，看个人喜好。\n\n```bash\necho \"npm test\" > .husky/pre-commit\n```\n\n此外，初始化时还会修改 **package.json** 文件，添加 `scripts.prepare` 脚本，以在 npm 安装依赖前执行 husky 命令，用于正确配置 **core.hooksPath** 为 `.husky` 文件夹。\n\n```json package.json\n{\n  \"scripts\": {\n    \"prepare\": \"husky\"\n  }\n}\n```\n\n## 配置 commit-msg 钩子\n添加 .husky/commit-msg 文件，调用 commitlint 进行检查。\n\n```sh .husky/commit-msg\n#!/usr/bin/env sh\n\n# --no 不按照任何缺失的包，确保 npx 只运行已经安装的包。\n# --：这是一个分隔符，用于区分 npx 的选项和要运行的命令的选项。所有在 -- 之后的内容都会被视为要运行的命令的参数。\n# HUSKY_GIT_PARAMS 被移除。取而代之的是 Git 参数应该直接在脚本中使用（例如 $1）。\n# --edit 选项用于指定要检查的提交消息文件。$1 是传递给脚本的第一个参数，通常是提交消息文件的路径。\nnpx --no -- commitlint --edit $1\n```\n\n现在，不规范的提交将被拒绝。\n\n```bash\n> git commit -m \"测试不规范提交\"\n⧗   input: 测试不规范提交\n✖   subject may not be empty [subject-empty]\n✖   type may not be empty [type-empty]\n\n✖   found 2 problems, 0 warnings\nⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint\n\nhusky - commit-msg script failed (code 1)\n\n> git commit -m \"test: 测试规范提交\"   \n[main 1bd745a] test: 测试规范提交\n 2 files changed, 7 insertions(+), 2 deletions(-)\n create mode 100644 .husky/commit-msg\n delete mode 100644 .husky/pre-commit\n```\n\n# lint-staged 实现增量检查\n目前的 **ESLint**、**Stylelint** 都是全量检查，这是耗时且不必要的，因为往往只有修改后即将提交的文件才需要检查。\n\n很容易想到的是配合 Git 实现增量检查，即只检查 **staged（暂存区）** 的文件。[lint-staged](https://github.com/lint-staged/lint-staged) 就是这样一个工具。\n\n## 安装\n\n```bash\npnpm i -wD lint-staged\n```\n\n**lint-staged** 支持通过 glob 模式匹配，对暂存区的文件列表进行分类过滤，以实现对不同的文件应用不同检查的效果。\n\n创建 `lint-staged.config.mjs` 配置文件。\n\n```js lint-staged.config.mjs\nexport default {\n  // 对于 js、ts 脚本文件，应用 eslint\n  '**/*.{js,jsx,tsx,ts}': ['eslint --fix'],\n  // 对于 css scss 文件，应用 stylelint\n  '**/*.{scss,css}': ['stylelint --fix'],\n  // Vue 文件由于同时包含模板、样式、脚本，因此 eslint、stylelint 都要使用\n  '**/*.vue': ['eslint --fix', 'stylelint --fix'],\n  // 用 prettier 修复所有文件的格式\n  '**/*': ['prettier --write'],\n};\n```\n\n## 配置 pre-commit 钩子\n[lint-staged](https://github.com/lint-staged/lint-staged) 要处理的是暂存区文件，所以需要使用 Git 的 pre-commit 钩子，实现在 commit 发生之前对发生变化的文件进行 Lint 扫描，若 Lint 抛出错误，说明此次准备提交的文件存在代码规范的问题，提交失败。\n\n这需要我们再次用到 husky。\n\n```sh .husky/pre-commit\n#!/usr/bin/env sh\nnpx --no -- lint-staged\n```\n\n现在提交代码时，会检查并尝试修复暂存区的文件。\n\n# commitizen\n配合 VSCode 可以使用 [Conventional Commits](https://marketplace.visualstudio.com/items?itemName=vivaxy.vscode-conventional-commits)、[git-commit-plugin](https://marketplace.visualstudio.com/items?itemName=redjue.git-commit-plugin) 等插件快速生成符合 [Angular 团队规范](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines)的提交信息。\n\n而命令行工具更加通用，[commitizen](https://www.npmjs.com/package/commitizen) 提供 cz 命令替代 commit 命令，它会引导开发者通过一系列问题来填写提交信息，确保提交信息符合规范。\n\n## 安装\n\n```bash\nnpm i -g commitizen\npnpm i -wD commitizen # 推荐在项目中安装，全局模式下, 需要 ~/.czrc 配置文件, 为 commitizen 指定 Adapter\n```\n\n还需要安装额外的适配器，否则 repo 就不是对 Commitizen 友好的，git cz 的工作方式会与 git commit 完全相同。\n\n[cz-conventional-changelog](https://www.npmjs.com/package/cz-conventional-changelog) 是 commitizen 的首选适配器。\n\n```bash\npnpm i -wD cz-conventional-changelog\n```\n\n编辑 package.json 文件，添加 **config.commitizen** 字段，指定适配器。\n\n```json package.json\n\"scripts\": {\n  \"commit\": \"cz\"\n}\n\"config\": {\n  \"commitizen\": {\n    \"path\": \"cz-conventional-changelog\"\n  }\n}\n```\n\n现在，使用 `pnpm run commit` 命令提交代码，会引导你填写符合规范的提交信息。\n\n```bash\n> pnpm run commit\ncz-cli@4.3.0, cz-conventional-changelog@3.3.0\n? Select the type of change that you're committing: (Use arrow keys)\n> feat:     A new feature\n  fix:      A bug fix\n  docs:     Documentation only changes\n  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n  refactor: A code change that neither fixes a bug nor adds a feature\n  perf:     A code change that improves performance\n  test:     Adding missing tests or correcting existi\n```\n\n## 更换适配器\n[cz-conventional-changelog](https://www.npmjs.com/package/cz-conventional-changelog) 适配器提示信息都是英文的，不能自定义配置，我们使用更灵活的 [cz-customizable](https://github.com/leoforfree/cz-customizable) 适配器。\n\n```bash\npnpm i -wD cz-customizable\n```\n\n更换适配器：\n\n```json package.json\n\"config\": {\n  \"commitizen\": {\n    \"path\": \"cz-customizable\"\n  }\n},\n```\n\n在 root 下新建 `.cz-config.js` 配置文件，配置适配器。[配置选项文档](https://github.com/leoforfree/cz-customizable#options)。\n\n> 吐槽，.cz-config.js 只能是 CJS 模块，因为 cz-customizable 用的是 require 引入。\n\n```js .cz-config.js\nmodule.exports = {\n  // 定义提交类型\n  types: [\n    {\n      value: 'feat',\n      name: 'feat: 新功能',\n    },\n    {\n      value: 'fix',\n      name: 'fix: 修复bug',\n    },\n    {\n      value: 'init',\n      name: 'init: 初始化',\n    },\n    {\n      value: ':pencil2: docs',\n      name: 'docs: 文档变更',\n    },\n    {\n      value: 'style',\n      name: 'style: 代码的样式美化',\n    },\n    {\n      value: 'refactor',\n      name: 'refactor: 重构',\n    },\n    {\n      value: 'perf',\n      name: 'perf: 性能优化',\n    },\n    {\n      value: 'test',\n      name: 'test: 测试',\n    },\n    {\n      value: 'revert',\n      name: 'revert: 回退',\n    },\n    {\n      value: 'build',\n      name: 'build: 打包',\n    },\n    {\n      value: 'chore',\n      name: 'chore: 构建/工程依赖/工具',\n    },\n    {\n      value: 'ci',\n      name: 'ci: CI related changes',\n    },\n  ],\n  // 自定义提示信息\n  messages: {\n    type: '请选择提交类型(必填)',\n    customScope: '请输入文件修改范围(可选)',\n    subject: '请简要描述提交(必填)',\n    body: '请输入详细描述(可选)',\n    breaking: '列出任何BREAKING CHANGES(可选)',\n    footer: '请输入要关闭的issue(可选)',\n    confirmCommit: '确定提交此说明吗？',\n  },\n  // 允许自定义 scopes 范围\n  allowCustomScopes: true,\n  // 当提交类型为feat、fix时才有破坏性修改选项\n  allowBreakingChanges: ['feat', 'fix'],\n  // 简短描述长度限制\n  subjectLimit: 72,\n};\n```\n\n再次运行，现在可以看到自定义的提示信息。cz -> lint -> commit，一套流程行云流水。\n\n```bash\n> pnpm run commit\n\n> pnpm-workspace-test@ commit C:\\chuckle\\qx\\study_demo\\Monorepo\\pnpmWorkspaceTest\n> cz\n\ncz-cli@4.3.0, cz-customizable@7.2.1\n\nAll lines except first will be wrapped after 100 characters.\n? 请选择提交类型(必填) feat: 新功能\n? 请简要描述提交(必填) 集成 commitizen\n? 请输入详细描述(可选)\n? 列出任何BREAKING CHANGES(可选) \n? 请输入要关闭的issue(可选)\n\n###--------------------------------------------------------###\nfeat(custom): 集成 commitizen\n###--------------------------------------------------------###\n\n? 确定提交此说明吗？ Yes\n[STARTED] Preparing lint-staged...\n[COMPLETED] Preparing lint-staged...\n[STARTED] Running tasks for staged files...\n[STARTED] lint-staged.config.mjs — 3 files\n[STARTED] **/*.{js,jsx,tsx,ts} — 1 file\n[STARTED] **/*.{scss,css} — 0 files\n[STARTED] **/*.vue — 0 files\n[STARTED] **/* — 3 files\n[SKIPPED] **/*.{scss,css} — no files\n[SKIPPED] **/*.vue — no files\n[STARTED] eslint --fix\n[STARTED] prettier --write\n[COMPLETED] prettier --write\n[COMPLETED] **/* — 3 files\n[COMPLETED] eslint --fix\n[COMPLETED] **/*.{js,jsx,tsx,ts} — 1 file     \n[COMPLETED] lint-staged.config.mjs — 3 files  \n[COMPLETED] Running tasks for staged files... \n[STARTED] Applying modifications from tasks...\n[COMPLETED] Applying modifications from tasks...\n[STARTED] Cleaning up temporary files...        \n[COMPLETED] Cleaning up temporary files...\n[main c0c24d9] feat(custom): 集成 commitizen\n 3 files changed, 815 insertions(+)\n create mode 100644 .cz-config.js\n```\n\n# CHANGELOG 自动生成\nCHANGELOG 用于记录项目所有的 commit 信息并归类版本。\n\n可以使用 VSCode 插件 [whatchanged](https://marketplace.visualstudio.com/items?itemName=axetroy.vscode-whatchanged) 或 [commit-and-tag-version](https://github.com/absolute-version/commit-and-tag-version)、[conventional-changelog](https://github.com/conventional-changelog/conventional-changelog) 自动生成 CHANGELOG。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","Git"],"categories":["学习笔记"]},{"title":"集成 lint 代码规范工具","url":"/article/b2086eb9.html","content":"\n# 前言\n书接上回，为 [Monorepo 单仓库多应用](/article/65df4aa6.html) 项目集成代码规范工具，提高代码质量。\n\n示例仓库：[qxchuckle/monorepo-test](https://github.com/qxchuckle/monorepo-test)\n\n参考：\n[【从 0 到 1 搭建 Vue 组件库框架】3. 集成 lint 代码规范工具](https://juejin.cn/post/7260499321983336509)\n[【前端工程化】项目搭建篇-项目初始化&prettier、eslint、stylelint、lint-staged、husky](https://juejin.cn/post/7353504333999505408)\n[前端工程：ESLint - eslint.config.js 配置详解](https://juejin.cn/post/7330293818361151488)\n[一文搞懂eslint、prettier以及vscode插件之间的弯弯绕绕](https://juejin.cn/post/7345352532657831987)\n[stylelint 规范你的 css](https://juejin.cn/post/7032167758674526215)\n[你不能再说你不会配置ESLint和prettier了](https://juejin.cn/post/7239987776552714300)\n[3分钟入门 StyleLint](https://juejin.cn/post/6876367482412597262)\n[使用 ESLint、Prettier 和 Stylelint 来规范代码](https://juejin.cn/post/7258831031728717881)\n[2024年｜ESlint9+Prettier从0开始配置教程](https://juejin.cn/post/7402696141495779363)\n[通过引入eslint-config包的方式解决项目代码风格和规范](https://juejin.cn/post/7201048368380969019)\n\n\n# ESLint\n[ESLint](https://eslint.org/docs/latest/use/getting-started) 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。\n\n## 安装\n仅需一行代码即可安装 ESLint：\n\n```bash\nnpm init @eslint/config@latest\n```\n\n但在 Monorepo 环境下，很可能会在最后安装依赖时出现如下错误：\n\n```bash\n√ Which package manager do you want to use? · pnpm\n☕️Installing...\n ERR_PNPM_ADDING_TO_ROOT  Running this command will add the dependency to the workspace root, which might not be what you want - if you really meant it, make it explicit by running this command again with the -w flag (or --workspace-root). If you don't want to see this warning anymore, you may set the ignore-workspace-root-check setting to true.\n```\n\n需要在 `.npmrc` 添加 `ignore-workspace-root-check=true` 配置。\n\n> 默认情况下，如果你在工作区根目录下运行 npm i 命令，npm 会显示一个警告，提示你这可能不是你想要的，因为这会将依赖添加到所有的工作区项目中。如果你想在工作区根目录下添加依赖，你需要使用-w或--workspace-root标志来明确指定。如果设置了ignore-workspace-root-check=true，那么 npm 将不会显示这个警告，而是默认在工作区根目录下添加依赖。\n\n再次运行，cli 为我们添加了五个开发依赖。\n1. [@eslint/js](https://www.npmjs.com/package/@eslint/js) 插件的 recommended 配置包含了一组被 ESLint 社区推荐的规则。\n2. [eslint](https://github.com/eslint/eslint) 是 ESLint 的核心库。\n3. [eslint-plugin-vue](https://github.com/vuejs/eslint-plugin-vue) 提供了一些针对 Vue 的 ESLint 规则。\n4. [globals](https://github.com/sindresorhus/globals) 提供了一个包含各种 JS 环境全局变量的对象，在 ESLint 中，使用 globals 来配置哪些全局变量是允许在你的代码中使用的。\n5. [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) 使 ESLint 和 Prettier 支持 TypeScript 的工具。\n\n```bash\ndevDependencies:\n+ @eslint/js ^9.10.0\n+ eslint ^9.10.0\n+ eslint-plugin-vue ^9.28.0\n+ globals ^15.9.0\n+ typescript-eslint ^8.4.0\n```\n\n还在根目录输出了 `eslint.config.mjs` 文件。\n\n```js eslint.config.mjs\nimport globals from \"globals\";\nimport pluginJs from \"@eslint/js\";\nimport tseslint from \"typescript-eslint\";\nimport pluginVue from \"eslint-plugin-vue\";\n\nexport default [\n  { files: [\"**/*.{js,mjs,cjs,ts,vue}\"] },\n  { languageOptions: { globals: globals.browser } },\n  pluginJs.configs.recommended,\n  ...tseslint.configs.recommended,\n  ...pluginVue.configs[\"flat/essential\"],\n  {\n    files: [\"**/*.vue\"],\n    languageOptions: { parserOptions: { parser: tseslint.parser } },\n  },\n];\n```\n\n## 运行\n在 package.json 中添加 lint 命令：\n`--fix` 参数表示自动修复一些错误。\n\n```json package.json\n\"scripts\": {\n  \"lint\": \"eslint --fix ./\",\n},\n```\n\n首次运行，会出现非常多的报错，但不必担心，这些只是 ESLint 对代码的检查，并不是代码出现了不可运行的错误。\n\n```bash\nC:\\chuckle\\qx\\study_demo\\Monorepo\\pnpmWorkspaceTest\\demo\\src\\views\\List.vue\n  1:1   error  Component name \"List\" should always be multi-word             vue/multi-word-component-names\n  6:11  error  Custom elements in iteration require 'v-bind:key' directives  vue/valid-v-for\n\nC:\\chuckle\\qx\\study_demo\\Monorepo\\pnpmWorkspaceTest\\demo\\src\\views\\list\\Estimated.vue\n   1:1   error  Component name \"Estimated\" should always be multi-word  vue/multi-word-component-names\n  31:36  error  '_' is defined but never used                           @typescript-eslint/no-unused-vars\n  31:39  error  'index' is defined but never used                       @typescript-eslint/no-unused-vars\n\n# ...\n```\n\n## 配置文件变化\nESLint v8.x 的生命周期终止日期为 2024-10-05，此后将不再维护。\n在最新的 v9.x 版本中，使用了新的 `eslint.config.js` [Flat config（扁平化配置）](https://eslint.org/docs/latest/use/configure/configuration-files)，而不再使用传统的 **.eslintrc** 配置。[迁移至 v9.x](https://eslint.org/docs/latest/use/migrate-to-9.0.0)。\n\n> 关于 eslint 作出这一改变的原因，可以参阅 [前端工程：ESLint - 扁平化配置系统【译】](https://juejin.cn/post/7330203430256787508)。\n\n可以使用如下命令，自动转换传统配置文件，但不保证在不进行进一步修改的情况下立即生效。\n\n```bash\nnpx @eslint/migrate-config .eslintrc.json\n```\n\n还可以安装 `@eslint/eslintrc` 包，导入 `FlatCompat()` 并创建一个新实例来转换现有的 eslintrc 配置。\n\n```js\nimport { FlatCompat } from \"@eslint/eslintrc\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n// mimic CommonJS variables -- not needed if using CommonJS\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst compat = new FlatCompat({\n    baseDirectory: __dirname\n});\n\nexport default [\n    // mimic ESLintRC-style extends\n    ...compat.extends(\"eslint-config-my-config\"),\n];\n```\n\n\n## 配置提示\n安装 [eslint-define-config](https://github.com/eslint-types/eslint-define-config) 插件，在编辑配置时提供代码提示。\n\n```bash\npnpm add -wD eslint eslint-define-config\n```\n\n该插件提供了 **defineConfig** 和 **defineFlatConfig** 函数，分别用于传统配置和平面配置。\n\n```js\nimport { defineFlatConfig } from \"eslint-define-config\";\nexport default defineFlatConfig([\n  { files: [\"**/*.{js,mjs,cjs,ts,vue}\"] },\n  // ...\n]);\n```\n\n## 配置对象简介\n[Flat config（扁平化配置）](https://eslint.org/docs/latest/use/configure/configuration-files) 导出一个包含若干**配置对象**的数组。官方文档：[配置 ESLint](https://eslint.org/docs/latest/use/configure/)\n\n配置对象由以下属性组成：\n1. [files](https://eslint.org/docs/latest/use/configure/configuration-files#specifying-files-and-ignores)：glob 数组，表示配置适用的文件，**未指定时适用于所有与其他配置对象匹配的文件**。\n2. [ignores](https://eslint.org/docs/latest/use/configure/ignore)：glob 数组，表示忽略检查的文件，\n3. [languageOptions](https://eslint.org/docs/latest/use/configure/language-options)：配置如何检查 js 代码\n  - **ecmaVersion**：strIng，表示支持的 ES 语法版本（只是语法，不包括 ES 的全局变量，全局变量要在 globals 中指定），可以是年份（如 2022）或者版本号（如 5），默认为 latest，表示最新版本\n  - **sourceType**：string，表示js 源码类型，\"script\"表示传统 script 标签引入，\"module\"表示 esm，\"commonjs\"表示CommonJS 文件。默认情况下，.js 和 .mjs 文件使用 \"module\"；.cjs 文件使用 \"commonjs\"\n  - **globals**：对象，指定添加到全局作用域中的其他对象，避免从第三方库中引入的全局变量不能被识别\n  - **parser**：默认为 espree，指定解析器（包含 parse() 方法或 parseForESLint() 方法的对象）\n  - **parserOptions**：对象，指定 parser 所需的额外配置选项，\n4. **linterOptions**：对象，包含与 linting 过程相关的设置\n  - **noInlineConfig** ：boolean，表示是否允许内联配置\n  - **reportUnusedDisableDirectives**：boolean，表示是否应该跟踪和报告未用的禁用指令\n5. [processor](https://eslint.org/docs/latest/use/configure/plugins#specify-a-processor)：包含 preprocess() 和 postprocess() 方法的对象，或者指示插件中处理器的名称的字符串（例如 \"pluginName/processorName\"）。\n6. [plugins](https://eslint.org/docs/latest/use/configure/plugins)：包含插件名称与对应的插件对象的名值对对象。如果指定了 files，则只适用于与之匹配的文件。\n7. [rules](https://eslint.org/docs/latest/use/configure/rules)：包含具体的规则配置，当指定了 files 或 ignores 时，这些规则配置仅对匹配的文件可用。[内置规则](https://eslint.org/docs/latest/rules/)。规则值: **warn(警告) | error(报错) | off**。\n8. [settings](https://eslint.org/docs/latest/use/configure/configuration-files#configuring-shared-settings)：包含名称值对的对象，用于所有规则都可以访问的信息。\n\n### 级联配置\n当多个配置对象同时匹配一个给定的 glob 时，配置对象会被合并，如果有冲突时，后面的对象会覆盖前面的对象。\n\n```js\nexport default [\n  {\n    files: [\"**/*.js\"],\n    languageOptions: {\n      globals: {\n        MY_CUSTOM_GLOBAL: \"readonly\",\n      },\n    },\n  },\n  {\n    files: [\"tests/**/*.js\"],\n    languageOptions: {\n      globals: {\n        it: \"readonly\",\n        describe: \"readonly\",\n      },\n    },\n  },\n];\n\n```\n\n上述配置中，对于所有的 js 文件，都只有一个自定义全局对象 MY_CUSTOM_GLOBAL，而对于 tests 目录下的 js 文件，还会有 it 和 describe 全局对象。\n\n### files\n默认情况下，[files](https://eslint.org/docs/latest/use/configure/configuration-files#specifying-files-and-ignores) 会匹配 `**/*.js`、`**/*.cjs` 和 `**/*.mjs`。 一般使用 files 和 ignores 的组合来决定配置对象的文件适用范围。\n\n当一个配置对象没有 files 字段，则该配置对象为**共享配置**，供其他配置对象使用。\n\n### ignores\n[ignores](https://eslint.org/docs/latest/use/configure/ignore) 默认忽略 `**/node_modules/**` 和 `.git/**`。\n\n对于仅有 ignores 的配置对象，则为**全局忽略配置**，会对默认忽略项进行扩展。\n\n```js\n{\n  ignores: [\"**/*.d.ts\", \"**/dist/*\"],\n},\n```\n\n指定了 ignore，最好也要指定 files：\n如果有 ignores 而没有 files，但有任何其他配置项（如 rules），那么该配置对象适用于**除了 ignores 指定的文件外的所有文件**，相当于 files 为 `**/*`。\n\n通过 `!` 取消忽略文件和目录，包括默认忽略项。\n\n```js 忽略 build 目录中除 build/test.js 之外的所有内容。\n{\n  ignores: [\n    // 使用 build/** 会忽略整个目录及其内容，因此遍历将完全跳过目录，也就无法取消忽略其中的任何内容。\n    \"build/**/*\",\n    \"!build/test.js\"\n  ]\n}\n```\n\n安装 [@eslint/compat](https://www.npmjs.com/package/@eslint/compat)，通过 `includeIgnoreFile()`，可以导入传统的 .gitignore 文件。\n\n```js\nimport { includeIgnoreFile } from \"@eslint/compat\";\n// ...\nconst gitignorePath = path.resolve(__dirname, \".gitignore\");\n\nexport default [\n  includeIgnoreFile(gitignorePath),\n];\n```\n\n\n### linterOptions\n专门用来配置检查过程的选项，对文件源码的解析方式没有影响。它有两个选项：\n1. **noInlineConfig**：默认为 false，表示是否禁用内联配置，内联配置是通过 `/*eslint*/` 注释实现的，例如 `/*eslint semi: error*/`。设置为 true，则会忽略所有内联配置。\n2. **reportUnusedDisableDirectives** 像 `/*eslint-disable*/` 和 `/*eslint-disable-next-line*/` 这样的禁用指令是用来禁用 ESLint 规则的，围绕代码的某些部分。随着代码的变化，这些指令有可能不再需要，因为代码的变化使规则不再被触发。通过设置该选项为 true，可以把未用的禁用指令被报告为警告。\n\n### languageOptions\n[languageOptions](https://eslint.org/docs/latest/use/configure/language-options) 是配置语言选项。\n1. **ecmaVersion** 指定支持的 ES 语法版本，确定语法和可用的全局变量，可以是年份（如 2022）或者版本号（如 5），默认为 latest，表示最新版本。\n2. **sourceType** 表示正在使用的 JavaScript 文件的模式。有以下三种值：\n  - **module** ESM 模块（当ecmaVersion为3或5时无效）。代码具有模块范围并以严格模式运行。\n  - **commonjs** CommonJS 模块。代码具有顶级函数作用域，并以非严格模式运行。\n  - **script** 非模块。代码具有共享的全局范围并以非严格模式运行。\n  - 默认情况下，.js 和 .mjs 文件的 sourceType 是 \"module\"，而 .cjs 文件则是 \"commonjs\"。\n3. **parser** [官方文档](https://eslint.org/docs/latest/use/configure/parser)，自定义解析器将 JavaScript 代码转换为抽象语法树，以供 ESLint 检查。\n4. **parserOptions** 键值对对象，用于向自定义解析器传递选项。\n5. **globals** 配置可用的全局变量，键是全局变量名，值为 readonly、writable、off 之一，通常配合 [globals](https://github.com/sindresorhus/globals) 库使用。\n\n### plugins\n[plugins](https://eslint.org/docs/latest/use/configure/plugins) 插件是 eslint 最重要的配置，用于在 ESLint 项目中共享规则、处理器、配置、解析器等等。\n\n可以通过 `<插件名>/` 使用插件中特定的规则：\n\n```js\n{\n  rules: {\n    \"@typescript-eslint/no-unused-vars\": \"off\",\n    \"@typescript-eslint/no-explicit-any\": \"off\",\n    \"@typescript-eslint/no-unused-expressions\": \"off\",\n    \"@typescript-eslint/no-unsafe-function-type\": \"off\",\n    \"vue/multi-word-component-names\": \"off\",\n    \"vue/no-unused-vars\": \"off\",\n  },\n},\n```\n\n插件本质是一个向 ESLint 公开某些属性的 JavaScript 对象，创建插件详见[官方文档-Create Plugins](https://eslint.org/docs/latest/extend/plugins)。\n\n### processor\n[processor](https://eslint.org/docs/latest/use/configure/plugins#specify-a-processor) 用于将非 js 文件转化为 eslint 可以检查的代码片段。\n\n```js 处理 markdown 文件\nimport markdown from \"@eslint/markdown\";\nexport default [\n  {\n    files: [\"**/*.md\"],\n    plugins: {\n      markdown\n    },\n    processor: \"markdown/markdown\"\n  }\n];\n```\n\n## 工作流程\nESLint 通过 `parser` 指定的解析器，如 `@typescript-eslint/parser`，将源码转换为抽象语法树（AST），供后续流程使用，而 `parserOptions` 可以对解析器的能力进行详细设置。\n\nESLint 提供了[自定义规则](https://eslint.org/docs/latest/extend/custom-rule-tutorial)的接口，开发者需要遵照接口，根据分析器的 AST 产物，实现规范检查逻辑，再将实现的多条规范聚合为 plugin 插件的形式，形成**规则集**。\n\n有了规则集，能够理解规范，还需要进一步在 `rules` 字段中对这些规则进行开启或者关闭的声明，只有开启的规则才会生效。\n\n规则集中有大量的规则，完全在项目中一条条配置是不可取的，社区逐渐演进出了许多配置预设，从而减少绝大多数手动配置的工作量。大部分插件本身也自带推荐预设，如 `eslint:recommended`、`@typescript-eslint/recommended`。\n\n最新的扁平化配置也使得我们很容易去自定义、覆盖一些独特的配置。\n\n\n## 编辑配置\n按目前项目需求编辑规则，关闭一些不需要的检查。\n\n```js eslint.config.mjs\n// @ts-check\nimport globals from \"globals\";\nimport pluginJs from \"@eslint/js\";\nimport tseslint from \"typescript-eslint\";\nimport pluginVue from \"eslint-plugin-vue\";\nimport { defineFlatConfig } from \"eslint-define-config\";\n\n/// <reference types=\"@eslint-types/typescript-eslint\" />\n\nexport default defineFlatConfig([\n  // 插件的预设配置放在最前面\n  pluginJs.configs.recommended,\n  ...tseslint.configs.recommended,\n  ...pluginVue.configs[\"flat/recommended\"],\n  {\n    languageOptions: {\n      // 配置全局变量\n      globals: {\n        ...globals.browser,\n        ...globals.node,\n        InstanceType: \"readonly\",\n        NodeJS: \"readonly\",\n      },\n    },\n  },\n  {\n    // 因为demo使用了auto-imports插件，所以需要把自动导入的变量加到全局变量配置里\n    files: [\"demo/src/**/*\"],\n    languageOptions: {\n      // 配置全局变量\n      globals: {\n        ref: \"readonly\",\n        onMounted: \"readonly\",\n        nextTick: \"readonly\",\n      },\n    },\n  },\n  // 需要忽略的文件\n  {\n    ignores: [\"**/*.d.ts\", \"**/dist/*\"],\n  },\n  // 一些自定义规则\n  {\n    rules: {\n      \"@typescript-eslint/no-unused-vars\": \"off\",\n      \"@typescript-eslint/no-explicit-any\": \"off\",\n      \"@typescript-eslint/no-unused-expressions\": \"off\",\n      \"@typescript-eslint/no-unsafe-function-type\": \"off\",\n      \"vue/multi-word-component-names\": \"off\",\n      \"vue/no-unused-vars\": \"off\",\n      \"no-unused-vars\": \"off\",\n      semi: \"error\",\n      \"prefer-const\": \"error\",\n    },\n  },\n  // 匹配 vue、ts 文件，使用 tseslint.parser\n  {\n    files: [\"**/*.ts\", \"**/*.vue\"],\n    languageOptions: {\n      parserOptions: {\n        parser: tseslint.parser,\n        project: \"./tsconfig.eslint.json\",\n        extraFileExtensions: [\"vue\"],\n      },\n    },\n  },\n]);\n```\n\n我们希望 ESLint 能覆盖所有源码文件，一般新创建一个 `tsconfig.eslint.json`，在其中包含所有希望被规范化的源码文件。\n\n```json tsconfig.eslint.json\n{\n  // eslint 检查专用，不要包含到 tsconfig.json 中\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"noEmit\": true\n  },\n  // 只检查，不构建，因此要包含所有需要检查的文件\n  \"include\": [\n    \"**/*\",\n    // .xxx.js 文件需要单独声明，例如 .eslintrc.js\n    \"**/.*.*\"\n  ],\n  \"exclude\": [\n    // 排除产物目录\n    \"**/dist\",\n    \"**/node_modules\"\n  ]\n}\n```\n\n注意，tsconfig 的文件集合范围总是需要 >= ESLint 的 files 范围，否则会出现该 TSConfig 不包括此文件的报错。\n\n```bash 该 TSConfig 不包括此文件的报错\nC:\\chuckle\\qx\\study_demo\\Monorepo\\pnpmWorkspaceTest\\scripts\\utils.ts\n  0:0  error  Parsing error: ESLint was configured to run on `<tsconfigRootDir>/scripts\\utils.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.eslint.json\nFound unexpected extension `vue` specified with the `parserOptions.extraFileExtensions` option. Did you mean `.vue`?\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/troubleshooting/typed-linting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file\n```\n\n## 社区规则集\nESLint 拥有许多成熟的规则集，这些规则集都是成熟团队的实践。它们通过 `plugin` 实现了很多个性化的规则，又内置了海量的 `rules` 配置预设。\n\n[eslint-config-airbnb](https://github.com/airbnb/javascript) Airbnb 规则集\n[eslint-config-alloy](https://github.com/AlloyTeam/eslint-config-alloy) 腾讯 AlloyTeam 的规则集\n[eslint-config-standard](https://github.com/standard/eslint-config-standard) StandardJS 规则集\n\n# Stylelint\n[Stylelint](https://github.com/stylelint/stylelint) 是 CSS 样式的 Lint 工具，用于在代码中发现并报告样式代码中的问题。\n\n它与 ESLint 非常相似，包括配置文件、规则等，只是它专注于 CSS 样式的检查。\n\n## 安装\n\n```bash\npnpm i -wD stylelint\n```\n\n继续安装一些项目需要的插件、规则集。\n1. [stylelint-config-standard-scss](https://github.com/stylelint-scss/stylelint-config-standard-scss)：集成完整的 sass 规则集。它本身继承了很多东西，包括 sass 规则实现的插件、css 标准规则集 [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard) 等。\n2. [stylelint-config-recommended-vue](https://github.com/ota-meshi/stylelint-config-recommended-vue)：使 Stylelint 支持对 .vue 文件的 style 标签部分进行检查。\n3. [stylelint-config-recess-order](https://github.com/stormwarning/stylelint-config-recess-order)：一种推荐的 css 属性排序的规则（先写定位，再写盒模型，再写内容区样式，最后写 CSS3 相关属性）。\n4. [@stylistic/stylelint-plugin](https://github.com/elirasza/stylelint-stylistic)：Stylelint 升级到 15.0.0 大版本后，计划废弃风格相关的规则，这部分内容分离出来由社区维护，需要单独安装。(若使用 prettier 管理代码风格，则不必使用该插件)\n\n```bash\npnpm i -wD stylelint-config-standard-scss stylelint-config-recommended-vue stylelint-config-recess-order @stylistic/stylelint-plugin\n```\n\n安装 [stylelint-define-config](https://www.npmjs.com/package/stylelint-define-config) 以获得配置提示。\n\n```bash\npnpm i -wD stylelint-define-config\n```\n\n## 配置\nStylelint 的配置文件与 ESLint 的传统配置 .eslintrc 相似。\n\n在根目录创建 **stylelint.config.mjs** 文件。具体的规则配置项，详见[官方文档-rules](https://stylelint.io/user-guide/rules)。\n\n```js\n// @ts-check\nimport defineConfig from \"stylelint-define-config\";\n\n/// <reference types=\"@stylelint-types/stylelint-scss\" />\n\nexport default defineConfig({\n  // 继承的预设，这些预设包含了规则集插件\n  extends: [\n    // 基本 scss 规则\n    \"stylelint-config-standard-scss\",\n    // scss vue 规则\n    \"stylelint-config-recommended-vue/scss\",\n    // 样式属性顺序规则\n    \"stylelint-config-recess-order\",\n  ],\n  plugins: [\n    // 代码风格插件\n    \"@stylistic/stylelint-plugin\",\n  ],\n  rules: {\n    // 自定义规则集的启用 / 禁用\n    \"@stylistic/max-line-length\": 100,\n    \"no-empty-source\": null,\n  },\n  // glob 匹配排除的文件\n  ignoreFiles: [\"**/dist/*\", \"**/node_modules/*\"],\n  overrides: [\n    {\n      files: [\"*.html\", \"**/*.html\"],\n      customSyntax: \"postcss-html\",\n    },\n  ],\n});\n```\n\n### 修复 html 报错\n在对 html 检查时，可能有如下莫名其妙的报错：\n\n```bash\ndemo/index.html\n  1:1  ✖  Unknown word  CssSyntaxError\n```\n\n针对 html 格式文件采用自定义语法解析器：\n\n```bash\npnpm i -wD postcss-html\n```\n\n```js stylelint.config.mjs\noverrides: [\n  {\n    files: [\"*.html\", \"**/*.html\"],\n    customSyntax: \"postcss-html\",\n  },\n],\n```\n\n## 运行\n编辑 package.json，添加 lint 命令。\n\n```json package.json\n\"scripts\": {\n  \"lint:style\": \"stylelint --fix ./**/*.{css,scss,vue,html}\",\n  \"build:ui\": \"pnpm run lint:fix && pnpm run lint:style && pnpm run type:src && pnpm --filter ./packages/** run build && pnpm run dts-mv && pnpm run css-mv\"\n},\n```\n\nStylelint 将自动按规则格式化 CSS，并报告了需要手动修复的问题。\n\n# VSCode 插件\n配合 VSCode 插件 [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)、[Stylelint](https://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint)、[Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) 使用，可以在编辑器中实时检查代码规范。\n\n> 如果插件没有实时提示，可以查看面板->输出，找到对应插件查看问题，多半是 VSCode 版本需要升级了。\n\n在 `.vscode\\settings.json` 对插件进行配置：\n\n```json .vscode\\settings.json\n{\n  // 指定 typescript 的路径，使其能够找到项目中安装的 typescript。\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  // 关闭 IDE 自带的样式验证\n  \"css.validate\": false,\n  \"less.validate\": false,\n  \"scss.validate\": false,\n  // 指定 stylelint 生效的文件类型(尤其是 vue 文件)。\n  \"stylelint.validate\": [\n    \"css\",\n    \"scss\",\n    \"postcss\",\n    \"vue\"\n  ],\n  // 启用 eslint 的格式化能力\n  \"eslint.format.enable\": true,\n  // eslint 会在检查出错误时，给出对应的文档链接地址\n  \"eslint.codeAction.showDocumentation\": {\n    \"enable\": true\n  },\n  // 指定 eslint 生效的文件类型(尤其是 vue 文件)。\n  \"eslint.probe\": [\n    \"javascript\",\n    \"typescript\",\n    \"vue\"\n  ],\n  // 指定 eslint 的工作区\n  // \"eslint.workingDirectories\": [\n  //   {\n  //     \"mode\": \"auto\"\n  //   }\n  // ],\n  // 指定 eslint 的 node_modules 路径，使其能够找到项目中安装的 eslint。\n  \"eslint.nodePath\": \"node_modules\",\n  // 在保存时，自动修复 lint 错误。\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": \"explicit\",\n    \"source.fixAll.stylelint\": \"explicit\"\n  },\n  // 保存时自动格式化\n  \"editor.formatOnSave\": true,\n}\n```\n\n# 代码风格\n我们通过 **Stylelint** 管理了 CSS 的**代码质量**，且 ESLint 更多是用来管理代码质量。\n\nESLint 在 v8.53.0 版本弃用了代码格式化规则，[deprecating-formatting-rules](https://eslint.org/blog/2023/10/deprecating-formatting-rules/)，但这些规则仍然能用，真正的移除预计会在 v10 版本。\n\n仍要使用 ESLint 去管理代码风格，可以使用 [@stylistic/eslint-plugin-js](https://www.npmjs.com/package/@stylistic/eslint-plugin-js) 或 [@stylistic/eslint-plugin-ts](https://www.npmjs.com/package/@stylistic/eslint-plugin-ts) 插件，这些插件由 [Anthony Fu](https://github.com/antfu) 维护，包含了 ESLint 核心和 typescript-eslint 中废弃的格式化规则。\n\n代码风格应该交给专业的插件去做，比如 [Prettier](https://github.com/prettier/prettier)。\n\n# Prettier\n[Prettier](https://prettier.io/docs/en/index.html) 是一个代码格式化工具，它会自动格式化代码，使代码风格保持一致。\n\n并且支持 vue、react 等框架的 SFC 文件，以及 markdown、json 等文件的格式化。它会删除了所有原始代码格式，并确保所有输出的代码符合一致的格式。\n\n## 安装\n```bash\npnpm i -wD prettier\n```\n\n在 .vscode/setting.json 中设置一些配置。\n\n```json\n{\n  // 设置默认格式化程序\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  // 保存时自动格式化\n  \"editor.formatOnSave\": true,\n}\n```\n\n`.prettierignore` 为 Prettier 的忽略文件。\n\n## eslint 集成 prettier\neslint 及其相关插件目前仍然管理着一部分代码风格，我们需要将 prettier 的规则集成覆盖到 eslint 中，并解决 eslint 和 prettier 之间的冲突。\n\n两个插件：\n1. [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier)：基于 prettier 代码风格的 eslint 规则。即 eslint 使用 prettier 规则来格式化代码，并将差异报告为单个ESLint问题\n2. [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)：禁用所有与格式相关的 eslint 规则，解决 prettier 与 eslint 规则冲突。\n\n```bash\npnpm install -wD eslint-config-prettier eslint-plugin-prettier\n```\n\n按[文档](https://github.com/prettier/eslint-plugin-prettier#configuration-new-eslintconfigjs)操作导入 `eslint-plugin-prettier/recommended`，该 recommended 已经集成了两者的配置。\n\n注意：将其添加为文件中配置数组的最后一项，以便 eslint-config-prettier 有机会覆盖其他配置。\n\n```js eslint.config.mjs\nimport eslintPluginPrettierRecommended from \"eslint-plugin-prettier/recommended\";\nexport default defineFlatConfig([\n  // ....\n  eslintPluginPrettierRecommended,\n  {\n    rules: {\n      // prettier 配置为警告而不是报错\n      'prettier/prettier': ['warn'],\n    },\n  },\n]);\n```\n\n\n\n## 与 stylelint 集成\n\n> 从 Stylelint v15 开始，[所有与样式相关的规则都已弃用](https://stylelint.io/migration-guide/to-15/#deprecated-stylistic-rules)。如果您使用的是 v15 或更高版本，并且未使用这些弃用的规则，则 [stylelint-config-prettier](https://www.npmjs.com/package/stylelint-config-prettier) 插件不再是必要的。\n\n## 配置文件\n创建 `.prettierrc` 文件，并设定一些规则。[configuration](https://prettier.io/docs/en/configuration)，[options](https://prettier.io/docs/en/options)。\n我喜欢使用 `prettier.config.mjs` 配合 [prettier-define-config](https://www.npmjs.com/package/@archoleat/prettier-define-config) 插件以获得配置提示。\n\n```js prettier.config.mjs\n// @ts-check\nimport { defineConfig } from '@archoleat/prettier-define-config';\nexport default defineConfig({\n  arrowParens: 'always', // 箭头函数参数周围加上括号\n  bracketSameLine: true, // 大括号与代码在同一行\n  bracketSpacing: true, // 大括号内部加空格\n  semi: true, // 分号结尾\n  experimentalTernaries: false, // 不使用实验性三元表达式\n  singleQuote: true, // 使用单引号\n  jsxSingleQuote: true, // JSX属性值使用单引号\n  quoteProps: 'preserve', // 保留引号样式\n  trailingComma: 'all', // 尾随逗号保留\n  singleAttributePerLine: false, // 不强制单个属性换行\n  htmlWhitespaceSensitivity: 'css', // HTML空格敏感性为css\n  vueIndentScriptAndStyle: false, // Vue脚本和样式不缩进\n  proseWrap: 'never', // 文本不换行\n  insertPragma: false, // 不插入格式化标记\n  printWidth: 80, // 打印宽度为80个字符\n  requirePragma: false, // 不要求格式化标记\n  useTabs: false, // 不使用Tab缩进\n  embeddedLanguageFormatting: 'auto', // 嵌入语言格式自动\n  tabWidth: 2, // Tab宽度为2个空格\n  endOfLine: 'auto', // 行尾自动\n});\n```\n\n> VSCode 响应配置修改有时候非常慢，善用 reload。\n\n在 `.vscode\\settings.json` 中配置自动格式化等。\n\n```json\n{\n  // 保存时自动格式化\n  \"editor.formatOnSave\": true,\n  // 指定格式化工具为 prettier\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"[vue]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascriptreact]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescriptreact]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[json]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[html]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[css]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[less]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[scss]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n}\n```\n\n## 运行\n除了在保存时自动格式化（这个也看个人喜好开启），每当 git 提交代码前，也应该格式化代码。\n\n暂时不在这里展开，后续在 git hook 上集成 prettier 的操作。\n\n```bash https://prettier.nodejs.cn/docs/en/cli.html\n# 暂时先使用命令行格式化吧\nnpx prettier . --write\n```\n\n## Replace ··· with ↹↹\n这是因为没有统一好项目的缩进风格。\n\n在 `.vscode\\settings.json` 中配置强制使用2个空格缩进：\n\n```json\n{\n  \"editor.tabSize\": 2,\n  \"editor.insertSpaces\": true,\n  \"editor.detectIndentation\": false,\n}\n```\n\n# 完整配置\n[qxchuckle/monorepo-test](https://github.com/qxchuckle/monorepo-test)\n\n```js eslint.config.mjs\n// @ts-check\nimport globals from 'globals';\nimport pluginJs from '@eslint/js';\nimport tseslint from 'typescript-eslint';\nimport pluginVue from 'eslint-plugin-vue';\nimport { defineFlatConfig } from 'eslint-define-config';\nimport eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';\n\n/// <reference types=\"@eslint-types/typescript-eslint\" />\n\nexport default defineFlatConfig([\n  // 插件的预设配置放在最前面\n  pluginJs.configs.recommended,\n  ...tseslint.configs.recommended,\n  ...pluginVue.configs['flat/recommended'],\n  {\n    languageOptions: {\n      // 配置全局变量\n      globals: {\n        ...globals.browser,\n        ...globals.node,\n        InstanceType: 'readonly',\n        NodeJS: 'readonly',\n      },\n    },\n  },\n  {\n    // 因为demo使用了auto-imports插件，所以需要把自动导入的变量加到全局变量配置里\n    files: ['demo/src/**/*'],\n    languageOptions: {\n      // 配置全局变量\n      globals: {\n        ref: 'readonly',\n        onMounted: 'readonly',\n        nextTick: 'readonly',\n      },\n    },\n  },\n  // 需要忽略的文件\n  {\n    ignores: ['**/*.d.ts', '**/dist/*'],\n  },\n  // 一些自定义规则\n  {\n    rules: {\n      '@typescript-eslint/no-unused-vars': 'off',\n      '@typescript-eslint/no-explicit-any': 'off',\n      '@typescript-eslint/no-unused-expressions': 'off',\n      '@typescript-eslint/no-unsafe-function-type': 'off',\n      'vue/multi-word-component-names': 'off',\n      'vue/no-unused-vars': 'off',\n      'no-unused-vars': 'off',\n      semi: 'error',\n      'prefer-const': 'error',\n    },\n  },\n  // 匹配 vue、ts 文件，使用 tseslint.parser\n  {\n    files: ['**/*.ts', '**/*.vue'],\n    languageOptions: {\n      parserOptions: {\n        parser: tseslint.parser,\n        project: './tsconfig.eslint.json',\n        extraFileExtensions: ['vue'],\n      },\n    },\n  },\n  eslintPluginPrettierRecommended,\n  {\n    rules: {\n      // prettier 配置为警告而不是报错\n      'prettier/prettier': ['warn'],\n    },\n  },\n]);\n```\n\n```js stylelint.config.mjs\n// @ts-check\nimport defineConfig from 'stylelint-define-config';\n\n/// <reference types=\"@stylelint-types/stylelint-scss\" />\n\nexport default defineConfig({\n  // 继承的预设，这些预设包含了规则集插件\n  extends: [\n    // 基本 scss 规则\n    'stylelint-config-standard-scss',\n    // scss vue 规则\n    'stylelint-config-recommended-vue/scss',\n    // 样式属性顺序规则\n    'stylelint-config-recess-order',\n  ],\n  plugins: [\n    // 代码风格插件，应该使用 prettier 管理代码风格\n    // '@stylistic/stylelint-plugin',\n  ],\n  rules: {\n    // 自定义规则集的启用 / 禁用\n    // '@stylistic/max-line-length': 100,\n    'no-empty-source': null,\n  },\n  // glob 匹配排除的文件\n  ignoreFiles: ['**/dist/*', '**/node_modules/*'],\n  overrides: [\n    {\n      files: ['*.html', '**/*.html'],\n      customSyntax: 'postcss-html',\n    },\n  ],\n});\n```\n\n```js prettier.config.mjs\n// @ts-check\nimport { defineConfig } from '@archoleat/prettier-define-config';\n\nexport default defineConfig({\n  arrowParens: 'always', // 箭头函数参数周围加上括号\n  bracketSameLine: true, // 大括号与代码在同一行\n  bracketSpacing: true, // 大括号内部加空格\n  semi: true, // 分号结尾\n  experimentalTernaries: false, // 不使用实验性三元表达式\n  singleQuote: true, // 使用单引号\n  jsxSingleQuote: true, // JSX属性值使用单引号\n  quoteProps: 'preserve', // 保留引号样式\n  trailingComma: 'all', // 尾随逗号保留\n  singleAttributePerLine: false, // 不强制单个属性换行\n  htmlWhitespaceSensitivity: 'css', // HTML空格敏感性为css\n  vueIndentScriptAndStyle: false, // Vue脚本和样式不缩进\n  proseWrap: 'never', // 文本不换行\n  insertPragma: false, // 不插入格式化标记\n  printWidth: 80, // 打印宽度为80个字符\n  requirePragma: false, // 不要求格式化标记\n  useTabs: false, // 不使用Tab缩进\n  embeddedLanguageFormatting: 'auto', // 嵌入语言格式自动\n  tabWidth: 2, // Tab宽度为2个空格\n  endOfLine: 'auto', // 行尾自动\n});\n```\n\n```json .vscode\\settings.json\n{\n  \"editor.tabSize\": 2, // 设置缩进的空格数\n  \"editor.insertSpaces\": true, // 使用空格而不是制表符进行缩进\n  \"editor.detectIndentation\": false, // 禁用自动检测文件的缩进方式\n  \"files.exclude\": {\n    \"**/.git\": true,\n    \"**/.svn\": true,\n    \"**/.hg\": true,\n    \"**/CVS\": true,\n    \"**/.DS_Store\": true,\n    \"**/Thumbs.db\": true,\n    \"**/node_modules\": false,\n    \"**/.deploy_git\": true,\n    \"**/.history\": true\n  },\n  // 指定哪些文件不参与搜索\n  \"search.exclude\": {\n    \"**/node_modules\": true,\n    \"dist\": true,\n    \"build\": true,\n    \"yarn.lock\": true\n  },\n  // 指定 typescript 的路径，使其能够找到项目中安装的 typescript。\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  // 关闭 IDE 自带的样式验证\n  \"css.validate\": false,\n  \"less.validate\": false,\n  \"scss.validate\": false,\n  // 指定 stylelint 生效的文件类型(尤其是 vue 文件)。\n  \"stylelint.validate\": [\n    \"css\",\n    \"scss\",\n    \"postcss\",\n    \"vue\"\n  ],\n  // 启用 eslint 的格式化能力\n  \"eslint.format.enable\": true,\n  // eslint 会在检查出错误时，给出对应的文档链接地址\n  \"eslint.codeAction.showDocumentation\": {\n    \"enable\": true\n  },\n  // 指定 eslint 生效的文件类型(尤其是 vue 文件)。\n  \"eslint.probe\": [\n    \"javascript\",\n    \"typescript\",\n    \"vue\",\n  ],\n  // 指定 eslint 的工作区\n  // \"eslint.workingDirectories\": [\n  //   {\n  //     \"mode\": \"auto\"\n  //   }\n  // ],\n  // 指定 eslint 的 node_modules 路径，使其能够找到项目中安装的 eslint。\n  \"eslint.nodePath\": \"node_modules\",\n  // 在保存时，自动修复 lint 错误。\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": \"explicit\",\n    \"source.fixAll.stylelint\": \"explicit\"\n  },\n  // 保存时自动格式化\n  \"editor.formatOnSave\": true,\n  // 指定格式化工具为 prettier\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"[vue]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascriptreact]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescriptreact]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[json]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[html]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[css]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[less]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[scss]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  // 行尾默认为 LF 换行符而非 CRLF\n  \"files.eol\": \"\\n\",\n  // 自动补充闭合的 HTML 标签\n  \"html.autoClosingTags\": true,\n}\n```\n\n\n\n\n# 总结\n我们在原先的 Monorepo 项目中集成了最新的 ESLint 和 Stylelint，以对代码质量进行检查。\n\n然后，我们引入了 Prettier，使代码风格保持一致。\n\n最后，我们解决了 ESLint 和 Prettier 之间的冲突，并配合 VSCode 设置了一系列自动化配置。\n\n> 每次都进行全量 lint 检查是非常耗时的，在下一篇文章中进行解决。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"Monorepo 单仓库多应用","url":"/article/65df4aa6.html","content":"\n# 前言\n最近想把之前在各个项目中封装好的 Vue 组件单独拿出来发布个组件库，但在原先的仓库中修修补补，总还有些问题。\n使用 vite-plugin-dts 插件生成 dts 时会报错，TS写的组件库没有类型那可太糟糕了。\n\n看了一圈，绝大部分组件库、各大开源软件都使用了一个叫 **Menorepo** 的东西，那就学学吧，少踩点坑。\n\n示例仓库：[qxchuckle/monorepo-test](https://github.com/qxchuckle/monorepo-test)\n\n**参考：**\n[初识Monorepo-转转技术团队](https://juejin.cn/post/7237145375311839289?searchId=20240905230846FA918CA4EB0D04505500)\n[Monorepo 的前世今生](https://juejin.cn/post/7326268989011673097)\n[开源项目都在用 monorepo，但是你知道居然有那么多坑么？](https://juejin.cn/post/6950082433647640612)\n[【从 0 到 1 搭建 Vue 组件库框架】](https://juejin.cn/column/7257547252540178469)\n[带你了解更全面的 Monorepo - 优劣、踩坑、选型](https://juejin.cn/post/7215886869199896637)\n[为什么越来越多的项目选择 Monorepo？](https://juejin.cn/post/7207743145999368229)\n\n> 没有前人的经验，摸索工程化的东西确实麻烦，毕竟这东西没有一个标准答案，项目结构、构建流程等，都需要根据实际情况来定制。\n\n# 什么是 Menorepo\n**Menorepo** 即**单仓库多应用**，是一种软件开发的**策略模式**、是管理项目代码的一种方式。\n\n项目代码管理的演变：\n1. **monolith**(单仓库单应用)：传统的单体式应用程序通常将所有的功能和模块打包在一起，形成一个单一的代码库和部署单元。这种单一的代码库包含了应用程序的所有部分，从前端界面到后端逻辑，甚至包括数据库模式和配置文件等。\n缺点：高度耦合，代码臃肿，难以实现部分更新和独立扩展的灵活性。\n1. **multirepo**(多仓库多应用)：将功能模块、组件或服务分别存放在独立仓库中，可以实现独立的版本控制、构建、部署和发布，方便不同开发者进行并行开发和维护，减少代码冲突，简化协作流程。每个模块的发布与更新互不依赖，提高了开发和发布的灵活性。\n缺点：频繁发布、安装 npm 包过程繁琐，多仓维护成本高，同步依赖版本、统一环境存在问题。\n1. **monorepo**(单仓库多应用)：保留了 monolith 单仓环境维护的便利性，同时满足 multirepo 多仓对于项目解耦的独立开发管理。在一个代码仓中，任意一个模块发生修改，另一个模块能够立即反馈而不用走繁琐的发布和依赖更新流程；各个模块之间也能够充分复用配置、CI 流程的脚本；各个包的版本和互相之间的依赖关系得到集中管理。\n\nMenorepo 缺点：\n1. 单仓过大，git 管理耗时。\n2. 需要专门优化构建流程。\n3. 弱权限管理，git 不支持文件夹级权限管理。\n4. 强依赖第三方工具，需要选择一组工具实现。\n5. 弱隔离解耦，需避免产生网状依赖、保证每个包可以独立编译工作。\n6. 幽灵依赖。\n\n# 适用场景\n1. 代码共享：当多个项目或模块之间需要共享代码、组件或工具库时。\n2. 统一版本管理：需要统一管理各个项目的版本依赖，确保一致性。\n3. 简化依赖管理：减少依赖安装和版本冲突，提高构建和部署效率。\n4. 协作与团队工作：团队成员可以更轻松地共享代码、协作开发和进行代码审查。\n5. 简化构建和部署：需要更方便地进行整体构建和部署，尤其对于有相互依赖关系的子项目。\n6. 敏捷开发和迭代：需要加快开发和迭代周期，避免在多个代码仓库之间切换和同步。\n\n\n# Menorepo 技术\n前端没有大而统一的 Menorepo 框架，大部分工具以库形式提供。\n\n核心技术：\n1. 包管理方案：npm、yarn、pnpm\n2. 包版本方案：[Lerna](https://lerna.js.org/)、[Changesets](https://github.com/changesets/changesets)\n3. 包构建方案：Turborepo、Nx\n\n辅助技术：\n1. 代码规范工具：Eslint、Prettier\n2. 提交规范工具：Commitlint、Commitizen\n\n> 在后文，使用 [pnpm Workspace](https://pnpm.io/zh/workspaces) 和 Lerna 实践 Menorepo。\n\n\n# 项目结构\nMenorepo 并没有统一的模板。下面是常见的结构：\n\n```\n├── packages/\n│   ├── module1/\n│   │   ├── src/\n│   │   ├── tests/\n│   │   ├── package.json\n│   │   └── ...\n│   └── module2/\n│       ├── src/\n│       ├── tests/\n│       ├── package.json\n│       └── ...\n├── docs/\n├── .gitignore\n├── package.json\n└── ...\n```\n\n并不只是简单地将各个项目都放在了同一个文件夹里。项目之间的关联、依赖、管理需要使用上述工具完成。\n1. 无需切换目录，在根目录下就可以给各个项目装包、运行。\n2. 项目间代码共享无需单独发包，package.json 中添加 `***: \"workspace:*\"` 即可导入。\n3. 各个项目、模块依然可以独立发包。\n4. 自动版本控制、统一提交 commit。\n\n> 在正式实践之前，不妨先看看成熟的组件库的代码组织形式，[element-plus](https://github.com/element-plus/element-plus)。\n\n# Pnpm Workspace\n[Pnpm](https://pnpm.io/zh/) 通过 [workspace(工作空间)](https://pnpm.io/zh/workspaces) 轻量化实现了 Monorepo，并能集成其它库进行扩展。[pnpm 介绍](/article/98a1db82.html#pnpm)\n\n它要求在 **root（代码仓根目录）**中存在 **pnpm-workspace.yaml** 文件，用于指定哪些目录作为**独立的**工作空间（一个子模块或 npm 包）。pnpm 会读取这些目录下的 package.json 以确定一个模块。\n\n```yaml\n# a 目录、b 目录、c 目录下的所有子目录，都会各自被视为独立的模块。\npackages:\n  - a\n  - b/*\n```\n\n# 命令操作\n在 workspace 模式下，**root** 通常不会作为一个 npm 包，而是作为一个**管理中枢**，执行一些全局操作，安装一些共有的依赖。\n1. `pnpm i` 安装 root 依赖以及所有工作空间的依赖。\n2. `-w` 在 monorepo 模式下的根目录进行操作。每个子包都能访问根目录的依赖。\n3. [--filter](https://pnpm.io/zh/filtering) `-F` 过滤子模块，对各个工作空间进行精细化操作。\n\n```bash\n# 为 a 包安装 lodash\npnpm --filter a i -S lodash\n# 安装公共依赖\npnpm install -w xxx\n# 发布所有包名为 @a/ 开头的包\npnpm --filter @a/* publish\n```\n\n当 **--filter** 筛选出多个包时，会首先分析多个包之间的内部依赖关系，按照依赖关系[拓扑排序](https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)的顺序对这些包执行指令，即按依赖树**从叶到根**的顺序。\n\n**--filter** 拥有多种筛选方式，可以根据包名、包路径、包的依赖关系、git 提交记录进行筛选。\n\n```bash\n# 为 a 以及 a 的所有依赖项执行测试脚本\npnpm --filter a... run test\n# 为 b 以及依赖 b 的所有包执行测试脚本\npnpm --filter ...b run test\n\n# 找出自 origin/master 提交以来所有变更涉及的包\n# 为这些包以及依赖它们的所有包执行构建脚本\n# README.md 的变更不会触发此机制\npnpm --filter=\"...{packages/**}[origin/master]\"\n  --changed-files-ignore-pattern=\"**/README.md\" run build\n\n# 找出自上次 commit 以来所有变更涉及的包\npnpm --filter \"...[HEAD~1]\" run build\n```\n\n\n# 基本环境\n理论结束，接下来创建 Pnpm Workspace 的项目结构，并集成 **vite**、**typescript** 开发 vue 组件库。\n\n**1、**全局安装 pnpm，新建一个文件夹作为 **root**，并初始化。\n\n```bash\nnpm install pnpm -g\nmkdir pnpmWorkSpaceTest && cd pnpmWorkSpaceTest\npnpm init -y\n```\n\n**2、**在 **root** 下新建 **pnpm-workspace.yaml**，pnpm 会读取这个文件，指定哪些目录作为独立的工作空间。\n\n```yaml pnpm-workspace.yaml\npackages:\n  # 文档\n  - \"docs\"\n  # 主包，存放各个子模块\n  - \"packages/*\"\n  # 示例\n  - \"demo\"\n```\n\n**3、**创建项目基本结构。并初始化每个子模块的 **package.json**、**vite.config.ts**\n**src** 为模块源码、**src/index.ts** 为模块总出口、**dist** 为构建产物。\n\n```bash\n├───📁 node_modules/ # 公共依赖，例如 vue、eslint 等。\n├───📁 demo/ # 示例模块，无需发布\n├───📁 docs/ # 文档模块，无需发布\n│   └───📄 package.json\n├───📁 packages/ # 主包目录，里面的每个模块通常都需要独立构建、发布\n│   ├───📁 button/ # vue 按钮组件模块\n│   │   ├───📁 dist/ # 模块构建产物\n│   │   ├───📁 node_modules/\n│   │   ├───📁 src/ # 模块源码\n│   │   │   └───📄 index.ts # 模块总出口\n│   │   ├───📄 package.json\n│   │   └───📄 vite.config.ts\n│   ├───📁 list/ # vue 列表组件模块\n│   ├───📁 ui/ # ui 模块作为各个组件的统一出口\n│   └───📁 utils/ # 公共方法模块\n├───📁 scripts/ # 构建脚本\n├───📄 .gitignore\n├───📄 package.json\n├───📄 pnpm-lock.yaml\n├───📄 pnpm-workspace.yaml\n```\n\n# 设置 package.json\n配置正确的 package.json 方便后续构建、发布流程，是实现 Monorepo 的关键。\n\n## 根目录 package.json\n修改 root 的 **package.json**，最小化如下。\n\n```json package.json\n{\n  \"name\": \"pnpm-workspace-test\",\n  // root 作为管理中枢，不需要发布\n  \"private\": true,\n  \"scripts\": {}, // 各种构建脚本\n  \"devDependencies\": {},\n  \"dependencies\": {}\n}\n```\n\n## 子模块 package.json\n**packages** 目录下的子模块，其 package.json 都如下：\n1. **name** 以 `@<组织名>/<子模块名>` 命名。子模块名通常和文件夹名相同。\n2. **peerDependencies** 定义项目需要的依赖环境。常用于表示插件、子项目和主框架的关系。\n3. **dependencies** 除了公共依赖，子模块的运行依赖都安装在这里。\n4. **devDependencies** 开发依赖通常安装在 root，子模块一般无需此字段。\n\n```json packages\\list\\package.json\n{\n  \"name\": \"@qx/list\",\n  \"main\": \"./dist/qx-list.umd.js\",\n  \"module\": \"./dist/qx-list.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/qx-list.umd.js\",\n      \"module\": \"./dist/qx-list.mjs\"\n    }\n  },\n  \"scripts\": {},\n  \"dependencies\": {},\n  \"peerDependencies\": {}\n}\n```\n\n## 内部模块依赖管理\nMonorepo 策略的一个目的就是方便**内部模块**之间的依赖管理。\n\n例如：`@qx/list` 依赖 `@qx/utils`，可以直接在 `@qx/list` 的 package.json 中添加 `workspace:^` 依赖。\n\n```json packages\\list\\package.json\n{\n  \"name\": \"@qx/list\",\n  \"dependencies\": {\n    \"@qx/utils\": \"workspace:^\"\n  }\n}\n```\n\n也可以使用命令完成依赖的添加。\n`--workspace` 不能简写，意思是在工作空间中找到依赖，而不是去 npm 仓库上查找。\n\n```bash\npnpm --filter @qx/list i -S --workspace @qx/utils\n```\n\nworkspace 版本号规则：**major.minor.patch(主版本号.次版本号.修订号)**，在实际发布 npm 包时，会被替换成内部模块对应版本号。\n1. `workspace:^` major 版本依赖，将被转为 ^x.x.x，会安装最新的 minor 版本。\n2. `workspace:~` minor 版本依赖，将被转为 ~x.x.x，会安装最新的 patch 版本。\n3. `workspace:*` 依赖最新版本，将被转为 x.x.x，固定版本。\n\n> 其它模块，如文档、示例等，通常是一个完整的项目，按正常配置即可。\n\n# 集成 vite、typescript(上)\n使用 vite 构建各个子模块。除了根目录，每个子模块都需要 `vite.config.ts`。\n\n> 除了 vite，后续还会在 scripts目录下写一些辅助构建的脚本，例如生成 dts、发布 npm 包等。\n> 随着项目体量增大，可能还需要集成其它工具进行构建，如 Gulp、Lerna 等。\n\n## 安装公共依赖\n公共开发依赖统一安装在根目录下，各个子模块可以直接使用。\n目标是开发一个 vue 组件库，所以还需要编译 [vue 单文件组件 SFC](https://cn.vuejs.org/guide/scaling-up/sfc)的 vite 插件 `@vitejs/plugin-vue`。\n此外，按个人喜好，这里使用 **sass** 处理 CSS。\n\n```bash\npnpm i -wD vite typescript @vitejs/plugin-vue sass\n```\n\n[resolve-peers-from-workspace-root](https://pnpm.io/zh/npmrc#resolve-peers-from-workspace-root) 默认为 true，使用根工作区项目的 **dependencies** 解析工作区中任何项目的 **peer dependencies** 。在该机制下，可以**将公共生产依赖也安装在 root**，并可以确保工作区中的所有项目都使用相同版本的依赖。\n\n```bash\npnpm i -wS vue\n```\n\n# 编写、构建模块\n下面以简单的 vue 组件与 utils 公共方法模块为例，演示 Monorepo 下的模块编写、构建流程。\n\n## 公共方法模块\n先为 `@qx/utils` 安装自有依赖。这里使用 lodash 作为示例，演示引入外部依赖的工程能力。\n\n```bash\npnpm --filter @qx/utils i -S lodash @types/lodash\n```\n\n编写两个 hello 和 useLodash 两个公共方法文件，并统一在 **src/index.ts** 中导出。\n\n```text @qx/utils 模块结构 packages\\utils\n├───📁 src/\n│   ├───📄 hello.ts\n│   ├───📄 index.ts\n│   └───📄 useLodash.ts\n├───📁 dist/\n├───📁 node_modules/\n├───📄 package.json\n└───📄 vite.config.ts\n```\n\n```ts\n// packages\\utils\\src\\hello.ts\nexport function hello(to: string = \"World\") {\n  const txt = `Hello ${to}!`;\n  alert(txt);\n  return txt;\n}\n\n// packages\\utils\\src\\useLodash.ts\nimport lodash from \"lodash\";\nexport function useLodash() {\n  return lodash;\n}\n\n// packages\\utils\\src\\index.ts\nexport * from \"./hello\";\nexport * from \"./useLodash\";\n```\n\n编写 **vite.config.ts**：\n构建工具打包时默认行为，会将所有涉及模块的代码都一并集合到产物中。\n如果是为 web 应用构建，这样做是合理的。但对于 npm 库来说，则会导致产物体积过大，且会引入一些不必要的依赖。在工程环境下，构建工具是可以识别模块引入语法的，**无需将模块的外部依赖打包进产物**。\n\n所以，需要配置 **rollupOption.external**，告诉构建工具哪些模块是外部依赖，不需要打包进产物，**保留 import 语句**。\n\n```ts packages\\utils\\vite.config.ts\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  build: {\n    outDir: 'dist', // 产物输出目录，默认值 dist。\n    // 参考：https://cn.vitejs.dev/config/build-options.html#build-lib\n    lib: {\n      entry: \"./src/index.ts\", // 构建的入口文件\n      formats: ['es', 'umd'], // 产物的生成格式，默认为 ['es', 'umd']。\n      name: \"QXUtils\", // 当产物为 umd、iife 格式时，该模块暴露的全局变量名称\n      fileName: \"qx-utils\", // 产物文件名称\n    },\n    minify: false, // 是否压缩代码，在编写插件、库时通常无需压缩\n    rollupOptions: {\n      // 确保外部化处理那些你不想打包进库的依赖\n      external: [/lodash.*/],\n      output: {\n        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量。即使不设置，构建工具也会为我们自动生成。\n        /*\n        globals: {\n          lodash: 'lodash'\n        }\n        */\n      },\n    },\n  },\n});\n```\n\n> 外部化处理依赖对于库的开发者而言是一件非常严肃的事情，产物的大小会直接影响下游用户的使用体验。\n> 在为 库 / npm 包 构建产物时，通常会将依赖项 dependencies、peerDependencies 字段下的依赖声明为 external(外部依赖)，使这个依赖相关的源码不被整合进产物，而是保留着 import xxx from 'pkg' 的导入语句。\n\n修改 package.json 编写构建脚本：\n\n```json\n\"scripts\": {\n  \"build\": \"vite build\"\n},\n```\n\n现在，可以构建 `@qx/utils` 模块了。\n构建产物中 qx-utils.mjs 是 es 模块，qx-utils.umd.js 是 umd 模块。\n\n```bash\n> pnpm --filter @qx/utils run build\nvite v5.4.3 building for production...\n✓ 4 modules transformed.\ndist/qx-utils.mjs  1.24 kB │ gzip: 0.45 kB\nNo name was provided for external module \"lodash\" in \"output.globals\" – guessing \"lodash\".\ndist/qx-utils.umd.js  1.89 kB │ gzip: 0.67 kB\n✓ built in 99ms\n```\n\n## Vue 组件模块\n编写 `@qx/button` 按钮组件模块，并依赖 `@qx/utils` 公共方法模块。\n\n首先当然是声明所需要的依赖，并 **pnpm i**。\n\n```json\n{\n  \"name\": \"@qx/button\",\n  \"scripts\": {\n    \"build\": \"vite build\"\n  },\n  \"dependencies\": {\n    \"@qx/utils\": \"workspace:^\"\n  },\n  \"peerDependencies\": {\n    \"vue\": \">=3.0.0\"\n  }\n}\n```\n\n编写 button.vue 组件文件，引入 `@qx/utils` 模块，并使用其中的方法。\n由于还没有配置 **tsconfig.json** 所以 IDE 会在导入处报错，但不影响构建。在集成完 TS 后会报错都会消失。\n\n```html packages\\button\\src\\button.vue\n<script setup lang=\"ts\">\nimport { hello } from \"@qx/utils\";\n\nconst props = withDefaults(\n  defineProps<{\n    text?: string;\n  }>(),\n  {\n    text: \"world\",\n  }\n);\n\nfunction clickHandler() {\n  hello(props.text);\n}\n</script>\n\n<template>\n  <button class=\"qx-button\" @click=\"clickHandler\">\n    <slot></slot>\n  </button>\n</template>\n\n<style>\n.qx-button {\n  color: red;\n}\n</style>\n```\n\n在 index.ts 中导出组件。\n\n```ts packages\\button\\src\\index.ts\nimport Button from \"./button.vue\";\nexport { Button };\n```\n\n编写 vite.config.ts，配置构建选项。\n使用正则将 `@qx` 开头的**内部依赖项**处理掉，便于未来可能增加的内部模块依赖。\n\n```ts packages\\button\\vite.config.ts\nimport { defineConfig } from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\n\nexport default defineConfig({\n  plugins: [vue()], // 增加插件的使用\n  build: {\n    lib: {\n      entry: \"./src/index.ts\",\n      name: \"QXButton\",\n      fileName: \"qx-button\",\n    },\n    minify: false,\n    rollupOptions: {\n      external: [\n        // 除了 @qx/utils，未来可能还会依赖其他内部模块，不如用正则表达式将 @qx 开头的依赖项一起处理掉\n        /@qx.*/,\n        \"vue\",\n      ],\n    },\n  },\n});\n```\n\n构建信息：\nCSS 被打包为了独立的 style.css 文件，若是每个组件都有各自的 CSS 文件，且散落在各个组件包内，是不便于导入的，后续会额外编写个构建脚本，统一处理所有组件的 CSS，现在就先这样吧。\n\n```bash\nvite v5.4.3 building for production...\n✓ 4 modules transformed.\ndist/style.css      0.03 kB │ gzip: 0.05 kB\ndist/qx-button.mjs  0.60 kB │ gzip: 0.34 kB\nNo name was provided for external module \"vue\" in \"output.globals\" – guessing \"vue\".\nNo name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\ndist/style.css         0.03 kB │ gzip: 0.05 kB\ndist/qx-button.umd.js  1.06 kB │ gzip: 0.54 kB\n✓ built in 236ms\n```\n\n## ui 模块\n除了 button 组件，可能还有 list、input 等组件，这些组件除了可以独立发布供用户安装外，还可以统一打包成一个 ui 组件库。\n\nui 模块要做的很简单，就是导入各个组件并导出。\n\n```ts packages\\ui\\src\\index.ts\nexport * from \"@qx/button\";\nexport * from \"@qx/utils\";\nexport * from \"@qx/list\";\n```\n\n```json packages\\ui\\package.json\n{\n  \"name\": \"@qx/ui\",\n  \"main\": \"./dist/qx-ui.umd.js\",\n  \"module\": \"./dist/qx-ui.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/qx-ui.umd.js\",\n      \"module\": \"./dist/qx-ui.mjs\"\n    },\n    \"./*\": \"./*\"\n  },\n  \"style\": \"dist/index.css\",\n  \"scripts\": {\n    \"build\": \"vite build\"\n  },\n  \"sideEffects\": [\n    \"dist/*\"\n  ],\n  \"dependencies\": {\n    \"@qx/button\": \"workspace:^\",\n    \"@qx/utils\": \"workspace:^\",\n    \"@qx/list\": \"workspace:^\"\n  },\n  \"peerDependencies\": {\n    \"vue\": \">=3.0.0\"\n  }\n}\n```\n\n```ts packages\\ui\\vite.config.ts\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: \"./src/index.ts\",\n      name: \"QXUI\",\n      fileName: \"qx-ui\",\n    },\n    minify: false,\n    rollupOptions: {\n      external: [/@qx.*/],\n    },\n  },\n});\n```\n\n构建信息：\n\n```bash\nvite v5.4.3 building for production...\n✓ 1 modules transformed.\ndist/qx-ui.mjs  0.08 kB │ gzip: 0.07 kB\nNo name was provided for external module \"@qx/button\" in \"output.globals\" – guessing \"button\".\nNo name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\nNo name was provided for external module \"@qx/list\" in \"output.globals\" – guessing \"list\".\ndist/qx-ui.umd.js  1.24 kB │ gzip: 0.43 kB\n✓ built in 71ms\n```\n\n## 整体构建\n现在，各个模块的构建流程已经完成，可以一键构建所有模块了。\n\n```bash\n# 构建 packages 下的所有模块\npnpm --filter \"./packages/**\" run build\n# 构建 @qx/ui 及其依赖的所有模块\npnpm --filter @qx/ui... run build\n```\n\n编写 root 的 package.json 脚本。\n\n```json\n\"scripts\": {\n  \"build:ui\": \"pnpm --filter ./packages/** run build\"\n},\n```\n\n从构建信息可以看到，构建顺序为：`utils -> button & list(并行) -> ui`，符合依赖树的拓扑排序。\n由于使用了 **rollupOptions.external** 外部化了依赖，这个特性现在对我们而言无关紧要，但在未来定制完善的打包体系，需要研究全量构建时，拓扑排序的特性就会变得非常关键。\n\n```bash\n> pnpm --filter ./packages/** run build\nScope: 4 of 7 workspace projects\npackages/utils build$ vite build\n│ The CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\n│ vite v5.4.3 building for production...\n│ transforming...\n│ ✓ 4 modules transformed.\n│ rendering chunks...\n│ computing gzip size...\n│ dist/qx-utils.mjs  1.24 kB │ gzip: 0.45 kB\n│ No name was provided for external module \"lodash\" in \"output.globals\" – guessing \"lodash\".\n│ dist/qx-utils.umd.js  1.89 kB │ gzip: 0.67 kB\n│ ✓ built in 94ms\n└─ Done in 519ms\npackages/button build$ vite build\n│ The CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.     \n│ vite v5.4.3 building for production...\n│ transforming...\n│ ✓ 4 modules transformed.\n[1 lines collapsed]\n│ computing gzip size...\n│ dist/style.css      0.03 kB │ gzip: 0.05 kB\n│ dist/qx-button.mjs  0.60 kB │ gzip: 0.34 kB\n│ No name was provided for external module \"vue\" in \"output.globals\" – guessing \"vue\".\n│3No name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\n│ ✓ 4 modules transformed.\n│ rendering chunks...\n│ computing gzip size...\n│ dist/style.css      0.03 kB │ gzip: 0.05 kB\n│ dist/qx-button.mjs  0.60 kB │ gzip: 0.34 kB kB\n└─ Done in 791msovided for external module \"vue\" in \"output.globals\" – guessing \"vue\".\n│ No name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\n[3 lines collapsed]\n│ ✓ 13 modules transformed.\n│ rendering chunks...\n│ computing gzip size...\n│ dist/style.css     2.75 kB │ gzip: 0.55 kB\n│ dist/qx-list.mjs  30.15 kB │ gzip: 6.00 kB\n│ No name was provided for external module \"vue\" in \"output.globals\" – guessing \"vue\".\n│ No name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\n│ dist/style.css        2.75 kB │ gzip: 0.55 kB\n│ dist/qx-list.umd.js  32.56 kB │ gzip: 6.20 kB\n│ ✓ built in 655ms\n└─ Done in 1.2s\npackages/ui build$ vite build\n[2 lines collapsed]\n│ transforming...\n│ ✓ 1 modules transformed.\n│ rendering chunks...\n│ computing gzip size...\n│ dist/qx-ui.mjs  0.08 kB │ gzip: 0.07 kB\n│ No name was provided for external module \"@qx/button\" in \"output.globals\" – guessing \"button\".\n│ No name was provided for external module \"@qx/utils\" in \"output.globals\" – guessing \"utils\".\n│ No name was provided for external module \"@qx/list\" in \"output.globals\" – guessing \"list\".\n│ dist/qx-ui.umd.js  1.24 kB │ gzip: 0.43 kB\n│ ✓ built in 66ms\n└─ Done in 516ms\n```\n\n## demo 演示模块\ndemo 模块是一个完整的 vue web 应用，用于演示我们的组件库。\n\n这个项目结构，可再熟悉不过了。\n\n```\n├───📁 node_modules/\n├───📁 src/\n│   ├───📁 assets/\n│   ├───📁 router/\n│   ├───📁 views/\n│   ├───📄 App.vue\n│   └───📄 main.ts\n├───📄 auto-imports.d.ts\n├───📄 components.d.ts\n├───📄 env.d.ts\n├───📄 index.html\n├───📄 package.json\n├───📄 tsconfig.json\n└───📄 vite.config.ts\n```\n\n这里将开发依赖都装到了 root 中，毕竟之后可能还有其它模块会用到。\n\n```json demo\\package.json\n{\n  \"name\": \"@qx/demo\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"vite dev\",\n    \"build\": \"vite build\"\n  },\n  \"dependencies\": {\n    \"@qx/ui\": \"workspace:^\"\n  },\n  \"devDependencies\": {},\n  \"peerDependencies\": {\n    \"vue\": \">=3.0.0\"\n  }\n}\n```\n\n编写 **vite.config.ts**\n\n```ts demo\\vite.config.ts\nimport { defineConfig } from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\nimport { join } from \"node:path\";\n\nimport AutoImport from \"unplugin-auto-import/vite\";\nimport Components from \"unplugin-vue-components/vite\";\nimport ElementPlus from \"unplugin-element-plus/vite\";\nimport { ElementPlusResolver } from \"unplugin-vue-components/resolvers\";\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    ElementPlus({}),\n    AutoImport({\n      resolvers: [ElementPlusResolver()],\n      imports: [\"vue\", \"vue-router\"],\n    }),\n    Components({\n      resolvers: [ElementPlusResolver()],\n    }),\n  ],\n});\n```\n\n至于源码，就是一个简单的 vue 应用，引入 `@qx/ui` 组件库，然后使用其中的组件。这里不多赘述。\n\n### 样式丢失与热更新\n当然现在还有个问题，样式丢了，且没有热更新(HMR)。\n1. 样式问题前面有提到过，CSS 都被打包为了独立的 style.css 文件，且 JS 并没有导入它，自然丢失了。\n2. vite 默认将 `@qx/*` 当做 npm 模块，在 node_modules 中查找，并根据模块的 package.json 定位到了 dist 下的构建产物，而不是源码，所以热更新失效了。 \n\n在修改了子模块后，demo 并不能实时更新，需要重新构建子模块，这是繁琐且不可接受的。Monorepo 的一个巨大优势就是**模块的修改能够得到即刻反馈**，我们需要通过配置实现该功能。\n\n可以设置 vite.config 的 **resolve.alias** 路径别名（路径别名解析的优先级要高于 npm 模块解析），将 `@qx/*` 重定向到源码目录，这样就可以实现热更新了，且样式也不再丢失，因为 CSS 也是源码，同样在 vue SFC 中。\n\n```ts demo\\vite.config.ts\nexport default defineConfig({\n  // ...\n  resolve: {\n    alias: [\n      {\n        find: /^@qx\\/(.+)$/,\n        replacement: join(__dirname, \"..\", \"packages\", \"$1\", \"src\"),\n      },\n    ],\n  },\n});\n```\n\n需要如此设置 alias 别名的，只有需要及时热更新的 web 应用模块，如 demo、docs 等。对于库模块则不需要：\n1. 子模块的依赖在打包时都外部化处理了，依赖项实际上并不会被 Vite 读取到。\n2. 即使 Vite 可能读取到依赖项，但我们批量打包组件时，pnpm 会做好拓扑排序处理，永远确保被依赖者先完成打包，依赖者后完成打包。\n\n# 集成 vite、typescript(下)\n在已经安装好 typescript 公共依赖的情况下，集成 TS 就是**编写 tsconfig.json 文件**。\n\n> TypeScript 本身内容，详见 [TypeScript 笔记](/article/9d362be7.html)\n\n## TS 在工程中的位置\n在之前的内容中，我们仅是安装好了相关的依赖，且无视了导入内部模块的 IDE 报错，甚至 tsconfig.json 文件都没有，但仍然能够顺利完成构建。\n\n这是因为 **Vite 天然支持引入 .ts 文件**，但它仅执行 .ts 文件的转译工作，**并不执行任何类型检查**。并假定类型检查已经被你的 IDE 或构建过程处理了。\n\nVite 采用 Rollup、Esbuild 双引擎架构，Esbuild 有着超快的编译速度，它在其中负责第三方库构建和 TS/JSX 语法编译。**无论是构建模式还是开发服务器模式，Vite 都通过 Esbuild 将 ts 文件转译为 js**。Vite 总是将去除了所有类型检查配置的最小 tsconfig 交给 Esbuild，只确保生成对应的 js 产物，所以在没有 tsconfig.json 的情况下，Vite 也能正常工作，而 tsconfig 中也只有少数几个配置项能够影响到 Vite 的构建行为。\n\n**“假定类型检查已经被你的 IDE 或构建过程处理了。”**现在目标就很清晰了：\n1. IDE 会根据 tsconfig.json 文件进行类型检查，但并不会影响构建。\n2. 我们需要在构建脚本中，额外使用 tsc 等工具进行类型检查，以确保代码质量。\n\n## tsconfig 文件\n每个 `tsconfig.[name].json` 都管理着一个**文件集合**：\n1. `include` 字段声明**文件集合**，除了 node_modules 中的三方依赖，每个被引用的源码文件都要被包含进来。\n2. `exclude` 声明集合中需要**排除**的文件。\n3. include 与 exclude 字段都通过 [glob](https://docs.python.org/zh-cn/3/library/glob.html) 语法进行文件匹配\n4. `compilerOptions` 是编译选项，控制 TypeScript 编译器处理该文件集合的策略与行为。\n\nIDE 只读取 tsconfig.json 文件，`tsconfig.[name].json` 最终都需要集成到一个 tsconfig.json 中。\n\n通过[项目引用(Project References)](https://www.typescriptlang.org/docs/handbook/project-references.html)，可以将多个 `compilerOptions.composite = true` 的 tsconfig 聚合在一起。\n\n```ts tsconfig.json 聚合 tsconfig\n\"references\": [\n  {\n    \"path\": \"./tsconfig.src.json\"\n  },\n  {\n    \"path\": \"./tsconfig.node.json\"\n  }\n],\n```\n\n项目引用功能提供了**为项目的不同部分应用不同 tsconfig 的能力**，为 Monorepo 项目提供了很大的便利，形成 tsconfig 分治策略。\n\n```bash 通过该命令，可以查看最终的 TypeScript 编译器配置。\n> npx tsc -p tsconfig.src.json --showConfig\n\n{\n  \"compilerOptions\": {   \n    #  ...\n  },\n  # 可以清晰看到文件集合包含了哪些文件\n  \"files\": [\n      \"./packages/button/src/index.ts\",\n      \"./packages/list/src/index.ts\",\n      \"./packages/ui/src/index.ts\",\n      \"./packages/utils/src/functionControlUtils.ts\",\n      \"./packages/utils/src/hello.ts\",\n      \"./packages/utils/src/index.ts\",\n      \"./packages/utils/src/useLodash.ts\"\n  ],  \n  \"include\": [\n      \"env.d.ts\",\n      \"packages/**/src\"\n  ],\n  \"exclude\": [\n      \"C:/chuckle/qx/study_demo/Monorepo/pnpmWorkspaceTest/dist\"\n  ]\n}\n```\n\n> VSCode 的 TypeScript 状态有时会有更新延迟。遇到这种情况，可以尝试通过 Ctrl + P 调出命令框，搜索 reload 关键字，执行 Developer: Reload Window 指令重载 IDE。\n\n## tsconfig 分治策略\n我们当然可以为每个子模块都建立一个 tsconfig 文件，分散在各个包中管理，但这样会导致大量重复的配置，且不利于统一管理。\n\n应当参考 [element-plus](https://github.com/element-plus/element-plus) ，**将功能相似的代码划分到同个 tsconfig 中，集中在根目录下管理**。\n\n**1、**编译选项 `compilerOptions` 大部分都是重复的，新建 `tsconfig.base.json` 作为基础配置文件，供其他配置文件通过 `extends` 字段继承。\n\n```json tsconfig.base.json\n{\n  \"compilerOptions\": {\n    // 项目的根目录\n    \"rootDir\": \".\",\n    // 项目基础目录\n    \"baseUrl\": \".\",\n    // tsc 编译产物输出目录\n    \"outDir\": \"dist\",\n    // 编译目标 js 的版本\n    \"target\": \"es2022\",\n    // 生成代码的模板标准\n    \"module\": \"esnext\",\n    // 模块解析策略\n    \"moduleResolution\": \"node\",\n    // 是否生成辅助 debug 的 .map.js 文件。 \n    \"sourceMap\": false,\n    // 产物不消除注释\n    \"removeComments\": false,\n    // 严格模式类型检查，建议开启\n    \"strict\": true,\n    // 不允许有未使用的变量\n    \"noUnusedLocals\": false,\n    // 允许引入 .json 模块\n    \"resolveJsonModule\": true,\n    // 与 esModuleInterop: true 配合允许从 commonjs 的依赖中直接按 import XX from 'xxx' 的方式导出 default 模块。\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    // 在使用 const enum 或隐式类型导入时受到 TypeScript 的警告\n    \"isolatedModules\": true,\n    // 检查类型时是否跳过类型声明文件，一般在上游依赖存在类型问题时置为 true。\n    \"skipLibCheck\": true,\n    // 引入 ES 的功能库\n    \"lib\": [],\n    // 默认引入的模块类型声明\n    \"types\": [],\n    // 路径别名设置\n    \"paths\": {\n      \"@qx/*\": [\n        \"packages/*/src\"\n      ]\n    }\n  }\n}\n```\n\n**2、**将所有 node 环境下执行的脚本、配置文件划分到 `tsconfig.node.json`。\n因为集成了 Node.js 库函数的类型声明，`\"types\": [\"node\"]`，所以需要 `pnpm i -wD @types/node`。\n\n```json tsconfig.node.json\n{\n  // 继承基础配置\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    // 该 ts project 将被视作一个部分，通过项目引用(Project References)功能集成到一个 tsconfig.json 中\n    \"composite\": true,\n    // node 脚本没有 dom 环境，因此只集成 esnext 库即可\n    \"lib\": [\n      \"ESNext\"\n    ],\n    // 集成 Node.js 库函数的类型声明\n    \"types\": [\n      \"node\"\n    ],\n    // 脚本有时会以 js 编写，因此允许 js\n    \"allowJs\": true\n  },\n  \"include\": [\n    // 目前项目中暂时只有配置文件，如 vite.config.ts，以后会逐步增加\n    \"**/*.config.*\",\n    \"scripts\"\n  ],\n  \"exclude\": [\n    // 暂时先排除产物目录，packages/xxx/dist/x.config.js 或者 node_modules/pkg/x.config.js 不会被包含进来\n    \"**/dist\",\n    \"**/node_modules\"\n  ]\n}\n```\n\n**3、**对于所有模块中 src 目录下的源码文件，几乎都是组件库的实现代码，大多要求浏览器环境下特有的 API(例如 DOM API)，且相互之间存在依赖关系。都划分到 `tsconfig.src.json`。\n\n```json tsconfig.src.json\n{\n  // 继承基础配置\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"composite\": true,\n    // 组件库依赖浏览器的 DOM API\n    \"lib\": [\n      \"ESNext\",\n      \"DOM\",\n      \"DOM.Iterable\"\n    ],\n    \"types\": [\n      \"node\"\n    ],\n  },\n  \"include\": [\n    \"env.d.ts\",\n    \"packages/**/src\"\n  ],\n}\n```\n\n`env.d.ts` 存放了一些全局类型声明。\n\n```ts env.d.ts\n// 让 TypeScript 对于 Vite 的一些特定功能提供类型定义\n// https://cn.vitejs.dev/guide/env-and-mode#intellisense\n/// <reference types=\"vite/client\" />\n```\n\n**4、**将 `tsconfig.[name].json` 聚合到 `tsconfig.json` 中。\n\n```json tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"moduleResolution\": \"node\",\n    // vite 会读取到这个 tsconfig 文件(位于工作空间根目录)，按照其推荐配置这两个选项\n    // https://cn.vitejs.dev/guide/features.html#typescript-compiler-options\n    \"isolatedModules\": true,\n    \"useDefineForClassFields\": true\n  },\n  \"types\": [],\n  \"files\": [],\n  \"references\": [\n    // 聚合 ts project\n    {\n      \"path\": \"./tsconfig.src.json\"\n    },\n    {\n      \"path\": \"./tsconfig.node.json\"\n    }\n  ],\n}\n```\n\n## compilerOptions.paths\n在 IDE 在读取到 tsconfig.json 文件后，原本的导入报错应该都消失了。这是因为正确设置了 `compilerOptions.paths`。\n\n```json tsconfig.base.json\n{\n  \"compilerOptions\": {\n    // ...\n    \"paths\": {\n      \"@qx/*\": [\"packages/*/src\"]\n    }\n  }\n}\n```\n\npaths 提供了别名转换的功能，可以将 import 导入语句如下转换：\n\n```ts\n// 原语句\nimport { hello } from '@qx/utils'\n// ts 编译时转换为\nimport { hello } from '<rootPath>/<baseUrl>/packages/utils/src'\n```\n\n**对于内部模块的依赖，配置 paths，将其转为源码路径是很有必要的**：\n在没有设置 paths 时，typescript 会去 node_modules 中找模块，**若还未构建该模块**，则自然会报错找不到模块的导出，并且现在我们还没有生成 d.ts 文件，也会报错找不到该模块的类型。而在设置 paths 后，typescript 定位到了源码路径，自然没有上述的问题了。\n\n结合之前 vite 的 resolve.alias 配置，我们可以得出结论，**对于内部模块，最好都在构建工具、tsconfig中，将其路径别名设置为源码路径**。\n\n## demo 模块的 tsconfig\ndemo、docs 等模块是一个完整的 web 应用，相对独立，可以拥有独立的 tsconfig。\n\n```json demo\\tsconfig.json\n{\n  // 集成基础配置\n  \"extends\": \"../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    // Web 应用需要 DOM 环境\n    \"lib\": [\n      \"ESNext\",\n      \"DOM\",\n      \"DOM.Iterable\"\n    ],\n    // Web 应用不需要 node 相关方法\n    \"types\": [\n      \"element-plus/global\"\n    ],\n    // baseUrl 改变了，基础配置中的 paths 也需要一并重写\n    \"paths\": {\n      \"@/*\": [\n        \"src/*\"\n      ],\n      \"@qx/*\": [\n        \"../packages/*/src\"\n      ]\n    }\n  },\n  \"include\": [\n    // demo 应用会引用其他子模块的源码，因此都要包含到 include 中 \n    \"../packages/*/src\",\n    \"./*.d.ts\",\n    \"env.d.ts\",\n    \"src\"\n  ]\n}\n```\n\n需要注意，由于 baseUrl 改变了，基础配置中的 paths 也需要一并重写。\n\n## TypeScript 类型检查\n通过 tsc 命令指定对应的 tsconfig 文件，就能对其文件集合进行类型检查。\n\n```bash\n# 指定 tsconfig.src.json 检查源码文件。\nnpx tsc -p tsconfig.src.json --noEmit --composite false\n# --noEmit 使构建产物不被输出，--composite false 使得 buildInfo 文件不被输出。\n```\n\n由于源码是 Vue 组件，使用 tsc 命令会报错，需要使用 vue-tsc。\n\n```bash\npnpm i -wD vue-tsc\nnpx vue-tsc -p tsconfig.src.json --noEmit --composite false\n```\n\n编写 package.json 脚本。\n\n```json package.json\n// package.json\n{\n  // ...\n  \"scripts\": {\n    \"type:node\": \"tsc -p tsconfig.node.json --noEmit --composite false\",\n    \"type:src\": \"vue-tsc -p tsconfig.src.json --noEmit --composite false\",\n    \"build:ui\": \"pnpm run type:src && pnpm --filter ./packages/** run build\"\n  },\n}\n```\n\n## 生成 d.ts 类型声明文件\n> 这里就是前言中所说的，令我头疼的地方了。\n> 看了别人的文章后才知道 [vite-plugin-dts](https://github.com/qmhc/vite-plugin-dts) 插件并不适合 Monorepo 环境。该插件在迭代的过程中做了太多兼容以及细节处理，已经过于复杂，内部的路径解析总是出现各种各样的问题。\n> 在 3.0.0 版本后，其内部生成 d.ts 的机制已经改为 vue-tsc 实现，不如直接使用 vue-tsc。\n\n在先前的类型检查命令的基础上，补充 --declaration 和 --emitDeclarationOnly 选项就可以为所有的包生成 d.ts 文件。\n\n```json\n\"type:src\": \"vue-tsc -p tsconfig.src.json --composite false --declaration --emitDeclarationOnly\",\n```\n\n所有的产物都会被生成到 outDir 字段指定的根目录下的 dist。但我们需要的是对应的 d.ts 文件放到对应模块的 dist 目录中。\n\n```text dist\n└───📁 packages/\n    ├───📁 button/\n    │   └───📁 src/\n    │       ├───📄 button.vue.d.ts\n    │       └───📄 index.d.ts\n    ├───📁 list/\n    │   └───📁 src/\n    │       ├───📄 EstimatedVirtualList.vue.d.ts\n    │       ├───📄 index.d.ts\n    │       ├───📄 VirtualList.vue.d.ts\n    │       ├───📄 VirtualWaterFallList.vue.d.ts\n    │       └───📄 WaterFallList.vue.d.ts\n    ├───📁 ui/\n    │   └───📁 src/\n    │       └───📄 index.d.ts\n    └───📁 utils/\n        └───📁 src/\n            ├───📄 functionControlUtils.d.ts\n            ├───📄 hello.d.ts\n            ├───📄 index.d.ts\n            └───📄 useLodash.d.ts\n```\n\n观察产物可以发现，其目录结构与 packages 的结构是一致的，所以很容易可以移动它们到正确位置。\n\n```ts scripts\\utils.ts 将通用的内容提取出来。\nimport { join } from \"node:path\";\n\n/** 以根目录为基础解析路径 */\nexport const fromRoot = (...paths: string[]) => join(__dirname, \"..\", ...paths);\n\n/** 包的目录 */\nexport const PKGS_DIR = fromRoot(\"packages\");\n\n/** 包的 d.ts 产物目录 */\nexport const PKGS_DTS_DIR = fromRoot(\"dist/packages\");\n\n/** 单个包的 d.ts 产物相对目录 */\nexport const PKG_DTS_RELATIVE_DIR = \"dist\";\n\n/** 包的代码入口相对目录 */\nexport const PKG_ENTRY_RELATIVE_DIR = \"src\";\n```\n\n```ts scripts\\dts-mv.ts\n// 将 vue—tsc 编译产物 d.ts 移动到 packages 对应模块的 dist 目录下\nimport { join } from \"node:path\";\nimport { readdir, cp } from \"node:fs/promises\";\nimport {\n  fromRoot,\n  PKGS_DIR,\n  PKGS_DTS_DIR,\n  PKG_ENTRY_RELATIVE_DIR,\n  PKG_DTS_RELATIVE_DIR,\n} from \"./utils\";\n\nasync function main() {\n  const pkgs = await match();\n  const tasks = pkgs.map(resolve);\n  await Promise.all(tasks);\n}\n\n/** 寻找所有需要移动 dts 的包 */\nasync function match() {\n  const res = await readdir(PKGS_DTS_DIR, { withFileTypes: true });\n  return res.filter((item) => item.isDirectory()).map((item) => item.name);\n}\n\n/**\n * 处理单个包的 dts 移动\n * @param pkgName 包名\n */\nasync function resolve(pkgName: string) {\n  try {\n    const sourceDir = join(PKGS_DTS_DIR, pkgName, PKG_ENTRY_RELATIVE_DIR);\n    const targetDir = join(PKGS_DIR, pkgName, PKG_DTS_RELATIVE_DIR);\n    const sourceFiles = await readdir(sourceDir);\n    const cpTasks = sourceFiles.map((file) => {\n      const source = join(sourceDir, file);\n      const target = join(targetDir, file);\n      console.log(`[${pkgName}]: moving: ${source} => ${target}`);\n      return cp(source, target, {\n        force: true,\n        recursive: true,\n      });\n    });\n    await Promise.all(cpTasks);\n    console.log(`[${pkgName}]: moved successfully!`);\n  } catch (e) {\n    console.log(`[${pkgName}]: failed to move!`);\n  }\n}\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n```\n\n修改 package.json 完善脚本。\n使用 [tsx](https://github.com/esbuild-kit/tsx) 执行该 ts 文件，使用 [rimraf](https://github.com/isaacs/rimraf) 清除原本产物。\n\n```json package.json\n\"scripts\": {\n  \"clean:type\": \"rimraf ./dist\",\n  \"type:node\": \"tsc -p tsconfig.node.json --noEmit --composite false\",\n  \"type:src\": \"pnpm run clean:type && vue-tsc -p tsconfig.src.json --composite false --declaration --emitDeclarationOnly\",\n  \"dts-mv\": \"tsx ./scripts/dts-mv.ts\",\n  \"build:ui\": \"pnpm run type:src && pnpm --filter ./packages/** run build && pnpm run dts-mv\"\n},\n```\n\n现在，只需要运行 **build:ui** 脚本，即可完成项目构建。\n\n# 处理 CSS 文件\n虽然在前面通过设置了 vite 的路径别名，使得样式不再丢失，但本质上是因为定位到了源码，而安装组件库的用户并不会直接引入源码，而是引入构建产物，所以仍然会丢失样式。\n\n解决起来也简单，仿照 d.ts 的处理，将 CSS 文件都移动到 ui 模块的 dist 目录下，并重命名为各自模块名方便用户按需导入，最后还需要组装一个 index.css 文件，提供完整导入。\n\n```ts scripts\\css-mv.ts\n// 将 packages 中的各个包(除了ui文件夹)的 dist 目录下的 style.css 移动并改名到 packages/ui/dist/<对应包名>.css\nimport { join } from \"node:path\";\nimport { readdir, cp, stat, readFile } from \"node:fs/promises\";\nimport { createWriteStream } from \"node:fs\";\nimport { fromRoot, PKGS_DIR } from \"./utils\";\n\n/** UI 包的目录 */\nexport const UI_DIST_DIR = join(PKGS_DIR, \"ui\", \"dist\");\n\n/** 获取所有包的名称 */\nconst getPackages = async () => {\n  const files = await readdir(PKGS_DIR);\n  return files.filter((file) => file !== \"ui\");\n};\n\n/** 检查文件是否存在 */\nconst fileExists = async (path: string) => {\n  try {\n    await stat(path);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// 去除 css 文件中的 @charset 声明\nconst removeCharsetDeclaration = async (cssContent: string) => {\n  const charsetPattern = /@charset \"[^\"]+\";\\s*/g;\n  return cssContent.replace(charsetPattern, \"\");\n};\n\n/** 移动并重命名 style.css 文件、生成 index.css */\nconst moveAndRenameCss = async () => {\n  const packages = await getPackages();\n  const writeStream = createWriteStream(\n    join(UI_DIST_DIR, \"index.css\"),\n    \"utf-8\"\n  );\n  writeStream.write(`@charset \"UTF-8\";\\n`);\n\n  const promises = packages.map(async (pkg) => {\n    const src = join(PKGS_DIR, pkg, \"dist\", \"style.css\");\n    if (!(await fileExists(src))) {\n      return;\n    }\n    const css = await readFile(src, \"utf-8\");\n    const cssWithoutCharset = await removeCharsetDeclaration(css);\n    writeStream.write(cssWithoutCharset);\n    const dest = join(UI_DIST_DIR, `${pkg}.css`);\n    await cp(src, dest);\n    console.log(`[${pkg}.css]: moved successfully!`);\n  });\n  await Promise.all(promises);\n  console.log(\"[index.css]: created successfully!\");\n  writeStream.end();\n  writeStream.close();\n};\n\nmoveAndRenameCss().catch(console.error);\n```\n\n最终 ui 模块的构建产物如下：\n\n```text\n├───📄 button.css\n├───📄 index.css\n├───📄 index.d.ts\n├───📄 list.css\n├───📄 qx-ui.mjs\n└───📄 qx-ui.umd.js\n```\n\n在需要时，如下导入 CSS 即可。\n\n```ts\nimport \"@qx/ui/dist/index.css\";\n```\n\n修改完善 package.json 脚本。\n\n```json package.json\n\"scripts\": {\n  \"clean:type\": \"rimraf ./dist\",\n  \"type:node\": \"tsc -p tsconfig.node.json --noEmit --composite false\",\n  \"type:src\": \"pnpm run clean:type && vue-tsc -p tsconfig.src.json --composite false --declaration --emitDeclarationOnly\",\n  \"dts-mv\": \"tsx ./scripts/dts-mv.ts\",\n  \"css-mv\": \"tsx ./scripts/css-mv.ts\",\n  \"build:ui\": \"pnpm run type:src && pnpm --filter ./packages/** run build && pnpm run dts-mv && pnpm run css-mv\"\n},\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"Vue+TS 实现虚拟列表","url":"/article/6ae8614b.html","content":"\n# 前言\n将大量DOM元素直接渲染到页面性能是很差的，存在的问题：\n1. 大量DOM元素重绘，CPU开销大，滚动卡顿。\n2. GPU渲染能力不够，跳屏。\n3. 页面等待、布局时间长，白屏问题。\n4. 大量DOM元素内存占用大。\n\n传统的做法是随着滚动增量渲染，堆积的DOM元素也会越来越多，会出现同样的性能问题。\n\n虚拟列表的核心思想是**动态计算**、**按需渲染**，是一种根据滚动容器元素的**可视区域**来渲染长列表数据中**部分数据**的技术。\n在线感受虚拟列表的魅力：[virtual-list-demo](https://list.qcqx.cn/#/list/estimated)\n\n虚拟列表可以简单分为以下几类：\n1. **定高**：每个DOM元素高度确定\n2. **不定高**：每个DOM元素高度不确定\n3. **瀑布流**：例如小红书首页，是普通瀑布流的优化，也属于不定高类型。\n\n# 原生JS定高\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/98-1.gif\" width=\"100%\" />\n\n定高的原理比较简单，也是其它虚拟列表的基础，这里使用原生JS实现。\n\n这是预期的DOM结构：\n\n```html\n<!-- 虚拟列表容器 -->\n<div class=\"virtual-list-container\">\n  <!-- 虚拟列表 -->\n  <div class=\"virtual-list\">\n    <!-- 动态渲染的虚拟列表项 -->\n    <div class=\"virtual-list-item\">1</div>\n  </div>\n</div>\n```\n\n`virtual-list-container` 外层的滚动容器元素，由它确定**可视区域**。\n`virtual-list` 实际列表容器，撑起滚动高度。\n`virtual-list-item` 动态渲染的虚拟列表项。\n\n## 撑起滚动高度\n由于是动态渲染，滚动高度不能再由列表项元素撑起，为了维持正常的滚动条，需要如下技巧。\n\n在滚动过程中，对 `virtual-list` 设置 `transform: translateY()` 撑起卷去高度(滚动的偏移量)，模拟滚动效果，再设置 `height` 为初始列表高度减去滚动的偏移量。\n\n## 基本数据结构\n基本的数据结构：封装 `virtualList` 类方便调用。\n\n```js\nclass virtualList {\n  constructor(el, itemHeight) {\n    this.state = {\n      data: [], // 数据\n      itemHeight: itemHeight || 100, // 每一项的高度，固定\n      viewHeight: 0, // 整个列表可视区域的高度\n      renderCount: 0, // 渲染的项数\n    };\n    this.startIndex = 0; // 开始渲染的索引\n    this.endIndex = 0; // 结束渲染的索引\n    this.renderList = []; // 实际渲染列表\n    this.scrollStyle = {\n      height: \"0px\",\n      transform: \"translateY(0px)\",\n    }; // 滚动样式，用于设置列表的偏移量，实现滚动效果\n    this.el = document.querySelector(el); // 挂载元素\n    this.init();\n  }\n}\n```\n\n`state` 是一些基本数据，包括列表数据、每一项高度、可视区域高度、渲染项数。\n根据滚动状态计算 `startIndex`、`endIndex`，由这两者确定 `renderList` 实际渲染的列表数据，以及 `scrollStyle` 虚拟滚动样式。\n\n## 挂载\n`mount()` 创建虚拟列表预期的DOM结构，并挂载到指定元素上。\n\n```js\nmount() {\n  // 创建虚拟列表容器\n  this.oContainer = document.createElement(\"div\");\n  this.oContainer.className = \"virtual-list-container\";\n  // 创建虚拟列表\n  this.oList = document.createElement(\"div\");\n  this.oList.className = \"virtual-list\";\n  // 设置子元素\n  this.oContainer.appendChild(this.oList);\n  // 挂载到页面\n  this.el.innerHTML = \"\";\n  this.el.appendChild(this.oContainer);\n}\n```\n\n## 初始化\n`init()` 进行必要的初始化，进行挂载、计算基本数据、绑定事件（主要是滚动事件），当然还需要进行一次初始渲染。\n\n```js\ninit() {\n  this.mount();\n  // 计算列表可视区域的高度\n  this.state.viewHeight = this.oContainer.offsetHeight;\n  // 计算渲染的项数，向上取整，多渲染一项，避免滚动时出现空白\n  this.state.renderCount =\n    Math.ceil(this.state.viewHeight / this.state.itemHeight) + 1;\n  this.render(); // 进行一次渲染\n  this.bindEvent(); // 绑定事件，如滚动事件\n}\n```\n\n`offsetHeight` 只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距、边框和滚动条，且是一个整数。使用它作为可视区域的高度正合适。\n\n计算 `renderCount` 时需要至少多渲染一项，避免滚动时出现空白。\n\n## 渲染数据\n`render()` 进行一些必要的计算后，渲染出列表子项，并设置虚拟滚动样式。\n\n```js\nrender() {\n  // 进行必要的计算\n  this.computeEndIndex();\n  this.computeRenderList();\n  this.computeScrollStyle();\n  // 列表子项\n  const items = this.renderList.map((item) => {\n    return `<div class=\"virtual-list-item\" style=\"height: ${this.state.itemHeight}px;\">${item}</div>`;\n  });\n  const template = items.join(\"\");\n  this.oList.innerHTML = template;\n  // 设置滚动样式\n  this.oList.style.height = this.scrollStyle.height;\n  this.oList.style.transform = this.scrollStyle.transform;\n}\n```\n\n## 一些计算\n每次渲染前需要计算必要的数据，包括末索引、渲染列表、滚动样式。\n\n```js 计算结束渲染的索引\ncomputeEndIndex() {\n  this.endIndex = this.startIndex + this.state.renderCount - 1;\n  // 如果结束索引大于数据长度，结束索引等于数据长度\n  if (this.endIndex > this.state.data.length - 1) {\n    this.endIndex = this.state.data.length - 1;\n  }\n}\n```\n\n```js 计算渲染的列表\ncomputeRenderList() {\n  // 截取数据，slice方法是左闭右开区间，所以结束索引要加1\n  this.renderList = this.state.data.slice(this.startIndex, this.endIndex + 1);\n}\n```\n\n```js 计算虚拟滚动样式\ncomputeScrollStyle() {\n  // 计算滚动的偏移量\n  const scrollTop = this.startIndex * this.state.itemHeight;\n  // 始终保证height+transformY=列表总高度，也就是this.state.data.length * this.state.itemHeight\n  this.scrollStyle = {\n    // 设置列表的高度，减去滚动的偏移量\n    height: `${this.state.data.length * this.state.itemHeight - scrollTop}px`,\n    // 设置列表的偏移量，通过transform实现滚动效果\n    transform: `translateY(${scrollTop}px)`,\n  };\n}\n```\n\n## 绑定事件\n绑定滚动事件，注意要将滚动回调的this绑定到当前类实例。\n\n```js\nbindEvent() {\n  // 注意将handleScroll的this绑定为当前实例\n  const handle = this.rafThrottle(this.handleScroll.bind(this));\n  this.oContainer.addEventListener(\"scroll\", handle);\n}\n```\n\n滚动回调：\n在滚动过程中计算起始索引，即将 scrollTop （卷去高度）除以每项高度，并向下取整。还需要调用渲染函数，不断渲染最新DOM元素。\n\n```js\nhandleScroll() {\n  // 计算开始渲染的索引\n  this.startIndex = Math.floor(\n    this.oContainer.scrollTop / this.state.itemHeight\n  );\n  // 渲染列表\n  this.render();\n}\n```\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>原生JS固高虚拟列表</title>\n  <style>\n    .container {\n      width: 600px;\n      height: 500px;\n      border: 1px solid #333;\n      margin: 150px auto;\n    }\n\n    .virtual-list-container {\n      width: 100%;\n      height: 100%;\n      overflow: auto;\n    }\n\n    .virtual-list {\n      width: 100%;\n      height: 100%;\n    }\n\n    .virtual-list-item {\n      width: 100%;\n      /* 固定高度 */\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      border: 1px solid #333;\n      box-sizing: border-box;\n      text-align: center;\n      font-size: 20px;\n      font-weight: bold;\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"container\"></div>\n  <script src=\"index.js\"></script>\n</body>\n\n</html>\n```\n\n```js\n// <!-- 虚拟列表容器 -->\n// <div class=\"virtual-list-container\">\n//   <!-- 虚拟列表 -->\n//   <div class=\"virtual-list\">\n//     <!-- 动态渲染的虚拟列表项 -->\n//     <div class=\"virtual-list-item\">1</div>\n//   </div>\n// </div>\nclass virtualList {\n  constructor(el, itemHeight) {\n    this.state = {\n      data: [], // 数据\n      itemHeight: itemHeight || 100, // 每一项的高度，固定\n      viewHeight: 0, // 整个列表可视区域的高度\n      renderCount: 0, // 渲染的项数\n    };\n    this.startIndex = 0; // 开始渲染的索引\n    this.endIndex = 0; // 结束渲染的索引\n    this.renderList = []; // 实际渲染列表\n    this.scrollStyle = {\n      height: \"0px\",\n      transform: \"translateY(0px)\",\n    }; // 滚动样式，用于设置列表的偏移量，实现滚动效果\n    this.el = document.querySelector(el); // 挂载元素\n    this.init();\n  }\n  // 初始化\n  init() {\n    this.mount();\n    // 计算列表可视区域的高度\n    this.state.viewHeight = this.oContainer.offsetHeight;\n    // 计算渲染的项数，向上取整，多渲染一项，避免滚动时出现空白\n    this.state.renderCount =\n      Math.ceil(this.state.viewHeight / this.state.itemHeight) + 1;\n    this.render(); // 进行一次渲染\n    this.bindEvent(); // 绑定事件，如滚动事件\n  }\n  // 创建并挂载dom元素\n  mount() {\n    // 创建虚拟列表容器\n    this.oContainer = document.createElement(\"div\");\n    this.oContainer.className = \"virtual-list-container\";\n    // 创建虚拟列表\n    this.oList = document.createElement(\"div\");\n    this.oList.className = \"virtual-list\";\n    // 设置子元素\n    this.oContainer.appendChild(this.oList);\n    // 挂载到页面\n    this.el.innerHTML = \"\";\n    this.el.appendChild(this.oContainer);\n  }\n  // 计算结束渲染的索引\n  computeEndIndex() {\n    this.endIndex = this.startIndex + this.state.renderCount - 1;\n    // 如果结束索引大于数据长度，结束索引等于数据长度\n    if (this.endIndex > this.state.data.length - 1) {\n      this.endIndex = this.state.data.length - 1;\n    }\n  }\n  // 计算渲染的列表\n  computeRenderList() {\n    // 截取数据，slice方法是左闭右开区间，所以结束索引要加1\n    this.renderList = this.state.data.slice(this.startIndex, this.endIndex + 1);\n  }\n  // 计算虚拟滚动样式\n  computeScrollStyle() {\n    // 计算滚动的偏移量\n    const scrollTop = this.startIndex * this.state.itemHeight;\n    // 始终保证height+transformY=列表总高度，也就是this.state.data.length * this.state.itemHeight\n    this.scrollStyle = {\n      // 设置列表的高度，减去滚动的偏移量\n      height: `${this.state.data.length * this.state.itemHeight - scrollTop}px`,\n      // 设置列表的偏移量，通过transform实现滚动效果\n      transform: `translateY(${scrollTop}px)`,\n    };\n  }\n  // 渲染列表\n  render() {\n    // 进行必要的计算\n    this.computeEndIndex();\n    this.computeRenderList();\n    this.computeScrollStyle();\n    // 列表子项\n    const items = this.renderList.map((item) => {\n      return `<div class=\"virtual-list-item\" style=\"height: ${this.state.itemHeight}px;\">${item}</div>`;\n    });\n    const template = items.join(\"\");\n    this.oList.innerHTML = template;\n    // 设置滚动样式\n    this.oList.style.height = this.scrollStyle.height;\n    this.oList.style.transform = this.scrollStyle.transform;\n  }\n  // 节流\n  throttle(fn, delay = 50) {\n    let lastTime = 0;\n    return function () {\n      const now = Date.now();\n      if (now - lastTime > delay) {\n        fn.apply(this, arguments);\n        lastTime = now;\n      }\n    };\n  }\n  // 使用requestAnimationFrame实现节流\n  // requestAnimationFrame会在浏览器下一次重绘之前执行回调函数\n  rafThrottle(fn) {\n    let ticking = false;\n    return function () {\n      if (ticking) return;\n      ticking = true;\n      window.requestAnimationFrame(() => {\n        fn.apply(this, arguments);\n        ticking = false;\n      });\n    };\n  }\n  // 滚动事件处理函数\n  handleScroll() {\n    // 计算开始渲染的索引\n    this.startIndex = Math.floor(\n      this.oContainer.scrollTop / this.state.itemHeight\n    );\n    // 渲染列表\n    this.render();\n  }\n  // 绑定事件\n  bindEvent() {\n    // 注意将handleScroll的this绑定为当前实例\n    // const handle = this.throttle(this.handleScroll.bind(this));\n    const handle = this.rafThrottle(this.handleScroll.bind(this));\n    this.oContainer.addEventListener(\"scroll\", handle);\n  }\n  // 设置数据\n  setData(data) {\n    this.state.data = data;\n    this.render();\n  }\n}\nconst list = new virtualList(\".container\", 50);\nlist.setData(new Array(1000).fill(0).map((item, index) => index + 1));\n```\n\n# Vue3定高\n原理相同，不需要自己操作DOM更加方便。增加了触底增量等功能。[在线效果](https://list.qcqx.cn/#/list/fixed)。\n\n```html\n<template>\n  <div class=\"virtual-list-panel\" v-loading=\"props.loading\">\n    <!-- 虚拟列表容器 -->\n    <div class=\"virtual-list-container\" ref=\"container\">\n      <!-- 虚拟列表 -->\n      <div class=\"virtual-list\" :style=\"listStyle\" ref=\"list\">\n        <!-- 动态渲染的虚拟列表项 -->\n        <div\n          class=\"virtual-list-item\"\n          :style=\"{\n            height: props.itemHeight + 'px',\n          }\"\n          v-for=\"(i, index) in renderList\"\n          :key=\"startIndex + index\"\n        >\n          <slot name=\"item\" :item=\"i\" :index=\"startIndex + index\"></slot>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport { CSSProperties } from \"vue\";\n\nconst props = defineProps<{\n  loading: boolean; // 加载状态\n  itemHeight: number; // item固定高度\n  dataSource: T[]; // 数据\n}>(); // 定义props\nconst emit = defineEmits<{\n  addData: [];\n}>(); // 定义emit\n// 定义插槽类型\ndefineSlots<{\n  // 插槽本质就是个函数，接收一个参数props，props是一个对象，包含了插槽的所有属性\n  item(props: { item: T; index: number }): any;\n}>();\n\n// 获取dom元素\nconst container = ref<HTMLDivElement | null>(null);\nconst list = ref<HTMLDivElement | null>(null);\n\n// 状态\nconst state = reactive({\n  viewHeight: 0, // 列表可视区域高度\n  renderCount: 0, // 渲染数量\n});\n// 起始索引\nconst startIndex = ref(0);\n// 结束索引\nconst endIndex = computed(() => {\n  // 结束索引等于起始索引加上渲染数量\n  const end = startIndex.value + state.renderCount;\n  // 如果结束索引大于数据长度，返回数据长度\n  if (end > props.dataSource.length) {\n    return props.dataSource.length;\n  }\n  return end;\n});\n// 渲染列表\nconst renderList = computed(() => {\n  // 截取数据，slice方法是左闭右开区间，所以结束索引要加1\n  return props.dataSource.slice(startIndex.value, endIndex.value);\n});\n// 列表动态样式\nconst listStyle = computed(() => {\n  // 虚拟卷去的高度\n  const scrollTop = startIndex.value * props.itemHeight;\n  // 虚拟列表的总高度\n  const listHeight = props.dataSource.length * props.itemHeight;\n  // 始终保证height+transformY=列表总高度\n  return {\n    // 设置列表的高度，减去滚动的偏移量\n    height: `${listHeight - scrollTop}px`,\n    // 设置列表的偏移量，通过transform实现滚动效果\n    transform: `translate3d(0, ${scrollTop}px, 0)`,\n  } as CSSProperties;\n});\n\n// 滚动回调\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  return () => {\n    if (!container.value) return;\n    // 滚动的时候计算起始索引，从而引起renderList的重新计算\n    startIndex.value = Math.floor(container.value.scrollTop / props.itemHeight);\n    const { scrollTop, clientHeight, scrollHeight } = container.value;\n    // 滚动到底部，触发加载更多\n    const bottom = scrollHeight - clientHeight - scrollTop;\n    // 判断是否向下滚动\n    const isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    if (bottom < 20 && isScrollingDown) {\n      !props.loading && emit(\"addData\");\n    }\n  };\n};\nconst handleScroll = rafThrottle(createHandleScroll());\n\nconst handleResize = rafThrottle(() => {\n  if (!container.value) return;\n  // 重新计算可视区域高度\n  state.viewHeight = container.value.offsetHeight ?? 0;\n  // 重新计算渲染数量\n  state.renderCount = Math.ceil(state.viewHeight / props.itemHeight) + 1;\n  // 重新计算起始索引\n  startIndex.value = Math.floor(container.value.scrollTop / props.itemHeight);\n});\n\n// 初始化\nconst init = () => {\n  // 获取容器高度作为可视区域高度\n  state.viewHeight = container.value?.offsetHeight ?? 0;\n  // 渲染数量等于可视区域高度除以item高度再加1\n  state.renderCount = Math.ceil(state.viewHeight / props.itemHeight) + 1;\n  // 绑定滚动事件\n  container.value?.addEventListener(\"scroll\", handleScroll);\n  // 绑定resize事件\n  window.addEventListener(\"resize\", handleResize);\n};\n\n// 销毁\nconst destroy = () => {\n  container.value?.removeEventListener(\"scroll\", handleScroll);\n  window.removeEventListener(\"resize\", handleResize);\n};\n\nonMounted(() => {\n  init();\n});\n\nonUnmounted(() => {\n  destroy();\n});\n</script>\n\n<style lang=\"scss\">\n.virtual-list-panel {\n  width: 100%;\n  height: 100%;\n  .virtual-list-container {\n    overflow: auto;\n    width: 100%;\n    height: 100%;\n    .virtual-list {\n      width: 100%;\n      height: 100%;\n      .virtual-list-item {\n        width: 100%;\n        /* 固定高度 */\n        height: 50px;\n        border: 1px solid #333;\n        box-sizing: border-box;\n      }\n    }\n  }\n}\n</style>\n```\n\n使用：\n\n```html\n<template>\n  <div class=\"list-container\">\n    <VirtualList\n      :loading=\"loading\"\n      :data-source=\"data\"\n      :item-height=\"60\"\n      @add-data=\"addData\"\n    >\n      <template #item=\"{ item, index }\">\n        <div>{{ index + 1 }} - {{ item.content }}</div>\n      </template>\n    </VirtualList>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Mock from \"mockjs\";\nconst data = ref<\n  {\n    content: string;\n  }[]\n>([]);\nconst loading = ref(false);\nconst addData = () => {\n  loading.value = true;\n  setTimeout(() => {\n    data.value = data.value.concat(\n      new Array(5000).fill(0).map((_, index) => ({\n        content: Mock.mock(\"@csentence(100)\"),\n      }))\n    );\n    loading.value = false;\n  }, 1000);\n};\nonMounted(() => {\n  addData();\n});\n</script>\n\n<style scoped lang=\"scss\">\n.list-container {\n  max-width: 600px;\n  width: 100%;\n  height: calc(100vh - 100px);\n  border: 1px solid #333;\n}\n</style>\n```\n\n# Vue3不定高\n不定高即每个列表项高度不确定，核心原理和定高一样，找到 `startIndex` 和 `endIndex` 确定实际渲染列表、虚拟滚动样式，再由 `transform` 模拟滚动。[在线效果](https://list.qcqx.cn/#/list/estimated)。\n\n但不定高，确定 `startIndex` 以及计算位置信息就需要额外设计。\n\n## 数据结构\n通常做法是由外部传入一个适中的**平均高度**，作为每项的初始高度，并确定一个固定的渲染数量。\n\n组件 props：\n\n```ts\ninterface EstimatedListProps<T> {\n  loading: boolean; // 加载状态\n  estimatedHeight: number; // 预测的高度\n  dataSource: T[]; // 数据\n}\nconst props = defineProps<EstimatedListProps<T>>();\n```\n\n为了方便计算和使用**位置信息**，使用一个数组，对应记录 `dataSource` 中每一项的顶部位置、底部位置、高度、高度差。\n\n```ts\ninterface PosInfo {\n  top: number; // 顶部位置\n  bottom: number; // 底部位置\n  height: number; // 高度\n  dHeight: number; // 实际高度与预设高度的差值,判断是否需要更新\n}\nconst positions = ref<PosInfo[]>([]);\n```\n\n列表的状态：\n\n```ts\nconst state = reactive({\n  viewHeight: 0, // 列表可视区域高度\n  listHeight: 0, // 列表总高度\n  startIndex: 0, // 起始索引\n  renderCount: 0, // 渲染数量\n  preLen: 0, // 当前数据量\n});\n```\n\n结束索引 `endIndex` 是一个计算属性：\n\n```ts\nconst endIndex = computed(() =>\n  Math.min(props.dataSource.length, state.startIndex + state.renderCount)\n);\n```\n\n渲染列表同样由 startIndex 和 endIndex 确定。\n\n```ts\nconst renderList = computed(() =>\n  props.dataSource.slice(state.startIndex, endIndex.value)\n);\n```\n\n计算动态样式，使用 transform 模拟滚动，使用 translate3d 可以调用 GPU 辅助计算，性能更好。\n\n```ts\nconst listStyle = computed(() => {\n  // 起始元素的top就是虚拟列表的前置占位高度\n  const preHeight = positions.value[state.startIndex]?.top;\n  return {\n    height: `${state.listHeight - preHeight}px`,\n    transform: `translate3d(0, ${preHeight}px, 0)`,\n  } as CSSProperties;\n});\n```\n\n## 挂载初始化\n在组件挂载后调用 `init()`。\n\n```ts\nonMounted(() => {\n  init();\n});\n```\n\n初始化获取可视区域高度、计算渲染数量、绑定事件。\n\n```ts\nconst init = () => {\n  state.viewHeight = contentRef.value?.offsetHeight ?? 0;\n  // 不定高的渲染数量也是确定的，根据item预设高度得到，所以预设高度应该根据实际情况设置，最好偏小\n  state.renderCount = Math.ceil(state.viewHeight / props.estimatedHeight) + 1;\n  contentRef.value?.addEventListener(\"scroll\", handleScroll);\n  window.addEventListener(\"resize\", handleResize);\n};\n```\n\n## 滚动事件\n滚动事件的核心是调用 `findStartingIndex()` 找到起始索引，在后续根据起始索引计算位置信息。\n\n```ts\n// 滚动回调\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  return () => {\n    if (!contentRef.value) return;\n    const { scrollTop, clientHeight, scrollHeight } = contentRef.value;\n    // 计算起始索引\n    state.startIndex = findStartingIndex(scrollTop);\n    // 接着处理触底\n    const bottom = scrollHeight - clientHeight - scrollTop;\n    // 判断是否向下滚动\n    const isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    if (bottom < 20 && isScrollingDown) {\n      // 触底触发事件\n      !props.loading && emit(\"addData\");\n      // console.log(\"触底\");\n    }\n  };\n};\nconst handleScroll = rafThrottle(createHandleScroll());\n```\n\n## 查找起始索引\n使用二分查找，找到第一个 bottom 大于或等于 scrollTop 的 item。\n\n```ts\nconst findStartingIndex = (scrollTop: number) => {\n  // 每一项的bottom是递增的，所以可以通过二分查找来查找起始索引\n  let left = 0;\n  let right = positions.value.length - 1;\n  let mid = -1;\n  while (left < right) {\n    const midIndx = Math.floor((left + right) / 2);\n    const midValue = positions.value[midIndx].bottom;\n    if (midValue === scrollTop) {\n      return midIndx;\n    } else if (midValue < scrollTop) {\n      left = midIndx + 1;\n    } else {\n      right = midIndx;\n      // 如果midValue大于scrollTop，还需要记录midIndx\n      // 其作用是，如果找不到相等的值，返回bottom大于scrollTop的第一个item\n      // 逐步往顶部逼近，直到找到第一个bottom大于scrollTop的item\n      if (mid === -1 || mid > midIndx) {\n        mid = midIndx;\n      }\n    }\n  }\n  return mid;\n};\n```\n\n## 计算位置信息\n不定高虚拟列表的核心就是计算每一项的位置信息，再根据这些信息去渲染。\n\n使用 watch 监听数据源的变化、Dom变化，计算位置信息。先初始化位置信息，再在下一次渲染时更新实际位置信息。\n\n```ts\n// 当list dom渲染完成后，初始化位置信息，当dataSource变化时，也重新初始化位置信息\nwatch([() => listRef.value, () => props.dataSource], () => {\n  props.dataSource.length && initPositions();\n  nextTick(() => {\n    updatePositions();\n  });\n});\n```\n\n当 startIndex 变化时，也需要更新位置信息。\n\n```ts\n// 监听startIndex变化，更新位置信息\nwatch(\n  () => state.startIndex,\n  () => {\n    nextTick(() => {\n      updatePositions();\n    });\n  }\n);\n```\n\n### 初始化位置信息\n位置信息需要与数据源一一对应，初始的高度就是预设高度。\n\n```ts\nconst initPositions = () => {\n  const pos: PosInfo[] = [];\n  const disLen = props.dataSource.length - state.preLen;\n  // 记录前一次的最后一个元素的top和bottom，增量的数据根据其计算初始位置\n  const preTop = positions.value[state.preLen - 1]?.bottom ?? 0;\n  const preBottom = positions.value[state.preLen - 1]?.bottom ?? 0;\n  for (let i = 0; i < disLen; i++) {\n    pos.push({\n      height: props.estimatedHeight, // 初始化时传入预设高度\n      top: preTop + i * props.estimatedHeight, // 前一个的bottom就是下一个的top\n      bottom: preBottom + (i + 1) * props.estimatedHeight, // 下一个的top就是前一个的bottom\n      dHeight: 0, // 实际高度与预设高度的差值\n    });\n  }\n  // 增量更新positions\n  positions.value = [...positions.value, ...pos];\n  state.preLen = props.dataSource.length;\n};\n```\n\n### 更新位置信息\n在实际DOM渲染完成后，获取实际位置信息，并更新 positions。\n\n这里是不定高虚拟列表计算量最大的地方：\n1. 获取DOM上已渲染的item，累加一个高度差偏移量，根据实际DOM更新对应的位置信息。\n2. 更新后续所有未渲染的item的位置信息、以及列表总高度。\n\n```ts\nconst updatePositions = () => {\n  // 获取dom上已渲染的所有的item\n  const itemNodes = listRef.value?.children;\n  if (!itemNodes || !itemNodes.length) return;\n  // dHeightAccount类似一个偏移量，可以影响后续的item的位置\n  let dHeightAccount = 0;\n  // 遍历所有的itemNode\n  for (let i = 0; i < itemNodes.length; i++) {\n    const node = itemNodes[i];\n    // 遍历获取每个itemNode的实际位置信息\n    const rect = node.getBoundingClientRect();\n    const id = state.startIndex + i;\n    // 获取当前item在positions保存的位置信息\n    const itemPos = positions.value[id];\n    // 真实高度减去预设高度\n    const dHeight = rect.height - itemPos.height;\n    // 累加高度偏移量\n    dHeightAccount += dHeight;\n    if (dHeight) {\n      // 更新positions中的位置信息\n      itemPos.height = rect.height;\n      itemPos.dHeight = dHeight;\n      itemPos.bottom = itemPos.bottom + dHeightAccount;\n    }\n    // 不是第一个item，可以更新top\n    if (i !== 0) {\n      // 当前的top等于前一个的bottom\n      itemPos.top = positions.value[id - 1].bottom;\n    }\n  }\n  // 处理后续未渲染的item\n  const endID = endIndex.value;\n  for (let i = endID; i < positions.value.length; i++) {\n    const itemPos = positions.value[i];\n    // 当前的top等于前一个的bottom\n    itemPos.top = positions.value[i - 1].bottom;\n    // 当前item的bottom受到dHeightAccount的影响，相当于被前面的item挤开了\n    itemPos.bottom = itemPos.bottom + dHeightAccount;\n    if (itemPos.dHeight) {\n      // 累加高度偏移量\n      dHeightAccount += itemPos.dHeight;\n      itemPos.dHeight = 0;\n    }\n  }\n  // 更新列表总高度\n  // 最后一个item的bottom就是列表的总高度\n  state.listHeight = positions.value[positions.value.length - 1].bottom;\n};\n```\n\n## 完整代码\n\n```html\n<template>\n  <!-- 容器 -->\n  <div class=\"virtual-list-container\" v-loading=\"props.loading\">\n    <!-- 内容 -->\n    <div class=\"virtual-list-content\" ref=\"contentRef\">\n      <!-- 虚拟列表 -->\n      <div class=\"virtual-list\" ref=\"listRef\" :style=\"listStyle\">\n        <div\n          class=\"virtual-list-item\"\n          v-for=\"(i, index) in renderList\"\n          :id=\"String(state.startIndex + index)\"\n          :key=\"state.startIndex + index\"\n        >\n          <slot name=\"item\" :item=\"i\" :index=\"state.startIndex + index\"></slot>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport { CSSProperties } from \"vue\";\n// props类型\ninterface EstimatedListProps<T> {\n  loading: boolean; // 加载状态\n  estimatedHeight: number; // 预测的高度\n  dataSource: T[]; // 数据\n}\n// 位置信息\ninterface PosInfo {\n  top: number; // 顶部位置\n  bottom: number; // 底部位置\n  height: number; // 高度\n  dHeight: number; // 实际高度与预设高度的差值,判断是否需要更新\n}\n\nconst props = defineProps<EstimatedListProps<T>>();\nconst emit = defineEmits<{\n  addData: [];\n}>();\n// 定义插槽类型\ndefineSlots<{\n  // 插槽本质就是个函数，接收一个参数props，props是一个对象，包含了插槽的所有属性\n  item(props: { item: T; index: number }): any;\n}>();\n\n// 状态\nconst state = reactive({\n  viewHeight: 0, // 列表可视区域高度\n  listHeight: 0, // 列表总高度\n  startIndex: 0, // 起始索引\n  renderCount: 0, // 渲染数量\n  preLen: 0, // 当前数据量\n});\n// 结束索引\nconst endIndex = computed(() =>\n  Math.min(props.dataSource.length, state.startIndex + state.renderCount)\n);\n// 渲染列表\nconst renderList = computed(() =>\n  props.dataSource.slice(state.startIndex, endIndex.value)\n);\n// 位置信息\nconst positions = ref<PosInfo[]>([]);\n// 动态样式\nconst listStyle = computed(() => {\n  // 起始元素的top就是虚拟列表的前置占位高度\n  const preHeight = positions.value[state.startIndex]?.top;\n  return {\n    height: `${state.listHeight - preHeight}px`,\n    transform: `translate3d(0, ${preHeight}px, 0)`,\n  } as CSSProperties;\n});\n// 获取dom元素\nconst contentRef = ref<HTMLDivElement>();\nconst listRef = ref<HTMLDivElement>();\n\n// 初始化位置信息\nconst initPositions = () => {\n  const pos: PosInfo[] = [];\n  const disLen = props.dataSource.length - state.preLen;\n  // 记录前一次的最后一个元素的top和bottom，增量的数据根据其计算初始位置\n  const preTop = positions.value[state.preLen - 1]?.bottom ?? 0;\n  const preBottom = positions.value[state.preLen - 1]?.bottom ?? 0;\n  for (let i = 0; i < disLen; i++) {\n    pos.push({\n      height: props.estimatedHeight, // 初始化时传入预设高度\n      top: preTop + i * props.estimatedHeight, // 前一个的bottom就是下一个的top\n      bottom: preBottom + (i + 1) * props.estimatedHeight, // 下一个的top就是前一个的bottom\n      dHeight: 0, // 实际高度与预设高度的差值\n    });\n  }\n  // 增量更新positions\n  positions.value = [...positions.value, ...pos];\n  state.preLen = props.dataSource.length;\n};\n\n// 在实际dom渲染完成后，获取实际位置信息，并更新positions\nconst updatePositions = () => {\n  // 获取dom上已渲染的所有的item\n  const itemNodes = listRef.value?.children;\n  if (!itemNodes || !itemNodes.length) return;\n  // dHeightAccount类似一个偏移量，可以影响后续的item的位置\n  let dHeightAccount = 0;\n  // 遍历所有的itemNode\n  for (let i = 0; i < itemNodes.length; i++) {\n    const node = itemNodes[i];\n    // 遍历获取每个itemNode的实际位置信息\n    const rect = node.getBoundingClientRect();\n    const id = state.startIndex + i;\n    // 获取当前item在positions保存的位置信息\n    const itemPos = positions.value[id];\n    // 真实高度减去预设高度\n    const dHeight = rect.height - itemPos.height;\n    // 累加高度偏移量\n    dHeightAccount += dHeight;\n    if (dHeight) {\n      // 更新positions中的位置信息\n      itemPos.height = rect.height;\n      itemPos.dHeight = dHeight;\n      itemPos.bottom = itemPos.bottom + dHeightAccount;\n    }\n    // 不是第一个item，可以更新top\n    if (i !== 0) {\n      // 当前的top等于前一个的bottom\n      itemPos.top = positions.value[id - 1].bottom;\n    }\n  }\n  // 处理后续未渲染的item\n  const endID = endIndex.value;\n  for (let i = endID; i < positions.value.length; i++) {\n    const itemPos = positions.value[i];\n    // 当前的top等于前一个的bottom\n    itemPos.top = positions.value[i - 1].bottom;\n    // 当前item的bottom受到dHeightAccount的影响，相当于被前面的item挤开了\n    itemPos.bottom = itemPos.bottom + dHeightAccount;\n    if (itemPos.dHeight) {\n      // 累加高度偏移量\n      dHeightAccount += itemPos.dHeight;\n      itemPos.dHeight = 0;\n    }\n  }\n  // 更新列表总高度\n  // 最后一个item的bottom就是列表的总高度\n  state.listHeight = positions.value[positions.value.length - 1].bottom;\n};\n\n// 滚动回调\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  return () => {\n    if (!contentRef.value) return;\n    const { scrollTop, clientHeight, scrollHeight } = contentRef.value;\n    // 计算起始索引\n    state.startIndex = findStartingIndex(scrollTop);\n    // 接着处理触底\n    const bottom = scrollHeight - clientHeight - scrollTop;\n    // 判断是否向下滚动\n    const isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    if (bottom < 20 && isScrollingDown) {\n      // 触底触发事件\n      !props.loading && emit(\"addData\");\n      // console.log(\"触底\");\n    }\n  };\n};\nconst handleScroll = rafThrottle(createHandleScroll());\n\n// 查找起始索引\nconst findStartingIndex = (scrollTop: number) => {\n  // 每一项的bottom是递增的，所以可以通过二分查找来查找起始索引\n  let left = 0;\n  let right = positions.value.length - 1;\n  let mid = -1;\n  while (left < right) {\n    const midIndx = Math.floor((left + right) / 2);\n    const midValue = positions.value[midIndx].bottom;\n    if (midValue === scrollTop) {\n      return midIndx;\n    } else if (midValue < scrollTop) {\n      left = midIndx + 1;\n    } else {\n      right = midIndx;\n      // 如果midValue大于scrollTop，还需要记录midIndx\n      // 其作用是，如果找不到相等的值，返回bottom大于scrollTop的第一个item\n      // 逐步往顶部逼近，直到找到第一个bottom大于scrollTop的item\n      if (mid === -1 || mid > midIndx) {\n        mid = midIndx;\n      }\n    }\n  }\n  return mid;\n};\n\nconst handleResize = rafThrottle(() => {\n  if (!contentRef.value) return;\n  state.viewHeight = contentRef.value.offsetHeight ?? 0;\n  state.renderCount = Math.ceil(state.viewHeight / props.estimatedHeight) + 1;\n  state.startIndex = findStartingIndex(contentRef.value.scrollTop);\n});\n\n// 初始化\nconst init = () => {\n  state.viewHeight = contentRef.value?.offsetHeight ?? 0;\n  // 不定高的渲染数量也是确定的，根据item预设高度得到，所以预设高度应该根据实际情况设置，最好偏小\n  state.renderCount = Math.ceil(state.viewHeight / props.estimatedHeight) + 1;\n  contentRef.value?.addEventListener(\"scroll\", handleScroll);\n  window.addEventListener(\"resize\", handleResize);\n};\n\n// 销毁\nconst destroy = () => {\n  contentRef.value?.removeEventListener(\"scroll\", handleScroll);\n  window.removeEventListener(\"resize\", handleResize);\n};\n\n// 当list dom渲染完成后，初始化位置信息，当dataSource变化时，也重新初始化位置信息\nwatch([() => listRef.value, () => props.dataSource], () => {\n  props.dataSource.length && initPositions();\n  nextTick(() => {\n    updatePositions();\n  });\n});\n\n// 监听startIndex变化，更新位置信息\nwatch(\n  () => state.startIndex,\n  () => {\n    nextTick(() => {\n      updatePositions();\n    });\n  }\n);\n\nonMounted(() => {\n  init();\n});\n\nonUnmounted(() => {\n  destroy();\n});\n</script>\n\n<style lang=\"scss\">\ndiv.virtual-list-container {\n  width: 100%;\n  height: 100%;\n  div.virtual-list-content {\n    width: 100%;\n    height: 100%;\n    overflow: auto;\n    div.virtual-list {\n      div.virtual-list-item {\n        width: 100%;\n        box-sizing: border-box;\n        border: 1px solid #333;\n      }\n    }\n  }\n}\n</style>\n```\n\n使用：\n\n```html\n<template>\n  <div class=\"list-container\">\n    <EstimatedVirtualList\n      :data-source=\"data\"\n      :loading=\"loading\"\n      :estimated-height=\"40\"\n      @addData=\"addData\"\n      :height=\"500\"\n      :width=\"600\"\n    >\n      <template #item=\"{ item, index }\">\n        <div>{{ index + 1 }} - {{ item.content }}</div>\n      </template>\n    </EstimatedVirtualList>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Mock from \"mockjs\";\nconst data = ref<\n  {\n    content: string;\n  }[]\n>([]);\nconst loading = ref(false);\nconst addData = () => {\n  loading.value = true;\n  setTimeout(() => {\n    data.value = data.value.concat(\n      new Array(2000).fill(0).map((_, index) => ({\n        content: Mock.mock(\"@csentence(40, 100)\"),\n      }))\n    );\n    loading.value = false;\n  }, 1000);\n};\nonMounted(() => {\n  addData();\n});\n</script>\n\n<style scoped lang=\"scss\">\n.list-container {\n  max-width: 600px;\n  width: 100%;\n  height: calc(100vh - 100px);\n  border: 1px solid #333;\n}\n</style>\n```\n\n\n# 瀑布流\n在实现虚拟瀑布流之前，需要先学习下普通的瀑布流。[在线效果](https://list.qcqx.cn/#/list/waterfall)。\n\n通常通过绝对定位实现瀑布流，动态计算**布局**，且元素通常带有图片。\n\n对于图片的处理，常见的优化是由后端预先传图片的宽高，这样能减少计算布局的次数。\n不过在普通瀑布流这，我还是采用了前端计算，即在图片 load 完后再次计算布局，实际上性能还可以。在之后的虚拟瀑布流实现，就允许传入宽高信息，减少计算量。\n\n布局计算：每次找到最小高度列，添加元素。\n\n## DOM结构\n使用插槽，允许自定义每项的DOM结构。\n\n```html\n<template>\n  <div class=\"water-fall-panel\" v-loading=\"props.loading\">\n    <div class=\"water-fall-container\" ref=\"containerRef\" @scroll=\"handleScroll\">\n      <div\n        class=\"water-fall-content\"\n        ref=\"contentRef\"\n        :style=\"{\n          height: state.maxHeight + 'px',\n        }\"\n      >\n        <div\n          class=\"water-fall-item\"\n          v-for=\"(i, index) in props.data\"\n          :style=\"{\n            width: state.columnWidth + 'px',\n          }\"\n          :key=\"index\"\n        >\n          <slot name=\"item\" :item=\"i\" :index=\"index\" :load=\"imgLoadHandle\">\n            <img :src=\"i.src\" @load=\"imgLoadHandle\" />\n          </slot>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\n## 数据结构\n每项数据定义：需要一个图片地址，当然也可以加入其它东西，毕竟使用了插槽，DOM结构是允许自定义的。\n\n```ts\ninterface imgData {\n  src: string; // 图片地址\n  [key: string]: any;\n}\n```\n\n组件 props：\n传入列数、每项之间的间距、以及数据源。\n\n```ts\nconst props = defineProps<{\n  loading: boolean; // 加载状态\n  column: number; // 列数\n  space: number; // 间距\n  data: imgData[]; // 数据\n}>(); // 定义props\n```\n\n基本状态：\n主要是列宽和最高列高，三种数据长度只是辅助计算需要。\n\n```ts\nconst state = reactive<{\n  columnWidth: number; // 列宽\n  maxHeight: number; // 最高列高\n  firstLength: number; // 第一次加载的数据长度\n  lastLength: number; // 最后一次加载的数据长度\n  loadedLength: number; // 已加载的数据长度\n}>({\n  columnWidth: 0,\n  maxHeight: 0,\n  firstLength: 0,\n  lastLength: 0,\n  loadedLength: 0,\n});\n```\n\n## 挂载初始化\n计算一次布局，绑定事件，滚动事件已经通过模板语法 @scroll 绑定。\n\n```ts\nconst init = () => {\n  computedLayout();\n  window.addEventListener(\"resize\", resizeHandler);\n};\n\nonMounted(() => {\n  init();\n});\n```\n\n## 计算布局\n计算布局分为两部：先计算列宽，再计算每项位置信息。\n\n```ts\nconst computedLayout = rafThrottle(() => {\n  computedColumWidth();\n  setPositions();\n});\n```\n\n列宽通过容器宽度除以列数即可，当然还要考虑间距。\n\n```ts\n// 计算列宽\nconst computedColumWidth = () => {\n  // 获取容器宽度\n  const containerWidth = contentRef.value?.clientWidth || 0;\n  // 计算列宽\n  state.columnWidth =\n    (containerWidth - (props.column - 1) * props.space) / props.column;\n};\n```\n\n### 计算位置信息\n初始化每列高度为0，遍历所有图片元素，每次找到最小高度列添加元素。\n\n代码中有一大段是为了实现动画效果。\n\n```ts\nconst setPositions = () => {\n  // 每列的高度初始化为0\n  const columnHeight = new Array(props.column).fill(0);\n  // 获取所有图片元素\n  const imgItems = contentRef.value?.children;\n  if (!imgItems || imgItems.length === 0) return;\n  if (state.firstLength === 0) {\n    state.firstLength = imgItems.length;\n  }\n  // 遍历图片元素\n  for (let i = 0; i < imgItems.length; i++) {\n    const img = imgItems[i] as HTMLDivElement;\n    // 获取最小高度的列\n    const minHeight = Math.min.apply(null, columnHeight);\n    // 获取最小高度的列索引\n    const minHeightIndex = columnHeight.indexOf(minHeight);\n    // 设置图片位置\n    // img.style.top = minHeight + \"px\";\n    // img.style.left = minHeightIndex * (state.columnWidth + props.space) + \"px\";\n    img.style.setProperty(\n      \"--img-tr-x\",\n      `${minHeightIndex * (state.columnWidth + props.space)}px`\n    );\n    img.style.transform = `translate3d(var(--img-tr-x), var(--img-tr-y), 0)`;\n    if (!img.classList.contains(\"animation-over\")) {\n      img.classList.add(\"animation-over\");\n      img.style.transition = \"none\";\n      if (i >= state.firstLength) {\n        img.style.setProperty(\"--img-tr-y\", `${minHeight + 60}px`);\n      } else {\n        img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n      }\n      img.offsetHeight; // 强制渲染\n      img.style.transition = \"all 0.3s\";\n      img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n    } else {\n      img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n    }\n    // 更新列高\n    columnHeight[minHeightIndex] += img.offsetHeight + props.space;\n  }\n  // 更新最高列高\n  state.maxHeight = Math.max.apply(null, columnHeight);\n};\n```\n\n每当有图片加载完，也要重新计算布局。\n\n```ts\nconst imgLoadHandle = () => {\n  state.loadedLength++;\n  computedLayout();\n};\n```\n\n## 完整代码\n\n```ts\n<template>\n  <div class=\"water-fall-panel\" v-loading=\"props.loading\">\n    <div class=\"water-fall-container\" ref=\"containerRef\" @scroll=\"handleScroll\">\n      <div\n        class=\"water-fall-content\"\n        ref=\"contentRef\"\n        :style=\"{\n          height: state.maxHeight + 'px',\n        }\"\n      >\n        <div\n          class=\"water-fall-item\"\n          v-for=\"(i, index) in props.data\"\n          :style=\"{\n            width: state.columnWidth + 'px',\n          }\"\n          :key=\"index\"\n        >\n          <slot name=\"item\" :item=\"i\" :index=\"index\" :load=\"imgLoadHandle\">\n            <img :src=\"i.src\" @load=\"imgLoadHandle\" />\n          </slot>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface imgData {\n  src: string; // 图片地址\n  [key: string]: any;\n}\nconst props = defineProps<{\n  loading: boolean; // 加载状态\n  column: number; // 列数\n  space: number; // 间距\n  data: imgData[]; // 数据\n}>(); // 定义props\nconst emit = defineEmits<{\n  addData: [];\n}>(); // 定义emit\n// 定义插槽\ndefineSlots<{\n  // 插槽本质就是个函数，接收一个参数props，props是一个对象，包含了插槽的所有属性\n  item(props: {\n    item: imgData;\n    index: number;\n    load: typeof computedLayout;\n  }): any;\n}>();\n\n// 状态\nconst state = reactive<{\n  columnWidth: number; // 列宽\n  maxHeight: number; // 最高列高\n  firstLength: number; // 第一次加载的数据长度\n  lastLength: number; // 最后一次加载的数据长度\n  loadedLength: number; // 已加载的数据长度\n}>({\n  columnWidth: 0,\n  maxHeight: 0,\n  firstLength: 0,\n  lastLength: 0,\n  loadedLength: 0,\n});\n\n// 获取dom元素\nconst contentRef = ref<HTMLDivElement | null>(null);\nconst containerRef = ref<HTMLDivElement | null>(null);\n\n// 计算列宽\nconst computedColumWidth = () => {\n  // 获取容器宽度\n  const containerWidth = contentRef.value?.clientWidth || 0;\n  // 计算列宽\n  state.columnWidth =\n    (containerWidth - (props.column - 1) * props.space) / props.column;\n};\n\n// 设置每个图片的位置\nconst setPositions = () => {\n  // 每列的高度初始化为0\n  const columnHeight = new Array(props.column).fill(0);\n  // 获取所有图片元素\n  const imgItems = contentRef.value?.children;\n  if (!imgItems || imgItems.length === 0) return;\n  if (state.firstLength === 0) {\n    state.firstLength = imgItems.length;\n  }\n  // 遍历图片元素\n  for (let i = 0; i < imgItems.length; i++) {\n    const img = imgItems[i] as HTMLDivElement;\n    // 获取最小高度的列\n    const minHeight = Math.min.apply(null, columnHeight);\n    // 获取最小高度的列索引\n    const minHeightIndex = columnHeight.indexOf(minHeight);\n    // 设置图片位置\n    // img.style.top = minHeight + \"px\";\n    // img.style.left = minHeightIndex * (state.columnWidth + props.space) + \"px\";\n    img.style.setProperty(\n      \"--img-tr-x\",\n      `${minHeightIndex * (state.columnWidth + props.space)}px`\n    );\n    img.style.transform = `translate3d(var(--img-tr-x), var(--img-tr-y), 0)`;\n    if (!img.classList.contains(\"animation-over\")) {\n      img.classList.add(\"animation-over\");\n      img.style.transition = \"none\";\n      if (i >= state.firstLength) {\n        img.style.setProperty(\"--img-tr-y\", `${minHeight + 60}px`);\n      } else {\n        img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n      }\n      img.offsetHeight; // 强制渲染\n      img.style.transition = \"all 0.3s\";\n      img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n    } else {\n      img.style.setProperty(\"--img-tr-y\", `${minHeight}px`);\n    }\n    // 更新列高\n    columnHeight[minHeightIndex] += img.offsetHeight + props.space;\n  }\n  // 更新最高列高\n  state.maxHeight = Math.max.apply(null, columnHeight);\n};\n\nconst imgLoadHandle = () => {\n  state.loadedLength++;\n  computedLayout();\n};\n\n// 计算布局\nconst computedLayout = rafThrottle(() => {\n  computedColumWidth();\n  setPositions();\n});\n\n// 尺寸变化后计算布局\nconst createResizeComputedLayout = () => {\n  let timer: number;\n  return () => {\n    computedColumWidth();\n    window.requestAnimationFrame(() => {\n      timer = setTimeout(() => {\n        setPositions();\n      }, 300);\n    });\n  };\n};\n\nconst resizeComputedLayout = createResizeComputedLayout();\n\n// 监听列数和间距变化，重新计算布局\nwatch(\n  () => [props.column, props.space],\n  () => {\n    // console.log(\"change column or space\");\n    resizeComputedLayout();\n  }\n);\n\nconst resizeHandler = debounce(() => {\n  resizeComputedLayout();\n}, 300);\n\nconst init = () => {\n  computedLayout();\n  window.addEventListener(\"resize\", resizeHandler);\n};\n\nonMounted(() => {\n  init();\n});\n\nonUnmounted(() => {\n  window.removeEventListener(\"resize\", resizeHandler);\n});\n\n// 滚动回调\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  return () => {\n    if (!containerRef.value) return;\n    const { scrollTop, clientHeight, scrollHeight } = containerRef.value;\n    const bottom = scrollHeight - clientHeight - scrollTop;\n    // 判断是否向下滚动\n    const isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    if (bottom < 20 && isScrollingDown) {\n      // 只有本次加载的数据加载完毕后才能继续加载\n      if (state.loadedLength >= props.data.length - state.lastLength) {\n        // 记录上次加载的数据长度\n        state.lastLength = props.data.length;\n        state.loadedLength = 0;\n        // 加载新数据\n        !props.loading && emit(\"addData\");\n      }\n      containerRef.value.offsetHeight;\n    }\n  };\n};\nconst handleScroll = rafThrottle(createHandleScroll());\n</script>\n\n<style lang=\"scss\">\n.water-fall-panel {\n  height: 100%;\n  width: 100%;\n  .water-fall-container {\n    height: 100%;\n    width: 100%;\n    overflow-y: auto;\n    overflow-x: hidden;\n    .water-fall-content {\n      height: 100%;\n      width: 100%;\n      position: relative;\n      .water-fall-item {\n        position: absolute;\n        transition: all 0.3s;\n        overflow: hidden;\n        img {\n          width: 100%;\n          object-fit: cover;\n          overflow: hidden;\n          display: block;\n        }\n      }\n    }\n  }\n}\n</style>\n```\n\n使用：\n\n```ts\n<template>\n  <div class=\"list-container\">\n    <WaterFallList\n      :data=\"data\"\n      :loading=\"loading\"\n      :column=\"column\"\n      :space=\"space\"\n      @add-data=\"addData\"\n    >\n      <template #item=\"{ item, index, load }\">\n        <div\n          :style=\"{\n            display: 'flex',\n            flexDirection: 'column',\n          }\"\n        >\n          <img :src=\"item.src\" @load=\"load\" />\n          <span>{{ item.title }}</span>\n        </div>\n      </template>\n    </WaterFallList>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Mock from \"mockjs\";\nconst data = ref<\n  {\n    src: string;\n    title: string;\n  }[]\n>([]);\nconst loading = ref(false);\nconst column = ref(4);\nconst space = ref(10);\n\nlet size = 40;\nlet page = 1;\nconst addData = () => {\n  // fetchData();\n  simulatedData();\n};\nconst simulatedData = () => {\n  loading.value = true;\n  setTimeout(() => {\n    data.value = data.value.concat(\n      new Array(size * 2).fill(0).map((_, index) => ({\n        src: Mock.Random.dataImage(),\n        title: Mock.mock(\"@ctitle(5, 15)\"),\n      }))\n    );\n    loading.value = false;\n  }, 1000);\n};\nconst fetchData = () => {\n  loading.value = true;\n  fetch(\n    `https://www.vilipix.com/api/v1/picture/public?limit=${size}&offset=${\n      (page - 1) * size\n    }&sort=hot&type=0`\n  )\n    .then((res) => res.json())\n    .then((res) => {\n      page++;\n      const list = res.data.rows;\n      data.value = data.value.concat(\n        list.map((item: any) => ({\n          src: item.regular_url,\n          title: item.title,\n        }))\n      );\n      loading.value = false;\n    });\n};\nonMounted(() => {\n  addData();\n  // setTimeout(() => {\n  //   column.value = 5;\n  // }, 3000);\n});\n</script>\n\n<style scoped lang=\"scss\">\n.list-container {\n  max-width: 800px;\n  width: 100%;\n  height: calc(100vh - 100px);\n  border: 1px solid #333;\n}\n</style>\n```\n\n\n# 虚拟瀑布流\n虚拟瀑布流将虚拟列表和瀑布流相结合，保证在大量图片、DOM元素的情况下，能够正常渲染。[在线效果](https://list.qcqx.cn/#/list/virtualwaterfall)。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/98-2.webp\" width=\"100%\" />\n\n## DOM结构\n\n```ts\n<template>\n  <div class=\"virtual-waterfall-panel\" v-loading=\"props.loading\">\n    <component :is=\"'style'\">{{ animationStyle }}</component>\n    <div class=\"virtual-waterfall-container\" ref=\"containerRef\">\n      <div\n        class=\"virtual-waterfall-list\"\n        ref=\"listRef\"\n        :style=\"{\n          height: state.minHeight + 'px',\n        }\"\n      >\n        <div\n          class=\"virtual-waterfall-item\"\n          v-for=\"i in state.renderList\"\n          :style=\"i.style\"\n          :data-column=\"i.column\"\n          :data-renderIndex=\"i.renderIndex\"\n          :data-loaded=\"i.data.src ? 0 : 1\"\n          :key=\"i.index\"\n        >\n          <div class=\"animation-box\">\n            <slot\n              name=\"item\"\n              :item=\"i\"\n              :index=\"i.index\"\n              :load=\"imgLoadedHandle\"\n            >\n              <img\n                :src=\"i.data.src\"\n                @load=\"imgLoadedHandle\"\n                v-if=\"props.compute\"\n              />\n              <img :src=\"i.data.src\" v-else />\n            </slot>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\n\n## 数据结构\n虚拟瀑布流的数据结构较为复杂，需要额外维护渲染队列和渲染列表。\n\n数据源：允许传入宽高，以减少计算量。\n\n```ts\n// 每个图片的数据\ninterface ImgData {\n  src: string; // 图片地址\n  height?: number; // 图片高度\n  width?: number; // 图片宽度\n  [key: string]: any;\n}\n```\n\n虚拟瀑布流需要多维护一个渲染队列，保存瀑布流中每列的渲染列表、列高度，而渲染列表中保存了渲染项的元数据。\n\n```ts\n// 每列队列的信息\ninterface columnQueue {\n  height: number; // 高度\n  renderList: RenderItem[]; // 该列的渲染列表\n}\n```\n\n每个渲染项元数据包括了其在数据源的索引、所在列、渲染索引、Y轴偏移量、样式等。\n其中 offsetY 是关键，它参与计算量该项是否要渲染，以及渲染的高度（Y轴位置）。\n\n```ts\n// 渲染的每个item\ninterface RenderItem {\n  index: number; // 位于数据源的索引\n  column: number; // 所在列\n  renderIndex: number; // 渲染索引\n  data: ImgData; // 图片数据\n  offsetY: number; // y轴偏移量\n  height: number; // 高度\n  style: CSSProperties; // 用于渲染视图上的样式（宽、高、偏移量）\n}\n```\n\n组件 props：\n允许自定义动画、设置缓冲高度、以及设置 compute 动态计算尺寸。\n\n仍然需要传入 estimatedHeight 预设高度，因为其本质也是不定高的，需要预设高度完成每项的初始计算，当然外部传入宽高将在计算时覆盖预设高度。\n\n```ts\n// 定义props\ninterface Props {\n  loading: boolean; // 加载状态\n  column: number; // 列数\n  estimatedHeight: number; // 每项预设高度\n  gap?: number; // 间距\n  dataSource: ImgData[]; // 数据源\n  compute?: boolean; // 是否需要动态计算尺寸\n  animation?: boolean | string; // 是否需要动画，也可以传入自定义动画\n  bufferHeight?: number; // 缓冲高度，会提前渲染一部分数据\n}\nconst props = withDefaults(defineProps<Props>(), {\n  gap: 0,\n  compute: true,\n  animation: true,\n  bufferHeight: -1,\n});\n```\n\n基本状态：\nstate.renderList 保存了**实际需要渲染**的渲染元数据。注意与 queueList[number].renderList 区分。\n还需记录最高、最低列高，方便计算。\n\n```ts\n// 状态\nconst state = reactive({\n  columnWidth: 0, // 列宽\n  viewHeight: 0, // 视口高度\n  // 队列集合\n  queueList: Array.from({ length: props.column }).map<columnQueue>(() => ({\n    height: 0,\n    renderList: [],\n  })),\n  renderList: [] as RenderItem[], // 渲染列表\n  maxHeight: 0, // 最高列高\n  minHeight: 0, // 最低列高\n  preLen: 0, // 前一次数据长度\n  isScrollingDown: true, // 是否向下滚动\n});\n```\n\n最后，还需要保存渲染高度范围。\n\n```ts\n// 开始渲染的列表高度\nconst start = ref(0);\n// 结束渲染的列表高度\nconst end = computed(() => start.value + state.viewHeight);\n```\n\n## 初始化\n除了熟悉的绑定事件外，调用了两个简单的计算函数。\n1. `computedViewHeight()` 计算容器视口高度。\n2. `computedColumWidth()` 计算列宽。\n\n```ts\nonMounted(() => {\n  computedViewHeight();\n  computedColumWidth();\n  containerRef.value?.addEventListener(\"scroll\", handleScroll);\n  window.addEventListener(\"resize\", resizeHandler);\n});\n```\n\n布局计算使用了 watch 监听。当数据源发生变化后，分别计算渲染队列和渲染列表。\n\n```ts\nwatch(\n  () => props.dataSource,\n  (a, b) => {\n    state.preLen = b?.length ?? 0;\n    if (!a.length) return;\n    if (isReload) {\n      isReload = false;\n      return;\n    }\n    computedQueueList();\n    computedRenderList();\n  },\n  {\n    deep: false,\n    immediate: true,\n  }\n);\n```\n\n## 计算渲染队列\n遍历数据源，每次找到高度最小的队列添加该渲染项的元数据。\n\n```ts\n// 确定每列的渲染列表，增量更新，可选全量\nconst computedQueueList = (total: boolean = false) => {\n  // console.log(\"computedQueueList\", new Date().getTime());\n  // 确定更新范围\n  const startIndex = total ? 0 : state.preLen;\n  // 清空列队列\n  total && initQueueList();\n  // 遍历数据源\n  for (let i = startIndex; i < props.dataSource.length; i++) {\n    const img = props.dataSource[i];\n    // 获取最小高度的列\n    const minColumn = getMinHeightColumn();\n    // 图片的渲染高度，默认为预设高度\n    let imgHeight = props.estimatedHeight ?? 50;\n    // 如果图片的高度和宽度存在，则计算实际图片的渲染高度\n    if (img.height && img.width) {\n      imgHeight = (state.columnWidth / img.width) * img.height;\n    }\n    // 偏移量就是列的高度\n    const offsetY = minColumn.column.height;\n    // 更新列的渲染列表\n    minColumn.column.renderList.push({\n      index: i,\n      column: minColumn.index,\n      renderIndex: minColumn.column.renderList.length,\n      data: img,\n      offsetY: offsetY,\n      height: imgHeight,\n      style: getRenderStyle(minColumn.index, offsetY),\n    });\n    // 更新列的高度\n    minColumn.column.height += imgHeight + props.gap;\n  }\n  // 更新最高列高\n  updateMinMaxHeight();\n};\n\n// 获取最小高度的列\nconst getMinHeightColumn = () => {\n  let minColumnIndex = 0;\n  let minColumn = state.queueList[minColumnIndex];\n  for (let i = 1; i < state.queueList.length; i++) {\n    if (state.queueList[i].height < minColumn.height) {\n      minColumn = state.queueList[i];\n      minColumnIndex = i;\n    }\n  }\n  return {\n    index: minColumnIndex,\n    column: minColumn,\n  };\n};\n```\n\n## 计算渲染列表\n`state.renderList` 是实际需要渲染的渲染列表。在渲染队列中找到所有 offsetY 在 start、end 范围内的渲染项元数据。\n\n可以使用计算属性实现：\n\n```ts\nconst renderList = computed(() => {\n  return state.queueList.reduce<RenderItem[]>((prev, cur) => {\n    const filteredRenderList = cur.renderList.filter(\n      (i) => i.height + i.offsetY > start.value && i.offsetY < end.value\n    );\n    return prev.concat(filteredRenderList);\n  }, []);\n});\n```\n\n但offsetY是有序的，二分查找性能更好：\n\n```ts\n// 二分查找函数\nconst binarySearch = (arr: any[], target: number) => {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid].offsetY === target) {\n      return mid;\n    } else if (arr[mid].offsetY < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return left; // 如果没找到，返回应插入的位置\n};\n\n// 计算渲染列表\nconst computedRenderList = rafThrottle(() => {\n  // console.log(\"computedRenderList\");\n  const nextRenderList: RenderItem[] = [];\n  const pre = props.bufferHeight >= 0 ? props.bufferHeight : state.viewHeight / 2;\n  const top = start.value - pre;\n  const bottom = end.value + pre;\n  // 更新最值\n  updateMinMaxHeight();\n  for (let i = 0; i < state.queueList.length; i++) {\n    const renderList = state.queueList[i].renderList;\n    const startIndex = binarySearch(renderList, top);\n    const endIndex = binarySearch(renderList, bottom);\n    // 将这个范围内的元素加入renderList\n    for (let j = startIndex - 1; j < endIndex + 1; j++) {\n      const item = renderList[j];\n      if (item && item.offsetY < state.minHeight) {\n        nextRenderList.push(item);\n      }\n    }\n  }\n  // 覆盖原来的渲染列表\n  state.renderList = nextRenderList;\n  nextTick(() => {\n    computedLayoutAll();\n  });\n});\n```\n\n## 计算布局\n在计算完渲染队列且渲染完成后，需要根据实际DOM计算布局。\n\n```ts\n// 重新计算整个list布局\nconst computedLayoutAll = () => {\n  for (let i = 0; i < props.column; i++) {\n    computedLayout(i);\n  }\n};\n```\n\n`computedLayout(column)` 计算某列或某个元素的布局。\n该函数的逻辑较为复杂，因为涉及到大量计算，进行了较多优化。\n1. 先获取 DOM 上为当前列的元素。\n2. 再确定渲染索引范围，firstRenderIndex 和 lastRenderIndex。\n3. 将第一个元素的 offsetY 作为初始偏移量。\n4. 遍历该列所有元素，根据实际 DOM 更新其元数据信息。\n5. 如果是向下滚动，还需要预加载一部分后续元素，以进行优化。\n\n```ts\n// 计算样式\n/**\n *\n * @param column 列索引\n * @param target 触发更新的目标元素所在的渲染队列索引\n */\nconst computedLayout = (\n  column: number,\n  targetRenderIndex: number | number[] | undefined = undefined\n) => {\n  // console.log(\"computedLayout\");\n  const isArrayTarget = Array.isArray(targetRenderIndex);\n  // 缓存当前列已渲染的所有元素\n  let list = [];\n  for (let i = 0; i < listRef.value!.children.length; i++) {\n    let child = listRef.value!.children[i] as HTMLDivElement;\n    if (child.matches(`[data-column='${column}']`)) {\n      list.push(child);\n    }\n  }\n  if (!list.length) return;\n  // 获取该列的队列信息\n  const queue = state.queueList[column];\n  // 获取第一个和最后一个元素的渲染索引\n  const firstRenderIndex = parseInt(\n    list[0].getAttribute(\"data-renderIndex\") || \"0\"\n  );\n  const lastRenderIndex = firstRenderIndex + list.length - 1;\n  // 获取第一个元素的偏移量，作为初始偏移量\n  let offsetYAccount = queue.renderList[firstRenderIndex].offsetY;\n  // console.log(column, list, offsetYAccount);\n  // 遍历更新该列的所有元素的信息\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    const renderItem =\n      queue.renderList[parseInt(item.getAttribute(\"data-renderIndex\") || \"0\")];\n    // 如果没有目标，或渲染索引相同，则可以更新实际尺寸\n    if (\n      !targetRenderIndex ||\n      renderItem.renderIndex === targetRenderIndex ||\n      (isArrayTarget && targetRenderIndex.includes(renderItem.renderIndex))\n    ) {\n      if (item.getAttribute(\"data-loaded\") === \"1\") {\n        // 更新队列高度，也就是加上新的高度与旧高度的差值\n        queue.height += item.offsetHeight - renderItem.height;\n        // 更新渲染项高度\n        renderItem.height = item.offsetHeight;\n      }\n    }\n    // 更新渲染项偏移量\n    renderItem.offsetY = offsetYAccount;\n    // 更新渲染项样式\n    renderItem.style = getRenderStyle(column, offsetYAccount);\n    // 累加偏移量\n    offsetYAccount += renderItem.height + props.gap;\n  }\n  // 如果不是向下滚动，不需要更新后续元素\n  if (!state.isScrollingDown) return;\n  // 没必要更新所有元素，预加载一些就行了\n  // const preloadIndex = queue.renderList.length;\n  const i = list.length * props.column + lastRenderIndex;\n  const preloadIndex =\n    i > queue.renderList.length ? queue.renderList.length : i;\n  // 更新render列表中后续元素的offsetY信息\n  for (let i = lastRenderIndex + 1; i < preloadIndex; i++) {\n    const item = queue.renderList[i];\n    item.offsetY = offsetYAccount;\n    item.style = getRenderStyle(column, offsetYAccount);\n    offsetYAccount += item.height + props.gap;\n  }\n  // console.log(column, queue);\n  // 更新最值\n  // updateMinMaxHeight();\n};\n```\n\n## 图片 load\n在图片加载完成后，需要更新该元素的布局，并标记已加载，避免重复触发动画。\n\n```ts\n// 图片加载完成后，计算样式\n// let itemCache: HTMLImageElement[] = [];\nconst imgLoadedHandle = function (e: Event) {\n  const target = e.target as HTMLImageElement;\n  const item = target.closest(\".virtual-waterfall-item\") as HTMLImageElement;\n  if (!item) return;\n  // 标记已加载\n  item.setAttribute(\"data-loaded\", \"1\");\n  if (!props.compute) return;\n  // itemCache.push(item);\n  // if (isAllLoad()) {\n  //   for (let i = 0; i < props.column; i++) {\n  //     computedLayout(i);\n  //   }\n  //   for (let i = 0; i < itemCache.length; i++) {\n  //     const item = itemCache[i];\n  //     // 添加动画\n  //     nextTick(() => {\n  //       item.firstElementChild?.classList.add(\"active\");\n  //     });\n  //   }\n  //   itemCache = [];\n  // }\n  computedLayout(\n    parseInt(item.getAttribute(\"data-column\") || \"0\"),\n    parseInt(item.getAttribute(\"data-renderIndex\") || \"0\")\n  );\n};\n```\n\n## 滚动回调\n在滚动过程中重新计算渲染列表，当向下触底、且当前渲染项都加载完毕时，增量加载新数据。\n\n```ts\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  let flag = true;\n  const fn = () => {\n    const { scrollTop, scrollHeight } = containerRef.value!;\n    // 计算开始渲染的列表高度，也就是卷去的高度\n    start.value = scrollTop;\n    // 重新计算渲染列表\n    computedRenderList();\n    // 判断是否向下滚动\n    state.isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    // 如果触底并且是向下滚动\n    if (\n      !props.loading &&\n      state.isScrollingDown &&\n      scrollTop + state.viewHeight + 5 > scrollHeight\n    ) {\n      // console.log(\"加载数据\");\n      // !props.loading && emit(\"addData\");\n      const allLoaded = isAllLoad();\n      if (allLoaded) {\n        isReload && (isReload = false);\n        emit(\"addData\");\n      }\n    }\n    flag = true;\n  };\n  const createHandle = (handle: Function) => {\n    return () => {\n      if (!flag) return;\n      flag = false;\n      handle();\n    };\n  };\n  if (\"requestIdleCallback\" in window) {\n    return createHandle(() => {\n      window.requestIdleCallback(fn);\n    });\n  } else if (\"requestAnimationFrame\" in window) {\n    return createHandle(() => {\n      window.requestAnimationFrame(fn);\n    });\n  }\n  return createHandle(fn);\n};\nconst handleScrollFun = createHandleScroll();\nconst throttleHandleScroll = throttle(handleScrollFun, 250);\nconst debounceHandleScroll = debounce(handleScrollFun, 50);\nconst handleScroll = () => {\n  debounceHandleScroll();\n  throttleHandleScroll();\n};\n\n// 判断真实dom上所有item是否都已加载完毕\nconst isAllLoad = () => {\n  for (let i = 0; i < listRef.value!.children.length; i++) {\n    const child = listRef.value!.children[i] as HTMLDivElement;\n    if (child.matches(\"[data-loaded='0']\")) {\n      return false;\n    }\n  }\n  return true;\n};\n```\n\n\n\n## 完整代码\n\n```html\n<template>\n  <div class=\"virtual-waterfall-panel\" v-loading=\"props.loading\">\n    <component :is=\"'style'\">{{ animationStyle }}</component>\n    <div class=\"virtual-waterfall-container\" ref=\"containerRef\">\n      <div\n        class=\"virtual-waterfall-list\"\n        ref=\"listRef\"\n        :style=\"{\n          height: state.minHeight + 'px',\n        }\"\n      >\n        <div\n          class=\"virtual-waterfall-item\"\n          v-for=\"i in state.renderList\"\n          :style=\"i.style\"\n          :data-column=\"i.column\"\n          :data-renderIndex=\"i.renderIndex\"\n          :data-loaded=\"i.data.src ? 0 : 1\"\n          :key=\"i.index\"\n        >\n          <div class=\"animation-box\">\n            <slot\n              name=\"item\"\n              :item=\"i\"\n              :index=\"i.index\"\n              :load=\"imgLoadedHandle\"\n            >\n              <img\n                :src=\"i.data.src\"\n                @load=\"imgLoadedHandle\"\n                v-if=\"props.compute\"\n              />\n              <img :src=\"i.data.src\" v-else />\n            </slot>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { CSSProperties, withDefaults } from \"vue\";\n\n// 每个图片的数据\ninterface ImgData {\n  src: string; // 图片地址\n  height?: number; // 图片高度\n  width?: number; // 图片宽度\n  [key: string]: any;\n}\n// 渲染的每个item\ninterface RenderItem {\n  index: number; // 位于数据源的索引\n  column: number; // 所在列\n  renderIndex: number; // 渲染索引\n  data: ImgData; // 图片数据\n  offsetY: number; // y轴偏移量\n  height: number; // 高度\n  style: CSSProperties; // 用于渲染视图上的样式（宽、高、偏移量）\n}\n// 每列队列的信息\ninterface columnQueue {\n  height: number; // 高度\n  renderList: RenderItem[]; // 该列的渲染列表\n}\n\n// 定义props\ninterface Props {\n  loading: boolean; // 加载状态\n  column: number; // 列数\n  estimatedHeight: number; // 每项预设高度\n  gap?: number; // 间距\n  dataSource: ImgData[]; // 数据源\n  compute?: boolean; // 是否需要动态计算尺寸\n  animation?: boolean | string; // 是否需要动画，也可以传入自定义动画\n  bufferHeight?: number; // 缓冲高度，会提前渲染一部分数据\n}\nconst props = withDefaults(defineProps<Props>(), {\n  gap: 0,\n  compute: true,\n  animation: true,\n  bufferHeight: -1,\n});\n// 定义emit\nconst emit = defineEmits<{\n  addData: [];\n}>();\n\n// 动画样式\nconst animationStyle = computed(() => {\n  // 默认动画\n  let animation = \"WaterFallItemAnimate 0.25s\";\n  // 如果为false，则不需要动画\n  if (props.animation === false) {\n    animation = \"none\";\n  }\n  // 如果是字符串，则使用自定义动画\n  if (typeof props.animation === \"string\") {\n    animation = props.animation;\n  }\n  return `\n    .virtual-waterfall-list>.virtual-waterfall-item[data-loaded=\"1\"]>.animation-box {\n      animation: ${animation};\n    }\n  `;\n});\n\n// 状态\nconst state = reactive({\n  columnWidth: 0, // 列宽\n  viewHeight: 0, // 视口高度\n  // 队列集合\n  queueList: Array.from({ length: props.column }).map<columnQueue>(() => ({\n    height: 0,\n    renderList: [],\n  })),\n  renderList: [] as RenderItem[], // 渲染列表\n  maxHeight: 0, // 最高列高\n  minHeight: 0, // 最低列高\n  preLen: 0, // 前一次数据长度\n  isScrollingDown: true, // 是否向下滚动\n});\n// 开始渲染的列表高度\nconst start = ref(0);\n// 结束渲染的列表高度\nconst end = computed(() => start.value + state.viewHeight);\n\n// 使用计算属性也行，但是offsetY是有序的，二分查找性能更好\n// const renderList = computed(() => {\n//   return state.queueList.reduce<RenderItem[]>((prev, cur) => {\n//     const filteredRenderList = cur.renderList.filter(\n//       (i) => i.height + i.offsetY > start.value && i.offsetY < end.value\n//     );\n//     return prev.concat(filteredRenderList);\n//   }, []);\n// });\n\n// 二分查找函数\nconst binarySearch = (arr: any[], target: number) => {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid].offsetY === target) {\n      return mid;\n    } else if (arr[mid].offsetY < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return left; // 如果没找到，返回应插入的位置\n};\n\n// 计算渲染列表\nconst computedRenderList = rafThrottle(() => {\n  // console.log(\"computedRenderList\");\n  const nextRenderList: RenderItem[] = [];\n  const pre = props.bufferHeight >= 0 ? props.bufferHeight : state.viewHeight / 2;\n  const top = start.value - pre;\n  const bottom = end.value + pre;\n  // 更新最值\n  updateMinMaxHeight();\n  for (let i = 0; i < state.queueList.length; i++) {\n    const renderList = state.queueList[i].renderList;\n    const startIndex = binarySearch(renderList, top);\n    const endIndex = binarySearch(renderList, bottom);\n    // 将这个范围内的元素加入renderList\n    for (let j = startIndex - 1; j < endIndex + 1; j++) {\n      const item = renderList[j];\n      if (item && item.offsetY < state.minHeight) {\n        nextRenderList.push(item);\n      }\n    }\n  }\n  // 覆盖原来的渲染列表\n  state.renderList = nextRenderList;\n  nextTick(() => {\n    computedLayoutAll();\n  });\n});\n\n// 更新最高和最高列高\nconst updateMinMaxHeight = () => {\n  // console.log(\"updateMinMaxHeight\");\n  state.maxHeight = 0;\n  state.minHeight = state.queueList[0].height;\n  for (let i = 0; i < state.queueList.length; i++) {\n    const item = state.queueList[i];\n    if (item.height > state.maxHeight) {\n      state.maxHeight = item.height;\n    }\n    if (item.height < state.minHeight) {\n      state.minHeight = item.height;\n    }\n  }\n};\n\n// 计算样式\nconst getRenderStyle = (column: number, offsetY: number) => {\n  return {\n    width: state.columnWidth + \"px\",\n    transform: `translate3d(${\n      column * (state.columnWidth + props.gap)\n    }px, ${offsetY}px, 0)`,\n  };\n};\n\n// 初始化列队列\nconst initQueueList = () => {\n  state.queueList = Array.from({ length: props.column }).map<columnQueue>(\n    () => ({\n      height: 0,\n      renderList: [],\n    })\n  );\n};\n\n// 确定每列的渲染列表，增量更新，可选全量\nconst computedQueueList = (total: boolean = false) => {\n  // console.log(\"computedQueueList\", new Date().getTime());\n  // 确定更新范围\n  const startIndex = total ? 0 : state.preLen;\n  // 清空列队列\n  total && initQueueList();\n  // 遍历数据源\n  for (let i = startIndex; i < props.dataSource.length; i++) {\n    const img = props.dataSource[i];\n    // 获取最小高度的列\n    const minColumn = getMinHeightColumn();\n    // 图片的渲染高度，默认为预设高度\n    let imgHeight = props.estimatedHeight ?? 50;\n    // 如果图片的高度和宽度存在，则计算实际图片的渲染高度\n    if (img.height && img.width) {\n      imgHeight = (state.columnWidth / img.width) * img.height;\n    }\n    // 偏移量就是列的高度\n    const offsetY = minColumn.column.height;\n    // 更新列的渲染列表\n    minColumn.column.renderList.push({\n      index: i,\n      column: minColumn.index,\n      renderIndex: minColumn.column.renderList.length,\n      data: img,\n      offsetY: offsetY,\n      height: imgHeight,\n      style: getRenderStyle(minColumn.index, offsetY),\n    });\n    // 更新列的高度\n    minColumn.column.height += imgHeight + props.gap;\n  }\n  // 更新最高列高\n  updateMinMaxHeight();\n};\n\n// 判断真实dom上所有item是否都已加载完毕\nconst isAllLoad = () => {\n  for (let i = 0; i < listRef.value!.children.length; i++) {\n    const child = listRef.value!.children[i] as HTMLDivElement;\n    if (child.matches(\"[data-loaded='0']\")) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// 获取最小高度的列\nconst getMinHeightColumn = () => {\n  let minColumnIndex = 0;\n  let minColumn = state.queueList[minColumnIndex];\n  for (let i = 1; i < state.queueList.length; i++) {\n    if (state.queueList[i].height < minColumn.height) {\n      minColumn = state.queueList[i];\n      minColumnIndex = i;\n    }\n  }\n  return {\n    index: minColumnIndex,\n    column: minColumn,\n  };\n};\n\n// 计算视口高度\nconst computedViewHeight = () => {\n  if (!containerRef.value) return;\n  state.viewHeight = containerRef.value.clientHeight;\n};\n\n// 获取dom元素\nconst listRef = ref<HTMLDivElement | null>(null);\nconst containerRef = ref<HTMLDivElement | null>(null);\n\n// 计算样式\n/**\n *\n * @param column 列索引\n * @param target 触发更新的目标元素所在的渲染队列索引\n */\nconst computedLayout = (\n  column: number,\n  targetRenderIndex: number | number[] | undefined = undefined\n) => {\n  // console.log(\"computedLayout\");\n  const isArrayTarget = Array.isArray(targetRenderIndex);\n  // 缓存当前列已渲染的所有元素\n  let list = [];\n  for (let i = 0; i < listRef.value!.children.length; i++) {\n    let child = listRef.value!.children[i] as HTMLDivElement;\n    if (child.matches(`[data-column='${column}']`)) {\n      list.push(child);\n    }\n  }\n  if (!list.length) return;\n  // 获取该列的队列信息\n  const queue = state.queueList[column];\n  // 获取第一个和最后一个元素的渲染索引\n  const firstRenderIndex = parseInt(\n    list[0].getAttribute(\"data-renderIndex\") || \"0\"\n  );\n  const lastRenderIndex = firstRenderIndex + list.length - 1;\n  // 获取第一个元素的偏移量，作为初始偏移量\n  let offsetYAccount = queue.renderList[firstRenderIndex].offsetY;\n  // console.log(column, list, offsetYAccount);\n  // 遍历更新该列的所有元素的信息\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    const renderItem =\n      queue.renderList[parseInt(item.getAttribute(\"data-renderIndex\") || \"0\")];\n    // 如果没有目标，或渲染索引相同，则可以更新实际尺寸\n    if (\n      !targetRenderIndex ||\n      renderItem.renderIndex === targetRenderIndex ||\n      (isArrayTarget && targetRenderIndex.includes(renderItem.renderIndex))\n    ) {\n      if (item.getAttribute(\"data-loaded\") === \"1\") {\n        // 更新队列高度，也就是加上新的高度与旧高度的差值\n        queue.height += item.offsetHeight - renderItem.height;\n        // 更新渲染项高度\n        renderItem.height = item.offsetHeight;\n      }\n    }\n    // 更新渲染项偏移量\n    renderItem.offsetY = offsetYAccount;\n    // 更新渲染项样式\n    renderItem.style = getRenderStyle(column, offsetYAccount);\n    // 累加偏移量\n    offsetYAccount += renderItem.height + props.gap;\n  }\n  // 如果不是向下滚动，不需要更新后续元素\n  if (!state.isScrollingDown) return;\n  // 没必要更新所有元素，预加载一些就行了\n  // const preloadIndex = queue.renderList.length;\n  const i = list.length * props.column + lastRenderIndex;\n  const preloadIndex =\n    i > queue.renderList.length ? queue.renderList.length : i;\n  // 更新render列表中后续元素的offsetY信息\n  for (let i = lastRenderIndex + 1; i < preloadIndex; i++) {\n    const item = queue.renderList[i];\n    item.offsetY = offsetYAccount;\n    item.style = getRenderStyle(column, offsetYAccount);\n    offsetYAccount += item.height + props.gap;\n  }\n  // console.log(column, queue);\n  // 更新最值\n  // updateMinMaxHeight();\n};\n\n// 重新计算整个list布局\nconst computedLayoutAll = () => {\n  for (let i = 0; i < props.column; i++) {\n    computedLayout(i);\n  }\n};\n\n// 图片加载完成后，计算样式\n// let itemCache: HTMLImageElement[] = [];\nconst imgLoadedHandle = function (e: Event) {\n  const target = e.target as HTMLImageElement;\n  const item = target.closest(\".virtual-waterfall-item\") as HTMLImageElement;\n  if (!item) return;\n  // 标记已加载\n  item.setAttribute(\"data-loaded\", \"1\");\n  if (!props.compute) return;\n  // itemCache.push(item);\n  // if (isAllLoad()) {\n  //   for (let i = 0; i < props.column; i++) {\n  //     computedLayout(i);\n  //   }\n  //   for (let i = 0; i < itemCache.length; i++) {\n  //     const item = itemCache[i];\n  //     // 添加动画\n  //     nextTick(() => {\n  //       item.firstElementChild?.classList.add(\"active\");\n  //     });\n  //   }\n  //   itemCache = [];\n  // }\n  computedLayout(\n    parseInt(item.getAttribute(\"data-column\") || \"0\"),\n    parseInt(item.getAttribute(\"data-renderIndex\") || \"0\")\n  );\n};\n\n// 计算列宽\nconst computedColumWidth = () => {\n  if (!listRef.value) return;\n  state.columnWidth =\n    (listRef.value.clientWidth - (props.column - 1) * props.gap) / props.column;\n};\n\nlet isReload = false;\nconst reload = () => {\n  isReload = true;\n  // 全量更新列队列\n  computedQueueList(true);\n  // 清空渲染列表\n  state.renderList = [];\n  // 滚动回顶部，不然列数改变再后往上滚动，前面已经渲染过的元素会闪\n  containerRef.value!.scrollTop = 0;\n  start.value = 0;\n  nextTick(() => {\n    computedRenderList();\n  });\n};\n\nwatch(\n  () => props.dataSource,\n  (a, b) => {\n    state.preLen = b?.length ?? 0;\n    if (!a.length) return;\n    if (isReload) {\n      isReload = false;\n      return;\n    }\n    computedQueueList();\n    computedRenderList();\n  },\n  {\n    deep: false,\n    immediate: true,\n  }\n);\n\n// 滚动回调\nconst createHandleScroll = () => {\n  let lastScrollTop = 0;\n  let flag = true;\n  const fn = () => {\n    const { scrollTop, scrollHeight } = containerRef.value!;\n    // 计算开始渲染的列表高度，也就是卷去的高度\n    start.value = scrollTop;\n    // 重新计算渲染列表\n    computedRenderList();\n    // 判断是否向下滚动\n    state.isScrollingDown = scrollTop > lastScrollTop;\n    // 记录上次滚动的距离\n    lastScrollTop = scrollTop;\n    // 如果触底并且是向下滚动\n    if (\n      !props.loading &&\n      state.isScrollingDown &&\n      scrollTop + state.viewHeight + 5 > scrollHeight\n    ) {\n      // console.log(\"加载数据\");\n      // !props.loading && emit(\"addData\");\n      const allLoaded = isAllLoad();\n      if (allLoaded) {\n        isReload && (isReload = false);\n        emit(\"addData\");\n      }\n    }\n    flag = true;\n  };\n  const createHandle = (handle: Function) => {\n    return () => {\n      if (!flag) return;\n      flag = false;\n      handle();\n    };\n  };\n  if (\"requestIdleCallback\" in window) {\n    return createHandle(() => {\n      window.requestIdleCallback(fn);\n    });\n  } else if (\"requestAnimationFrame\" in window) {\n    return createHandle(() => {\n      window.requestAnimationFrame(fn);\n    });\n  }\n  return createHandle(fn);\n};\nconst handleScrollFun = createHandleScroll();\nconst throttleHandleScroll = throttle(handleScrollFun, 250);\nconst debounceHandleScroll = debounce(handleScrollFun, 50);\nconst handleScroll = () => {\n  debounceHandleScroll();\n  throttleHandleScroll();\n};\n\n// resize回调\nconst resizeHandler = rafThrottle(() => {\n  computedViewHeight();\n  computedColumWidth();\n  computedRenderList();\n});\n\nonMounted(() => {\n  computedViewHeight();\n  computedColumWidth();\n  containerRef.value?.addEventListener(\"scroll\", handleScroll);\n  window.addEventListener(\"resize\", resizeHandler);\n});\n\nonUnmounted(() => {\n  containerRef.value?.removeEventListener(\"scroll\", handleScroll);\n  window.removeEventListener(\"resize\", resizeHandler);\n});\n\n// 监视列数变化，更新渲染信息\nwatch(\n  () => props.column,\n  () => {\n    // 计算列宽\n    computedColumWidth();\n    reload();\n  }\n);\n\ndefineExpose({\n  reload,\n});\n</script>\n\n<style lang=\"scss\">\n.virtual-waterfall-panel {\n  height: 100%;\n  width: 100%;\n  .virtual-waterfall-container {\n    height: 100%;\n    width: 100%;\n    overflow-y: scroll;\n    overflow-x: hidden;\n    .virtual-waterfall-list {\n      height: 100%;\n      width: 100%;\n      position: relative;\n      .virtual-waterfall-item {\n        position: absolute;\n        // transition: all 0.3s;\n        overflow: hidden;\n        box-sizing: border-box;\n        transform: translate3d(0);\n        > .content {\n          width: 100%;\n          height: auto;\n        }\n        > .animation-box {\n          visibility: hidden;\n        }\n        &[data-loaded=\"1\"] {\n          > .animation-box {\n            visibility: visible;\n            // animation: WaterFallItemAnimate 0.25s;\n          }\n        }\n        img {\n          width: 100%;\n          object-fit: cover;\n          overflow: hidden;\n          display: block;\n        }\n      }\n    }\n  }\n}\n@keyframes WaterFallItemAnimate {\n  from {\n    opacity: 0;\n    transform: translateY(100px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n</style>\n```\n\n使用：\n\n```html\n<template>\n  <div class=\"list-panel\">\n    <div class=\"btn-box\">\n      <el-button @click=\"changeMock(MockType.simulated)\">模拟数据</el-button>\n      <el-button @click=\"changeMock(MockType.real)\">真实数据</el-button>\n      <el-button @click=\"changeMock(MockType.noImg)\">无图片</el-button>\n    </div>\n    <div class=\"list-container\">\n      <virtual-water-fall-list\n        :dataSource=\"data\"\n        :loading=\"loading\"\n        :column=\"column\"\n        :estimatedHeight=\"estimatedHeight\"\n        :gap=\"gap\"\n        :compute=\"true\"\n        @add-data=\"addData\"\n        :animation=\"animation\"\n        ref=\"list\"\n      >\n        <template #item=\"{ item, index, load }\">\n          <div class=\"item-box\">\n            <img :src=\"item.data.src\" @load=\"load\" />\n            <span>{{ index + 1 + \" \" + item.data.title }}</span>\n          </div>\n        </template>\n      </virtual-water-fall-list>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Mock from \"mockjs\";\nimport VirtualWaterFallList from \"@/components/VirtualWaterFallList.vue\";\nconst data = ref<\n  {\n    src: string;\n    title: string;\n  }[]\n>([]);\nconst loading = ref(false);\nconst column = ref(4);\nconst estimatedHeight = ref(50);\nconst gap = ref(10);\nconst list = ref<InstanceType<typeof VirtualWaterFallList> | null>(null);\n// const animation = ref(\"ItemMoveAnimate 0.3s\");\nconst animation = ref(true);\n\nenum MockType {\n  simulated = 0,\n  real = 1,\n  noImg = 2,\n}\n\nconst addData = async () => {\n  switch (mock.value) {\n    case MockType.simulated:\n      await simulatedData();\n      break;\n    case MockType.real:\n      await fetchData();\n      break;\n    case MockType.noImg:\n      await onImgData();\n      break;\n  }\n};\n\n// 模拟数据\nconst simulatedData = () => {\n  loading.value = true;\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      data.value = data.value.concat(\n        new Array(size * 2).fill(0).map((_, index) => ({\n          src: Mock.Random.dataImage(),\n          title: Mock.mock(\"@ctitle(5, 15)\"),\n        }))\n      );\n      loading.value = false;\n      resolve(null);\n    }, 1000);\n  });\n};\n\nlet size = 40;\nlet page = 1;\n// 真实数据\nconst fetchData = () => {\n  loading.value = true;\n  return new Promise((resolve) => {\n    fetch(\n      `https://www.vilipix.com/api/v1/picture/public?limit=${size}&offset=${\n        (page - 1) * size\n      }&sort=hot&type=0`\n    )\n      .then((res) => res.json())\n      .then((res) => {\n        page++;\n        const list = res.data.rows;\n        data.value = data.value.concat(\n          list.map((item: any) => ({\n            src: item.regular_url,\n            title: item.title,\n            height: item.height,\n            width: item.width,\n          }))\n        );\n        loading.value = false;\n        resolve(null);\n      });\n  });\n};\n\n// 无图片\nconst onImgData = () => {\n  loading.value = true;\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      data.value = data.value.concat(\n        new Array(500).fill(0).map((_, index) => ({\n          src: \"\",\n          title: Mock.mock(\"@ctitle(20, 100)\"),\n        }))\n      );\n      loading.value = false;\n      resolve(null);\n    }, 1000);\n  });\n};\n\nonMounted(() => {\n  addData();\n  // setTimeout(() => {\n  //   // 更新列数\n  //   column.value = 3;\n  // }, 3000);\n});\n\nconst mock = ref(MockType.simulated);\nconst changeMock = async (value: number) => {\n  if (loading.value) return;\n  loading.value = true;\n  mock.value = value;\n  switch (value) {\n    case MockType.simulated:\n      estimatedHeight.value = 50;\n      break;\n    case MockType.real:\n      estimatedHeight.value = 50;\n      break;\n    case MockType.noImg:\n      estimatedHeight.value = 50;\n      break;\n  }\n  page = 1;\n  data.value = [];\n  try {\n    await addData();\n  } catch (error) {\n    loading.value = false;\n    console.error(\"数据加载出错\", error);\n  }\n  list.value?.reload();\n};\n</script>\n\n<style scoped lang=\"scss\">\n.list-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  .btn-box {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n  .list-container {\n    max-width: 800px;\n    width: 100%;\n    height: calc(100vh - 120px);\n    border: 1px solid #333;\n    .item-box {\n      display: flex;\n      flex-direction: column;\n    }\n  }\n}\n</style>\n\n<style>\n@keyframes ItemMoveAnimate {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n</style>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","Vue","TS"],"categories":["学习笔记"]},{"title":"开发了一个 Canvas 2D 渲染引擎","url":"/article/8275f29.html","content":"\n# 前言\n写一个 Canvas 2D 渲染引擎，让绘制更简单些。\n\n参考：\n[Canvas的高级绘制技巧和事件系统](https://zhangwang1990.gitbooks.io/canvas-in-deeps/content/canvasde-gao-ji-hui-zhi-ji-qiao-ji-shi-jian.html)\n[canvas进阶——如何实现canvas的事件系统](https://juejin.cn/post/6888209975965909000)\n[聊聊Canvas事件机制相关 (非API层,偏框架设计方面)](https://segmentfault.com/a/1190000041506890)\n[【前端】从零开始的Canvas事件处理系统（上）](https://www.bilibili.com/video/BV1mP411Y77q)\n[从0-1入门数据可视化-canvas事件系统](https://wzf1997.github.io/learn-visualization/blog/canvas/2d-event.html)\n[如何实现一个canvas渲染引擎](https://juejin.cn/post/7323382193640423451)\n[canvas核心技术-如何实现碰撞检测](https://juejin.cn/post/6844903665191370765)\n[二、Canvas进阶-9、碰撞检测](https://zhuanlan.zhihu.com/p/461062061)\n[“等一下，我碰！”——常见的2D碰撞检测](https://github.com/JChehe/blog/issues/8)\n[浅谈 Canvas 渲染引擎](https://zhuanlan.zhihu.com/p/608415829)\n[手把手教你打造一款轻量级canvas渲染引擎](https://www.cnblogs.com/yuanzm/p/12053110.html)\n[leaferjs，全新的 Canvas 渲染引擎](https://juejin.cn/post/7256386855721074747)\n\n# 基本架构\nCanvas 的原生 API 是非常底层的，所有图形不分层级、父子关系依次覆盖绘制。\n\n为了方便绘制，一个 Canvas 引擎应该如下设计：\n1. **数据结构：**仿照 DOM 树结构，设计出层级关系的图形树结构。\n2. **层级关系：**抽象出节点，具有坐标位置、样式等基础属性，节点之间可以有父子、兄弟关系。\n3. **组：**一个节点及其子节点的集合，可以看作一个组。组也是一个节点，可以作为其他组的子节点。各种图形类都继承自组。\n4. **绘制顺序：**祖先节点最先绘制，后代节点后绘制，兄弟节点由 z-index 控制，视觉上子元素在上层。\n5. **定位：**子节点完全依赖父节点进行定位，相当于 position:static。\n6. **锚点：**在canvas中一切变换都是相对于原点进行的，所以需要实现锚点来确定变换的中心。\n7. **封装：**将 Canvas API 的封装成更简单、清晰的形式，贴近于我们熟悉的 DOM，屏蔽底层绘制细节。\n8. **性能：**异步批量渲染、离屏渲染、脏区渲染。\n9.  **包围盒：**AABB、OBB、碰撞检测。这是为了知道每个节点的位置和大小，以便处理图形相交、事件等。\n10. **排版系统：**成熟的 canvas 库一般具有排版系统，可以脱离坐标系进行布局。\n11. **多画布：**大型的应用可能需要多个画布，就如 Konva，它抽象出了一个舞台 Stage，包含多个画布 Layer，每个 Layer 可以包含多个节点 Node。\n\n# qx-canvas\n项目地址：[qx-canvas](https://github.com/qxchuckle/qx-canvas)\n\n花了一星期时间完成，虽然还没用过 pixijs，但 api 格式是仿照其设计的。\n\n实现了基础图形和路径的绘制、以组为基本渲染单元的树结构、完善的碰撞检测、具有传播机制的事件系统。可以像 DOM 一样操作 Canvas 图形。\n\n项目结构：\n\n```plaintext\n├───📁 display/ # 布局管理，树结构\n│   ├───📄 group.ts # 组\n│   ├───📄 index.ts\n│   └───📄 node.ts # 节点\n├───📁 events/ # 事件\n│   ├───📄 eventAdmin.ts # 事件管理器\n│   ├───📄 eventClient.ts # 事件中心\n│   ├───📄 eventObject.ts # 事件对象\n│   ├───📄 eventSystem.ts # 事件系统\n│   └───📄 index.ts\n├───📁 graphics/ # 图案\n│   ├───📁 style/ # 上下文样式\n│   │   ├───📄 fill.ts # 填充样式\n│   │   ├───📄 index.ts\n│   │   └───📄 line.ts # 描边样式\n│   ├───📄 graphics.ts # 图案类\n│   ├───📄 graphicsData.ts # 图形数据\n│   └───📄 index.ts\n├───📁 math/ # 数学相关\n│   ├───📄 bezier.ts # 贝塞尔曲线\n│   ├───📄 constant.ts # 常量\n│   ├───📄 index.ts\n│   ├───📄 matrix.ts # 3*3矩阵\n│   ├───📄 point.ts # 点\n│   └───📄 transform.ts # 变换矩阵\n├───📁 renderer/ # 渲染相关\n│   ├───📄 canvasRenderer.ts # canvas2d渲染器\n│   ├───📄 index.ts\n│   └───📄 renderer.ts # 渲染器\n├───📁 shapes/ # 各种可绘制的基础图形\n│   ├───📄 circle.ts # 圆\n│   ├───📄 ellipse.ts # 椭圆\n│   ├───📄 image.ts # 图像\n│   ├───📄 index.ts\n│   ├───📄 path.ts # 路径\n│   ├───📄 polygon.ts # 多边形\n│   ├───📄 rectangle.ts # 矩形\n│   ├───📄 roundRect.ts # 圆角矩形\n│   ├───📄 shape.ts # 图形抽象类\n│   └───📄 text.ts # 文本\n├───📁 test/ # 测试\n│   └───📄 index.ts\n├───📁 types/ # 类型\n│   ├───......\n├───📁 utils/ # 工具函数\n│   └───📄 index.ts\n├───📄 app.ts # 库入口\n└───📄 index.ts # 打包入口\n```\n\n\n# 快速开始\n安装：\n\n```bash\npnpm i qx-canvas -S\n```\n\n将 `canvas` 元素传入 `App` 类，即可创建一个 `App` 实例。`App` 用于管理整个 canvas 及其事件系统。\n\n```ts\nimport * as QxCanvas from \"qx-canvas\";\nconst app = new QxCanvas.App({\n  canvas: document.querySelector(\"canvas\")!,\n});\n```\n\n接着使用 `Graphics` 类创建**图案对象**，并挂载到 `app.stage` 舞台(根节点)上。\n\n**绘制图形：**  \n`Graphics` 具有一系列绘制基础图形的方法，它们以 **draw** 开头，如 `drawRect`、`drawCircle`、`drawLine` 等。  \n但你应该先调用 `beginFill` 或 `beginLine` 方法，以表明开始**填充**或**描边**，并传入样式参数。\n\n**添加事件：**  \n你可以为**图案对象**添加事件监听器，如 `click`、`mousedown`、`mousemove` 等，并具有和 DOM 一样的事件传播机制。\n\n```ts\nconst rect1 = new QxCanvas.Graphics()\n  // `Graphics` 的所有方法都支持链式调用\n  .beginFill({\n    color: \"blue\",\n  })\n  .drawRect(200, 0, 100, 100)\n  .setPivot(200, 0) // 设置变换中心\n  .setRotation(45) // 顺时针旋转45度\n  .setScale(2, 2) // 放大两倍\n  .setAlpha(0.5) // 透明度\n  .setCursor(\"pointer\") // 鼠标样式\n  .addEventListener(\"click\", (e) => {\n    // 若你需要在异步环境中使用事件对象，需要调用 clone 方法，以拷贝其副本。\n    console.log(e.clone());\n  });\napp.stage.add(rect1);\n```\n\n`app.stage` 是**舞台**、根节点，所有 `Graphics` 图形都是其后代节点，其类型为 `Group` 表示**组**的概念。\n\n`Graphics` 继承自 `Group`，也就是说，所有图形节点本身也是**组**，可以添加子节点，以此形成树结构。\n\n```ts\nconst circle1 = new QxCanvas.Graphics()\n  .beginLine({\n    width: 5,\n  })\n  .setPosition(0, 100) // 设置位置偏移量\n  .drawCircle(200, 0, 20);\nrect1.add(circle1); // 作为rect1的子节点\n```\n\n在同一个组中，其透明度、变换(旋转、缩放等)是共享叠加的，如：父节点的变换叠加上子节点自身的局部变换，形成子节点最终的全局变换效果。\n\n`Graphics` 除了可以绘制基础图形，还可以绘制**路径**，这和原生 Canvas 类似，不过和绘制图形一样，需要提前调用 `beginFill` 或 `beginLine` 方法。\n\n```ts\nconst path1 = new QxCanvas.Graphics()\n  .beginLine()\n  .moveTo(100, 100)\n  .lineTo(200, 200)\n  .lineTo(300, 100)\n  .closePath();\napp.stage.add(path1);\n```\n\n# API 文档\n较为详细的 API 文档。\n\n## App\n`App` 类是整个引擎的入口，用于管理整个 canvas 及其事件系统。\n\n```ts\nconst app = new QxCanvas.App({\n  canvas: document.querySelector(\"canvas\")!,\n});\n```\n\n参数：\n\n```ts\nexport interface IAppOptions {\n  // 传入的canvas元素\n  canvas: HTMLCanvasElement;\n  // canvas 元素宽高\n  width?: number;\n  height?: number;\n  // 背景颜色\n  backgroundColor?: string;\n  // 背景透明度\n  backgroundAlpha?: number;\n}\n```\n\n属性和方法：\n  \n```ts\ndeclare class App<T extends IContext[\"ctx\"] = CanvasRenderingContext2D> {\n  readonly stage: Group; // 舞台，根节点\n  constructor(options: IAppOptions);\n  clear(): void; // 清空舞台\n  resize(width: number, height: number): void; // 调整canvas大小\n  get ctx(): T; // 获取canvas上下文\n  get canvas(): HTMLCanvasElement; // 获取canvas元素\n}\n```\n\n## Node\n`Node` 类是所有节点的基类，具有一些基础的属性和方法。(内部类，未向外暴露)\n\n```ts\ndeclare abstract class Node extends EventClient {\n  visible: boolean; // 节点是否可见\n  readonly transform: Transform; // 变换对象\n  cursor: Cursor; // 鼠标样式\n  hitArea: Shape | null; // 自定义碰撞图形（区域）\n  parent: this | null; // 父节点\n  readonly children: this[]; // 子节点列表\n  id: string; // 节点id\n  class: string[]; // 节点类名\n  get zIndex(): number; // 获取节点层级\n  set zIndex(value: number); // 设置节点层级\n\n  // 一些操作属性的方法，返回this，方便链式调用\n  setZIndex(index: number): this; // 设置节点层级\n  setAlpha(alpha: number): this; // 设置透明度\n  setVisible(visible: boolean): this; // 设置可见性\n  setCursor(cursor: Cursor): this; // 设置鼠标样式\n  setHitArea(hitArea: Shape): this; // 设置碰撞区域\n  setId(id: string): this; // 设置节点id\n  setClass(className: string): this; // 覆盖设置类名\n  addClass(className: string): this; // 添加类名\n  removeClass(className: string): this; // 移除类名\n  setScale(x: number, y: number): this; // 设置缩放\n  setRotation(rotation: number): this; // 设置旋转角度\n  setPosition(x: number, y: number): this; // 设置位置偏移量\n  setPivot(x: number, y: number): this; // 设置变换中心\n  setSkew(x: number, y: number): this; // 设置倾斜角度\n\n  // 添加事件监听器\n  addEventListener(type: EventType, listener: EventListener, options?: boolean | EventOptions): this;\n  // 移除事件监听器\n  removeEventListener(type: EventType, listener: EventListener, capture?: boolean): this;\n\n  // 根据id或class查找子节点\n  findById(id: string): this | null;\n  findByClass(className: string): this[];\n}\n```\n\n## Group\n`Group` 类是**组**对象，继承自 `Node`，用于管理子节点。(内部类，未向外暴露)\n\n```ts\ndeclare class Group extends Node {\n  add(child: this | this[]): this; // 添加子节点\n  remove(child: this): this; // 移除子节点\n  removeChildren(): this; // 移除所有子节点\n  removeSelf(): this; // 从父节点移除自身\n  destroy(): void; // 销毁节点，移除自身及所有子节点\n  getSpreadPath(): Group[]; // 获取传播路径，即从根节点到自身的路径\n\n  // 生命周期\n  onBeforeMount(handler: (item: this) => void): this;\n  onMounted(handler: (item: this) => void): this;\n  onBeforeRender(handler: (item: this, renderer: CanvasRenderer) => void): this;\n  onRendering(handler: (item: this, renderer: CanvasRenderer) => void): this;\n  onRendered(handler: (item: this, renderer: CanvasRenderer) => void): this;\n  onBeforeUnmount(handler: (item: this) => void): this;\n  onUnmounted(handler: (item: this) => void): this;\n}\n```\n\n## Graphics\n`Graphics` 类是图案对象，继承自 `Group`，用于绘制图形、路径，以及绑定事件监听器。\n\n```ts\ndeclare class Graphics extends Group {\n  readonly graphicsDataList: GraphicsData[];\n  // 开始填充或描边\n  beginFill(style?: Partial<FillStyleType>): this;\n  beginLine(style?: Partial<LineStyleType>): this;\n  // 结束填充或描边\n  endFill(): this;\n  endLine(): this;\n\n  // 判断点是否在图形内\n  contains(p: Point): boolean;\n\n  // 绘制基础图形\n  // 矩形\n  drawRect(x: number, y: number, width: number, height: number): this;\n  // 圆\n  drawCircle(x: number, y: number, radius: number): this;\n  // 椭圆\n  drawEllipse(x: number, y: number, radiusX: number, radiusY: number): this;\n  // 圆角矩形\n  drawRoundRect(x: number, y: number, width: number, height: number, radius: number): this;\n  // 多边形\n  drawPolygon(points: number[]): this;\n  // 文本\n  drawText(text: string, x: number, y: number, textStyle?: TextStyle): this;\n\n  // 绘制路径\n  moveTo(x: number, y: number): this;\n  lineTo(x: number, y: number): this;\n  // 绘制任意数量控制点的贝塞尔曲线，指定 t 参数，绘制一定曲线阶段，accuracy 参数指定精度\n  bezierCurveTo(controlPoints: number[], t?: number, accuracy?: number): this;\n  closePath(): this;\n  // 开始新路径\n  beginPath(): this;\n  // 清空路径\n  clearPath(): this;\n  // 开始剪切\n  beginClip(): this;\n  // 结束剪切\n  endClip(): this;\n\n  // 设置遮罩，将另一个图案对象作为遮罩\n  // x、y、width、height，设置遮罩作用区域。type，设置遮罩的合成方式\n  setMask(x: number, y: number, width: number, height: number, graphics: Graphics, type?: GlobalCompositeOperation): this;\n}\n```\n\n### 生命周期\n每个图案对象 `Graphics`（`Group`）都具有生命周期，以便在特定的时机执行特定的操作。\n\n```ts\nconst s = new QxCanvas.Graphics()\ns.onBeforeMount((item) => {\n  console.log(\"before mount\");\n})\n  .onMounted((item) => {\n    console.log(\"mounted\");\n  })\n  .onBeforeRender((item, renderer) => {\n    console.log(\"before render\");\n  })\n  .onRendering((item, renderer) => {\n    console.log(\"rendering\");\n  })\n  .onRendered((item, renderer) => {\n    console.log(\"after render\");\n    app.stage.remove(s);\n  })\n  .onBeforeUnmount((item) => {\n    console.log(\"before unmount\");\n  })\n  .onUnmounted((item) => {\n    console.log(\"unmounted\");\n  });\n```\n\n顺序如下：\n1. `onBeforeMount`：挂载到父节点前触发。\n2. `onMounted`：挂载到父节点后触发。\n3. `onBeforeRender`：每帧渲染前触发。\n4. `onRendering`：每帧渲染时触发，此时节点自身已经渲染完毕，但子节点还未渲染。\n5. `onRendered`：每帧渲染后触发，此时节点及其子节点都已经渲染完毕。\n6. `onBeforeUnmount`：从父节点移除前触发。\n7. `onUnmounted`：从父节点移除后触发。\n\n# 案例\n使用 [qx-canvas](https://github.com/qxchuckle/qx-canvas) 实现一些简单的案例。\n\n> 有了渲染引擎，写这些小Demo就非常方便且简单了。\n\n## 绘画板\n可以选择画笔颜色的绘画板。\n\n```ts\nconst color = document.querySelector(\"#color\") as HTMLInputElement;\n\nconst s1 = new QxCanvas.Graphics();\n\napp.stage.add(s1).addEventListener(\"mousedown\", (e) => {\n  s1.beginLine({ width: 2, color: color.value });\n  const onMove = (e: any) => {\n    s1.lineTo(e.global.x, e.global.y);\n  };\n  app.stage.addEventListener(\"mousemove\", onMove);\n  app.stage.addEventListener(\n    \"mouseup\",\n    () => {\n      app.stage.removeEventListener(\"mousemove\", onMove);\n    },\n    { once: true }\n  );\n});\n```\n\n## 任意图形拖动\n使用 `setPosition` 设置位置偏移量。\n\n```ts\na.addEventListener(\"mousedown\", (e) => {\n  const mouseDownPoint = e.global.clone();\n  const { x, y } = a.transform.position;\n  const onMove = (e: any) => {\n    const movePoint = e.global.clone();\n    const dx = movePoint.x - mouseDownPoint.x;\n    const dy = movePoint.y - mouseDownPoint.y;\n    a.setPosition(x + dx, y + dy);\n  };\n  app.stage.addEventListener(\"mousemove\", onMove);\n  app.stage.addEventListener(\n    \"mouseup\",\n    () => {\n      app.stage.removeEventListener(\"mousemove\", onMove);\n    },\n    { once: true }\n  );\n});\n```\n\n## 刮刮乐\n利用遮罩和自由绘画实现。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/96-1.gif\" width=\"100%\" style=\"max-width: fit-content\" />\n\n```ts\nconst mask = new QxCanvas.Graphics().beginLine({ width: 12 });\n\nconst bg = new QxCanvas.Graphics()\n  .beginFill({ color: \"#ccc\" })\n  .drawRect(0, 0, app.canvas.width, app.canvas.height)\n  .setMask(0, 0, app.canvas.width, app.canvas.height, mask, \"destination-out\")\n  .addEventListener(\"mousedown\", (e) => {\n    mask.moveTo(e.global.x, e.global.y);\n    const onMove = (e: any) => {\n      mask.lineTo(e.global.x, e.global.y);\n    };\n    bg.addEventListener(\"mousemove\", onMove);\n    bg.addEventListener(\"mouseup\", () => {\n      bg.removeEventListener(\"mousemove\", onMove);\n    });\n  });\n\napp.stage.add(bg);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","canvas"],"categories":["项目"]},{"title":"Canvas 2D 事件","url":"/article/5b168750.html","content":"\n# 前言\nCanvas 并没有提供原生的事件机制，所有的事件交互都需要基于 dom 事件来实现，为了操作画布上的图形，往往需要自己实现一个事件系统。\n\n很多 Canvas 库都带有自己的事件系统：[Konva](https://konvajs.org/docs/sandbox/index.html)、[fabric.js](https://github.com/fabricjs/fabric.js)、[pixi](https://github.com/pixijs/pixijs)\n\n# 事件\n**常用鼠标事件：**\n1. click 点击\n2. dblclick 双击\n3. mouseover 鼠标移入及在元素内移动，冒泡，移入和移出其子元素时也会触发\n4. mouseout 鼠标移出，冒泡，移入和移出其子元素时也会触发\n5. mouseenter 鼠标首次移入，不会冒泡\n6. mouseleave 鼠标移出，不会冒泡\n7. mousedown 鼠标按下\n8. mouseup 鼠标抬起\n9. mousemove 鼠标移动\n10. mousewheel 鼠标滚轮\n\n## 键盘事件\n三个键盘事件：\n1. keydown 按下按键触发，返回键盘码\n2. keyup 松开按键触发，返回键盘码\n3. keypress 按下按键，并产生一个字符时触发，返回其ASCII码。一些功能键不会产生字符，也就不会触发该事件。\n\nkeydown 和 keypress 在按住不松开时会重复触发。\n\n**注意：**键盘事件只发生在当前拥有焦点的HTML元素上，如果没有元素拥有焦点，那么事件将会上移至windows和document对象。所以 canvas 不能直接监听键盘事件。\n\n两种解决办法：\n\n**1、添加 tabindex 属性，使 canvas 具有焦点：**\n`tabindex` 属性表示元素**可聚焦**，值表示元素是否/在何处参与顺序键盘导航（通常使用Tab键，因此得名）。\n1. **负值：**不能通过键盘导航来访问到该元素。\n2. **0：**默认值，可以通过键盘导航来访问到该元素。导航相对顺序由 DOM 结构决定。\n3. **正值：**可以通过键盘导航来访问到该元素。导航相对顺序由 tabindex 的值决定。\n\n```js\ncanvas.tabIndex = -1;\ncanvas.focus();\ncanvas.addEventListener(\"keydown\", (e)=>{\n  console.log(e.key);\n}, false);\n```\n\n当其失去焦点时，则也会失去键盘监听，通常适合做游戏等当失去焦点游戏自动暂停等场景。\n\n**2、监听 window 键盘事件：**\n容易与其它元素冲突，需要更复杂的逻辑来判断是否在 canvas 上按下按键。\n\n```js\nwindow.addEventListener(\"keydown\", (e) => {\n  console.log(e.key);\n}, false);\n```\n\n# 图形绘制demo\n用一个 demo 初试事件逻辑。[在线演示](https://canvas-event-demo-fc37mhbi4-qcqxs-projects.vercel.app/)。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/94-1.gif\" width=\"100%\" style=\"max-width: fit-content\" />\n\n## 获取鼠标位置\n事件对象具有 **clientX** 和 **clientY** 属性，表示鼠标在视口中的坐标。\ndom 元素在视口中的坐标，可以使用 **getBoundingClientRect** 方法获取。\n\n于是，可以通过以下代码获取鼠标在 canvas 上的坐标：\n\n```js\ncanvas.addEventListener(\"mousemove\", (e) => {\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.x;\n  const y = e.clientY - rect.y;\n  console.log(`X: ${x}, Y: ${y}`);\n});\n```\n\n## 架构\n所有图形都应该是具有 `draw` 方法的对象，于是可以抽象出一个父类 `Shape`，所有图形都继承自它，并且实现 `draw` 方法。\n\n还需要实现 `isInside` 方法，用于判断一个点是否在图形上。\n\n外部使用一个数组保存所有图形对象，每次绘制时，遍历数组，调用每个图形的 `draw` 方法。\n\n> js 没有原生的抽象类，一般使用 ts 方便约束。\n\n```js\n// 图形父类\nclass Shape {\n  draw() {}\n  isInside(x, y) {}\n}\n\n// 保存所有图形\nconst shapes = [];\n\nfunction main() {\n  // 清空画布\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  // 画所有图形\n  shapes.forEach((shape) => {\n    shape.draw();\n  });\n  requestAnimationFrame(main);\n}\nmain();\n```\n\n在 main 主循环中，重复清空画布和绘制图形，性能问题暂不考虑，可以使用标志位来控制是否需要重绘等，这并不是本文需要关心的。\n\n## 画矩形\n每种图形类的实现都为 `draw` 和 `isInside` 方法服务。\n\n实现矩形绘制后其它图形也差不多，无非就是画的方式和检测位置的算法不同。\n\n矩形根据四个点就能确定图形的位置和大小，所以实现起来也很简单。因为拖动的方向不确定，endX 也可能比 startX 小，所以创建 getter 来获取矩形的四个边界点和矩形大小，方便后续计算。\n`draw` 在最小边界点开始，绘制一个矩形即可。\n`isInside` 也很简单，判断点是否在矩形的四个边界内即可。\n\n```js\nclass Rect extends Shape {\n  // 传入四个点的坐标和颜色\n  constructor(startX, startY, endX, endY, color) {\n    super();\n    this.startX = startX;\n    this.startY = startY;\n    this.endX = endX;\n    this.endY = endY;\n    this.color = color;\n  }\n\n  draw() {\n    ctx.save();\n    ctx.fillStyle = this.color;\n    ctx.fillRect(this.minX, this.minY, this.width, this.height);\n    ctx.restore();\n  }\n\n  isInside(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n\n  get minX() {\n    return Math.min(this.startX, this.endX);\n  }\n\n  get minY() {\n    return Math.min(this.startY, this.endY);\n  }\n\n  get maxX() {\n    return Math.max(this.startX, this.endX);\n  }\n\n  get maxY() {\n    return Math.max(this.startY, this.endY);\n  }\n\n  get width() {\n    return this.maxX - this.minX;\n  }\n\n  get height() {\n    return this.maxY - this.minY;\n  }\n\n  get size() {\n    return this.width * this.height;\n  }\n}\n```\n\n## 拖动绘制\n监听 **mousedown** 事件，在鼠标按下后，在该位置创建一个大小为 0 的矩形。\n然后监听 **mousemove** 事件，根据鼠标移动的位置，修改矩形的终点坐标，实现拖动绘制的效果。\n最后监听 **mouseup** 事件，在鼠标抬起后，清除相关事件。\n\n```js\n// 鼠标按下时开始拖动逻辑\ncanvas.addEventListener(\"mousedown\", (e) => {\n  const rect = canvas.getBoundingClientRect();\n  // 鼠标按下时相对于画布的坐标\n  const mX = e.clientX - rect.x;\n  const mY = e.clientY - rect.y;\n  // 绘制一个矩形，刚开始时起点和终点相同\n  const shape = new Rect(clickX, clickY, clickX, clickY, color.value);\n  // 记录是已经加入到图形数组中\n  let isPush = false;\n  // 鼠标移动时修改终点坐标\n  canvas.onmousemove = (e) => {\n    // 拖动后图形具有大小，才加入到图形数组中\n    if (!isPush) {\n      isPush = true;\n      // 加入到图形数组中\n      shapes.push(shape);\n    }\n    // 鼠标移动时相对于画布的坐标\n    const x = e.clientX - rect.x;\n    const y = e.clientY - rect.y;\n    // 修改终点坐标\n    shape.endX = x;\n    shape.endY = y;\n  };\n  // 鼠标抬起时清除事件\n  canvas.onmouseup = () => {\n    canvas.onmousemove = null;\n    canvas.onmouseup = null;\n  };\n});\n```\n\n## 拖动移动\n在 **mousedown** 事件中，判断鼠标按下的位置是否在图形上，如果在，则开始拖动图形的逻辑。\n\n倒序遍历图形数组，因为后画的图形在数组的后面，调用 `isInside` 方法判断是否在图形上，如果在，则根据鼠标移动的距离，在图形原来坐标的基础上，修改图形坐标。\n\n```js\n// 鼠标按下时开始拖动逻辑\ncanvas.addEventListener(\"mousedown\", (e) => {\n  const rect = canvas.getBoundingClientRect();\n  // 鼠标按下时相对于画布的坐标\n  const clickX = e.clientX - rect.x;\n  const clickY = e.clientY - rect.y;\n  // 记录被选中的图形\n  let select;\n  // 倒序遍历所有图形，判断是否有图形被选中\n  for (let i = shapes.length - 1; i >= 0; i--) {\n    if (shapes[i].isInside(clickX, clickY)) {\n      select = {\n        shape: shapes[i],\n        index: i,\n      };\n      break;\n    }\n  }\n  // 如果有图形被选中, 则移动图形\n  if (select) {\n    // 记录矩形原来位置\n    const { startX, startY, endX, endY } = select.shape;\n    canvas.onmousemove = (e) => {\n      // 鼠标移动时相对于画布的坐标\n      const x = e.clientX - rect.x;\n      const y = e.clientY - rect.y;\n      // 鼠标移动距离\n      const dx = x - clickX;\n      const dy = y - clickY;\n      // 更新起点和终点坐标\n      select.shape.startX = startX + dx;\n      select.shape.startY = startY + dy;\n      select.shape.endX = endX + dx;\n      select.shape.endY = endY + dy;\n    };\n  } else {\n    // 绘制一个矩形，刚开始时起点和终点相同\n    const shape = new Rect(clickX, clickY, clickX, clickY, color.value);\n    // 记录是已经加入到图形数组中\n    let isPush = false;\n    // 鼠标移动时修改终点坐标\n    canvas.onmousemove = (e) => {\n      // 鼠标移动时相对于画布的坐标\n      const x = e.clientX - rect.x;\n      const y = e.clientY - rect.y;\n      // 修改终点坐标\n      shape.endX = x;\n      shape.endY = y;\n      // 拖动后图形具有大小，才加入到图形数组中\n      if (!isPush && shape.size > 0) {\n        isPush = true;\n        // 加入到图形数组中\n        shapes.push(shape);\n      }\n    };\n  }\n\n  // 鼠标抬起时清除事件\n  canvas.onmouseup = () => {\n    canvas.onmousemove = null;\n    canvas.onmouseup = null;\n  };\n});\n```\n\n## 清空与撤销\n撤销图形的绘制，只需要将数组中最后一个图形删除即可。\n\n如果还需要撤销对图形的操作，那可以在图形类中实现一个栈结构，保存每次操作完毕的位置等状态，总之，办法很多，类似的还能实现重做等功能。\n\n```js\n// 清空画布\nclear.onclick = () => {\n  shapes.length = 0;\n};\n\n// 撤销图形绘制\nrevoke.onclick = () => {\n  shapes.pop();\n};\n```\n\n## 完整代码\n\n```js\nconst color = document.querySelector(\"#color\");\nconst clear = document.querySelector(\"#clear\");\nconst revoke = document.querySelector(\"#revoke\");\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\n// 图形父类\nclass Shape {\n  draw() {}\n  isInside(x, y) {}\n}\n\nclass Rect extends Shape {\n  // 传入四个点的坐标和颜色\n  constructor(startX, startY, endX, endY, color) {\n    super();\n    this.startX = startX;\n    this.startY = startY;\n    this.endX = endX;\n    this.endY = endY;\n    this.color = color;\n  }\n\n  draw() {\n    ctx.save();\n    ctx.fillStyle = this.color;\n    ctx.fillRect(this.minX, this.minY, this.width, this.height);\n    ctx.restore();\n  }\n\n  isInside(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n\n  get minX() {\n    return Math.min(this.startX, this.endX);\n  }\n\n  get minY() {\n    return Math.min(this.startY, this.endY);\n  }\n\n  get maxX() {\n    return Math.max(this.startX, this.endX);\n  }\n\n  get maxY() {\n    return Math.max(this.startY, this.endY);\n  }\n\n  get width() {\n    return this.maxX - this.minX;\n  }\n\n  get height() {\n    return this.maxY - this.minY;\n  }\n\n  get size() {\n    return this.width * this.height;\n  }\n}\n\n// 保存所有图形\nconst shapes = [];\n\nfunction main() {\n  // 清空画布\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  // 画所有图形\n  shapes.forEach((shape) => {\n    shape.draw();\n  });\n  requestAnimationFrame(main);\n}\nmain();\n\n// 鼠标按下时开始拖动逻辑\ncanvas.addEventListener(\"mousedown\", (e) => {\n  const rect = canvas.getBoundingClientRect();\n  // 鼠标按下时相对于画布的坐标\n  const clickX = e.clientX - rect.x;\n  const clickY = e.clientY - rect.y;\n  // 记录被选中的图形\n  let select;\n  // 倒序遍历所有图形，判断是否有图形被选中\n  for (let i = shapes.length - 1; i >= 0; i--) {\n    if (shapes[i].isInside(clickX, clickY)) {\n      select = {\n        shape: shapes[i],\n        index: i,\n      };\n      break;\n    }\n  }\n  // 如果有图形被选中, 则移动图形\n  if (select) {\n    // 记录矩形原来位置\n    const { startX, startY, endX, endY } = select.shape;\n    canvas.onmousemove = (e) => {\n      // 鼠标移动时相对于画布的坐标\n      const x = e.clientX - rect.x;\n      const y = e.clientY - rect.y;\n      // 鼠标移动距离\n      const dx = x - clickX;\n      const dy = y - clickY;\n      // 更新起点和终点坐标\n      select.shape.startX = startX + dx;\n      select.shape.startY = startY + dy;\n      select.shape.endX = endX + dx;\n      select.shape.endY = endY + dy;\n    };\n  } else {\n    // 绘制一个矩形，刚开始时起点和终点相同\n    const shape = new Rect(clickX, clickY, clickX, clickY, color.value);\n    // 记录是已经加入到图形数组中\n    let isPush = false;\n    // 鼠标移动时修改终点坐标\n    canvas.onmousemove = (e) => {\n      // 鼠标移动时相对于画布的坐标\n      const x = e.clientX - rect.x;\n      const y = e.clientY - rect.y;\n      // 修改终点坐标\n      shape.endX = x;\n      shape.endY = y;\n      // 拖动后图形具有大小，才加入到图形数组中\n      if (!isPush && shape.size > 0) {\n        isPush = true;\n        // 加入到图形数组中\n        shapes.push(shape);\n      }\n    };\n  }\n\n  // 鼠标抬起时清除事件\n  canvas.onmouseup = () => {\n    canvas.onmousemove = null;\n    canvas.onmouseup = null;\n  };\n});\n\n// 清空画布\nclear.onclick = () => {\n  shapes.length = 0;\n};\n\n// 撤销图形绘制\nrevoke.onclick = () => {\n  shapes.pop();\n};\n```\n\n# 事件系统\n在上面的 demo 中，我们让每个图形各自管理自己的 draw 和 isInside 方法，不同图形具有不同实现。\nisInside 方法用于辅助事件处理方法，判断鼠标点击的位置是否在该图形上。\n\n可以完全独立出来一个框架系统，用于处理所有图形的点击、拖拽等事件，这就是 **Canvas 事件系统**。\n事件系统的前提是**碰撞检测**，而判断一个点是否在一个**封闭的直边多边形内部**相对是比较容易的，这就需要实现一个渲染引擎。\n\n在后续文章中，将会使用 Rollup + TS 实现一个 Canvas2D 渲染引擎。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","canvas"],"categories":["学习笔记"]},{"title":"Canvas 2D 贝塞尔曲线","url":"/article/ba04fd32.html","content":"\n# 前言\nCanvas 提供的贝塞尔函数只能一次性绘制，而无法阶段性绘制，也就无法直接实现动画，并且只提供了二阶和三阶，有时候还需要更多阶。\n\n最重要一点是，原生的贝塞尔曲线不太好做碰撞检测，判断一个点是否在一个**封闭的直边多边形内部**相对是比较容易的。\n\n> 贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线。贝塞尔曲线由 n 个控制点对应着 n-1 阶的贝塞尔曲线，并且可以通过递归的方式来绘制。\n\n参考：\n[深入浅出贝塞尔曲线](https://juejin.cn/post/6995482699037147166)\n[贝塞尔曲线 javascript.info](https://zh.javascript.info/bezier-curve)\n[从零开始学图形学：10分钟看懂贝塞尔曲线](https://zhuanlan.zhihu.com/p/344934774)\n[用canvas绘制一个曲线动画——深入理解贝塞尔曲线](https://segmentfault.com/a/1190000012670045)\n[用Javascript+Canvas画N阶贝塞尔曲线](https://zhuanlan.zhihu.com/p/180508343)\n[canvas实现高阶贝塞尔曲线](https://www.jianshu.com/p/18a495956b15)\n\n# 公式推导\n下面是贝塞尔曲线的公式。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/95-1.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n**基本过程：**\n1. 贝塞尔曲线由 n 个控制点绘制，各个点依次连成折线\n2. 第一个点到 n-1 个点都发出一个运动点，每个运动点以**相同时间**到达下一个相邻点。\n3. 一共有 n-1 个运动点，此时出现递归，可以视为 n-1 个控制点的贝塞尔曲线绘制。\n4. 注意，递归过程形成的所有运动点，都同时到达下一个相邻点。\n5. 最终，递归到一阶贝塞尔曲线，其运动点的轨迹就是要绘制的贝塞尔曲线。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/95-1-1.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n这么说还是有些抽象，下面从一阶开始实际推导下。\n\n## 一阶\n一阶贝塞尔曲线具有两个点，也就是一条直线。t 是单位时间，值为 [0, 1]。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/95-2.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n很显然，运动点 Pt 坐标可以这么计算：\n`Pt = P0 + (P1 - P0)t = (1 - t)P0 + tP1`\n\n## 二阶\n二阶贝塞尔曲线具有三个点，已经可以绘制为曲线。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/95-3.webp\" width=\"100%\" style=\"max-width: 300px\" />\n\nPa 和 Pb 两个运动点都要以**相同时间**到达下一个相邻点，于是有：\n`|P0Pa| / |P0P1| = |P1Pb| / |P1P2| = t`\n\n每个运动点在各自线段上都可视为一阶贝塞尔曲线：\n`Pa = (1 - t)P0 + tP1`\n`Pb = (1 - t)P1 + tP2`\n`Pt = (1 - t)Pa + tPb`\n\n将 Pa、Pb 代入 Pt，可以得到：\n`Pt = (1 - n)^2P0 + 2t(1 - t)P1 + t^2P2`\n\n更多阶数也是如此，推导出的 Pt 已经符合公式了。\n\n# 实现\n明白了公式，就可以开始手写贝塞尔曲线了。\n\n新建一个 Bezier 类，传入 canvas 上下文。\n\n```js\nclass Bezier {\n  constructor(ctx) {\n    this.ctx = ctx;\n  }\n}\n```\n\n## 计算运动点\n也就是计算一阶贝塞尔曲线。\n\n```js\n// 计算两个点之间运动点位置\ncalcMotionPoint(p1, p2, t) {\n  // 也就是一阶贝塞尔曲线公式\n  return {\n    x: (1 - t) * p1.x + t * p2.x,\n    y: (1 - t) * p1.y + t * p2.y,\n  };\n}\n```\n\n## 绘制曲线\n设计上，采用增量更新，传入曲线点集合，只画最后两个点的连线。\n\n```js\n// 绘制贝塞尔曲线\ndrawCurve(curvePoints, isAnimation, p2d) {\n  // 任务很简单，把所有的点连起来就行了，这里采取增量绘制\n  const len = curvePoints.length;\n  if (isAnimation) {\n    const x = curvePoints[len - 1].x;\n    const y = curvePoints[len - 1].y;\n    // 对于动画，使用Path2D对象，保存上次绘制的路径\n    p2d.lineTo(x, y);\n    this.ctx.stroke(p2d);\n    // 绘制圆圈\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.strokeStyle = \"blue\";\n    this.ctx.lineWidth = 1;\n    this.ctx.arc(x, y, 5, 0, 2 * Math.PI);\n    this.ctx.stroke();\n    this.ctx.restore();\n  } else {\n    // 对于静态绘制，直接增量绘制\n    if (len < 3) return;\n    this.ctx.beginPath();\n    this.ctx.moveTo(curvePoints[len - 3].x, curvePoints[len - 3].y);\n    this.ctx.lineTo(curvePoints[len - 2].x, curvePoints[len - 2].y);\n    this.ctx.lineTo(curvePoints[len - 1].x, curvePoints[len - 1].y);\n    this.ctx.stroke();\n  }\n}\n```\n\n## 递归降阶\n这里递归将 n 阶贝塞尔曲线降为 1 阶，每次递归都调用 `calcMotionPoint()` 计算当前运动点（下一阶的控制点）位置，最后 1 阶的运动点就是曲线上的点，将其加入曲线点集合数组，并调用 `drawCurve()` 增量绘制。\n\n绘制出控制点之间的连线，更加直观。\n\n```js\n// 计算和连线各个控制点和运动点\ndrawLines(points, t, curvePoints, isAnimation, p2d, color) {\n  // 点小于2时，说明是最终运动点，即贝塞尔曲线上的点\n  if (points.length < 2) {\n    curvePoints.push({ ...points[0] });\n    this.drawCurve(curvePoints, isAnimation, p2d);\n    return;\n  }\n  if (isAnimation) {\n    // 绘制控制点连线\n    this.ctx.save();\n    for (let i = 0; i < points.length; i++) {\n      // 绘制控制点连线\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = color ?? \"red\";\n      this.ctx.lineWidth = 2;\n      i > 0 && this.ctx.moveTo(points[i - 1].x, points[i - 1].y);\n      this.ctx.lineTo(points[i].x, points[i].y);\n      this.ctx.stroke();\n      // 端点绘制圆圈\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = \"black\";\n      this.ctx.lineWidth = 1;\n      this.ctx.arc(points[i].x, points[i].y, 5, 0, 2 * Math.PI);\n      this.ctx.stroke();\n    }\n    this.ctx.restore();\n  }\n  // 下一阶新的控制点数组\n  const newPoints = [];\n  // 遍历所有控制点，算出下一阶的控制点\n  for (let i = 0; i < points.length - 1; i++) {\n    newPoints.push(this.calcMotionPoint(points[i], points[i + 1], t));\n  }\n  // 递归调用，计算从n阶到1阶的所有控制点\n  this.drawLines(newPoints, t, curvePoints, isAnimation, p2d, null);\n}\n```\n\n## 静态绘制\n\n```js\ndraw(controlPoints, t = 1) {\n  if (!controlPoints.length) return;\n  const curvePoints = [];\n  let i = 0;\n  while (i <= t) {\n    this.drawLines(controlPoints, i, curvePoints, false, null, \"blue\");\n    i += 0.01;\n  }\n  // 补偿绘制最后一段\n  this.drawLines(controlPoints, t, curvePoints, false, null, \"blue\");\n  return curvePoints;\n}\n```\n\n## 动画绘制\n\n```js\n// 绘制动画\ndrawAnimation(controlPoints, t = 1) {\n  if (!controlPoints.length) return;\n  return new Promise((resolve) => {\n    const curvePoints = [];\n    let i = 0;\n    const p2d = new Path2D();\n    const draw = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      if (i > t) {\n        // 补偿绘制最后一段\n        this.drawLines(controlPoints, t, curvePoints, true, p2d, \"blue\");\n        resolve(curvePoints);\n        return;\n      }\n      this.drawLines(controlPoints, i, curvePoints, true, p2d, \"blue\");\n      i += 0.01;\n      requestAnimationFrame(draw);\n    };\n    draw();\n  });\n}\n```\n\n## 完整代码\n\n```js\nclass Bezier {\n  constructor(ctx) {\n    this.ctx = ctx;\n  }\n\n  // 静态绘制\n  draw(controlPoints, t = 1) {\n    if (!controlPoints.length) return;\n    const curvePoints = [];\n    let i = 0;\n    while (i <= t) {\n      this.drawLines(controlPoints, i, curvePoints, false, null, \"blue\");\n      i += 0.01;\n    }\n    // 补偿绘制最后一段\n    this.drawLines(controlPoints, t, curvePoints, false, null, \"blue\");\n    return curvePoints;\n  }\n\n  // 绘制动画\n  drawAnimation(controlPoints, t = 1) {\n    if (!controlPoints.length) return Promise.resolve([]);\n    return new Promise((resolve) => {\n      const curvePoints = [];\n      let i = 0;\n      const p2d = new Path2D();\n      const draw = () => {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (i > t) {\n          // 补偿绘制最后一段\n          this.drawLines(controlPoints, t, curvePoints, true, p2d, \"blue\");\n          resolve(curvePoints);\n          return;\n        }\n        ctx.fillText(`t = (${i.toFixed(2)})`, 10, 20);\n        this.drawLines(controlPoints, i, curvePoints, true, p2d, \"blue\");\n        i += 0.01;\n        requestAnimationFrame(draw);\n      };\n      draw();\n    });\n  }\n\n  // 计算和连线各个控制点和运动点\n  drawLines(points, t, curvePoints, isAnimation, p2d, color) {\n    // 点小于2时，说明是最终运动点，即贝塞尔曲线上的点\n    if (points.length < 2) {\n      curvePoints.push({ ...points[0] });\n      this.drawCurve(curvePoints, isAnimation, p2d);\n      return;\n    }\n    if (isAnimation) {\n      // 绘制控制点连线\n      this.ctx.save();\n      for (let i = 0; i < points.length; i++) {\n        // 绘制控制点连线\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = color ?? \"red\";\n        this.ctx.lineWidth = 2;\n        i > 0 && this.ctx.moveTo(points[i - 1].x, points[i - 1].y);\n        this.ctx.lineTo(points[i].x, points[i].y);\n        this.ctx.stroke();\n        // 端点绘制圆圈\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = \"black\";\n        this.ctx.lineWidth = 1;\n        this.ctx.arc(points[i].x, points[i].y, 5, 0, 2 * Math.PI);\n        this.ctx.stroke();\n      }\n      this.ctx.restore();\n    }\n    // 下一阶新的控制点数组\n    const newPoints = [];\n    // 遍历所有控制点，算出下一阶的控制点\n    for (let i = 0; i < points.length - 1; i++) {\n      newPoints.push(this.calcMotionPoint(points[i], points[i + 1], t));\n    }\n    // 递归调用，计算从n阶到1阶的所有控制点\n    this.drawLines(newPoints, t, curvePoints, isAnimation, p2d, null);\n  }\n\n  // 绘制贝塞尔曲线\n  drawCurve(curvePoints, isAnimation, p2d) {\n    // 任务很简单，把所有的点连起来就行了，这里采取增量绘制\n    const len = curvePoints.length;\n    if (isAnimation) {\n      const x = curvePoints[len - 1].x;\n      const y = curvePoints[len - 1].y;\n      // 对于动画，使用Path2D对象，保存上次绘制的路径\n      p2d.lineTo(x, y);\n      this.ctx.stroke(p2d);\n      // 绘制圆圈\n      this.ctx.save();\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = \"blue\";\n      this.ctx.lineWidth = 1;\n      this.ctx.arc(x, y, 5, 0, 2 * Math.PI);\n      this.ctx.stroke();\n      this.ctx.restore();\n    } else {\n      // 对于静态绘制，直接增量绘制\n      if (len < 3) return;\n      this.ctx.beginPath();\n      this.ctx.moveTo(curvePoints[len - 3].x, curvePoints[len - 3].y);\n      this.ctx.lineTo(curvePoints[len - 2].x, curvePoints[len - 2].y);\n      this.ctx.lineTo(curvePoints[len - 1].x, curvePoints[len - 1].y);\n      this.ctx.stroke();\n    }\n  }\n\n  // 计算两个点之间运动点位置\n  calcMotionPoint(p1, p2, t) {\n    // 也就是一阶贝塞尔曲线公式\n    return {\n      x: (1 - t) * p1.x + t * p2.x,\n      y: (1 - t) * p1.y + t * p2.y,\n    };\n  }\n}\n```\n\n## 使用\n[在线使用](https://14-o8v4am8cu-qcqxs-projects.vercel.app/)\n\n```js\nconst points = [\n  { x: 120, y: 120 },\n  { x: 100, y: 200 },\n  { x: 300, y: 200 },\n  { x: 400, y: 200 },\n  { x: 200, y: 20 },\n  { x: 40, y: 20 },\n  { x: 30, y: 200 },\n];\nconst bezier = new Bezier(ctx);\nctx.lineWidth = 4;\nbezier.drawAnimation(points).then((res) => {\n  console.log(res);\n});\n// console.log(bezier.draw(points));\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/95-4.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","canvas"],"categories":["学习笔记"]},{"title":"Canvas 2D 进阶","url":"/article/995d74ec.html","content":"\n# 状态管理\ncanvas 是根据状态来绘图的\n\n状态：\n1. 描边/填充样式：strokeStyle, fillStyle, globalAlpha\n2. 线的样式：lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset\n3. 阴影：shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor,\n4. 字体样式：font, textAlign, textBaseline, direction\n5. 平滑质量：imageSmoothingEnabled\n6. 合成属性：globalCompositeOperation\n7. 当前变形\n8. 当前裁剪路径\n\nCanvas 维护了一个**状态栈**：\n1. `save()` 将当前状态压入栈中。\n2. `restore()` 弹出栈顶状态，恢复之前的状态。\n\n```js\nctx.fillStyle = 'red'\nctx.strokeStyle = 'blue'\nctx.lineWidth = 6\nctx.save() //  保存当前状态\n\nctx.beginPath()\nctx.rect(50, 50, 100, 50)\nctx.fill()\nctx.stroke()\n\n// 更改状态\nctx.fillStyle = 'green'\nctx.strokeStyle = 'red'\nctx.lineWidth = 10\n\nctx.beginPath()\nctx.rect(200, 50, 100, 50)\nctx.fill()\nctx.stroke()\n\nctx.restore() // 恢复之前保存的状态\nctx.beginPath()\nctx.rect(350, 50, 100, 50)\nctx.fill()\nctx.stroke()\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-12.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n# 变形\n变形本质是对**坐标系**的变换，可以实现旋转、缩放、平移等效果。\n\n变形效果只影响后续的绘制，不会影响之前的绘制。\n\n## 平移 translate\n`translate(x, y)` 移动画布的原点到原来的 `(x, y)`，即整个坐标系平移了 `(x, y)`。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-1.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n图形会根据新的原点重新绘制。视觉上看，图形在原来的位置上移动了 `(x, y)`。\n\n## 旋转 rotate\n`rotate(angle)` 以原点为中心旋转画布，`angle` 旋转的**弧度**，正值顺时针。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-2.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n## 缩放 scale\n`scale(x, y)` 缩放画布，`x` 为水平缩放比例，`y` 为垂直缩放比例。\n\n如果是负数，镜像反转。\n\n## 变换矩阵 transform\n`transform(a, b, c, d, e, f)` 变换矩阵，可多次调用叠加变换效果。\n`setTransform(a, b, c, d, e, f)` 重新设置（覆盖）当前的变形效果，包括 translate、rotate 等。\n`resetTransform()` 重置变换矩阵为单位矩阵。等同于 `setTransform(1, 0, 0, 1, 0, 0)`。\n\n```text 变换矩阵的描述 \n[ 𝑎 𝑐 𝑒\n  𝑏 𝑑 𝑓\n  0 0 1 ]\n[ x' ]   [ a  c  e ]   [ x ]   [a * x + c * y + e]\n[ y' ] = [ b  d  f ] * [ y ] = [b * x + d * y + f]\n[ 1  ]   [ 0  0  1 ]   [ 1 ]   [ 1 ]\n```\n\n参数：\n1. `a (m11)` 水平缩放，默认 1。\n2. `b (m12)` 竖直错切，默认 0。\n3. `c (m21)` 水平错切，默认 0。\n4. `d (m22)` 垂直缩放，默认 1。\n5. `e (dx)` 水平移动，默认 0。\n6. `f (dy)` 垂直移动，默认 0。\n\n### 常见效果\n**1、移动：**控制 e、f 参数。\n\n```text\n[ x' ]   [ 1  0  e ]   [ x ]   [ x + e ]\n[ y' ] = [ 0  1  f ] * [ y ] = [ y + f ]\n[ 1  ]   [ 0  0  1 ]   [ 1 ]   [ 1 ]\n```\n\n**2、缩放：**控制 a、d 参数。\n\n```text\n[ x' ]   [ a  0  0 ]   [ x ]   [ a * x ]\n[ y' ] = [ 0  d  0 ] * [ y ] = [ d * y ]\n[ 1  ]   [ 0  0  1 ]   [ 1 ]   [ 1 ]\n```\n\n**3、错切：**控制 b、c 参数。\nb 水平错切，即像素的y值不变，x的值随着y的增加，平移距离越来越多，变成斜线\nc 竖直错切，即像素的x值不变，y的值随着x的增加，平移距离越来越多，变成斜线\n\n```text\n[ x' ]   [ 1  c  0 ]   [ x ]   [ x + c * y ]\n[ y' ] = [ b  1  0 ] * [ y ] = [ y + b * x ]\n[ 1  ]   [ 0  0  1 ]   [ 1 ]   [ 1 ]\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-19.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n**4、旋转：**需要控制 a、b、c、d 参数\n如图所示，推导旋转的公式：\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-20.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n```text\nx0 = r * cos α\ny0 = r * sin α\nx = r * cos(α+θ) = r * cos α * cos θ - r * sin α * sin θ = x0 * cos θ - y0 * sin θ\ny = r * sin(α+θ) = r * sin α * cos θ + r * cos α * sin θ = y0 * cos θ + x0 * sin θ\n```\n\n最终推导的公式刚好可以使用变换矩阵表示\n\n```text\n[ x' ]   [ cos(θ)  -sin(θ)  0 ]   [ x ]   [ cos(θ) * x - sin(θ) * y ]\n[ y' ] = [ sin(θ)   cos(θ)  0 ] * [ y ] = [ sin(θ) * x + cos(θ) * y ]\n[ 1  ]   [   0        0     1 ]   [ 1 ]   [ 1 ]\n```\n\n```js\nfunction rotate(angle) {\n  angle = (angle * Math.PI) / 180;\n  const s = Math.sin(angle);\n  const c = Math.cos(angle);\n  ctx.transform(c, s, -s, c, 0, 0);\n}\n\nctx.translate(200, 200);\nfor (let i = 0; i <= 18; i++) {\n  ctx.save();\n  rotate(i * 10);\n  ctx.globalAlpha = 1 / 18 * i\n  ctx.fillRect(0, 0, 100, 100);\n  ctx.strokeRect(0, 0, 100, 100);\n  ctx.restore();\n}\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-21.webp\" width=\"100%\" style=\"max-width: 300px\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 合成\n`globalCompositeOperation` 设置在绘制新图形时应用的合成操作的类型。\n\n即绘制新图形时，如何与**画布上已有的图形**进行叠加。详见[文档](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation)\n\n展示所有合成类型：\n\n```js\nconst blendModes = [\n  \"source-over\",\n  \"source-in\",\n  \"source-out\",\n  \"source-atop\",\n  \"destination-over\",\n  \"destination-in\",\n  \"destination-out\",\n  \"destination-atop\",\n  \"lighter\",\n  \"copy\",\n  \"xor\",\n  \"multiply\",\n  \"screen\",\n  \"overlay\",\n  \"darken\",\n  \"lighten\",\n  \"color-dodge\",\n  \"color-burn\",\n  \"hard-light\",\n  \"soft-light\",\n  \"difference\",\n  \"exclusion\",\n  \"hue\",\n  \"saturation\",\n  \"color\",\n  \"luminosity\",\n];\n\nblendModes.forEach((blendMode, i) => {\n  const box = document.createElement(\"div\");\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 250;\n  canvas.height = 250;\n  const ctx = canvas.getContext(\"2d\");\n\n  ctx.fillStyle = \"rgba(255, 0, 0, 1)\";\n  ctx.fillRect(0, 0, 200, 150);\n  ctx.globalCompositeOperation = blendMode;\n  ctx.fillStyle = \"rgba(0, 255, 0, 1)\";\n  ctx.fillRect(0, 50, 100, 200);\n  ctx.fillStyle = \"rgba(0, 0, 255, 1)\";\n  ctx.fillRect(50, 100, 100, 100);\n\n  const p = document.createElement(\"p\");\n  p.textContent = i + 1 + \"、\" + blendMode;\n  box.appendChild(p);\n  box.appendChild(canvas);\n  document.body.appendChild(box);\n});\n```\n\n## 类型\n下面每四个一组，介绍不同类型的合成：\n\n1. `source-over` **默认**。新图形绘制在原有图形上。\n2. `source-in` 仅绘制新图形与目标画布重叠的地方，其它都是透明的。\n3. `source-out` 在不与现有画布内容重叠的地方绘制新图形。\n4. `source-atop` 新图形绘制在原有图形上，但只在与现有画布内容重叠的地方绘制新图形。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-3.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `destination-over` 新图形绘制在原有图形下方。\n2. `destination-in` 仅保留现有画布内容和新形状重叠的部分。其他的都是透明的。\n3. `destination-out` 仅保留现有画布内容和新形状不重叠的部分。\n4. `destination-atop` 仅保留现有画布内容和新形状重叠的部分。新形状是在现有画布内容的后面绘制的。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-4.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `lighter` 重叠部分颜色值相加。\n2. `copy` 只显示新图形。\n3. `xor` 重叠处变为透明，其他地方正常绘制。\n4. `multiply` 重叠部分颜色值相乘。更黑暗。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-5.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `screen` 重叠部分像素被倒转、相乘、再倒转，结果更亮（与 multiply 相反）。\n2. `overlay` multiply 和 screen 的结合。原本暗的地方更暗，原本亮的地方更亮。\n3. `darken` 保留两个图层中最暗的像素。\n4. `lighten` 保留两个图层中最亮的像素。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-6.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `color-dodge` 将底层除以顶层的反置。\n2. `color-burn` 将反置的底层除以顶层，然后将结果反过来。\n3. `hard-light` 类似于 overlay，multiply 和 screen 的结合——但上下图层互换了。\n4. `soft-light` 柔和版本的 hard-light。不会导致纯黑或纯白。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-7.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `difference` 从顶层减去底层（或反之亦然），始终得到正值。\n2. `exclusion` 与 difference 类似，但对比度较低。\n3. `hue` 保留底层的亮度（luma）和色度（chroma），同时采用顶层的色调（hue）。\n4. `saturation` 保留底层的亮度和色调，同时采用顶层的色度。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-8.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n1. `color` 保留了底层的亮度，同时采用了顶层的色调和色度。\n2. `luminosity` 保持底层的色调和色度，同时采用顶层的亮度。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-9.webp\" width=\"100%\" style=\"max-width: fit-content;max-height: 220px\" />\n\n> 前面几个还好理解，后面的，用到再说吧，看不懂。\n\n# 裁剪 clip\n`clip()` 将当前创建的路径作为剪切路径。`fillRule` 为**填充规则**。\n\n```js\nvoid ctx.clip();\nvoid ctx.clip(fillRule);\nvoid ctx.clip(path, fillRule);\n```\n\n剪裁只对后续的绘制生效。每次裁剪前应该 `save()` 保存状态，以便后续恢复。\n\n```js\n\n// 后面的剪裁不影响已经绘制的内容\nctx.fillRect(0, 0, 100, 100);\n\n// 裁剪区域，一个小三角形\nctx.beginPath();\nctx.moveTo(100, 100);\nctx.lineTo(150, 150);\nctx.lineTo(150, 100);\nctx.closePath();\n// 在设置裁剪区域之前，应该先保存当前的绘图状态\nctx.save();\nctx.clip();\n// 方便看到裁剪区域\nctx.stroke();\n\n// 绘制一个矩形，但被剪裁成了三角形\nctx.fillRect(0, 0, 130, 130);\n\n// 恢复裁剪区域\nctx.restore();\nctx.fillRect(150, 0, 100, 100);\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-10.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n# 填充规则\n`fillRule` 填充规则，一种算法，决定点是在路径内还是在路径外，即某一区域是否被填充。\n1. **nonzero** 非零环绕规则，**默认**。\n2. **evenodd** 奇偶环绕规则。\n\n两个规则的差异体现在**交叉点**的处理上。\n\nfill、clip、isPointinPath 等方法可以传入 fillRule，以指定填充规则。\n\n```js\n// 第一个三角形\nconst t1 = new Path2D();\nt1.moveTo(100, 100);\nt1.lineTo(220, 120);\nt1.lineTo(160, 220);\nt1.closePath();\n\n// 第二个三角形\nconst t2 = new Path2D();\nt2.moveTo(100, 100);\nt2.lineTo(160, 80);\nt2.lineTo(220, 220);\nt2.closePath();\n\n// 将两个三角形路径合并\nconst path = new Path2D();\npath.addPath(t1);\npath.addPath(t2);\n\n// 分别绘制三角形\nctx.font = \"20px 黑体\";\nctx.fillText(\"分别绘制三角形\", 100, 50);\nctx.fillStyle = \"red\";\nctx.fill(t1);\nctx.fillStyle = \"blue\";\nctx.fill(t2);\n\nctx.fillStyle = \"black\";\n\n// nonzero\nctx.translate(200, 0);\nctx.fillText(\"nonzero\", 120, 50);\nctx.fill(path, \"nonzero\");\n\n// evenodd\nctx.translate(200, 0);\nctx.fillText(\"evenodd\", 120, 50);\nctx.fill(path, \"evenodd\")\n```\n\n两个三角形路径均是顺时针。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-11.webp\" width=\"100%\" style=\"max-width: 520px\" />\n\n## nonzero\nnonzero 非零环绕规则，是默认的填充规则。顺+1逆-1，非0填。\n\n**规则：**选取任一区域内一点，发射一条无限长的射线，起始值为0，射线会和路径相交，如果路径方向和射线方向形成的是**顺时针**方向则+1，如果是**逆时针**方向则-1，最后如果数值**为0**，则是路径的外部，不填充，如果**非0**，则是路径的内部，填充。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-12.webp\" width=\"100%\" style=\"max-width: 360px\" />\n\n## evenodd\nevenodd 奇偶环绕规则。奇填偶不填。\n\n**规则：**起始值为0，射线会和路径相交，每交叉一条路径，计数+1，最后看总计算数值，如果是**奇数**，则是路径内部，如果是**偶数**，则是是路径外部。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-13.webp\" width=\"100%\" style=\"max-width: 620px\" />\n\n# 控制像素\n`getImageData()` 获取画布上指定矩形的像素数据。\n`putImageData()` 将 ImageData 数据（图片像素数据）绘制到画布上。\n`createImageData()` 创建一个新的、空白的 ImageData 对象。\n\n## 获取像素数据\n`getImageData(x, y, width, height)` 获取画布上指定矩形的像素数据。\n\n返回 `ImageData` 对象，包含指定矩形的像素数据、宽度和高度。\n\n```js\nconst img = new Image();\nimg.src = \"1.png\";\nimg.onload = () => {\n  ctx.drawImage(img, 0, 0);\n  const imgData = ctx.getImageData(0, 0, img.width, img.height);\n  console.log(imgData);\n}\n```\n\n```js\nImageData {data: Uint8ClampedArray(913936), width: 478, height: 478, colorSpace: 'srgb'}\n  data: Uint8ClampedArray(913936) [12, 83, 161, 255, 12, 83, 161, …]\n  colorSpace: \"srgb\"\n  height: 478\n  width: 478\n```\n\ndata 是一个二维数组，每个元素的取值范围是 0 - 255 的整数，每**四个元素**表示一个像素的 **RGBA** 值。\n\n```js\ndata: [[r1, g1, b1, a1, r2, g2, b2, a2, ......],...]\n// 颜色通道：r 代表红色 g 代表绿色 b 代表蓝色 a 透明度\n```\n\n## 设置像素数据\n`putImageData()` 将 ImageData 数据（图片像素数据）绘制到画布上。\n\n```js\nvoid ctx.putImageData(imagedata, dx, dy);\nvoid ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n// 后面四个参数用于裁剪图形\n```\n\n修改图像透明度案例：\n\n```js\nconst img = new Image();\nimg.src = \"1.png\";\nimg.onload = () => {\n  ctx.drawImage(img, 0, 0);\n  const imgData = ctx.getImageData(0, 0, img.width, img.height);\n\n  // 修改图像透明度\n  changeAlpha(imgData, 0.5);\n\n  // 重新绘制图片\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.putImageData(imgData, 0, 0);\n}\n\nfunction changeAlpha(imgData, alpha) {\n  const data = imgData.data;\n  for (let i = 0; i < data.length; i += 4) {\n    data[i + 3] = data[i + 3] * alpha;\n  }\n}\n```\n\n知道像素信息，还可以做滤镜效果，这需要不同的算法，后续再说。\n\n# 动画\ncanvas 动画的本质是**擦掉重画**和**几何变换**。\n\n`requestAnimationFrame()` 是做动画的核心 API。当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行 60 次。\n\n下面的案例涵盖了 canvas 动画的基本概念，如速度、边界、重复绘制。\n\n## 自由落体小球\n**1、绘制小球：**\n首先我们需要一个小球，它具有 draw 方法，能把自己画出来。\n\n```js\nclass Ball {\n   constructor(ctx, x, y, radius, color) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n  }\n  draw() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n}\nconst ball = new Ball(ctx, 50, 50, 20, \"blue\");\nball.draw();\n```\n\n**2、速率：**\n传入两个方向的速度，并添加一个 move 方法，使小球动起来。\n\n```js\nclass Ball {\n  constructor(ctx, x, y, radius, color, vx, vy) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.vx = vx;\n    this.vy = vy;\n  }\n  draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n  move() {\n    // 按速度移动\n    this.x += this.vx;\n    this.y += this.vy;\n    this.draw();\n    window.requestAnimationFrame(() => this.move());\n  }\n}\nconst ball = new Ball(ctx, 50, 50, 20, \"blue\", 5, 5);\nball.draw();\nball.move();\n```\n\n**3、边界：**\n当小球触碰到边界时，需要反弹，即将某个方向的速度取反。\n\n```js\nclass Ball {\n  constructor(ctx, x, y, radius, color, vx, vy) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.vx = vx;\n    this.vy = vy;\n  }\n  draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n  move() {\n    // 按速率移动\n    this.x += this.vx;\n    this.y += this.vy;\n    // 添加边界反弹\n    if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {\n      this.vx = -this.vx;\n    }\n    if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {\n      this.vy = -this.vy;\n    }\n    this.draw();\n    window.requestAnimationFrame(() => this.move());\n  }\n}\nconst ball = new Ball(ctx, 50, 50, 20, \"blue\", 5, 5);\n// ball.draw();\nball.move();\n```\n\n**4、加速度：**\n为了让小球自由落体，还需要引入y轴加速度，每次移动时 vy 乘以 0.99，让速度小幅度减小，模拟了速度的损失，再加上 0.25，模拟重力，实现下落时，速度不断增大，而上升时不断减小。\n\n```js\nclass Ball {\n  constructor(ctx, x, y, radius, color, vx, vy) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.vx = vx;\n    this.vy = vy;\n  }\n  draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n  move() {\n    // 如果y轴速度小于0.1，且小球位于底部，则停止动画\n    if (Math.abs(ball.vy) < 0.1 && ball.y === canvas.height - ball.radius) {\n      return;\n    }\n    // 添加加速度\n    ball.vy *= 0.99;\n    ball.vy += 0.25;\n    // 按速率移动\n    this.x += this.vx;\n    this.y += this.vy;\n    // 添加边界反弹\n    if (this.x + this.radius > canvas.width) {\n      this.vx = -this.vx;\n      this.x = canvas.width - this.radius;\n    }\n    if (this.x - this.radius < 0) {\n      this.vx = -this.vx;\n      this.x = this.radius;\n    }\n    if (this.y + this.radius > canvas.height) {\n      this.vy = -this.vy;\n      this.y = canvas.height - this.radius;\n    }\n    if (this.y - this.radius < 0) {\n      this.vy = -this.vy;\n      this.y = this.radius;\n    }\n    this.draw();\n    window.requestAnimationFrame(() => this.move());\n  }\n}\nconst ball = new Ball(ctx, 50, 50, 20, \"blue\", 5, 5);\n// ball.draw();\nball.move();\n```\n\n**5、拖尾效果：**\n一个取巧的办法是不再清空画布，而是使用带透明度的矩形覆盖。\n\n```js\nclass Ball {\n  constructor(ctx, x, y, radius, color, vx, vy) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.vx = vx;\n    this.vy = vy;\n  }\n  draw() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n  }\n  move() {\n    // 如果y轴速度小于0.1，且小球位于底部，则停止动画\n    if (Math.abs(ball.vy) < 0.1 && ball.y === canvas.height - ball.radius) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      this.draw();\n      return;\n    }\n    // ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // 使用透明度矩形覆盖\n    ctx.fillStyle = \"rgba(255, 255, 255, 0.5)\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // 添加加速度\n    ball.vy *= 0.99;\n    ball.vy += 0.25;\n    // 按速率移动\n    this.x += this.vx;\n    this.y += this.vy;\n    // 添加边界反弹\n    if (this.x + this.radius > canvas.width) {\n      this.vx = -this.vx;\n      this.x = canvas.width - this.radius;\n    }\n    if (this.x - this.radius < 0) {\n      this.vx = -this.vx;\n      this.x = this.radius;\n    }\n    if (this.y + this.radius > canvas.height) {\n      this.vy = -this.vy;\n      this.y = canvas.height - this.radius;\n    }\n    if (this.y - this.radius < 0) {\n      this.vy = -this.vy;\n      this.y = this.radius;\n    }\n    this.draw();\n    window.requestAnimationFrame(() => this.move());\n  }\n}\nconst ball = new Ball(ctx, 50, 50, 20, \"blue\", 5, 5);\n// ball.draw();\nball.move();\n```\n\n# 优化问题\n这里记录一些 canvas 绘图时的优化问题。\n\n## 1px 问题\n就像之前做的那样，绘制 1-10px 的线条。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-14.webp\" width=\"100%\" style=\"max-width: 600px\" />\n\n可以发现 1px 和 2px 线条在宽度上没区别，但 1px 是灰色且模糊，还有奇数宽度的线条边缘也模糊。\n\n这是 canvas 的栅格和绘制策略导致的：\n栅格化的画布，**其整数坐标位于两个像素之间**，绘制时会**从坐标位置开始向两侧扩散像素**，当坐标位置和线条(局部图形)宽度不合理时(如整数坐标奇数宽度)，就会有一个将要绘制的像素被扩散到两个实际像素中，各绘制 0.5px，但**物理像素不可分割**，这时会做**抗锯齿**和**近似处理**，两个像素都显示，1px 变成了 2px、黑色变成了灰色且模糊。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-15.webp\" width=\"100%\" style=\"max-width: 600px\" />\n\n既然有 0.5px 的扩散，那解决方法也很简单，**在需要时**坐标位置**偏移 0.5px** 即可。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-16.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n不建议直接使用 translate 偏移整个画布，可能会导致一个图形正常了，而另一个图形反而不正常。如下图，1px 正常了，但 2px 边缘反而模糊了。\n\n```js\nctx.font = \"20px 黑体\";\nctx.fillText(\"未偏移\", 150, 30);\nctx.fillText(\"1px\", 70, 100);\nctx.strokeRect(50, 50, 100, 100);\nctx.lineWidth = 2;\nctx.fillText(\"2px\", 220, 100);\nctx.strokeRect(200, 50, 100, 100);\n\nctx.translate(0.5, 0.5);\nctx.fillText(\"偏移 0.5px\", 450, 30);\nctx.lineWidth = 1;\nctx.fillText(\"1px\", 370, 100);\nctx.strokeRect(350, 50, 100, 100);\nctx.lineWidth = 2;\nctx.fillText(\"2px\", 520, 100);\nctx.strokeRect(500, 50, 100, 100);\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-17.webp\" width=\"100%\" style=\"max-width: 650px\" />\n\n**最佳实践：**\n将画布大小设置为元素大小的整数倍，这样等于将图形缩小了整数倍，再使用 `scale` 扩大坐标系同样倍数让图形显示预期大小，这样就能正常画出任意宽度的线条。副作用较小，是比较好的做法。\n\n```js\nconst width = 800;\nconst height = 650;\ncanvas.style.width = `${width}px`;\ncanvas.style.height = `${height}px`;\ncanvas.width = 2 * width;\ncanvas.height = 2 * height;\nctx.scale(2, 2)\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/93-18.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n\n### 物理意义的 1px\n一个栅格对应一个逻辑像素，但在高清屏幕上，一个逻辑像素会对应多个物理像素，若需要画出真正的 1px，还需要根据设备**像素比**进行缩放。\n\n`window.devicePixelRatio` 返回当前显示设备的物理像素分辨率与 CSS 像素分辨率之比。\n\n```js\nconst width = 800;\nconst height = 650;\ncanvas.style.width = `${width}px`;\ncanvas.style.height = `${height}px`;\ncanvas.width = window.devicePixelRatio * width;\ncanvas.height = window.devicePixelRatio * height;\n```\n\n## 清晰与模糊问题\n除了 1px 问题会导致图像模糊，浏览器的放大倍率也会导致图像模糊。\n\n`window.devicePixelRatio` 返回当前显示设备的物理像素分辨率与 CSS 像素分辨率之比。[文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio)。\n\n```js\nfunction createDprInit() {\n  // 记录初始设定的画布宽高\n  const width = canvas.width;\n  const height = canvas.height;\n  return () => {\n    const dpr = window.devicePixelRatio || 1;\n    canvas.style.width = width + \"px\";\n    canvas.style.height = height + \"px\";\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    // 使画布内容也跟着缩放\n    ctx.scale(dpr, dpr);\n  };\n}\nconst dprInit = createDprInit();\ndprInit();\n\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.style.width, canvas.style.height);\n  ctx.fillStyle = \"red\";\n  ctx.fillRect(0, 0, 100, 100);\n  ctx.beginPath();\n  ctx.rect(150, 0, 100, 100);\n  ctx.stroke();\n}\ndraw();\n\nwindow.addEventListener(\"resize\", () => {\n  dprInit();\n  draw();\n});\n```\n\n由于现代设备的高清屏幕，默认 `devicePixelRatio` 通常大于 1，所以这么做还能顺带解决 1px 问题。\n\n**模糊的根本原因：**\ncanvas 本质是一张绘制好的图片，所以和图片的模糊是同一个问题。\n\n图片在拍摄完成后具有原始尺寸，对应于 canvas 就是画布尺寸，当图片被放入一个大于其原始尺寸的容器中时，图片会被放大，导致原始尺寸的一个像素实际被多个像素显示，这样就会导致图片模糊。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","canvas"],"categories":["学习笔记"]},{"title":"Canvas 2D 基础","url":"/article/8c1c45d8.html","content":"\n# 前言\n平时看到的网页本质上是图片，HTML 和 CSS 经过[浏览器渲染流程](/article/4aea0348.html)，最终光栅化为位图。W3C 也陆续提供了更多的标签和 CSS3 属性，以完成更多的设计需求。\n\n但越来越复杂的页面效果在 DOM 结构下很难实现，大量、复杂的 DOM 渲染处理性能堪忧，推出更多的 CSS 属性也难以覆盖需求。\n\n于是 Canvas 诞生了，通过 JS 在 `<canvas>` 标签形成的画布区域内绘制图形，跳过了 HTML 和 CSS 的渲染，就像直接编写**绘制指令**一样，性能也更好。\n\n**兼容性：**IE9+，移动端支持良好，[Can I use Canvas?](https://caniuse.com/?search=canvas)\n\n> 学习 canvas 离不开线性代数、三角函数的知识，为了实现更多的效果，会需要更多的数学公式，当然，这些公式基本理解、会用就行。\n\n**参考：**\n[Canvas-MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)\n[Canvas 从入门到劝朋友放弃（图解版）](https://juejin.cn/post/7116784455561248775)\n[案例+图解带你一文读懂Canvas🔥🔥（2W+字）](https://juejin.cn/post/7119495608938790942)\n[Canvas 保姆级教程（上）：绘制篇](https://juejin.cn/post/7008064185972031524)\n[CanvasStudy](https://827652549.github.io/CanvasStudy/)\n[Canvas系列教程(从入门到精通)【详细解读】](https://blog.csdn.net/huoyihengyuan/category_9294371.html)\n\n# canvas 标签\n`<canvas>` 是 HTML5 新增的标签，形成一个画布区域，允许使用 JS 在画布上绘制图形。\n\n**与 SVG 对比:**\n1. SVG：基于 XML，矢量图，使用 DOM 操作，适合图形变化较少的场景。\n2. Canvas：基于 JS，位图，适合图形变化较多的场景。\n\n**两种常用 JS API：**\n1. **Canvas API：**`getContext('2d')`，用于 2D 绘图。\n2. **WebGL API：**`getContext('webgl')`，用于 3D 绘图，也能实现 2D 绘图。\n\n我们常说的 Canvas，以及本文所述的，是指使用 Canvas API 在 `<canvas>` 上绘制 2D 图形。\n\n## 大小(宽高)\n`<canvas>` 具有两个大小。一是作为 HTML 标签元素的大小，二是作为画布的大小(绘图表面大小)。\n\n**默认**的**画布大小**为 300px × 150px，**元素大小**为其内容大小，所以也是 300px × 150px。\n\n标签的 width 和 height 属性设置的是**画布大小**，而 CSS 设置的是**元素大小**。\n\n```html\n<style>\n  canvas {\n    width: 400px;\n    height: 400px;\n  }\n</style>\n<canvas width=\"200\" height=\"200\"></canvas>\n```\n\n通过 JS 获取和控制大小：\n\n**注意：**当改变画布大小时，画布会被**清空**，且上下文对象的属性值会被**重置**。\n\n```js\nconst canvas = document.querySelector('canvas');\n// 获取画布大小\nconsole.log(\"画布大小\", canvas.width, canvas.height); // 画布大小 200 200\n\n// 获取元素大小\nlet box = canvas.getBoundingClientRect();\nconsole.log(\"元素大小\", box.width, box.height); // 元素大小 400 400\n\n// 修改元素大小\ncanvas.style.width = \"600px\";\ncanvas.style.height = \"600px\";\nbox = canvas.getBoundingClientRect();\nconsole.log(\"修改元素大小\", box.width, box.height); // 修改元素大小 600 600\n```\n\n现在绘制个图形，一个位置在 (10, 10) 的 50px × 50px 蓝色正方形。\n\n```js\n// 获取画布上下文\nconst ctx = canvas.getContext('2d');\nctx.fillStyle = 'blue';\nctx.fillRect(10, 10, 50, 50);\n```\n\n但实际测量会发现，图形的位置和大小均扩大了一倍，这是因为元素大小是画布大小的两倍，导致画布内容被浏览器自动拉伸了两倍，以填充元素大小。\n\n## 缩放\n当画布大小和元素大小不一致时，**画布内容**会被缩放以**适应元素大小**，这会导致图形变形、坐标偏移。\n\n**缩放规则：**坐标也遵循这一规则。\n图形实际大小 = 内容大小 × (元素大小 / 画布大小)\n\n**案例：**\n元素宽度是画布宽度的两倍，而元素高度是画布高度的一半，还是绘制一个 50px × 50px 的正方形。\n  \n```html\n<style>\n  canvas {\n    width: 400px;\n    height: 100px;\n  }\n</style>\n<canvas width=\"200\" height=\"200\"></canvas>\n```\n\n实际测量，正方形的大小为 100px × 25px。\n\n所以，**为了避免缩放问题，通常不设置元素大小**。\n\n## 渲染上下文\n`<canvas>` 只提供了一个绘图表面，JS 通过**渲染上下文**上的方法来操作画布。\n\n使用 `getContext(ctxType)` 获取渲染上下文：\n1. **2d：**获取二维渲染上下文(CanvasRenderingContext2D)。\n2. **webgl、experimental-webgl：**获取 WebGL1(OpenGL ES 2.0) 的三维渲染上下文(WebGLRenderingContext)。\n3. **webgl2、experimental-webgl2：**获取 WebGL2(OpenGL ES 3.0) 的三维渲染上下文(WebGL2RenderingContext)。\n4. **bitmaprenderer：**创建一个只提供将 canvas 内容替换为指定 ImageBitmap 功能的 ImageBitmapRenderingContext。\n\n# 画布栅格\nCanvas 沿用了计算机图形学的坐标系，原点在左上角，x 轴向右，y 轴向下。\n\n画布被看不见的网格所覆盖，每个网格即是一个逻辑像素。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-1.webp\" width=\"80%\" style=\"max-width: fit-content\" />\n\n# 绘制形状\nCanvas 只支持两种形式的图形绘制：**矩形**和**路径**（由一系列点连成的线段）。\n\n其他类型的图形都是通过若干条路径组合而成的。\nCanvas 提供了许多生成不同路径的方法，如直线、弧、贝塞尔曲线等，这使得绘制复杂图形变得容易。\n\n## 矩形\n仅有三种方法绘制矩形：\n`fillRect(x, y, width, height)` 绘制**填充**矩形。填充色为当前的 fillStyle\n`strokeRect(x, y, width, height)` 绘制矩形**边框**。边框色为当前的 strokeStyle。\n`clearRect(x, y, width, height)` **清除**指定矩形区域，让清除部分完全透明。\n\nx 与 y 为矩形的左上角坐标。\n\n```js\nctx.fillRect(50, 50, 100, 100);\nctx.clearRect(70, 70, 60, 60);\nctx.strokeRect(80, 80, 40, 40);\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-2.webp\" width=\"80%\" style=\"max-width: fit-content\" />\n\nclearRect 清除整个画布：\n\n```js\nctx.clearRect(0, 0, canvas.width, canvas.height);\n```\n\n## 路径\n图形的**基本元素**是路径。路径是通过各种样式的**线段或曲线**相连形成的不同形状的**点的集合**。\n\n使用路径绘制图形的步骤：\n1. `beginPath()` **清空路径列表**，即开始绘制新路径。\n2. `moveTo(x, y)` **移动笔触**到指定的坐标点，作为子路径的起点。\n3. 使用各种[路径绘制命令](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D#%E8%B7%AF%E5%BE%84)，**在路径列表中积累子路径**。\n4. (可选) `closePath()` 封闭**连续**子路径，即使用直线连接起点和终点。多次使用 moveTo 可能会导致子路径不连续，无法闭合。\n5. 描边 `stroke()` 或填充 `fill()` 路径区域，绘制积累的子路径。fill 会自动闭合路径。\n\n```js\nctx.beginPath(); // 开始新路径\nctx.moveTo(50, 50); // 移动笔触\nctx.***(); // 调用若干路径绘制命令、设置样式\nctx.closePath(); // 封闭路径\nctx.stroke(); // 描边路径\n```\n\n### 移动笔触 moveTo\n`moveTo(x, y)` 移动笔触到指定的坐标点，不绘制任何内容。\n1. 设置子路径起点。\n2. 绘制一些不连续的路径。\n\n就像写字时，先把笔移动到纸上的某个位置，然后开始书写。\n\n### 直线 lineTo\n`lineTo(x, y)` 从当前笔触位置绘制一条直线到指定的坐标点。\n\n```js\n// 一个等腰三角形\nctx.beginPath();\nctx.moveTo(50, 50);\nctx.lineTo(150, 50);\nctx.lineTo(100, 150);\nctx.closePath();\nctx.stroke();\n```\n\n### 圆弧 arc \n`arc(x, y, radius, startAngle, endAngle, anticlockwise?)` 绘制圆弧路径。\n1. `(x, y)` 圆心坐标。\n2. `radius` 半径。\n3. 路径从**起始弧度** `startAngle` 到**结束弧度** `endAngle`。\n4. `anticlockwise` 可选，是否逆时针绘制，默认为 false。\n\n**弧度 = ( Math.PI / 180 ) × 角度**\n\n```js\n// 从半圆到全圆\nfor (i = 0; i < 12; i++) {\n  ctx.beginPath();\n  let radius = 20;\n  let x = radius + i * (radius * 2.5);\n  let y = radius;\n  let startAngle = 0;\n  let endAngle = Math.PI + (Math.PI * i) / 12;\n  ctx.arc(x, y, radius, startAngle, endAngle);\n  ctx.fill();\n}\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-3.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n### 矩形 rect\n`rect(x, y, width, height)` 绘制矩形路径。\n绘制一个左上角坐标为 (x,y)，宽高为 width 以及 height 的矩形。笔触会移动到 (x,y)。\n\n不同于直接绘制矩形的三个方法，rect 只是定义了一个矩形的路径。\n\n```js\nctx.beginPath();\nctx.rect(50, 50, 100, 100);\n// 从(50, 50)到(150, 150)\nctx.lineTo(150, 150);\nctx.stroke();\n```\n\n### 贝塞尔曲线\n贝塞尔曲线通过外部控制点绘制复杂的曲线。\n\n`quadraticCurveTo(cp1x, cp1y, x, y)` 绘制二次贝塞尔曲线。\n`bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)` 绘制三次贝塞尔曲线。\n\n当前坐标为起始点，cp* 为外部控制点，(x, y) 为结束点。\n\n一些可视化工具：\n[Canvas贝塞尔曲线绘制工具](http://wx.karlew.com/canvas/bezier/)\n[二次贝塞尔曲线调试器](http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html)\n[三次贝塞尔曲线调试器](http://blogs.sitepointstatic.com/examples/tech/canvas-curves/bezier-curve.html)\n\n```js\n// 二次贝塞尔曲线，聊天气泡\nctx.beginPath();\nctx.moveTo(75, 25);\nctx.quadraticCurveTo(25, 25, 25, 62.5);\nctx.quadraticCurveTo(25, 100, 50, 100);\nctx.quadraticCurveTo(50, 120, 30, 125);\nctx.quadraticCurveTo(60, 120, 65, 100);\nctx.quadraticCurveTo(125, 100, 125, 62.5);\nctx.quadraticCurveTo(125, 25, 75, 25);\nctx.stroke();\n\n// 三次贝塞尔曲线，心形\nctx.beginPath();\nctx.moveTo(275, 40);\nctx.bezierCurveTo(275, 37, 270, 25, 250, 25);\nctx.bezierCurveTo(220, 25, 220, 62.5, 220, 62.5);\nctx.bezierCurveTo(220, 80, 240, 102, 275, 120);\nctx.bezierCurveTo(310, 102, 330, 80, 330, 62.5);\nctx.bezierCurveTo(330, 62.5, 330, 25, 300, 25);\nctx.bezierCurveTo(285, 25, 275, 37, 275, 40);\nctx.stroke();\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-4.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n参考：\n[用canvas绘制一个曲线动画——深入理解贝塞尔曲线](https://segmentfault.com/a/1190000012670045)\n\n### Path2D\n`Path2D` 用于声明一个路径，即创建可以保留并重用的路径。\n\n`Path2D()` 创建一个新的 Path2D 实例对象，拥有所有路径绘制方法。\n\n```js\nnew Path2D();\nnew Path2D(path); // 克隆Path对象\nnew Path2D(d); // 从SVG建立Path对象\n```\n\n```js\nconst p1 = new Path2D();\np1.moveTo(50, 50);\np1.lineTo(150, 50);\np1.lineTo(100, 150);\np1.closePath();\nctx.stroke(p1); // 使用路径\n```\n\n`path.addPath(path[, transform])` 将 path 添加到当前路径。\n\ntransform 是一个 [DOMMatrix](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMMatrix) 对象，用于转换 path 的坐标。\n\n```js\nconst p1 = new Path2D(\"M10 10 h 80 v 80 h -80 Z\"); // 可以使用 SVG path 初始化路径\nconst p2 = new Path2D();\np2.rect(50, 50, 100, 100);\np2.addPath(p1);\nctx.stroke(p2); // 在绘制p2时，也会绘制p1\n```\n\n# 样式\n\n## 图形样式\n`fillStyle` 设置图形的填充样式，对应 `fill()` 方法。\n`strokeStyle` 设置图形的描边样式，对应 `stroke()` 方法。\n\n默认值都为 **#000**，可以接受色值、渐变对象和图案对象。\n\n`globalAlpha` 设置绘制透明度。\n\n### 色值\n接受的色值格式和 CSS 差不多，但不能用 linear-gradient 等函数。\n\n```js\nctx.strokeStyle = \"blue\";\nctx.fillStyle = \"rgba(255, 0, 0, 0.5)\";\nctx.fillStyle = \"#FFA500\";\n```\n\n### 渐变对象\n渐变分为两种：\n1. **线性渐变：**`createLinearGradient(x0, y0, x1, y1)` 创建一个线性渐变对象。渐变的起点 (x0,y0)，终点 (x1,y1)。\n2. **径向渐变：**`createRadialGradient(x0, y0, r0, x1, y1, r1)` 创建一个径向渐变对象。定义了两个圆，一个以 (x0,y0) 为原点，半径为 r0 的圆，一个以 (x1,y1) 为原点，半径为 r1 的圆\n\n都返回 [CanvasGradient](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient) 对象，使用 `addColorStop(offset, color)` 添加颜色。offset 偏移量为 0~1 的值，表示颜色的位置。\n\n```js\nctx.beginPath();\nctx.moveTo(50, 50);\nctx.lineTo(150, 50);\nctx.lineTo(100, 150);\n// 创建线性渐变\nconst lg = ctx.createLinearGradient(50, 50, 150, 150);\n// 添加颜色\nlg.addColorStop(0, \"#000\");\nlg.addColorStop(0.5, \"blue\");\nlg.addColorStop(1, \"#fff\");\nctx.fillStyle = lg;\nctx.fill();\n```\n\n### 图案对象\n`createPattern(image, repetition)` 创建一个图案对象，用于填充图形。[文档](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern)\n1. **image** 图像对象，可以是 `<img>`、`<video>`、`<canvas>`、ImageBitmap、ImageData、Blob、CanvasRenderingContext2D\n2. **repetition** 重复方式，可选值：repeat、repeat-x、repeat-y、no-repeat，默认为 repeat\n\n```js\nconst img = new Image();\nimg.src = \"1.png\";\n// 等待图片加载完成\nimg.onload = () => {\n  // 创建图案\n  const ptrn = ctx.createPattern(img, \"no-repeat\");\n  ctx.fillStyle = ptrn;\n  ctx.fillRect(50, 50, 100, 100);\n};\n```\n\ncreatePattern 不仅可以用于创建图案，还能将图案用作填充或描边，而 drawImage 只能用于将图像绘制到画布上。\n\n### 阴影 shadow\n1. `shadowColor` 阴影颜色。\n2. `shadowBlur` 阴影模糊程度，默认为 0 为无模糊。\n3. `shadowOffsetX` 阴影水平偏移量。正值向右。\n4. `shadowOffsetY` 阴影垂直偏移量。正值向下。\n\n```js\nctx.shadowOffsetX = 10;\nctx.shadowOffsetY = 10;\nctx.shadowBlur = 10;\nctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\nctx.fillRect(20, 20, 100, 100);\n```\n\n\n\n\n\n## 线条样式\n\n\n### 宽度 lineWidth\n`lineWidth` 设置线条的宽度，单位 px，默认为 1。\n\n```js 绘制 0-10 的线条\nfor (let i = 0; i < 10; i++) {\n  ctx.beginPath();\n  ctx.lineWidth = i + 1;\n  ctx.moveTo(50 + i * 20, 10);\n  ctx.lineTo(50 + i * 20, 100);\n  ctx.stroke();\n}\n```\n\n1px 的线条宽度上和 2px 差不多，但却模糊，这个问题在后面有详解\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-5.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n### 端点 lineCap\n`lineCap` 设置线条的端点样式，可选值：butt（默认）、round、square。\n\n```js 从左到右分别是 butt、round、square\nconst lineCaps = [\"butt\", \"round\", \"square\"];\nlineCaps.forEach((lineCap, i) => {\n  ctx.lineWidth = 15;\n  ctx.lineCap = lineCap;\n  ctx.beginPath();\n  ctx.moveTo(50 + i * 50, 10);\n  ctx.lineTo(50 + i * 50, 100);\n  ctx.stroke();\n});\nctx.beginPath();\nctx.lineWidth = 1;\nctx.strokeStyle = \"blue\";\nctx.moveTo(10, 10);\nctx.lineTo(200, 10);\nctx.moveTo(10, 100);\nctx.lineTo(200, 100);\nctx.stroke();\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-6.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n### 连接点 lineJoin\n`lineJoin` 设置线条的连接样式，可选值：miter（默认）、bevel、round。\n1. **miter：**斜接，尖角。\n2. **bevel：**平角。\n3. **round：**圆角。\n\n```js 从上到下分别是 miter、bevel、round\nconst lineJoins = [\"miter\", \"bevel\", \"round\"];\nctx.lineWidth = 12;\nlineJoins.forEach((lineJoin, i) => {\n  ctx.lineJoin = lineJoin;\n  ctx.beginPath();\n  ctx.moveTo(50, 20 + i * 40);\n  ctx.lineTo(100, 50 + i * 40);\n  ctx.lineTo(150, 20 + i * 40);\n  ctx.lineTo(200, 50 + i * 40);\n  ctx.stroke();\n});\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-7.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n### 斜接限制 miterLimit\n`miterLimit` 设置斜接的限制比例，为 lineWidth 的**倍数**。\n用于限制 lineJoin 值为 miter 时，两条线的斜接长度。斜接长度是指线条交接处内角顶点到外角顶点的长度。\n\n默认为 10，表示最大斜接长度为线条宽度的 10 倍，0、负数、Infinity 和 NaN 都会被忽略。\n\n角度越小，斜接长度越长，超过限制时 lineJoin 会变成 bevel。\n\n```js\nctx.lineWidth = 10;\nctx.lineJoin = \"miter\";\nctx.miterLimit = 8;\nfor (let i = 0; i < 4; i++) {\n  ctx.beginPath();\n  ctx.moveTo(50 + i * 80, 10);\n  ctx.lineTo(60 + i * 5 + i * 80, 100);\n  ctx.lineTo(70 + i * 10 + i * 80, 10);\n  ctx.stroke();\n}\n```\n\n第一个角的斜接长度超过限制，变成了 bevel，后面的都是 miter，但角度越大，斜接长度越小。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-8.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n### 虚线 lineDash\n1. `setLineDash(segments)` 设置虚线样式。segments 是一个数组，表示虚线的线段和间隙的长度。空数组切换回至实线模式。\n2. `lineDashOffset` 设置虚线的起始偏移量。正数向左偏移，负数向右偏移。\n3. `getLineDash()` 获取当前虚线样式。返回 segments 数组。\n\nsegments 中，元素的索引 index 为奇数表示线段长度，偶数 index 表示间隙长度。如 [5, 15] 表示 5px 线段，15px 间隙。若 segments 的**长度**为奇数，则会重复数组元素，如 [5] 表示 [5, 5]，即 5px 线段，5px 间隙。\n\n```js\nlet y = 15;\nfunction drawLineDash(segments) {\n  ctx.beginPath();\n  ctx.setLineDash(segments);\n  ctx.moveTo(50, y);\n  ctx.lineTo(500, y);\n  ctx.stroke();\n  y += 20;\n}\ndrawLineDash([]); // 实线\ndrawLineDash([1, 1]);\ndrawLineDash([10, 10]);\ndrawLineDash([20, 5]);\ndrawLineDash([15, 3, 3, 3]);\ndrawLineDash([20, 3, 3, 3, 3, 3, 3, 3]);\ndrawLineDash([12, 3, 3]); // 重复 [12, 3, 3, 12, 3, 3]\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-9.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n利用 lineDashOffset 可以让虚线动起来，即蚂蚁线效果。\n\n```js\n// 蚂蚁线\nlet offset = 0;\nfunction drawAntLine() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.setLineDash([12, 5, 3, 5]);\n  ctx.lineDashOffset = -offset; // 向右偏移，正转\n  ctx.strokeRect(10, 10, 100, 100);\n}\nfunction march() {\n  offset++;\n  if (offset > 25) {\n    offset = 0;\n  }\n  drawAntLine();\n  setTimeout(march, 20);\n}\nmarch();\n```\n\n# 绘制文本\n`fillText(text, x, y [, maxWidth])` 在 (x,y) **填充**指定的文本，可选最大宽度。\n`strokeText(text, x, y [, maxWidth])` 在 (x,y) 绘制文本**边框**，可选最大宽度。\n\n## 样式\n\n**1、font** 字体样式，和 CSS 一样，默认字体是 10px sans-serif。\n\n**2、textAlign** 文本对齐方式，默认为 start。\n\n```js\nctx.textAlign = \"left\" || \"right\" || \"center\" || \"start\" || \"end\";\n```\n\n**3、textBaseline** 文本基线位置，即文本的垂直对齐方式，默认为 alphabetic。\n1. top，文本基线在文本块的顶部。\n2. hanging，文本基线是悬挂基线。\n3. middle，文本基线在文本块的中间。\n4. alphabetic，文本基线是标准的字母基线。\n5. ideographic，文字基线是表意字基线；如果字符本身超出了 alphabetic 基线，那么 ideographic 基线位置在字符本身的底部。\n6. bottom，文本基线在文本块的底部。\n\n```js\nconst textBaselines = ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'];\nctx.font = '20px Arial';\ntextBaselines.forEach((baseline, i) => {\n  const x = 50;\n  const y = i * 40 + 50;\n  ctx.beginPath();\n  ctx.strokeStyle = 'blue';\n  ctx.moveTo(0, y);\n  ctx.lineTo(500, y);\n  ctx.stroke();\n  ctx.textBaseline = baseline;\n  ctx.fillText(`abcdefghijklmnopqrstuvwxyz(${baseline})`, x, y);\n});\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-10.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n**4、direction** 文本方向，默认为 inherit。会影响 textAlign 的表现。\n\n```js\nctx.direction = \"ltr\" || \"rtl\" || \"inherit\";\n// ltr，文本方向从左向右\n// rtl，文本方向从右向左\n// inherit，继承父元素的方向\n```\n\n## 预测量文本宽度\n`measureText(text)` 返回 [TextMetrics](https://developer.mozilla.org/zh-CN/docs/Web/API/TextMetrics) 对象，包含文本的宽度、像素等信息。不受最大宽度等外部因素影响。\n\n```text TextMetrics 属性\nwidth：基于当前上下文字体，计算内联字符串的宽度。\nactualBoundingBoxLeft：从 textAlign 属性确定的对齐点到文本矩形边界左侧的距离，使用 CSS 像素计算；正值表示文本矩形边界左侧在该对齐点的左侧。\nactualBoundingBoxRight：从 textAlign 属性确定的对齐点到文本矩形边界右侧的距离。\nfontBoundingBoxAscent：从 textBaseline 属性标明的水平线到渲染文本的所有字体的矩形最高边界顶部的距离。\nfontBoundingBoxDescent：从 textBaseline 属性标明的水平线到渲染文本的所有字体的矩形边界最底部的距离。\nactualBoundingBoxAscent：从 textBaseline 属性标明的水平线到渲染文本的矩形边界顶部的距离。\nactualBoundingBoxDescent：从 textBaseline 属性标明的水平线到渲染文本的矩形边界底部的距离。\nemHeightAscent：从 textBaseline 属性标明的水平线到线框中 em 方块顶部的距离。\nemHeightDescent：从 textBaseline 属性标明的水平线到线框中 em 方块底部的距离。\nhangingBaseline：从 textBaseline 属性标明的水平线到线框的 hanging 基线的距离。\nalphabeticBaseline：从 textBaseline 属性标明的水平线到线框的 alphabetic 基线的距离。\nideographicBaseline：从 textBaseline 属性标明的水平线到线框的 ideographic 基线的距离。\n```\n\n```js\nconst text = \"Abcdefghijklmnop\";\nctx.font = \"italic 50px serif\"; // italic 斜体\nconst textMetrics = ctx.measureText(text);\nctx.fillText(text, 50, 50);\n// 两种计算文本宽度的方法\nconsole.log(textMetrics.width); // 400\nconsole.log(\n  textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n); // 404\n```\n\n由于字母倾斜/斜体导致字符的宽度可能超出其预定的宽度，因此 actualBoundingBoxLeft 和 actualBoundingBoxRight 的总和可能会比内联盒子的宽度（width）更大。\n\n# 绘制图像\n步骤：\n1. 获取图片资源\n2. 使用 `drawImage()` 绘制图像。\n\n## drawImage\n**1、基础用法（三个参数）**\n\n```js\ndrawImage(image, x, y);\n```\n\n**2、指定宽高缩放（五个参数）**\n\n```js\ndrawImage(image, x, y, width, height);\n```\n\n**3、裁剪图像（九个参数）**\n\n```js\ndrawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/89-11.webp\" width=\"100%\" style=\"max-width: fit-content\" />\n\n\n## 获取图像资源\n`drawImage()` 允许任何的画布图像源，如 HTMLImageElement、SVGImageElement、HTMLVideoElement、HTMLCanvasElement、ImageBitmap、OffscreenCanvas 或 VideoFrame。\n\n利用 canvas 绘制视频。\n\n```js\nconst video = document.querySelector(\"video\");\nfunction render() {\n  window.requestAnimationFrame(render);\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  const proportion = video.videoWidth / video.videoHeight;\n  ctx.drawImage(video, 0, 0, canvas.width, canvas.width / proportion);\n}\nvideo.onloadeddata = function (e) {\n  render();\n};\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","canvas"],"categories":["学习笔记"]},{"title":"Git 规范与实践","url":"/article/7f942cef.html","content":"\n# commit message 规范\n格式统一、清晰的 commit message 有助于更好的管理提交历史，方便查找、回滚。\nAngular 的规范最为常用：[Angular Team Commit Specification](https://github.com/angular/angular/blob/main/CONTRIBUTING.md)、[Conventional Commits](https://www.conventionalcommits.org/zh-hans/v1.0.0/)\n\n```text 格式\n<type>[scope]: <subject>\n\n[body]\n\n[footer(s)]\n```\n\n在 VSCode 中，使用 [git-commit-plugin](https://marketplace.visualstudio.com/items?itemName=redjue.git-commit-plugin) 插件以快速生成 Angular 规范的 commit message。\n\n参考：\n[Commit message 和 Change log 编写指南-阮一峰](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\n## type\ntype 用于说明 commit 的类别：\n1. **init** 初始化\n2. **feat** 新功能（feature）\n3. **fix** 修补 bug\n4. **docs** 仅修改了文档（documentation）\n5. **style** 修改格式\n6. **refactor** 重构，没有加新功能或修复 bug\n7. **perf** 性能优化\n8. **test** 修改测试相关代码\n9. **build** 修改项目构建系统，如修改依赖库、外部接口或者升级 Node 版本等\n10. **ci** 修改项目持续集成流程，如修改 Travis 配置文件等\n11. **chore** 对非业务性代码进行修改，如修改构建流程或者工具配置等\n12. **revert** 回滚版本\n\n除了上述常见的 type，还可以根据项目的实际情况自定义 type，与其它开发者约定好即可。\n\n## scope\nscope 用于说明 commit 影响的范围，提供上下文信息，是一个名词，可选提供。\n\n应该根据具体项目而定，可以是某个模块、功能或其他任何限定的范围。\n\n## subject\nsubject 是 commit 目的的简短描述，不超过 50 个字符。\n\n1. 以动词开头，使用第一人称描述。\n2. 第一个字母小写。\n3. 结尾不加句号。\n\n## body 和 footer\nBody 是对本次 commit 的详细描述，包括具体的变化、原因等。\n\nFooter 是补充信息：\n1. 关联 issue，如 **Closes #123**，表示本次 commit 针对该 issue。\n2. 不兼容变动，以 **BREAKING CHANGE:** 开头，接着是对变动的描述、理由和迁移方法。\n\n# 工作流程\n工作流 workflow，是指团队成员如何协作完成项目的一系列规范和流程。\n在 Git 上即是如何设计分支、提交代码、避免冲突等，使项目像水流一样顺畅、有序地进行开发和维护。\n\n**常见工作流：**\n1. **GitFlow** - [Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/) 提出的一种工作流程，主要分为 feature、develop、release、hotfix、master 五种分支。其中 master 分支用于发布，develop 分支为主开发分支。\n2. **GitHubFlow** - Github 官方推荐的工作流程，主要分支只有 master，开发在新建分支上进行，开发完成后提交 PR 到 master 分支。当然也可以多增加一个 dev 作为主开发分支。\n3. **GitLabFlow** - GitLab 官方推荐的工作流程。上游优先，形成类似树形的结构，向上：从下游逐层合并到上游直到主分支，向下：只有上游分支采纳的代码变化，才能应用到其他下游分支。\n\n三者均为**功能驱动式开发(FDD)**：\n先有需求再有功能分支或者补丁分支等，完成开发后，该分支就合并到主分支，然后被删除。\n\n**对比：**\n1. GitFlow 过于复杂，分支多，适合**版本发布**项目，实际开发较难遵守。\n2. GitHubFlow 是 GitFlow 的简化版，简单易懂，适合**持续发布**项目，目前最为常用，适合中小项目。\n3. GitLabFlow 吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利，适用于每次合并功能分支后不需马上部署至生产环境的大型项目。\n\n一个 git 学习网站：[learnGitBranching](https://learngitbranching.js.org/?NODEMO=&locale=zh_CN)\n\n参考：\n[四种常见的Git工作流](https://zhuanlan.zhihu.com/p/434078984)\n[Git 工作流程-阮一峰](https://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\n[Git工作流面面观——Gitflow工作流](https://morningspace.github.io/tech/git-workflow-4/)\n[DevOps Guidebook-工作流](https://tsejx.github.io/devops-guidebook/code/git/git-flow/)\n[Git之GitFlow工作流 | Gitflow Workflow（万字整理，已是最详）](https://blog.csdn.net/sunyctf/article/details/130587970)\n\n## GitHubFlow\n**1、fork 项目仓库：**\n在 github 上 fork 项目仓库到自己的仓库。\n\n**2、clone 项目到本地：**\nclone 自己的仓库到本地。\n\n```bash\ngit clone git@github.com:qcqx/git-test.git\n```\n\n**3、添加上游远端仓库：**\n在 github 上可以看见本仓库是 fork 来的，但本地 git 并不知道，需要手动添加上游仓库，通常命名为 `upstream`。\n\n```bash\ngit remote add upstream git@github.com:qxchuckle/git-test.git\n```\n\n**4、同步上游主开发分支：**\n开发过程中，上游仓库可能有新的提交，需要同步到本地。\n\n通常 dev 分支为主开发分支，当然也有直接拿 main 分支开发的，看具体项目而定。\n\n```bash\ngit pull upstream dev:dev\n```\n\n**5、从主开发分支新建分支，用于开发新功能：**\n功能开发分支的命名：\n1. `feat/` 或 `feat-` 开头，/ 开头是为了在使用某些 git 工具时，能显示出树形目录结构，方便查看。\n2. 后面跟上功能名，多个单词用 `-` 连接，如 `feat/login`。\n3. 如果是为了解决某个 issue，可以在后面加上 issue 号，如 `feat/iss-123`。\n\n```bash\ngit switch dev\ngit checkout -b feat/new1\n```\n\n**6、在新分支上开发：**\n写代码，提交 commit。\n\n开发过程中可以定期同步下 dev 分支，以免最后合并时冲突太多。\n\n```bash 定期同步 dev 分支\ngit fetch upstream dev\n# 若 fetch 后有新提交，继续同步\n# 使用 merge，同步上游 dev 分支\ngit switch dev\ngit merge upstream/dev\n# 使用 rebase 同步功能开发分支和dev，有冲突则解决。\ngit switch feat/new1\ngit rebase upstream/dev # 通常会触发 Fast-forwarded\n```\n\n当然上面的操作可以简化，本地可以不存在一个 dev 分支，直接 rebase 到 upstream/dev。\n\n**7、开发完成，合并代码到主开发分支：**\n使用 merge 还是 rebase 合并，看具体项目规定了。\n\n```bash\ngit switch dev\ngit merge feat/new1\n# 或\ngit switch feat/new1\ngit rebase dev\ngit switch dev\ngit merge feat/new1 # 这是为了触发 Fast-forwarded，移动 dev 分支的 HEAD 到当前提交\n```\n\n**8、同步最新上游 dev 分支：**\n在提交 PR 之前，再次同步上游 dev 分支，以免提交 PR 时有冲突。\n\n```bash\ngit fetch upstream dev\n# 若 fetch 后有新提交，继续同步\ngit switch dev\ngit merge upstream/dev # 有冲突则解决\n```\n\n**9、推送代码到自己的仓库：**\n\n```bash\ngit push origin dev\n```\n\n**10、提交 PR（Pull Request）：**\n在 github 上提交 PR，通知上游仓库合并代码。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/91-1.webp\" width=\"100%\" />\n\n若需要压缩合并 commit，可以使用 rebase -i 合并 commit，或管理者用 squash merge 合并。\n\n> 到这里功能开发就完成了，后面是项目管理者的工作了。若 PR 被打回，则修改后重新提交 PR。\n\n**11、管理者 code review：**\n管理者在项目仓库中进行 code review。\n\n```bash\n# 从 dev 分支上新建一个分支用于 code review\ngit checkout -b qcqx-dev dev\n# 拉取 PR 分支到当前 qcqx-feature 分支\ngit pull https://github.com/qcqx/git-test.git dev\n```\n\n**12、合并 PR：**\n在测试没问题、解决冲突后，管理者将 PR 合并到主开发分支并推送。\n\n```bash\ngit switch dev\ngit merge --no-ff qcqx-dev\ngit push\n```\n\n现在 GitHubFlow 流程就结束了。可以选择删除 feat/new1 开发分支。\n\n上面的步骤中，可以发现下游的 dev 分支不是必要的，只是起到一个中转作用，开发者可以直接将 feat 分支和 upstream/dev 进行同步。提 PR 时将 feat 分支合并到上游 dev 分支。这就看具体项目的规定了。\n\n> 当然实际开发流程可能会有所不同，这里只是一个基本流程。\n\n# 常见场景\n记录一些常见场景下的 git 实践。\n\n## 提交一个空文件夹\n在文件夹中添加一个 `.gitkeep` 文件，然后提交。\n\n## 查看某个文件历史\n\n```bash\n# 列出文件的所有提交记录\n> git log --oneline <file>\n# 查看文件的详细提交记录，包括 diff  \n> git log -p <file>\n# 查看某个 commit 的详细信息，包括 diff\n> git show c178bf49\n# 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交信息，没有 diff\n> git whatchanged <file>\n# 显示文件的每一行最后修改的 commit 信息\n> git blame <file>\n13d78acb (qxchuckle 2024-05-12 16:46:29 +0800 1) console.log(\"1\")\n8fa8fd54 (qxchuckle 2024-05-12 16:47:41 +0800 2) console.log(\"2\")\n3ce8e33e (qxchuckle 2024-05-12 16:48:47 +0800 3) console.log(\"3\")\n5aa6a818 (qxchuckle 2024-05-12 16:31:50 +0800 4) console.log(\"4\")\n```\n\n## 自定义 git 命令\n`git config --global alias.<alias-name> <command>` 可以自定义 git 命令别名，方便使用。\n\n```bash\ngit config --global alias.st status\ngit config --global alias.br branch\ngit config --global alias.co checkout\ngit config --global alias.ci commit\n#使用\ngit st # git status\n```\n\n## 设置大小写敏感\n在 Windows 下，git 默认大小写不敏感，即文件名大小写不同，git 仍然认为是同一个文件。\n\n```bash\ngit config --get core.ignorecase # 查看git 的设置，默认为 true\ngit config core.ignorecase false # 设置大小写敏感\n```\n\n## 忽略文件的权限变化\n文件权限的变化不再视为修改。\n\n```bash\ngit config core.fileMode false\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Git"],"categories":["学习笔记"]},{"title":"Git 熟知熟用","url":"/article/120u7a12.html","content":"\n不要再一条 **main** 走到黑了。\n\n# 同步工具\n在很久很久以前，好吧其实也没多久，WinXP 上存在一个叫**公文包**的神奇软件。\n\n它用于在多台不联网的计算机上同步文件，在一台电脑上将文件拖入u盘内的公文包中，再在另一台电脑上插入u盘，修改里面的文件，当u盘插回原来的电脑并打开公文包后，便会提示更新的文件，并可选同步至本地。\n\n其本质是一个文件夹，保存有原文件的拷贝外加一个隐藏的**公文包数据库**配置文件。\n\n是的，这就是 SVN、Git、云同步的老祖宗，但公文包还缺少了**版本控制**，并且无法支持多人修改**解决冲突**。\n\n# 版本控制系统\n最原始的版本控制是按照修改时间拷贝出多个副本，这么做污染工作空间，并且在文件较多、多人修改解决冲突时极为低效。\n写论文时通常会这么做，但对于文件和成员繁多的软件项目来说不可能这么做。\n\n**版本控制系统**解决了这些问题，其目的是**跟踪文件变化**、让项目成员间**协作更加高效**。\n1. 跟踪代码历史记录\n2. 以团队形式协作编写代码\n3. 查看谁做了哪些更改\n\n类型：\n1. **集中式：**SVN、CVS。文件保存在中央服务器上，本地只保留文件副本。在修改文件前需要先从服务器上拉取最新版本，修改后再推送至服务器。优点是使用简单，缺点是服务器宕机后无法工作，且需要联网。\n2. **分布式：**Git、Mercurial。每个本地都有完整的版本库，可以直接在本地处理文件，在需要时多个本地互相同步更新文件，或通过远端仓库同步。但也意味着解决冲突、合并分支等操作更复杂，当然这是以可以通过高内聚低耦合、良好的分支设计来解决的。\n\n# 开始使用Git\n前往[Git 官网](https://git-scm.com/)下载安装包，就像其它软件一样，Linux 通过 apt 安装即可。\n\n相关文档：\n[Git 官方文档](https://git-scm.com/book/zh/v2)\n[GitHub-开始使用 Git](https://docs.github.com/zh/get-started/getting-started-with-git/set-up-git)\n[常用 Git 命令清单-阮一峰](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n[DevOps Guidebook-Git](https://tsejx.github.io/devops-guidebook/code/git)\n\n使用 Git 的方式有很多：命令行、GUI、IDE 集成等。本文主要使用命令行和 VSCode。\n\n常用命令图：\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/90-1.webp\" width=\"100%\" />\n\n> Git中有许多操作可以使用多个命令完成，本文以操作进行划分，将常用的命令列出。若一个操作只有一个常用的命令，则在目录中会直接列出该命令。\n\n## git config 基本配置\n使用 `git config` 命令配置用户名和邮箱。[Git官网-初次运行 Git 前的配置](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE)\n\n**作用范围：**\n1. `--global`：全局配置，只需配置一次。最常用。\n2. `--local` 或省略：只对当前仓库有效。\n3. `--system`：对系统所有用户有效。\n\n```bash\n# 配置用户名，有空格需加引号\ngit config --global user.name \"Your Name\"\n# 配置邮箱\ngit config --global user.email 123456@qq.com\n```\n\n`git config --list` 查看所有配置信息。\n`git config --get <name>` 查看单个配置信息。\n\n配置的用户名和邮箱会出现在 commits 提交记录中，仅作为标识，不作为身份验证。\n配置的是 Github 绑定的邮箱，则显示对应的账号，否则显示配置的用户名。\n\n**删除配置：**\n\n```bash\ngit config --global --unset user.name\n```\n\n# 初始化仓库\n`git init` 用于初始化一个新的仓库，会在当前目录下创建一个隐藏的 `.git` 文件夹，用于保存版本库和配置信息。\n\n```bash\ngit init # 直接在当前文件夹初始化仓库\ngit init <my-repo> # 创建一个文件夹，并将其初始化为仓库\n```\n\n这就像公文包一样，当你删除 **.git** 文件夹，那么该根文件夹也将不再是一个 Git 仓库。\n\n原本默认的分支名是 **master**，但现在已经改为 **main**，[github/renaming](https://github.com/github/renaming)，通过下面命令修改默认分支名：\n\n```bash\ngit config --global init.defaultbranch main\n```\n\n除此之外，`git clone` 可以克隆一个远端仓库到本地。\n\n# 组成与文件状态\nGit 仓库由三部分组成：\n1. **工作区 Working Directory**：当前工作目录，对项目的某个版本独立提取出来的内容，供用户修改。\n2. **暂存区 Staging Area**、**索引**：一个文件，记录了**将要**提交的**已修改**的文件列表信息。\n3. **版本库**、**本地仓库 Repository**：即 **.git** 文件夹，包含项目的元数据和对象数据库。\n\n**工作流程：**\n1. 在工作区修改文件。\n2. 将修改后的文件添加到暂存区。\n3. 将暂存区的文件提交到本地仓库。\n\n文件状态：\n1. **未跟踪 untracked**：文件未被 Git 管理，通常是新建的文件。\n2. **已修改 modified**：文件已被修改，但未添加到暂存区。\n3. **已暂存 staged**：文件已添加到暂存区，但未提交。\n4. **已提交 committed**：本地仓库保存着的特定版本的文件。\n\n还有些说法存在**已跟踪**状态，通常是为了方便理解，即文件已经被 Git 管理，首次将文件添加到暂存go会变为**已跟踪**状态。\n\n# 更改文件状态\n`git status` 用于查看仓库的状态，`-s` 精简显示。\n\n在仓库中新建文件并查看状态，显示了**未跟踪 untracked** 的文件列表。\n\n```bash\nOn branch main\nNo commits yet\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        01.js\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n## 添加到暂存区\n使用 `git add` 将**已修改**、**未跟踪**的文件添加到**暂存区**，再次查看状态，显示了**已暂存 staged** 的文件列表。\n1. `git add <file1> <file2>` 添加指定的若干个文件。\n2. `git add .` 添加工作区所有文件。\n3. `git add <folder>` 添加指定文件夹下的所有文件，包括子目录。\n4. `git add *.js` 支持通配符，添加所有后缀为 .js 的文件。\n\n> Git中 . 号表示当前目录，包括其子目录，使一个命令对当前目录下的所有文件生效。大多数命令都支持这种用法。后文的`<target>`即表示通用的目标表示。`<file>`则是必须明确指定文件path。\n\n```bash\nOn branch main\nNo commits yet\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   01.js\n```\n\n## 从暂存区移除\n`git rm <file>` 对于已提交**未修改**的文件，将文件从工作区移除，并暂存删除操作。\n\n```bash 不能删除已修改或已暂存的文件\n> git rm 01.js\nerror: the following file has changes staged in the index:\n    01.js\n(use --cached to keep the file, or -f to force removal)\n```\n\n若文件**已修改**或**已暂存**，则需要使用下面两个命令，否则会报错。\n`git rm --cached <file>` 可以将文件从**暂存区**和**版本库**中移除，但**保留工作区文件及其修改**，文件会变为**未跟踪**状态。\n`git rm -f <file>` 强制移除，将文件从暂存区、工作区移除，并暂存删除操作。\n\n**保留跟踪状态：**\n`git reset HEAD <target>` 和 `git restore --staged <target>` 也可以将文件从暂存区移除，且文件仍然是跟踪状态，保留工作区文件及其修改。\n\n> HEAD 是一个特殊的指针，它指向当前分支的最新提交。当你切换分支或创建新的提交时，HEAD 会自动移动，始终指向当前分支的最新提交。\n\n## 放弃工作区修改\n放弃工作区的修改：就是将文件恢复到最近一次提交的状态。\n\n下面几个命令都可以用来**放弃工作区的修改**，行为是一致的，但不影响暂存区，仅将工作区文件恢复到**最近一次提交**、**未修改**的状态。\n1. `git restore <target>` 放弃工作区修改。只作用于已跟踪的文件。\n2. `git checkout <target>` 多用于切换分支，但也可以用来**还原工作区**。只作用于已跟踪的文件。\n\n下面的命令会同时将文件从**暂存区**移除，再放弃工作区的修改。\n1. `git reset --hard HEAD` **清空暂存区**，并将最后一次提交的版本恢复到工作区。只作用于已跟踪的文件。\n2. `git restore --staged --worktree <target>` 将文件从**暂存区**移除，再放弃工作区的修改。只作用于已跟踪的文件。\n\n上面的命令只作用于已跟踪的文件，不会对未跟踪的新文件产生影响。\n对于刚新建的文件，其状态是**未跟踪**，需要使用 `git clean`，默认不删除 .gitignore 指定的文件夹和文件，参数列表如下，可混合使用。\n1. `-f <target>` 删除指定路径未跟踪文件，不包括子目录。\n2. `-d` 递归删除，时包括子目录。\n3. `-x` 删除 .gitignore 中忽略的文件。\n4. `-n` 显示将要删除的文件，但不删除。\n5. `-i` 进入交互模式，可以选择性删除文件。\n\n将工作区还原到最后一次 commit 状态：\n\n```bash\ngit clean -df # 删除.gitignore指定之外的未跟踪文件，包括子目录\ngit reset --hard HEAD # 清空暂存区，还原工作区\n```\n\n## git commit 提交到本地仓库\n`git commit` 用于将**已暂存**的文件提交到**本地仓库**。每次提交会形成一个新版本，commit id 就相当于版本号。\n\n可以加上 `-m <message>` 参数以快速设置提交信息。\n否则会进入系统配置的编辑器，通常是vim，可以通过 `git config --global core.editor <editor>` 修改。\n\n```bash\n> git commit -m \"一次提交\"\n[main b13367c] 一次提交\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n命令行会告诉你本次提交的分支名、commit id前若干位（能唯一标识的最短位数），以及修改的文件数量、插入和删除的行数。\n\n`-a` 参数把所有**已修改**的文件(不包括未跟踪的文件)都添加到暂存区中，并直接进行提交。\n\n```bash\n> git commit -am \"111\"\n[main d74b681] 111\n 3 files changed, 5 insertions(+), 2 deletions(-)\n```\n\n### --amend 修改最后提交\n**1、修改 message：**\n`git commit --amend -m <message>` 修改最后一次提交的提交信息。\n\n**2、增补修改：**\n`git commit --amend <target>` 会将**已暂存**的文件和上一次提交的文件合并，形成一个新的提，会弹出编辑器，可以修改提交信息。\n\n**3、修改提交者：**\n`git commit --amend --author='Name <email>'` 修改提交者信息。\n\n**其它参数：**\n`--no-edit` 不修改提交信息。\n`--reset-author` 使用新配置本地用户的信息。\n\n# git log 查看提交历史\n`git log` 用于查看提交历史，包括作者、时间、commit id、分支信息、提交信息。\n\n```bash\n> git log\ncommit b13367c4db55f5185eec096cc4b52256622ec3a9 (HEAD -> main)\nAuthor: qxchuckle <1934009145@qq.com>\nDate:   Wed May 8 20:59:59 2024 +0800\n    一次提交\n\ncommit 2722e35bdb5f324c54abe0fec53079a067fbd710\nAuthor: qxchuckle <1934009145@qq.com>\nDate:   Wed May 8 20:55:47 2024 +0800\n    test提交\n```\n\n`(HEAD -> main)` 表示当前 HEAD 指针指向 main 分支的最新提交。\n\n`--oneline` 参数可以将每次提交压缩为一行，只显示简短commit id和提交信息。\n\n```bash\n> git log --oneline\nb13367c (HEAD -> main) 一次提交\n2722e35 test提交\n```\n\n**其它参数：**\n`--grep` 搜索包含指定关键字的提交信息。\n`--author` 搜索指定作者的提交记录。\n`--since` `--after` 搜索指定时间之后的提交记录。\n`--until` `--before` 搜索指定时间之前的提交记录。\n`--no-merges` 不显示合并提交。\n`--graph` 以图形化方式显示提交历史。\n\n```bash\ngit log --grep=\"feat\"\ngit log --author=\"qxchuckle\"\ngit log --since=\"2024-05-10\" --until=\"2024-05-12\"\ngit log --no-merges\ngit log --graph\n```\n\n# git reset 回退版本\n`git reset <HEAD/commit id>` 用于回退版本，本质是更改 HEAD 指针的指向。\n\n**三个参数：**\n1. `--mixed` **默认参数**，清空暂存区，工作区不变。\n2. `--soft` 工作区和暂存区都保持不变。\n3. `--hard` 清空暂存区，工作区回退到指定版本的状态。\n\n直接执行该命令等同于 `git reset --mixed HEAD`，回退到当前分支的最后一个提交版本，清空暂存区，工作区不变。\n\n**版本的指定方式：**\n1. `HEAD`：当前分支的最新提交，`HEAD^` 表示上一个版本，`HEAD~<number>` 表示前 number 个版本。\n2. `commit id` 可以是完整的 commit id，也可以是前几位，只要能唯一标识即可。\n\n```bash 查看提交历史并回退到上一个版本\n> git log\nb13367c (HEAD -> main) 一次提交\n2722e35 test提交\n\n> git reset HEAD^\nUnstaged changes after reset:\nM       01.js\n```\n\n回退后，会提示未暂存的更改。\n\n```bash 再次查看提交历史\n2722e35 (HEAD -> main) test提交\n```\n\n可以看到，其本质是更改了 HEAD 指针的指向，而 `git log` 是从 HEAD 开始查看提交历史的。\n\n## git reflog 引用日志\n回退后的提交历史并没有被删除，只是不再在提交历史显示，这确保了 Git 的所有操作都是可回溯的。\n\n使用 `git reflog` 查看引用日志，所有引起 HEAD 指针变动的操作，都会被记录。\n\n**注意：**reflog 并不是 Git 仓库的一部分，它单独存储，是纯本地的。\n\n```bash\n> git reflog\n2722e35 (HEAD -> main) HEAD@{0}: reset: moving to HEAD^\nb13367c HEAD@{1}: commit: 一次提交\n2722e35 (HEAD -> main) HEAD@{2}: commit: test提交\n```\n\n可以看到 **b13367c** 版本仍然存在，这就是后悔药，可以通过 `git reset` 恢复到回退前的版本。\n\n```bash\n> git reset b13367c\n> git log --oneline\nb13367c (HEAD -> main) 一次提交\n2722e35 test提交\n```\n\n即使有了 reflog，但它也只能回溯已提交的版本，对于暂存区和工作区的数据丢失，还是无能为力的。\n\n# git diff 查看文件差异\n`git diff` 用于查看文件的差异，包括不同状态、不同版本、不同分支的差异。\n\n当然，这种 diff 对比通常使用 VSCode 或其它 GUI 工具更方便直观，但该命令是基石，还是有必要学习的。\n\n直接执行该命令，存在三种情况：\n1. **已暂存**的文件：不显示\n2. **已修改未暂存**的文件：查看工作区和最新版本的差异。\n3. **暂存后又有修改**的文件：查看工作区和暂存区的差异。\n\n```bash\n> git diff\ndiff --git a/01.js b/01.js\nindex de2c2d3..d0ec6cd 100644\n--- a/01.js\n+++ b/01.js\n@@ -1 +1 @@\n-console.log(\"111\")\n\\ No newline at end of file\n+console.log(\"222\")\n\\ No newline at end of file\ndiff --git a/src/index.js b/src/index.js\nindex e69de29..e98763e 100644\n--- a/src/index.js\n+++ b/src/index.js\n@@ -0,0 +1 @@\n+console.log(123)\n\\ No newline at end of file\n```\n\n显示了所有已修改的文件的差异，包括文件路径、hash值、内容的变动。\n\n**其它用法：**\n1. `git diff --cached` 只查看暂存区和最新版本的差异。\n2. `git diff <file>` 查看指定文件的差异。\n3. `git diff HEAD` 查看所有已修改的文件和最新版本的差异。\n4. `git diff <commit id>` 查看所有已修改的文件和指定版本的差异。\n5. `git diff <commit id1> <commit id2>` 查看两个版本的差异。\n6. `git diff <branch1> <branch2>` 查看两个分支的差异。\n\n参数前后位置关系：第二个版本相较于一个版本的差异，也就是第二个版本相较于第一个版本变动了什么。\n\n# git ls-files 查看文件列表\n`git ls-files` 用于查看 git 的文件列表\n\n它有很多参数，以查看**不同状态**的文件列表。\n1. `--cached(-c)` 查看已跟踪（暂存区+版本库）的文件列表。\n2. `--stage(-s)` 在 -c 基础上显示更详细的信息。\n3. `--deleted(-d)` 查看**工作区**已删除的文件列表。\n4. `--modified(-m)` 查看**工作区**已修改的文件列表。\n5. `--others(-o)` 查看**工作区**未跟踪的文件列表，包括忽略的文件。\n6. `--unmerged(-u)` 查看未合并的文件列表。\n7. `--killed(-k)`  显示文件系统上因文件/目录冲突而需要删除的文件。\n8. `--ignored(-i)` 查看被忽略的文件列表。\n\n同时使用多个参数，**取并集**。\n\n```bash\n> git ls-files -s       \n100644 8d7f07ffcaafd2ad61754ac05caf4d282f209523 0       .gitignore\n100644 c933c701bd2e066e8a715fa8d547d710d2eb0181 0       01.js\n100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       02.js\n100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       src/index.js\n\n> git ls-files -m\nsrc/index.js\n```\n\n# .gitignore 忽略文件\n`.gitignore` 文件用于指定不需要 Git 管理的文件或文件夹，通常是编译文件、日志文件、临时文件等。\n\n**注意：**只能忽略**未跟踪**的文件，已跟踪的文件需使用 `git rm --cached` 将其变为未跟踪状态再忽略。\n\n**匹配规则：**从上到下，先匹配先生效，后匹配的会覆盖前面的匹配。\n1. `#` 号开头的行为注释。\n2. 使用标准的 **glob 模式**，`*` 匹配零个或多个字符，`?` 匹配一个字符，`[abc]` 匹配 a、b、c 中的一个字符。\n3. `**` 匹配多级目录，`a/**/b` 匹配 a 目录下任意层级的 b 文件。\n4. `[0-9]` 任意一位数字，`[a-z]` 任意一位小写字母。\n5. `!` 取反，`!*.log` 表示不忽略所有 .log 文件，优先级比忽略文件夹低。\n6. `/` 当前目录。\n\n```\n# 忽略所有的log文件\n*.log\n# 在前面的规则下，不忽略error.log文件\n!error.log\n# 忽略所有node_modules文件夹\nnode_modules\n# 只忽略根目录下的dist文件夹\n/dist\n# 忽略public目录及其子目录下的所有pdf文件\npublic/**/*.pdf\n```\n\ngithub 提供了许多语言的模板，可以直接使用：[github/gitignore](https://github.com/github/gitignore)\n\n# 远端仓库与GitHub\n远端仓库用于多人协作，方便各个本地仓库同步和贡献代码，可以是自己搭建的 Git 服务器，也可以是第三方的 Git 服务，如 GitHub、GitLab、Gitee 等。\n\nGitHub 是一个基于 Git 的代码托管平台，并提供了issues、拉取请求、代码审查、actions等功能。[关于 GitHub 和 Git](https://docs.github.com/zh/get-started/start-your-journey/about-github-and-git)\n\nGitHub 提供了两种远程仓库地址：\n1. **HTTPS** 在 push 时需要输入用户名和密码，且 GitHub 在 2021 年 8 月 13 日后不再支持密码验证，需要使用 token。好处是 clone 时比较方便。\n2. **SSH** 通过 SSH 密钥验证，不需要输入用户名和密码，且更方便安全，但必须提前在 GitHub 配置本地 SSH 的公钥，否则 clone 和 push 都无权限。\n\n[Git远程操作详解-阮一峰](https://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n\n## 配置SSH\n先进入用户主目录，查看是否存在 `.ssh` 文件夹，若不存在则创建。\n\n```bash\n> cd ~/.ssh\n```\n\n查看是否存在公钥和私钥。\n\n```bash\n> ls\nknown_hosts\n```\n\n> known_hosts：当首次与一个SSH服务器建立连接时，客户端会记录下该服务器返回的的公钥，并保存在known_hosts文件中，以后每次连接该服务器时，客户端都会验证该服务器返回的公钥是否与known_hosts文件中保存的一致。\n\n接着使用 `ssh-keygen` 生成 SSH 密钥对。\n1. `-t` 指定密钥类型，默认 rsa。\n2. `-C` 添加注释，一般是邮箱。\n3. `-f` 指定密钥文件名。默认为 id_rsa。\n4. `-b` 指定密钥长度，默认 2048。\n\nEnter passphrase 这一步通常直接回车，不设置密码，否则每次 clone 和 push 都需要输入密码。\n\n```bash\n> ssh-keygen -b 4096\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/qcqx/.ssh/id_rsa): test\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in test\nYour public key has been saved in test.pub\nThe key fingerprint is:\nSHA256:JFvlLQwFsJKOH83TW8ik+TIXNljisQfOWTzbg7omiHo qcqx\nThe key's randomart image is:\n+---[RSA 4096]----+\n|      ..ooo      |\n......\n+----[SHA256]-----+\n```\n\n再次 ls，可以看到生成的 test 私钥和 test.pub 公钥。\n\n```bash\n> ls\nknown_hosts  test  test.pub\n```\n\n复制公钥内容，进入 GitHub 设置页面 [SSH and GPG keys](https://github.com/settings/keys)，添加 SSH 公钥。\n\n```bash\n> cat test.pub\nssh-rsa AAAAB3NzaC1yc2EAAA....\n```\n\n如果是默认的 id_rsa，则现在已经完成了配置，但如果自定义了 SSH 密钥文件名，则需要在 `~/.ssh/config` 文件中添加配置，指定在访问 GitHub 时使用该密钥。\n\nconfig 格式，详见 [[SSH]客户端配置文件config](https://zj-network-guide.readthedocs.io/zh-cn/latest/ssh/[SSH]%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config/)\n\n```\nHost 名称，用于标识某个特定的配置\n  User 用户名\n  HostName ssh连接的主机名，一般是IP地址\n  Port 端口号，默认22\n  PreferredAuthentications 指定认证方式，如publickey\n  IdentityFile 本地私钥地址\n  IdentitiesOnly 指定ssh是否仅使用配置文件或命令行指定的私钥文件进行认证。值为yes或no，默认为no\n  ForwardAgent 允许ssh-agent转发，值为yes或no，默认为no\n```\n\n```bash\n> vim ~/.ssh/config\nHost github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/test\n```\n\n测试配置是否成功\n\n```bash\n> ssh -T git@github.com\nHi qxchuckle! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n这里将 Host 和 HostName 都设置为 github.com，若有多个 SSH 密钥以连接不同 GitHub 账户，可以通过 Host 区分，但推送和拉取时需改为对应 Host。\n\n```bash\n> vim ~/.ssh/config\nHost qcqx\n# git@<Host>:qxchuckle/vsc-drafts.git\n> git clone git@qcqx:qxchuckle/vsc-drafts.git\n```\n\n## git remote 操作远端仓库\n`git remote` 查看已关联的远端仓库，`-v` 显示详细信息。\n\n`git remote add <name> <url>` 添加远端仓库\n1. name 一般是 origin，也可以是其它名字，用于区分多个远端仓库。\n2. url 远端仓库地址，可以是 HTTPS 或 SSH。\n\n```bash\n> git remote add test git@github.com:qxchuckle/git-test-2.git\n> git remote -v\n# origin 是之前添加的\norigin  https://github.com/qxchuckle/git-test.git (fetch)\norigin  https://github.com/qxchuckle/git-test.git (push)\ntest    git@github.com:qxchuckle/git-test-2.git (fetch)\ntest    git@github.com:qxchuckle/git-test-2.git (push)\n```\n\n`git remote show <name>` 查看远端仓库的详细信息。\n\n```bash\n> git remote show test\n* remote test\n  Fetch URL: git@github.com:qxchuckle/git-test-2.git\n  Push  URL: git@github.com:qxchuckle/git-test-2.git\n  HEAD branch: (unknown)\n```\n\n`git remote rm <name>` 移除远端仓库。\n\n`git remote rename <old> <new>` 重命名远端仓库。\n\n# git push 推送\n`git push <remote> <branch:remoteBranch>` 推送本地分支到远端仓库的指定分支，若远端分支不存在则会**自动创建**。\n\n**省略写法：**\n1. 冒号可以省略，简写为 `<branch>`，表示将指定本地分支推送到远端**同名分支**。\n2. 省略分支名，表示将当前分支推送到远端**同名分支**。\n3. 省略远程仓库名和分支名，将当前分支推送到与之存在**追踪关系**的远程分支（即**追踪分支**）。\n\n```bash\n# 将本地 main 分支推送到远端 test 仓库的同名 main 分支\n> git push test main\n * [new branch]      main -> main\n```\n\n## 追踪关系\n与远程分支建立追踪关系，则该远程分支就是本地分支的**追踪分支**，也称为**上游**。\n\npush 的 `-u` 参数可以将本地分支和远程分支建立**追踪关系**，在下次推送该分支时，可以省略远程仓库名和分支名。\n`-u` 是 `--set-upstream` 的简写形式。\n\n`git branch -vv` 查看本地分支和远程分支的追踪关系。\n\n```bash\n# 将本地 main 分支推送到远端 test 仓库的 other 分支，并建立追踪关系\n> git push -u test main:other\nEverything up-to-date\nbranch 'main' set up to track 'test/other'.\n> git branch -vv\n* main c4d02d8 [test/other]\n```\n\n一个本地分支只能有一个追踪分支，但一个远程分支可以被多个本地分支追踪。\n\n还可以通过 `git branch` 建立追踪关系：\n`git branch --set-upstream-to=<remote>/<branch> <branch>`\n\n删除追踪关系：\n`git branch --unset-upstream <branch>`\n\n在 clone 的时候，所有本地分支默认与远程的同名分支建立了追踪关系。\n\n**注意：**\n在默认的 simple 推送策略下，如果本地分支和追踪分支不同名，那么下次推送时还是需要指定远程仓库名和分支名。\n\n## 推送策略\n对于不带任何参数的 `git push` 的推送策略：\n1. **nothing** 什么都不做。\n2. **simple** 推送当前分支到**同名追踪分支**。\n3. **matching** 推送所有本地分支到**同名追踪分支**。\n4. **upstream** 推送当前分支到**追踪分支**。\n\n在 Git 2.0 之前，默认是 matching 模式，2.0 之后默认是 simple 模式。\n可以通过 `git config --global push.default <策略名>` 修改推送策略。**但通常不要修改**。\n\n**影响：**\n即使你将本地 main 分支关联到了 test 仓库的 other 分支，但如果推送策略是默认的 simple，那么下次推送时还是需要指定远程仓库名和分支名。\n\n```bash\n> git push test\nfatal: The upstream branch of your current branch does not match\nthe name of your current branch.  To push to the upstream branch\non the remote, use\n\n    git push test HEAD:other\n\nTo push to the branch of the same name on the remote, use\n\n    git push test HEAD\n\nTo choose either option permanently, see push.default in 'git help config'.\n```\n\n## 删除远端分支\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n或者使用 `git push <remote> --delete <branch>` 删除远端分支。\n\n```bash\n> git push origin :master\n> git push origin --delete master\nTo github.com:qxchuckle/git-test-2.git\n - [deleted]         master\n```\n\n## 强制推送\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做合并差异，然后再推送到远程主机。\n可以使用 `--force` 强制推送，**但一般不要使用**，因为会覆盖远程仓库的提交记录。\n\n```bash\n> git push test\nTo github.com:qxchuckle/git-test-2.git\n ! [rejected]        main -> main (fetch first)\nerror: failed to push some refs to 'github.com:qxchuckle/git-test-2.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n> git push test -f \nTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0\nTo github.com:qxchuckle/git-test-2.git\n + 0b733ec...e38c4b9 main -> main (forced update)\n```\n\n## 解决冲突\n当远程仓库和本地仓库的**提交记录不一致**时，会产生冲突，此时需要先解决冲突再推送。\n\n```bash\n> git push\nTo github.com:qxchuckle/git-test.git\n ! [rejected]        main -> main (non-fast-forward)\nerror: failed to push some refs to 'github.com:qxchuckle/git-test.git'      \nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.  \n```\n\n先 `git pull` 拉取远程仓库的更新。若存在冲突的文件，就会像下面这样，需要手动解决冲突。\n\n```bash\n> git pull\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n打开冲突的文件，可以看到 git 已经标记了冲突的地方。\n使用 `=======` 分隔开两个不同版本的内容，**上面**的 `<<<<<< HEAD` 是本地仓库的内容，**下面**的 `>>>>>> CID` 是远程仓库最新版本的内容。\n\n```txt\n111111111111111111\n<<<<<< HEAD\n333333333333333333\n=======\n222222222222222222\n>>>>>> db3e373b6c920c18f9ce06a68236a127ced34286\n```\n\n修改好最终的内容后，再次提交。\n\n```bash\n> git commit -am \"解决冲突\"\n[main 4d36e7a] 解决冲突\n> git push\n```\n\n若 pull 能正常拉取完成功，说明没有文件冲突，直接 push 即可。\n\n# git fetch 拉取\n`git fetch <remote>` 拉取远端仓库的**所有分支**到本地仓库，也可以指定拉取某个分支。\n\n在本地使用 `<remote>/<branch>` 访问远程分支。\n\n```bash\n> git branch -r\n  origin/main\n  test/main\n  test/other\n```\n\n在 fetch 后 可以在其基础上使用 `git checkout` 命令创建一个新的分支并切换过去，这通常是想先看看远程分支的情况。\n\n```bash\n> git checkout -b newBrach origin/main\n  Switched to a new branch 'newBrach'\n  branch 'newBrach' set up to track 'origin/main'.\n> git branch\n  main\n* newBrach\n```\n\n审查没问题后，就可以使用 merge 或 rebase 合并到本地分支。\n\n```bash\n> git merge origin/main # git merge FETCH_HEAD\n  Updating e38c4b9..c13f96b\n  Fast-forward\n  README.md | 7 +------\n```\n\n**另一个流程：**\n在 fetch 时也可以直接拉取到一个新的分支。\n\n```bash\n> git fetch origin main:main-tmp  \n * [new branch]      main       -> main-tmp\n   c13f96b..0177ab1  main       -> origin/main\n\n# 查看差异\n> git diff main main-tmp\ndiff --git a/README.md b/README.md\nindex 60d4268..78664bf 100644\n--- a/README.md\n+++ b/README.md\n@@ -1 +1,3 @@\n 111111111111111111\n+\n+5654645664\n\n# 合并分支\n> git merge main-tmp\nUpdating c13f96b..0177ab1\nFast-forward\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n\n# 删除分支\n> git branch -d main-tmp\nDeleted branch main-tmp (was 0177ab1).\n```\n\n`git fetch` 拉取的远程分支最新的 Commit-ID 会记录在 `.git/FETCH_HEAD` 文件中。\n若有多个分支，**FETCH_HEAD** 内会有多行数据。\n\n本地的 **FETCH_HEAD** 是一个特殊的指针，始终指向**执行 fetch 时对应的远程分支**的最新版本(Commit-ID)，可以通过 `git merge FETCH_HEAD` 合并到当前分支。\n\n这就会出现一个小问题，当在 B 分支上执行 `git fetch` 后，`FETCH_HEAD` 指向了远程的 B 分支，此时切换到 A 分支，执行 `git merge FETCH_HEAD` 会合并远程的 B 分支到 A 分支。所以要小心使用 FETCH_HEAD。\n\n# git pull 拉取合并\n`git pull` 用于拉取远程分支的更新，并与本地指定分支合并\n\n**基本用法：**\n`git pull <remote> <remoteBranch:branch>` 拉取远端仓库的指定分支到本地仓库的指定分支。若本地分支不存在，则会自动创建。\n省略冒号时，表示拉取到**当前活动分支**。\n在当前分支具有上游跟踪分支的情况下，可以省略远程仓库名和分支名。\n\n```bash\n> git pull\nremote: Enumerating objects: 5, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), 925 bytes | 115.00 KiB/s, done.\nFrom github.com:qxchuckle/git-test-2\n   d77f2bc..10766fa  main       -> test/main\nFast-forward\n 01.js | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n相当于 fetch 后 merge。\n\n```bash\ngit pull origin main\n# 相当于\ngit fetch origin main\ngit merge origin/main\n```\n\n**其余参数：**\n`--rebase` 参数：合并时采用 rebase 模式。\n`-p` 在本地删除远程已经删除的分支。而默认情况下不会在拉取远程分支的时候，删除对应的本地分支。\n\n```bash\ngit pull = git fetch + git merge FETCH_HEAD \ngit pull --rebase = git fetch + git rebase FETCH_HEAD \n```\n\n# git branch 分支\n在之前操作，大多都是在 main 分支上进行，但实际开发中，会创建多个分支，用于不同的功能开发和版本维护。\n\n**基本用法：**\n`git branch` 查看分支列表\n`git branch -v` 查看分支列表详情\n`git branch -vv` 查看追踪关系\n`git branch <name>` 创建分支\n`git branch -d <name>` 删除已合并分支，若分支未合并，需使用 `-D` 强制删除\n`git branch -m <old> <new>` 重命名分支\n\n切换分支：`git checkout <branch>` 或 `git switch <branch>`\ncheckout 还可以用来还原工作区，所以在 Git 2.23 之后，推荐使用 switch。\n\n切换分支时，HEAD 指针会指向新的分支最后一次的提交，工作区的内容也会变为新分支的内容。\n\n```bash\n> git branch\n* main\n  dev\n```\n\n**注意：**新建的分支就像新的树枝一样，从原来的主干上分岔出来，所以一个新的分支仍然包含了之前所有的提交记录，其工作区内容也是最新版本的。\n\n## git merge 合并分支\n在 dev 分支开发完成后，先切换至 main 分支，再使用 `git merge <branch>` 将其合并到当前分支，会产生一个新的提交记录（没触发快进时）。\n\n在 VSCode 中可以很直观看到不同分支的提交与合并。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/90-2.webp\" width=\"100%\" />\n\n也可以使用 `git log --oneline --graph` 查看分支合并情况。\n\n```bash\n> git log --oneline --graph\n*   0ad05d7 (HEAD -> main, origin/main) Merge branch 'dev'\n|\\\n| * 30abfbc (dev) dev:2\n| * aa4ed36 dev:1\n* | 48bf5e1 main:2\n* | e2b95fb main:1\n```\n\n合并分支时也可能会产生冲突，规则和 pull 一样，需要手动解决冲突后再提交。\n\n`git merge --abort` 可以放弃合并，回到合并前的状态。\n\n`--squash` 用于将多个待合并的提交合并为一个。不自动产生一个新提交，而是将变动暂存，需手动发起 commit。\n\n**快进模式：**\nGit 默认采取了 **fast-forward**（快进模式），当 main 分支上没有新的提交，会直接将 main 的 HEAD 指向合并后最新的提交，而不会产生新的提交记录。\n`--no-ff` 参数可以禁用 fast-forward 模式，即使 main 分支上没有新的提交，也会创建一个新的提交记录。\n\n\n# git rebase 变基\n`git rebase` 用于轻松更改一系列提交。\n1. 编辑之前的提交消息\n2. 将多个提交合并为一个\n3. 删除或还原不再必要的提交\n\n因为 rebase 会改变提交记录，所以不要在**公共分支**和**已推送到远端的提交**上使用 rebase，否则造成提交记录不一致会出现问题。\n\n## 转移提交\n`git rebase <branch>` 将**当前分支**的差异提交记录**移动**到**指定分支**的最后，使得提交记录成线性更加整洁。\n`git rebase <a> <b>` 将 b 分支的提交记录移动到 a 分支的最后。\n\nmerge 在合并时会产生一个新的提交记录，而 rebase 只是单纯的变基，不会产生新的提交记录。\n\n但产生冲突时，需要逐个 commit 解决，解决后(add)使用 `git rebase --continue` 继续变基。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/90-3.webp\" width=\"100%\" />\n\n**变基规则：**\n1. 先找到两个分支的**最近**共同祖先 commit 节点。\n2. 将当前分支从**祖先节点**开始的 commit 记录变基到目标分支的最后。\n\n**注意：**基分支的 **HEAD** 指针并没有变，仍然需要使用 merge，目的是将指针指向最新的提交。\n\n## -i 交互式操作\n`git rebase -i` 启动交互式 rebase 用于操作提交记录。\n\n指定要操作的 commit 范围：\n1. `git rebase -i  [start]  [end]` **(start, end]** 的提交。\n2. `git rebase -i [start]^  [end]`  **[start, end]** 的提交。\n3. 不指定 end 则表示到最新提交。\n4. `git rebase -i HEAD~3` 最近 3 次提交。\n\n```bash\n> git rebase -i HEAD~3\npick 0c49394 main:3\npick a1a0432 main:4\npick 02bccdb main:5 # 最新的提交在最末尾\n\n# Rebase 7d451dd..02bccdb onto 7d451dd (3 commands)\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup [-C | -c] <commit> = like \"squash\" but keep only the previous\n#                    commit's log message, unless -C is used, in which case\n#                    keep only this commit's message; -c is same as -C but\n#                    opens the editor\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified); use -c <commit> to reword the commit message\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n```\n\n修改每条记录前的**命令**(pick)，可以对提交记录进行操作：\n1. `pick` 使用该提交，在变基进行时重新排列 pick 命令的顺序会更改提交的顺序。\n2. `reword` 使用该提交，但变基过程会暂停，可以**修改提交注释**。\n3. `edit` 与 reword 类似，但可以完全**修改提交**，可以创建更多提交后再继续变基。\n4. `squash` 使用该提交，但将其**合并**到前一个提交，可以修改提交注释。\n5. `fixup` 与 squash 类似，但**不保留提交注释**。\n6. `drop` 丢弃该提交。删除整行效果一样。\n7. `exec` 执行 shell 命令。\n8. `break` 暂停变基，使用 `git rebase --continue` 以继续。\n\n在编辑器出现异常退出时，可以使用 `git rebase --edit-todo` 重新打开编辑器。\n随时都可以使用 `git rebase --abort` 放弃变基，回到变基前的状态。\n\n### 合并提交\nsquash 合并提交后，保存退出 rebase，会马上弹出 commit 编辑器，并展示了所有要合并的 commit 的注释，可以修改合并后的提交注释。\n\n```bash\n# This is a combination of 2 commits.\n# This is the 1st commit message:\n\nmain:3\n\n# This is the commit message #2:\n\nmain:4\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# Date:      Sat May 11 14:11:39 2024 +0800\n#\n# interactive rebase in progress; onto 7d451dd\n# Last commands done (2 commands done):\n#    pick 0c49394 main:3\n#    squash a1a0432 main:4\n# Next command to do (1 remaining command):\n#    pick 02bccdb main:5\n# You are currently rebasing branch 'main' on '7d451dd'.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n```\n\n## 与 merge 的区别\nHEAD 指向，以 dev -> main 为例：\n1. **merge：**main 的 HEAD 指向合并后的最新提交，dev 的 HEAD 指向不变（即最后一次修改文件的提交）。没触发快进时，dev 会落后一个提交，反之都指向最新的提交。\n2. **rebase：**main 和 dev 的 HEAD 指向都不变。但因为变基了，dev 从公共祖先开始的提交记录会被移动到 main 的最后，所以 main 落后于 dev。main 可以使用 merge 快进到此时的最新提交。\n\n由于 rebase 不改变 HEAD 的特性，可以用于其它分支同步主干分支的最新提交历史。毕竟嫁接过去，主干的提交历史也就成了自己的提交历史。而主干分支的提交历史不会受到影响，因为 HEAD 指向不变。\n\n最后经审核后，再使用 merge 快进到最新提交。这样可以使提交历史尽可能成一个线性，更加整洁。\n\n# git cherry-pick 挑选提交\n合并一个分支所有的提交使用 merge 或 rebase\n而 **cherry-pick** 可以挑选某个分支的某些提交合并到**当前分支**。\n\n这对于紧急修复 bug 或者合并某个特定的功能非常有用。\n\n基本使用：`git cherry-pick <commit id>` 挑选某个提交应用到**当前分支**。会产生一个新的提交记录。\n\n如下图，将 dev 分支的 fix bug 提交先应用到 main 分支。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/90-4.webp\" width=\"100%\" />\n\n`git cherry-pick <branch>` 表示挑选指定分支的**最新提交**应用到**当前分支**。\n也可以一次挑选多个提交，`git cherry-pick <id1> <id2>`，会产生多个新的提交记录。\n\n**应用一系列提交：**\n`git cherry-pick <start>..<end>` 挑选 **(start, end]** 的提交。\n`git cherry-pick <start>^..<end>` 挑选从 **[start, end]** 的提交。\n\n**发生冲突时需要逐个解决：**\n1. `--continue` 手动解决冲突(git add)后执行，继续应用后续提交。\n2. `--abort` 放弃所有挑选，回到挑选前的状态。\n3. `--skip` 跳过当前存在冲突的提交，应用后续提交。\n\n**其它参数：**\n1. `-e` `--edit` 应用提交时打开编辑器，可以修改提交信息。\n2. `-n` 只更新工作区和暂存区，不产生新的提交。\n3. `-s` `--signoff` 在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。\n4. `-x` 在提交信息的末尾追加一行(cherry picked from commit ...)，方便以后查到这个提交是如何产生的。\n\n# git stash 储藏\n当在一个分支上开发到一半，需要切换到另一个分支进行开发时，会爆出错误：\n\n```bash\n> git switch dev\nerror: Your local changes to the following files would be overwritten by checkout:\n        README.md\nPlease commit your changes or stash them before you switch branches.\nAborting\n```\n\n这是因为当前工作区有**未提交的更改**，尽管后续可以在推送前使用 rebase 合并提交，但直接提交开发到一半的代码显然是不合适的。\n\n这时就可以用 `git stash` 将当前的更改**储藏**起来，获得一个**干净**的工作区，然后切换分支。\n它会保存**暂存区**和**工作区**中**已跟踪**文件的修改，这些修改会保存在一个栈上。\n\n```bash\n> git stash\nSaved working directory and index state WIP on main: 90dfdec main:5\n```\n\n`git stash save [<message>]` 可以自定义描述信息。\n1. `--all` `-a` 储藏**所有**已跟踪和未跟踪的文件。\n2. `--include-untracked` `-u` **未跟踪**的文件也会被储藏，如新建的文件。\n3. `--keep-index` `-k` 默认，只储藏已跟踪的文件。\n\n`git stash list` 查看储藏列表。\n\n```bash\n> git stash save \"main第一次存储\"\n> git stash list\nstash@{0}: On main: main第一次存储\nstash@{1}: WIP on main: 90dfdec main:5\n```\n\n新的储藏会被添加到栈顶，`stash@{<num>}` 是会变动的id。\n\n## 恢复储藏\n1. `git stash apply [<stash>]` 恢复储藏，但不会删除储藏记录，不带参数默认恢复最新的储藏。\n2. `git stash pop [<stash>]` 恢复储藏**并删除**记录，不带参数默认恢复最新的储藏。\n\n**注意：**恢复前若有未提交的更改，可能会产生冲突，需要手动解决。\n恢复时，暂存区会被清空，其更改会被应用到工作区，需重新 add。可以添加 `--index` 尝试恢复暂存区的内容。\n\n```bash\n> git stash pop        \nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (c61e045b90a3a3ddf4af55b49c6c05f16b0827c1)\n```\n\n**其它命令：**\n1. `git stash clear` 清空所有储藏。\n2. `git stash drop [-q|--quiet] [<stash>]` 删除储藏，不带参数默认删除最新的储藏。`-q` 静默模式。\n3. `git stash show [-p] [<stash>]` diff查看储藏的文件。`-p` 显示详细内容。\n4. `git stash branch <branch> [<stash>]` 创建一个**新分支**，并将储藏的内容应用到新分支，若分支已存在，则会失败。\n\n**注意：**储藏栈是所有分支共享的，需注意操作时所在的分支。\n\n# git revert 撤销远端提交\n对于还未推送到远端的提交，通常回退版本以撤销提交：\n\n```bash\n # 回退到上一个提交，--hard 放弃工作区的更改\ngit reset --hard HEAD^\n```\n\n这会使 HEAD 指针指向上一个提交\n\n但如果已经推送到远端，`git push -f` 会破坏提交历史，造成团队成员之间提交历史不一致。\n\n`git revert` 用于撤销某次远端提交，本质是创建一个**新**的提交，并对文件进行**相反**操作（相对于要撤销的提交）。\n\n```bash\n# 撤销最新的提交\ngit reset HEAD\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Git"],"categories":["学习笔记"]},{"title":"解决System占CPU过高","url":"/article/11072a12.html","content":"\n# 前言\n这几天电脑风扇总是从开机后就一直狂转，起初查看进程发现是**System**占用CPU过高，以为只是win又间歇性抽风了，也就没在意。\n\n但连续几天给我整烦闷了，一细查，是腾讯的反作弊ACE在扫内存扫盘，逆天的内核驱动。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/88-1.webp\" width=\"80%\" />\n\n# 罪证确凿\n使用 [ProcessExplorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer) 查看 System 进程的线程，发现 **ACE-BASE.sys** 在吃CPU。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/88-2.webp\" width=\"80%\" />\n\nACE 那不就是腾讯的反作弊玩意，今年2月就有dnf玩家在Colg讨论过了。\n\n[[这么过分,一定要发Colg] 毒奶粉最近越来越占用CPU资源了叭](https://bbs.colg.cn/thread-9121017-1-1.html)\n\n那简单，把ACE图图了。\n\n# 解决\n**1、禁用两个ACE服务**\nAntiCheatExpert Protection 和 AntiCheatExpert Service\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/88-3.webp\" width=\"80%\" />\n\n**2、删除ACE-BASE注册表**\n删除 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\ACE-BASE\n\n重启电脑，System进程恢复正常。\n\n> 当然，现在启动lol等腾讯游戏就会提示安全组件异常了，要玩的时候再把两个服务打开吧。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["其它"],"categories":["其它"]},{"title":"浏览器HTTP缓存","url":"/article/7343d222.html","content":"\n# 前言\n浏览器数据存储可以分为**HTTP缓存**和**离线存储**，也可以合称为**缓存**。\n\n离线存储有 Cookie、WebStorage、IndexedDB 等，本文主要讨论[HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)，即由 Cache-Control 等响应头控制的，一种保存资源副本并在下次请求时复用该副本的技术。\n\n**缓存作用：**减轻服务器压力，提高网页性能，减少资源加载时间。\n\n# 存储位置\n按**缓存位置**可分为：\n1. Service Worker 一个服务器与浏览器之间的中间人角色（独立线程），可以拦截当前网站所有的请求，具有离线缓存的能力。\n2. Memory Cache 内存缓存\n3. Disk Cache 磁盘缓存\n4. Push Cache\n\n**优先级：**Service Worker > Memory Cache > Disk Cache > Push Cache\n\n## Service Worker\n[Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers) 是运行在浏览器背后的独立线程，一般用于实现离线缓存、消息推送等功能。充当服务器与浏览器之间的中间人角色，可以拦截当前网站所有的请求。\n\nService Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。\n\n需要按规则写一个 `sw.js` 注册激活 Service Worker，如下：\n\n```js\n/* 判断当前浏览器是否支持serviceWorker */\nif ('serviceWorker' in navigator) {\n  /* 当页面加载完成就创建一个serviceWorker */\n  window.addEventListener('load', function () {\n    /* 创建并指定对应的执行内容 */\n    /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 '/'，表示 根网域下的所有内容。这也是默认值。 */\n    navigator.serviceWorker.register('./serviceWorker.js', {scope: './'})\n      .then(function (registration) {\n        console.log('ServiceWorker registration successful with scope: ', registration.scope);\n      })\n      .catch(function (err) {\n        console.log('ServiceWorker registration failed: ', err);\n      });\n  });\n}\n```\n\n`sw.js` 中监听 `install` 事件，开启缓存，监听 `fetch` 事件，拦截全站请求，如下：\n\n```js\n/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */\nthis.addEventListener('install', function (event) {\n  /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */\n  event.waitUntil(\n    /* 创建一个名叫V1的缓存版本 */\n    caches.open('v1').then(function (cache) {\n      /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */\n      return cache.addAll([\n        './index.html'\n      ]);\n    })\n  );\n});\n\n/* 注册fetch事件，拦截全站的请求 */\nthis.addEventListener('fetch', function(event) {\n  event.respondWith(\n    /* 在缓存中匹配对应请求资源直接返回 */\n    caches.match(event.request)\n    // 这里还需处理没有缓存的情况\n  );\n});\n```\n\n**注意：**\n1. 使用 SW 后，传输协议必须为 HTTPS。因为涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。\n2. 当 SW 没有命中缓存的时候，需要手动调用 fetch 函数获取数据，这意味着还会受其它 HTTP 缓存机制影响。\n3. 无论从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 SW 中获取的内容。\n4. 注册 SW 后，需要等待下一次刷新页面才能生效。\n5. SW 运行在 Worker 线程中，无法操作 DOM，也无法操作 Cookie。\n6. SW 设计为完全异步，同步API（如XHR和localStorage）不能在 SW 中使用。\n\nSW 这个技术内容还是很多的，现在只是简单介绍了一下，本站也开启了 SW，后续有时间再深入学习。\n\n参考：\n[一文搞懂前端service-worker 技术](https://www.lmcc.top/articles/73.html)\n[网易云课堂 Service Worker 运用与实践](https://mp.weixin.qq.com/s/3Ep5pJULvP7WHJvVJNDV-g)\n\n## Memory Cache\nMemory Cache 是**内存缓存**。存储短时间内频繁访问的资源，读取速度快，但是容量小。会随着进程的关闭而释放。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/87-1.webp\" width=\"60%\" />\n\nMemory Cache 在缓存资源时不受开发者控制，也不受 HTTP 协议头的约束，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。是否缓存资源，以及缓存多久，都是由浏览器策略决定的。\n\n## Disk Cache\nDisk Cache 是**磁盘缓存**。读取速度慢于内存，但容量大，持久性强。不会随着进程的关闭而释放。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/87-2.webp\" width=\"60%\" />\n\nDisk Cache 会根据 HTTP 头中的某些字段判断哪些资源需要缓存。\n\n一些关键的、较小的、访问频繁的 Disk Cache 资源可能会被加载到 Memory Cache 中，这样可以提高访问速度。\n\n即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，且命中缓存，就不会重新请求。\n\n## Push Cache\nPush Cache 是**推送缓存**。HTTP/2 中的概念，当服务器使用 Server Push 功能主动推送资源时，这些资源会被缓存到 Push Cache 中，以备将来使用。\n\n当以上三种缓存都没有命中时，它才会被使用。且只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP/2 头中的缓存指令。\n\n[*HTTP/2 push is tougher than I thought*](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/) 提到的特性：\n1. 所有的资源都能被推送，并且能够被缓存，但是不同浏览器支持的程度不同。\n2. 可以推送 no-cache 和 no-store 的资源\n3. 一旦连接被关闭，Push Cache 就被释放\n4. 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。\n5. Push Cache 中的缓存只能被使用一次\n6. 浏览器可以拒绝接受已经存在的资源推送\n7. 可以给其他域名推送资源\n\n总之，战未来的东西，不必纠结，了解即可。\n\n# 缓存类型\n按**缓存类型**可分为：\n1. **强制缓存** 通过 `Expires` / `Cache-Control` 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 `200 from cache`\n2. **协商缓存** 通过 `Last-Modified` / `If-Modified-Since` 和 `Etag` / `If-None-Match` 控制，开启协商缓存时向服务器发送的请求会带上缓存标识，若命中协商缓存服务器返回 `304 Not Modified` 表示资源未修改，浏览器可以使用本地缓存，否则返回 `200 OK` 正常返回数据。\n\n强缓存和协商缓存，都属于 Disk Cache，也就是狭义上的 HTTP 缓存。\n\n## 强制缓存\n当客户端请求后，会先检查是否命中缓存(缓存存在且未过期)。如果命中则直接返回，未命中才会发送实际 HTTP 请求，响应后再写入 Disk Cache。\n\n受两个 HTTP 字段的控制：\n1. **Expires** 是 HTTP1.0 的字段，在响应时告诉浏览器在过期时间前可以直接使用缓存。\n2. **Cache-Control** 是 HTTP1.1 增加的字段，优先级高于 Expires，可以控制缓存的存储策略。\n\n### Expires\nExpires 设置缓存过期时间，是一个绝对时间\n\n```\nExpires: Wed, 21 Oct 2024 07:28:00 GMT\n```\n\n存在问题：\n1. 服务器和客户端时间可能不一致，导致缓存混乱。\n2. 用户可以手动修改客户端时间，导致缓存失效。\n3. GMT格林尼治标准时间写法复杂。\n\n### Cache-Control\nHTTP1.1 引入了 Cache-Control 字段，优先级高于 Expires，可以控制缓存的存储策略。\n\n**常用的值：**\n1. `max-age=xxx` 指定缓存的最大有效时间，单位为秒。\n2. `no-cache` 不使用强缓存，需要使用协商缓存。\n3. `no-store` 绝对不缓存。\n4. `public` 可以被所有用户缓存，包括终端用户和 CDN 等中间代理服务器。\n5. `private` 只能被终端用户缓存，中间代理服务器不能缓存。\n6. `must-revalidate` 如果超过了 `max-age` 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。\n\n设置 `max-age=3600` 表示资源在 1h 内有效，超过才会向服务器发起请求。\n\n这些值可以混用，以逗号分隔，如 `Cache-Control: max-age=3600, public`。\n冲突时考虑优先级，no-store > no-cache > max-age。\n\n**max-age=0 和 no-cache：**\n1. 从规范定义来说，两者不同，`max-age` 到期是**应该（SHOULD）**重新验证，而 `no-cache` 是**必须（ MUST ）**重新验证。\n2. 但实际情况以浏览器实现为准，大部分情况两者行为是一致的。\n3. 如果是 `max-age=0, must-revalidate` 就和 `no-cache` 等价。\n\n在 HTTP/1.1 之前，如果想使用 no-cache，通常是使用 Pragma 字段，如 Pragma: no-cache（这也是 Pragma 字段唯一的取值）。但该字段并不是标准字段，没有确切的规范，缺乏可靠性，自从 HTTP/1.1 开始，Expires 逐渐被 Cache-control 取代。\n\n为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都会设置。\n\n## 协商缓存\n当强制缓存失效时，就会进入协商缓存阶段。\n协商缓存会向服务器发送请求，并带上资源状态标识，根据服务器返回的响应决定是否使用缓存。\n\n协商缓存的请求与正常请求是一样的，都会实际到达服务器。\n\n**协商的两种情况：**\n1. 返回 304 Not Modified，表示资源未修改，可以继续使用缓存。返回 304 时仅返回头部信息，不返回资源内容。\n2. 返回 200 OK，表示资源已更新，获取最新资源并更新缓存。\n\n协商缓存可以和强制缓存一起使用，作为在强制缓存失效后的一种后备方案。\n\n**由两组字段控制：**\n1. `Last-Modified` / `If-Modified-Since` 是基于时间的协商缓存，资源在服务器上最后修改时间。\n2. `Etag` / `If-None-Match` 是基于内容的协商缓存，资源内容的唯一标识。\n\n实际开发中，两者都会设置，但校验时应优先考虑 `Etag` / `If-None-Match`。\n\n### Last-Modified / If-Modified-Since\n`Last-Modified` 由响应头携带，表示**资源最后修改时间**。在缓存资源时，浏览器会记录这个时间，并在下次请求时会带上 `If-Modified-Since` 字段，服务器根据这个时间判断资源是否更新。\n\n若 `If-Modified-Since` 与此时的 `Last-Modified` 相同，服务器返回 304，表示资源未修改，可以继续使用缓存。\n\n**存在问题：**\n1. 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。\n2. 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，起不到缓存的作用，尽管文件可能没有变化。\n3. 若文件存在重复上传，或打开文档然后又保存，都可能会造成时间的修改，但内容实际上并没有变化。\n\n为了解决这两个问题，HTTP/1.1 增加了 `ETag` 和 `If-None-Match`。\n\n### Etag / If-None-Match\n`Etag` 由响应头携带，是**资源的唯一标识**，如文件hash值。在缓存资源时，浏览器会记录这个标识，并在下次请求时会带上 `If-None-Match` 字段，服务器根据这个标识判断资源是否更新。\n\n若 `If-None-Match` 与此时的 `Etag` 相同，服务器返回 304，表示资源未修改，可以继续使用缓存。\n\n`ETag` 在标识前面加 W/ 前缀表示用弱比较算法（If-None-Match 本身就只用弱比较算法）。\n`ETag` 还可以配合 `If-Match` 检测当前请求是否为最新版本，若资源不匹配返回状态码 412 错误（If-Match 不加 W/ 时使用强比较算法）。\n\n# 缓存读取规则\n缓存读取规则（优先级）：\n1. 从 Service Worker 中获取内容\n2. 查看 Memory Cache\n3. 查看 Disk Cache\n  - 有缓存且未过期，直接使用，不发送请求\n  - 有缓存但已过期，发送请求验证，进入协商缓存，返回 304 或 200\n4. 查看 Push Cache\n5. 发送请求获取资源\n6. 将响应写入 Disk Cache\n7. 将响应写入 Memory Cache（浏览器策略）\n8. 将响应写入 Service Worker 的 Cache Storage\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/87-3.webp\" width=\"70%\" />\n\n# 浏览器行为\n用户对浏览器的不同操作，还会触发不同的缓存读取策略。\n1. 浏览器前进/后退具有特殊缓存，Backward/Forward Cache，即 BF Cache，是指浏览器在前进后退过程中，会应用更强的缓存策略，表现为 DOM、window、甚至 JavaScript 对象被缓存，以及同步 XHR 也被缓存。BF Cache 是一种浏览器优化，HTML 标准并未指定其如何进行缓存，因此缓存行为是与浏览器实现相关的。\n2. 直接输入地址、刷新、跳转链接，都会触发正常的浏览器缓存读取策略。\n3. 强制刷新 (Ctrl + F5)，浏览器不使用缓存，此时发送的请求头部均带有 Cache-control: no-cache（为了兼容，还带了 Pragma: no-cache ）。服务器直接返回 200 和最新内容。\n\n# 最佳实践\n对于经常变动的资源，使用 `Cache-Control: no-cache`\n对于不常变动的资源，使用 `Cache-Control: max-age=31536000`，即 1 年过期，但文件名需要带上 hash 值或版本号，在文件变化后让url也改变，不再命中之前的缓存。\n\n# 实操案例\n\n```js\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","浏览器"],"categories":["学习笔记"]},{"title":"浏览器渲染流程","url":"/article/4aea0348.html","content":"\n# 前言\n动动手写个网页非常简单，因为浏览器帮我们做了很多复杂的工作。\n\n[MDN-渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work) 告诉我们，**导航**是加载 web 页面的第一步，经过**响应**、**解析**、**渲染**，最终得到一个可**交互**的页面。\n\n现在我们聚焦于**解析**与**渲染**，即浏览器通过网络请求开始获取或已经拿到了 HTML 等静态资源。\n\n所谓渲染，就是将**静态资源**转为**可视**、**可交互**的页面（像素信息）。\n\n# 浏览器进程\n进程是 CPU 分配资源的最小单位(能够拥有资源和独立运行的最小单位) \n线程是 CPU 调度的最小单位(运行在进程上的一次程序运行单位)\n\n以Chrome为例，现代化的浏览器是**多进程**的\n1. **浏览器进程** 负责用户界面、子进程管理、提供存储等功能。\n2. **GPU 进程** 负责 3D CSS 渲染、页面绘制、解码等。\n3. **网络进程** 负责发起和接受网络请求。\n4. **渲染进程** 负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎**Blink**和JS引擎**V8**都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程，这是受**进程模型**控制的。\n\n常说的**浏览器内核**也就是浏览器的渲染引擎，即渲染进程，主要包括**排版引擎**和**JS引擎**，如 Chromium、Webkit。Chromium刚开始也是基于Webkit构建的，后面因为架构的需要换成Blink+V8了。\n\n**渲染进程**包含多个**线程**\n1. **JS 引擎线程** 负责解释执行 JavaScript 脚本。\n2. **GUI 渲染线程** 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 Render 树，布局和绘制。\n3. **合成线程** 将图层分为图块，并使用GPU进程，在栅格化线程池中将图块转化为位图。\n4. **事件触发线程** 负责事件的处理，如鼠标点击、滚动等，将事件放入事件队列中。\n5. **定时器触发线程** 负责处理定时器，计算是否到达定时时间，若到达时间则将定时器事件放入事件队列中。\n6. **异步 HTTP 请求线程**(网络线程) 处理异步请求及其回调函数。\n7. **IO 线程** 与其它进程通信。\n\n**注意：**GUI**渲染线程**与**JS引擎线程**是**互斥**的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n## 进程模型\nChrome具有有**四种进程模型**：\n1. `Process-per-site-instance`：**默认模式**。访问不同站点创建新的进程，在旧页面中打开的新页面，且属于**同一站点**的话会共用一个进程。\n2. `Process-per-site`：**同一站点**始终使用同一进程，无论在何处打开。\n3. `Process-per-tab`：每一个标签页都创建新的进程。\n4. `Single Process`：单进程模式，所有页面共用一个进程。\n\n**同一站点：**具有相同协议、**主域名**、端口，这与CORS的同源判定是有区别的。\n\n# 渲染总体流程\n浏览器通过网络请求获取 HTML 字符串。当浏览器收到第一个数据分块，就可以开始解析收到的信息。\n\n**渲染流程**分为多个阶段：HTML 解析、样式计算、布局、分层、生成绘制指令(绘制)、分块、光栅化、绘制(画)。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-1.webp\" width=\"90%\" />\n\n前一个阶段的输出是后一个阶段的输入，这些阶段是**逐步**进行的。\n\n# 解析HTML parse\n**解析 HTML：**浏览器遵守一套步骤将 HTML 转换为 DOM 树 (Document Object Model 文档对象模型)。\n\n**步骤：**字节数据 -> 字符串 -[状态机]-> 词（Token） -> 节点（Node） -> DOM\n\n浏览器首先将字节数据转为字符串，然后通过**状态机**进行**词法分析**，将字符流分解为词，再将词转为节点，最终形成 DOM 树。\n\n这个过程是**循序渐进**的，当浏览器收到首个 HTML 数据块，就会开始构建 DOM 树，由于**自顶向下**构建，因此后面构建的不会对前面的造成影响。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-2.webp\" width=\"90%\" />\n\n**Token** 分为 **TagToken** 和 **TextToken**，TagToken 即标签，又分为开始标签、结束标签、自封闭标签。\n\n## 预解析线程\n在解析 HTML 的过程中，可以能会遇到如 style、link、script 等标签。\n为了提高解析效率，浏览器在开始解析 HTML 前，会启动一个**预解析线程**，率先下载 HTML 中的外部 CSS 文件和外部的 JS 文件。\n\n**对于 CSS：**\n当渲染主线程解析到 link 位置，若外部 CSS 文件还未下载并解析好，主线程**不会等待**，而是**继续解析**后续的 HTML。下载和解析 CSS 的工作都在预解析线程中完成。所以 CSS 不会阻塞 HTML 解析。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-3.webp\" width=\"60%\" />\n\n**对于 JS：**\n当渲染线程解析到 script 位置，会**停止解析** HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。因为 JS 可能会修改 DOM 结构，此时停止构建 DOM 树才能避免解析错误。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-4.webp\" width=\"60%\" />\n\n执行 JS 实际上在 JS 引擎线程，而不是在 GUI 渲染线程，但这两个线程是互斥的，所以 JS 会阻塞渲染。\n\n现代化的浏览器提供了一些**资源提示关键词**，以避免 JS 阻塞渲染。\n1. `async` 异步加载 JS 文件，不等待 JS 文件下载，继续解析 HTML，直到下载完成后再执行 JS。执行时会阻塞 HTML 解析。\n2. `defer` 延迟加载 JS 文件，等到 HTML 解析完成后再执行 JS（在 `DOMContentLoaded` 事件之前），不会阻塞 HTML 解析。如果 async 和 defer 同时存在，async 优先级更高。\n3. `type=\"module\"` 默认为 defer，且 JS 代码会在严格模式下执行，但也可以使用 async。\n4. `rel=\"preload\"` 预加载资源，告诉浏览器提前加载资源，浏览器会**尽快**地加载某个资源，但不执行。preload 优先级高于 prefetch。\n5. `rel=\"prefetch\"` 预取资源，告诉浏览器提前加载资源，通常是未来可能需要的资源，浏览器会在**网络空闲时**下载它，但不执行。\n6. 还有一些，后面开个文章再说。\n\n## 构建CSSOM\nCSS 字符串同样会被解析，构建 CSSOM 树（CSS Object Model）。与构建 DOM 同时进行。\n\nCSSOM 的构建必须要获得一份完整的 CSS 文件，因为存在覆盖等情况。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-5.webp\" width=\"90%\" />\n\nCSSOM 中包含\n1. 通过 link 引用的外部 CSS 样式文件\n2. style 标签内的CSS样式\n3. 元素的 style 属性内嵌的CSS\n\n# 样式计算style、Render树\n得到了 DOM 和 CSSOM，还需要在**样式计算**阶段将两者结合起来，形成 **Render** 树（渲染树）。\n\n渲染树会确定一个节点的**所有**样式属性。计算过程：\n1. 确定声明：如果属性只有一个声明，那么直接应用该声明。\n2. 层叠冲突：如果属性有多个声明，那么进入层叠冲突流程。这一流程分为比较源的重要性、比较优先级和比较次序(声明的先后顺序)三个步骤\n3. 继承：如果属性没有声明且是可继承的属性，那么直接继承最近的父元素属性值。\n4. 默认值：如果一个属性经历了上述三个流程，还无法确定其属性值，那么就使用默认值。\n\n这个阶段还会**标准化属性值**，将各种 CSS 样式，转换为渲染引擎能够理解的、标准化的值。如将 `em` 转为 `px`、`red` 转为 `rgb(255,0,0)`。\n\n**不可见**元素**不会**出现在渲染树上，如 `<head>`、`<script>`、`display: none` 等。应用了 `visibility: hidden` 的节点会包含在渲染树中，因为它们会占用空间、拥有其它样式属性。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-6.webp\" width=\"60%\" />\n\n**注意：**此图还不是渲染树，因为缺失了默认样式，并且没有标准化属性值。\n\n**总结：**每个可见节点都应用了 CSSOM 规则。渲染树包含所有可见节点的内容和计算样式，将所有相关样式与 DOM 树中的每个可见节点匹配起来，并根据 [CSS 层叠](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)，确定每个节点的计算样式。\n\n# 布局layout\n浏览器根据 Render 树中的节点计算它们在屏幕上的确切位置（x，y 坐标）、输出每个元素的 Box Model（盒子模型）、将所有相对测量值(%)都将转换为绝对像素。这个过程称为**布局**。\n\n生成布局树的过程：主线程会遍历刚刚构建的渲染树，根据 DOM 节点的计算样式计算出一个布局树（layout tree）。布局树上每个节点会有它在页面上的 x，y 坐标以及盒子尺寸的具体信息。\n\n# 分层 layer\n**分层**是为了提高渲染性能，将页面分为多个图层。\n\n页面中有很多复杂的效果，如3D变换，页面滚动等，为了更方便的实现这些效果，渲染引擎为特定的节点生成专用的图层，并生成一颗对应的图层树，最后再合成图层。这些图层会按照一定顺序叠加在一起，就形成了最终的页面。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-7.webp\" width=\"70%\" />\n\n分层是自动的，一些属性会触发分层：\n1. 拥有[层叠上下文属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)的元素\n2. 文档根元素、video、canvas、iframe 等元素。\n3. animation 设置了动画的元素\n4. backface-visibility: hidden\n5. 滚动条也是一个单独图层\n6. 需要裁剪的元素，文字较多超过了盒子的高度，会为文字部分单独创建一个图层。\n\n```txt 层叠上下文属性\n文档根元素（<html>）；\nposition 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素；\nposition 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；\nflex (flex) 容器的子元素，且 z-index 值不为 auto；\ngrid (grid) 容器的子元素，且 z-index 值不为 auto；\nopacity 属性值小于 1 的元素（参见 the specification for opacity）；\nmix-blend-mode 属性值不为 normal 的元素；\n以下任意属性值不为 none 的元素：\ntransform\nfilter\nbackdrop-filter\nperspective\nclip-path\nmask / mask-image / mask-border\nisolation 属性值为 isolate 的元素；\nwill-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考这篇文章）；\ncontain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。\n```\n\n# 生成绘制指令paint\n渲染线程会为每个图层单独生成绘制指令，这些指令描述了如何将图层渲染到屏幕上。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-8.webp\" width=\"70%\" />\n\n绘制指令类似于 canvas 的绘图指令\n\n```js\ncontext.beginPath(); // 开始路径\ncontext.moveTo(10, 10); // 移动画笔\ncontext.lineTo(100, 100); // 绘画出一条直线\ncontext.closePath(); // 闭合路径\ncontext.stroke(); // 进行勾勒\n```\n\n这一步只是生成了各图层的绘制指令集，还没有开始执行这些指令。\n\n在开发者工具中，通过Layer标签可以看到图层的绘制列表和绘制过程。\n\n当图层绘制列表准备好之后，渲染主线程会把该绘制列表提交给**合成线程**。剩余的渲染工作（合成操作）都将由合成线程完成。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-9.webp\" width=\"70%\" />\n\n# 分块tiling\n一个图层可能很大，为了提高绘制效率、优先绘制视口区域，合成线程会将图层分成很多小块，这个过程称为**分块**。\n\n这些图块的大小通常是 256x256 或者 512x512。\n\n# 光栅化raster\n将图块转为**位图**，确认每一个像素点的 rgb 信息，这个过程称为**光栅化**。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-10.webp\" width=\"70%\" />\n\n合成线程将需要光栅化的图块提交给 GPU 进程，由 GPU 进程的**光栅化线程池**完成相关操作。会优先将视口区域的图块进行光栅化。\n\n# 绘制draw\n当所有的图块都被栅格化后，合成线程会拿到各个块的**位图**，从而生成一个个 **指引（quad）** 信息。\n\n指引信息会标识出每个位图应该画到屏幕的哪个位置，还会考虑到旋转、缩放等**变形效果**。\n\n**变形**发生在合成线程，与渲染主线程无关，这就是 `transform` 效率高的原因。\n\n合成线程会把指引提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-11.webp\" width=\"70%\" />\n\n合成线程会通过 IPC 向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的 UI线程（UI thread）提交以改变浏览器的 UI。这些合成帧都会被发送给 GPU 完成最终的屏幕成像。\n\n当合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给 GPU 来更新页面。\n\n# 总结\n这些步骤就是[关键渲染路径CRP](https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path)，其中生成绘制指令及其后的步骤可以合并看作是**绘制**步骤。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-12.webp\" width=\"80%\" />\n\n优化关键渲染路径：\n1. 通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量。\n2. 优化必须的请求数量和每个请求的文件体积。\n3. 通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。\n\n# 其它\n\n## 回流reflow\n**回流**（重排 reflow）：对页面的任意部分或整个文档的大小和位置的重新计算。性能开销较大。\n\n本质就是重新计算**布局树**。**回流一定会触发重绘**。\n\n**发生回流的情况：**\n1. 页面首次渲染\n2. 浏览器窗口大小发生变化\n3. 元素尺寸、位置、内容发生变化\n4. 添加或删除可见的DOM元素\n5. 激活CSS伪类\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-13.webp\" width=\"70%\" />\n\n在使用 JS 操作元素样式时，为了避免连续的多次操作可能导致布局树反复计算，浏览器会合并这些样式操作，在 JS 执行完后一次性进行渲染。\n\n若 JS 读取了元素的位置、尺寸等布局相关信息，则会**强制渲染**，这对于制作无缝轮播图以及一些动画效果是非常有用的。\n\n> 查看属性是否会触发回流或重绘：[csstriggers](https://csstriggers.com/)\n\n## 重绘repaint\n当改动了可见样式后，就需要重新计算，会触发**重绘**。\n\n重绘不会触发布局、分层阶段，所以效率比回流要高很多。\n\n本质是重新生成了绘制指令。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/86-14.webp\" width=\"70%\" />\n\n\n\n\n***\n\n**参考：**\n[渲染页面：浏览器的工作原理-MDN](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)\n[深入理解浏览器解析渲染 HTML](https://zhuanlan.zhihu.com/p/445810614)\n[浏览器渲染原理流程](https://347830076.github.io/myBlog/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B.html)\n[画了20张图，详解浏览器渲染引擎工作原理](https://cloud.tencent.com/developer/article/2139806)\n[渲染树构建、布局和绘制](https://web.dev/articles/critical-rendering-path/render-tree-construction?hl=zh-cn)\n[浏览器渲染流程(上) DOM树、CSSOM树、布局](https://juejin.cn/post/7126748165625085983)\n[JS深入浅出 - 浏览器的重绘(Repaint)与回流(Reflow)](https://github.com/jtwang7/JavaScript-Note/issues/2)\n\n\n\n\n\n\n\n\n","tags":["前端","浏览器"],"categories":["学习笔记"]},{"title":"数据类型与拷贝","url":"/article/6e8f8c6c.html","content":"\n# 数据类型\nJS中有**8种**数据类型，分为**基本数据类型**和**引用数据类型**\n\n1. **基本数据类型（值类型）:** String字符串、Number数值、BigInt(ES6)大型数值、Boolean布尔值、Null空值、Undefined未定义、Symbol(ES6)。\n2. **引用数据类型（引用类型）:** Object 对象(除了基本数据类型之外，都可称之为Object类型)。\n\n**存储方式：**\n1. **基本类型**直接保存在**栈**中\n2. **引用类型**存放在**堆**中。在栈空间中只保留了数据在堆中的地址，访问时，通过栈中的引用地址来访问堆中实际的数据。\n\n至于V8堆栈框架，以后再说。\n\n## null 和 undefined\nundefined 表示值的缺失，null 表示对象的缺失。当没有值时，通常默认为 undefined。\n\nnull 是一个关键字，但是 undefined 是一个普通的标识符，恰好是一个全局属性。\n\n早期 undefined 作为全局属性可以被赋值，所以有些人使用 `void 0` 来获取 undefined。\n\n```js null 与 undefined 不严格相等\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\n```\n\nnull 转为数字时为 0，undefined 转为数字时为 NaN。\n\n```js\nconsole.log(+null) // 0\nconsole.log(+undefined) // NaN\n```\n\n# 判断类型\n\n## typeof\n`typeof` 运算符，返回数据类型的字符串，对于引用类型，除了函数，都会返回 object。\n\n```js\nconsole.log(typeof '123'); // string\nconsole.log(typeof 123); // number\nconsole.log(typeof 123n); // bigint\nconsole.log(typeof NaN); // number\nconsole.log(typeof true); // boolean\nconsole.log(typeof Symbol()); // symbol\nconsole.log(typeof undefined); // undefined\nconsole.log(typeof undeclaredVariable); // undefined\n// console.log(typeof document.all) // undefined\n// 对象\nconsole.log(typeof null); // object\nconsole.log(typeof []); // object\nconsole.log(typeof {}); // object\nconsole.log(typeof new Date()); // object\nconsole.log(typeof /123/); // object\n// 函数\nconsole.log(typeof new Function()); // function\nconsole.log(typeof (()=>{})); // function\nconsole.log(typeof class A{}); // function\n```\n\n**null与object：**\n在 JS 的最初版本中，还广泛使用着32位系统，JS 用32个二进制位标识值，其中低三位表示值的类型。\n\ntypeof通过判断存储的机器码的低三位来进行类型判断。\n\n```js\n数据类型\t机器码标识\n对象(Object)\t000\n整数\t        1\n浮点数\t      010\n字符串\t      100\n布尔\t        110\nundefined\t -2^31（全为 1 的 32 位带符号整数)\nnull\t       全为0\n```\n\nnull的机器码标识为全0，而对象的机器码低位标识为000。所以typeof null被误判为Object。\n\n即使在 ES6 时有提案要修复这个bug，但因为兼容性问题被否决，这已经是一个**特性(feature)**不再被修复。\n\n甚至后来出现了[typeof null等于undefined](https://www.cnblogs.com/ziyunfei/p/5618152.html)的bug，被光速改回了原来的样子。\n\n[The history of typeof null](https://2ality.com/2013/10/typeof-null.html)\n\n## constructor\n对象原型上的 `constructor` 属性，返回实例对象的**构造函数**的引用。\n\n通过 `constructor` 判断对象数据类型，但这种方式并不可靠，因为可以通过更改**原型链**来更改 `constructor` 属性。\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(arr.constructor === Array); // true\nconsole.log(arr.constructor === Object); // false\n// 改写原型\nconst obj = {};\nObject.setPrototypeOf(arr, obj);\nconsole.log(arr.constructor === Array); // false\nconsole.log(arr.constructor === Object); // true\n```\n\n## instanceof\n`instanceof` 运算符判断一个**实例**是否属于某种**类型**。\n\n即某个**构造函数**的 `prototype` 属性（原型对象）是否出现在某个实例对象的**原型链**上。\n\n```js\nclass A {}\nclass B extends A {}\nconst b = new B();\nconsole.log(b instanceof B); // true\nconsole.log(b instanceof A); // true\n```\n\n**继承形成了两条原型链：**\n1. 实例的原型对象的 `__proto__` 指向父类的原型对象，这是为了继承父类的**方法**（实例属性在创建对象时，直接作为对象自己的属性实例化，无需通过原型链继承，而实例方法，都在原型上，所以只有实例方法需要通过原型链继承，向上查找）\n2. 构造函数的 `__proto__` 指向父类的构造函数，这是为了继承父类的**静态**属性和方法。\n\n```js\nconsole.log(B.prototype.__proto__ === A.prototype); // true\nconsole.log(B.__proto__ === A); // true\n```\n\n而 `instanceof` 就是通过判断实例的原型链上是否有某个构造函数的 `prototype` 属性（原型对象）来判断实例的类型。\n\n原型链上最后一个原型对象是 `Object.prototype`，所以所有的实例都属于 `Object` 类型，也就是万物皆对象。\n\n类本质是构造函数的语法糖，所以也是 `Function` 类型。\n\n```js\nconsole.log(b instanceof Object); // true\nconsole.log(B instanceof Function); // false\nconsole.log(B instanceof Object); // true\n```\n\n> 之前的笔记 [原型与原型链](https://www.qcqx.cn/article/7d8b8b34.html#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE)\n\n### 手写instanceof\n\n```js\nfunction myInstanceOf(Fn) {\n  if (!this) return false; // 如果this不存在，返回false\n  // 获取Fn的显示原型\n  const prototype = Fn.prototype;\n  // 获取this的隐式原型\n  let obj = Object.getPrototypeOf(this);\n  // 循环往原型链上查找，直到找到原型链尽头null\n  while (obj) {\n    if (obj === prototype) {\n      return true;\n    }\n    // 如果没有找到就继续向上查找\n    obj = Object.getPrototypeOf(obj);\n  }\n  return false;\n}\n// 挂载到所有对象的原型链上\nObject.prototype.myInstanceOf = myInstanceOf;\n```\n\n```js 测试\nclass A {}\nclass B extends A {}\nconst b = new B();\nclass C {}\nconsole.log(b.myInstanceOf(B)); // true\nconsole.log(b.myInstanceOf(A)); // true\nconsole.log(b.myInstanceOf(Object)); // true\nconsole.log(b.myInstanceOf(C)); // false\nconsole.log(B.myInstanceOf(Function)); // true\nconsole.log(B.myInstanceOf(Object)); // true\n```\n\n### 基本包装类型\n基本数据类型没有原型链，所以 `instanceof` 无法判断基本数据类型。\n\n但通过对应**基本包装类型**创建的实例，可以通过 `instanceof` 判断。\n\n三种基本包装类型：String, Number, Boolean。\n\n```js\nconst s = new String('111');\nconst n = new Number(111);\nconsole.log(s instanceof String); // true\nconsole.log(n instanceof Number); // true\nconst ss = '111';\nconst nn = 111;\nconsole.log(ss instanceof String); // false\nconsole.log(nn instanceof Number); // false\n```\n\n基本数据类型在调用属性和方法时，会进行`装箱操作`，把基本类型用它们相应的引用类型包装起来，使其具有对象的性质。会产生一些临时对象。\n\n## is方法\n`isPrototypeOf` 判断一个对象是否是另一个对象的原型。通用会在原型链上查找。\n\n```js\nclass A {}\nclass B extends A {}\nconst b = new B();\nconst bp = Object.getPrototypeOf(b);\nconsole.log(bp.isPrototypeOf(b)); // true\nconsole.log(A.prototype.isPrototypeOf(b)); // true\n```\n\n其它基本包装类型和内置类型也提供了一些 is 方法\n\n```js\nconsole.log(Array.isArray([])); // true\nconsole.log(Array.isArray({})); // false\nconsole.log(Number.isNaN(NaN)); // true\nconsole.log(Number.isNaN(123)); // false\nconsole.log(Number.isInteger(123)); // true\nconsole.log(Number.isInteger(123.1)); // false\nconsole.log(Number.isFinite(Infinity)) // false\n```\n\n### isNaN 和 isFinite\n全局和 Number 对象上都有 `isNaN` 和 `isFinite` 方法，用于判断是否是 NaN 和 有限数。但全局方法会进行**隐式类型转换**再判断，而 Number 对象上的方法则不会。\n\n```js\nconsole.log(isNaN(NaN)) // true\nconsole.log(isNaN({})) // true, Number({}) => NaN\nconsole.log(isNaN('NaN')) // true, Number('NaN') => NaN\nconsole.log(isNaN('123')) // false, Number('123') => 123\nconsole.log(Number.isNaN(NaN)) // true\nconsole.log(Number.isNaN({})) // false\nconsole.log(Number.isNaN('NaN')) // false\nconsole.log(Number.isNaN('123')) // false\n\nconsole.log(isFinite({})) // false\nconsole.log(isFinite(Infinity)) // false\nconsole.log(isFinite('123')) // true, Number('123') => 123\nconsole.log(Number.isFinite({})) // false\nconsole.log(Number.isFinite(Infinity)) // false\nconsole.log(Number.isFinite('123')) // false\n```\n\n## toString\n`Object.prototype.toString.call()` 以 `[object xxx]` 的字符串形式返回**当前调用者的对象类型**。是**最稳妥**的类型判断方式。\n\n必须调用 Object 显式原型上的 `toString` 方法，因为其它数据类，都**重写**了 toString 方法，返回的不再是 `[object xxx]` 类型字符串。\n\n```js\nfunction typeToString(any) {\n  return Object.prototype.toString.call(any).slice(8, -1);\n}\nconsole.log(typeToString([])); // Array\nconsole.log(typeToString((()=>{}))); // Function\nconsole.log(typeToString(123)); // Number\nconsole.log(typeToString(Symbol('a'))) // Symbol\n```\n\n这种方法只能判断**内置类型**和**基本包装类型**，即 Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp 和 String。\n\n```js\nconst a = new class A {};\nconsole.log(typeToString(a)); // Object\n```\n\n对于基本数据类型，会进行**装箱操作**，返回对应的引用类型。这会产生一些临时对象，所以通常需要配合 `typeof` 来判断类型，提高性能。\n\n[为什么Object.prototype.toString.call()可以如此准确的判断对象类型？](https://juejin.cn/post/7116114617834668062)\n\n### 封装类型判断函数\n1. null 比较特殊，typeof 会返回 object，先严格比较后返回 null。\n2. 基本数据类型直接使用 typeof 获取类型，避免装箱操作，提高性能。\n3. 其它引用类型使用 `Object.prototype.toString.call()` 获取类型。\n\n```js\nfunction typeJudge(val) {\n  if (val === null) return 'null';\n  if (typeof val !== \"object\") return typeof val;\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();\n}\nconsole.log(typeJudge([])); // array\nconsole.log(typeJudge({})); // object\nconsole.log(typeJudge(new Date())); // date\nconsole.log(typeJudge(null)); // null\nconsole.log(typeJudge(undefined)); // undefined\nconsole.log(typeJudge(123)); // number\nconsole.log(typeJudge('123')); // string\n```\n\n### Symbol.toStringTag\n`Object.prototype.toString` 会读取一个对象的 `Symbol.toStringTag` 属性，该属性返回值将作为 `[object xxx]` 中的 `xxx`。用于创建对象的默认字符串描述。\n\n应该返回一个字符串，否则会返回默认值，即 `[object Object]`。\n\n可以用于标识自定义类型。\n\n```js\nclass A {\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nconst a = new A();\nconsole.log(Object.prototype.toString.call(a)); // [object A]\n```\n\n**注意：**该属性可以被 `defineProperty` 修改。\n\n```js\nclass A {\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nconst a = new A();\nconsole.log(Object.prototype.toString.call(a)); // [object A]\nObject.defineProperty(a, Symbol.toStringTag, {\n  value: 'B',\n});\nconsole.log(Object.prototype.toString.call(a)); // [object B]\n```\n\n## Promise\nPromise 非常特殊，在 [Promise A+](https://promisesaplus.com/) 规范并没有设计如何创建、解决和拒绝 Promise，而是专注于提供一个通用的 `.then` 方法，换而言之，只要一个对象具有 `.then` 方法，并且符合规范（具有特定参数、返回特定值），就可以称之为 Promise。\n\nPromise A+ 早于 ES6，是社区规范，为了解决回调地狱和异步实现不统一的问题。\nES6 的 Promise 符合 Promise A+ 规范，是对该规范的实现。提供了 `Promise` 类（构造函数）去构建一个 Promise 对象。并提供了除了 `.then` 方法之外的一些方法。\n\n许多早期的第三方库使用的并不是 `Promise` 类构建的 Promise 对象，而是自己实现的 Promise 对象。\n\n下面实现 `isPromise()`，判断一个对象是否是 Promise 对象。\n\n```js\nfunction isObject(val) {\n  return val !== null && (typeof val === \"object\" || typeof val === \"function\");\n}\nfunction isPromise(p) {\n  return p instanceof Promise || (isObject(p) && typeof p.then === \"function\");\n}\nconst p = Promise.resolve();\nconst pp = { then: () => {} };\nconsole.log(isPromise(p)); // true\nconsole.log(isPromise(pp)); // true\n```\n\n## 等比较\n对于 `==` 和 `===` 已经非常熟悉了。\n1. `==` **宽松相等**，会进行**隐式类型转换**，并按照 IEEE754 标准对 NaN、-0 和 +0 进行特殊处理（故 NaN != NaN，且 -0 == +0），[IsLooselyEqual](https://tc39.es/ecma262/#sec-islooselyequal)\n2. `===` **严格相等**，与 `==` 逻辑相同，但**不会**进行**隐式类型转换**。如果类型不同，则返回 false。[IsStrictlyEqual](https://tc39.es/ecma262/#sec-isstrictlyequal)\n\n[JavaScript 中的相等性判断-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)\n\n```js\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\nconsole.log(NaN == NaN) // false\nconsole.log(+0 == -0) // true\n```\n\n`Object.is()` 方法判断两个值是否是相同的值。与 `===` 类似，但是对于 NaN 和 +0 和 -0 的判断有所不同。使用[SameValue](https://tc39.es/ecma262/#sec-samevalue)\n1. `Object.is(NaN, NaN)` 返回 `true`，而 `NaN == NaN` 返回 `false`\n2. `Object.is(+0, -0)` 返回 `false`，而 `+0 == -0` 返回 `true`\n\n```js\nconsole.log(Object.is(NaN, NaN)) // true\nconsole.log(Object.is(+0, -0)) // false\n```\n\n### indexOf 和 includes\n`indexOf` 无法判断 NaN，因为使用的是严格相等。而 `includes` 可以判断 NaN，使用 [SameValueZero](https://tc39.es/ecma262/#sec-samevaluezero) 算法，NaN等于NaN。\n\n```js\nconst arr = [NaN];\nconsole.log(arr.indexOf(NaN)) // -1\nconsole.log(arr.includes(NaN)) // true\nconsole.log(arr.findIndex((val) => Object.is(val, NaN))) // 0\n```\n\n\n# 拷贝\n拷贝，也就是复制数据，对于**基本数据类型**，直接赋值多个变量也互不影响。\n但对于**引用类型**，赋值是**浅拷贝**，多个变量保存同一个引用，指向同一个堆空间，修改其中一个变量，会影响到其它变量。而**深拷贝**，就是完全复制一个对象，包括其内部的对象，开辟新的堆空间，多个变量互不影响。\n\n直接赋值就是复制栈空间的值，对于基本类型，栈存放其数据值，而引用类型，栈存放其引用地址，指向实际存放对象数据的堆内存，所以直接赋值是浅拷贝。\n\n总之，基本类型的浅拷贝复制的就是数据值，而引用类型的浅拷贝，复制的是引用地址。\n\n## 浅拷贝\n除了直接赋值，还有一些方法可以实现浅拷贝。\n\n### Object.assign\n`Object.assign()` 用于将任意多个对象自身的**可枚举属性**拷贝给目标对象，然后返回**目标对象**。\n\n第一层**基本类型**的属性是将值本身复制一份，而**引用类型**的属性是**浅拷贝**。\n\n```js\nconst obj1 = { \n  name: '123',\n  data: {\n    val: 1\n  }\n};\nconst obj2 = {};\nObject.assign(obj2, obj1);\nconsole.log(obj2); // { name: '123' }\nobj2.name = '456';\nconsole.log(obj1.name); // 123，基本类型，直接复制一份\nobj2.data.val = 2;\nconsole.log(obj1.data.val); // 2，引用类型的属性是浅拷贝，修改其中一个对象，会影响到另一个对象\n```\n\n### 展开运算符...\n与 `Object.assign` 类似，也是**浅拷贝**。\n\n```js\nconst obj1 = { \n  name: '123',\n  data: {\n    val: 1\n  }\n};\nconst obj2 = { ...obj1 };\nobj2.data.val = 2;\nconsole.log(obj1.data.val); // 2\n```\n\n### Array.prototype.slice\n`slice` 方法返回一个新的数组，返回原数组指定范围（左闭右开）元素的**浅拷贝**。\n\n```js\nconst arr1 = [1, 2, { val: 3 }];\nconst arr2 = arr1.slice();\narr2[2].val = 4;\nconsole.log(arr1[2].val); // 4\n```\n\n### Array.prototype.concat\n`concat` 方法用于合并若干个数组，返回一个新数组，也是**浅拷贝**。\n\n```js\nconst arr1 = [{ val: 3 }];\nconst arr2 = [{ name: 'aaa' }];\nconst arr3 = arr1.concat(arr2);\nconsole.log(arr3); // [ { val: 3 }, { name: 'aaa' } ]\narr3[0].val = 4;\narr3[1].name = 'bbb';\nconsole.log(arr1[0].val); // 4\nconsole.log(arr2[0].name); // bbb\n```\n\n### 手写函数\n直接遍历对象属性，再添加给新对象。\n\n```js\nfunction clone(target) {\n  let cloneTarget = {};\n  for (const key in target) {\n      cloneTarget[key] = target[key];\n  }\n  return cloneTarget;\n};\n```\n\n## 深拷贝\n浅拷贝是常见的，而为了实现引用数据类型的深拷贝，需要借助其它的方法。\n\n### JSON方法\n`JSON.parse(JSON.stringify())` 先将对象转为JSON字符串，再将JSON转为对象。\n\n```js\nconst obj = {\n  data: {\n    val: 1\n  }\n}\nconst obj2 = JSON.parse(JSON.stringify(obj));\nobj2.data.val = 2;\nconsole.log(obj.data.val); // 1\n```\n\n缺点：\n1. 无法复制函数、正则、Date、undefined、Symbol等内置对象。\n2. 无法解析循环引用的对象，会报错。\n\n```js\nconst obj = {\n  a: new Date(),\n  b: /123/,\n  c: function() {},\n  d: Symbol('123'),\n}\nconst obj2 = JSON.parse(JSON.stringify(obj));\nconsole.log(obj2); // { a: '2024-03-13T02:34:16.846Z', b: {} }\nconsole.log(obj2.a instanceof Date); // false\n```\n\n\n#### 第二参数\n真的没办法复制函数和其它数据类型吗？其实可以。\n`JSON.parse` 和 `JSON.stringify` 可以传入第二个参数，是一个函数，用于自定义**过滤**和**转换**结果。\n\n```js\nconst obj1 = {\n  a: 1,\n  fn: function () {\n    console.log(\"123\");\n  },\n};\nconst obj2 = JSON.parse(JSON.stringify(obj1));\nconsole.log(obj2); // { a: 1 }\n// 传入第二个参数，对函数类型属性进行处理\nconst obj3 = JSON.parse(\n  JSON.stringify(obj1, (key, value) => {\n    if (typeof value === \"function\") {\n      // 将函数转为字符串，并且加上特殊标识\n      return value.toString() + '#function#';\n    }\n    return value;\n  }),\n  (key, value) => {\n    // 将函数字符串转为函数\n    if (typeof value === \"string\" && value.includes(\"#function#\")) {\n      // 去掉特殊标识\n      value = value.replace(\"#function#\", \"\");\n      return new Function(`return ${value}`)();\n    }\n    return value;\n  }\n);\nconsole.log(obj3); // { a: 1, fn: [Function (anonymous)] }\nobj3.fn(); // 123\n```\n\n借助这第二个参数，完全可以实现任何对象的深拷贝。但为了更加灵活可控，还是需要手写递归。\n\n### 手写递归\n深拷贝需要找到对象多层嵌套的最深层的基础数据类型，很显然，需要用到递归。\n\n```js\nfunction deepClone(target) {\n  // 值为空，或为基础类型，直接返回\n  if (!target || typeof target !== \"object\") return target;\n  // 对于对象、数组类型，则遍历其属性，递归深拷贝\n  let obj = Array.isArray(target) ? [] : {};\n  for (key in target){\n    obj[key] = deepClone(target[key]);\n  }\n  return obj;\n}\nconst obj1 = {\n  a: {\n    b: 1,\n    c: [1,2,3]\n  },\n}\nconst obj2 = deepClone(obj1);\nobj2.a.b = 2;\nobj2.a.c[0] = 2;\nconsole.log(obj1); // { a: { b: 1, c: [ 1, 2, 3 ] } }\nconsole.log(obj2); // { a: { b: 2, c: [ 2, 2, 3 ] } }\n```\n\n#### 循环引用\n手写深拷贝目的之一就是解决循环引用，例如原型链等就存在循环引用。\n\n可以使用 hashMap 来存储已经拷贝过的对象，遇到循环引用时，直接返回 hashMap 中的对象。\n\n在这里，map仅作为缓存，可以使用 `WeakMap`，其键必须是对象且是**弱引用**，不会阻止GC对作为键的对象的回收，无需手动清除Map属性，避免内存泄漏。\n\n```js\nfunction deepClone(target, map = new WeakMap()) {\n  // 如果是对象，即引用类型\n  if(typeof target === 'object') {\n    // 判断是数组还是对象\n    let cloneTarget = Array.isArray(target) ? [] : {};\n    // 如果已经克隆过了，直接返回之前的对象\n    if(map.get(target)) {\n      return map.get(target);\n    }\n    // 没有克隆过，就将当前克隆对象存入map中\n    map.set(target, cloneTarget);\n    // 遍历key，对象是属性，数组是索引\n    for(let key in target) {\n      cloneTarget[key] = deepClone(target[key], map);\n    }\n    // 返回克隆对象\n    return cloneTarget;\n  } else {\n    // 不是对象直接返回\n    return target;\n  }\n}\nconst obj1 = {\n  a: {\n    b: 1,\n    c: [1,2,3]\n  },\n}\nobj1.obj = obj1; // 循环引用\nconst obj2 = deepClone(obj1);\nobj2.a.b = 2;\nobj2.a.c[0] = 2;\nconsole.log(obj1); // { a: { b: 1, c: [ 1, 2, 3 ] }, obj: [Circular *1] }\nconsole.log(obj2); // { a: { b: 2, c: [ 2, 2, 3 ] }, obj: [Circular *1] }\nconsole.log(obj1.obj === obj2.obj); // false\n```\n\n#### 遍历性能优化\n`forEach` 和传统的 `for` 循环性能差不多，而 `for in` 性能遥遥落后，`while` 循环性能最好。\n\n```js 性能测试\nconst obj = {\n  a: {},\n  b: {},\n  c: {},\n};\nconsole.time();\nfor (const key in obj) {\n  console.log(key); // a b c\n}\nconsole.timeEnd(); // default: 8.696ms\n\nconsole.time();\nObject.keys(obj).forEach((key) => {\n  console.log(key); // a b c\n});\nconsole.timeEnd(); // default: 0.908ms\n\nconsole.time();\nconst keys1 = Object.keys(obj);\nconst length1 = keys1.length;\nfor (let i = 0; i < length1; i++) {\n  console.log(keys1[i]); // a b c\n}\nconsole.timeEnd(); // default: 1.022ms\n\nconsole.time();\nlet i = -1;\nconst keys2 = Object.keys(obj);\nconst length2 = keys2.length;\nwhile (++i < length2) {\n  console.log(keys2[i]); // a b c\n}\nconsole.timeEnd(); // default: 0.68ms\n```\n\n封装一个通用的遍历函数，用于遍历对象和数组。\n\n```js\nfunction forEach(obj, callback) {\n  // 无需区分数组和对象，因为数组也是对象，直接获取所有key\n  const keys = Object.keys(obj);\n  const length = keys.length;\n  let i = -1;\n  while (++i < length) {\n    // 回调函数传入当前遍历的值和索引\n    callback(obj[keys[i]], keys[i]);\n  }\n}\n\nconst obj = {\n  a: {}, b: {}, c: {},\n};\nforEach(obj, (val, index) => {\n  console.log(val, index); // {} a, {} b, {} c\n});\nconst arr = [1, 2, 3];\nforEach(arr, (val, index) => {\n  console.log(val, index); // 1 0, 2 1, 3 2\n});\n```\n\n修改原来的深拷贝函数，使用封装的 `forEach` 遍历对象。\n\n```js\nfunction deepClone(target, map = new WeakMap()) {\n  // 如果是对象，即引用类型\n  if (typeof target === \"object\") {\n    // 判断是数组还是对象\n    let cloneTarget = Array.isArray(target) ? [] : {};\n    // 如果已经克隆过了，直接返回之前的对象\n    if (map.get(target)) {\n      return map.get(target);\n    }\n    // 没有克隆过，就将当前克隆对象存入map中\n    map.set(target, cloneTarget);\n    // 使用封装的forEach遍历\n    forEach(target, (val, key) => {\n      cloneTarget[key] = deepClone(val, map);\n    });\n    // 返回克隆对象\n    return cloneTarget;\n  } else {\n    // 不是对象直接返回\n    return target;\n  }\n}\nfunction forEach(obj, callback) {\n  // 无需区分数组和对象，因为数组也是对象，直接获取所有key\n  const keys = Object.keys(obj);\n  const length = keys.length;\n  let i = -1;\n  while (++i < length) {\n    // 回调函数传入当前遍历的值和索引\n    callback(obj[keys[i]], keys[i]);\n  }\n}\n```\n\n#### 其它数据类型\n目前只处理了可遍历的对象和数组，还有一些内置对象，如函数、正则、Date、Map、Set等，需要根据其**特性**进行特殊处理\n\n判断数据类型的函数，在前面已经封装过了，这里直接拿来用。\n\n```js 判断数据类型\nfunction typeJudge(val) {\n  if (val === null) return 'null';\n  if (typeof val !== \"object\") return typeof val;\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();\n}\n```\n\n想要处理其它数据类型，就需要掌握它们的特性，这也是为什么，本文先讲数据类型再讲拷贝的原因。\n1. **可继续遍历的类型：**Object、Array、Map、Set，对于这种类型，可以和之前一样继续遍历其属性，递归深拷贝。\n2. **不可继续遍历的类型：**Bool、Number、String、Date、Error、RegExp这几种类型可以直接用其构造函数和原始数据创建一个新对象。\n\n**需要注意的点：**\n1. 由基本包装类型的构造函数 new 出来的对象，是 object 类型。\n2. Map 和 Set 虽然可以直接使用原数据 new 一个新的对象，但是其内部的数据可能是引用类型，所以还是需要递归深拷贝。\n3. 函数和错误类型通常不需要深拷贝，深拷贝没有意义，直接返回即可。\n\n```js 完整代码\n// 遍历函数\nfunction forEach(obj, callback) {\n  // 无需区分数组和对象，因为数组也是对象，直接获取所有key\n  const keys = Object.keys(obj);\n  const length = keys.length;\n  let i = -1;\n  while (++i < length) {\n    // 回调函数传入当前遍历的值和索引\n    callback(obj[keys[i]], keys[i]);\n  }\n  return obj;\n}\n// 获取最准确的数据类型\nfunction typeJudge(val) {\n  if (val === null) return \"null\";\n  if (typeof val !== \"object\") return typeof val;\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();\n}\n// 判断是否是引用数据类型，也就是广泛意义上的对象\nfunction isObject(val) {\n  return val !== null && typeof val === \"object\";\n}\n// 判断是否是函数\nfunction isFunction(val) {\n  return typeof val === \"function\";\n}\n// 获取对象的构造函数\nfunction getConstructor(val) {\n  return val.constructor;\n}\n// 判断是否是可继续遍历类型\nfunction createCanTraverse() {\n  const deepType = [\"object\", \"array\", \"map\", \"set\", \"weakmap\", \"weakset\"];\n  return (type) => deepType.includes(type);\n}\nconst canTraverse = createCanTraverse();\n// 克隆可遍历对象\nfunction createCloneCanTraverse(type, map) {\n  switch (type) {\n    case \"set\":\n    case \"weakset\":\n      return (cloneTarget, target) => {\n        target.forEach((val) => {\n          cloneTarget.add(deepClone(val, map));\n        });\n      };\n    case \"map\":\n    case \"weakmap\":\n      return (cloneTarget, target) => {\n        target.forEach((val, key) => {\n          cloneTarget.set(key, deepClone(val, map));\n        });\n      };\n    default:\n      return (cloneTarget, target) => {\n        forEach(target, (val, key) => {\n          cloneTarget[key] = deepClone(val, map);\n        });\n      };\n  }\n}\n// 克隆其它内置对象类型\nfunction cloneOtherObject(val, type) {\n  // 获取构造函数\n  const Ctor = getConstructor(val);\n  switch (type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"regexp\":\n    case \"date\":\n      return new Ctor(val);\n    case \"error\":\n      return val; // 错误对象无需克隆\n    default:\n      return null;\n  }\n}\nfunction deepClone(target, map = new WeakMap()) {\n  // 如果是对象，即引用类型\n  if (isObject(target)) {\n    // 如果已经克隆过了，直接返回之前的对象\n    if (map.get(target)) {\n      return map.get(target);\n    }\n    // 获取当前对象的类型\n    const type = typeJudge(target);\n    // 先尝试克隆其它对象类型\n    const result = cloneOtherObject(target, type);\n    if (result) {\n      return result;\n    }\n    // 如果result为null，说明是可继续遍历类型，或者修改了toString描述的自定义对象\n    let cloneTarget = {};\n    // 如果是可继续遍历类型，就创建一个对应的新的对象\n    if (canTraverse(type)) {\n      const Ctor = getConstructor(target);\n      cloneTarget = new Ctor();\n    }\n    // 没有克隆过，就将当前克隆对象存入map中\n    map.set(target, cloneTarget);\n    // 克隆可遍历对象\n    createCloneCanTraverse(type, map)(cloneTarget, target);\n    // 返回克隆对象\n    return cloneTarget;\n  }\n  if (isFunction(target)) {\n    // 如果是函数，直接返回，克隆也没什么意义\n    return target;\n  } else {\n    // 基本数据类型直接返回\n    return target;\n  }\n}\n\nconst obj1 = {\n  a: {\n    b: 1,\n    c: [1, 2, 3],\n    reg: /123/,\n    date: new Date(),\n    fn: function () {},\n    sym: Symbol(\"123\"),\n  },\n  set: new Set([1, 2, 3]),\n  map: new Map([\n    [\"a\", 1],\n    [\"b\", 2],\n    [\"c\", { val: 3 }],\n  ]),\n};\nobj1.obj = obj1; // 循环引用\nconst obj2 = deepClone(obj1);\nobj2.a.b = 2;\nobj2.a.c[0] = 2;\nobj2.set.add(4);\nobj2.map.set(\"d\", 4);\nobj2.map.get(\"c\").val = 666;\nconsole.log(obj1);\nconsole.log(obj2);\n/* <ref *1> {\n  a: {\n    b: 1,\n    c: [ 1, 2, 3 ],\n    reg: /123/,\n    date: 2024-03-13T06:41:58.179Z,\n    fn: [Function: fn],\n    sym: Symbol(123)\n  },\n  set: Set(3) { 1, 2, 3 },\n  map: Map(3) { 'a' => 1, 'b' => 2, 'c' => { val: 3 } },\n  obj: [Circular *1]\n}\n<ref *1> {\n  a: {\n    b: 2,\n    c: [ 2, 2, 3 ],\n    reg: /123/,\n    date: 2024-03-13T06:41:58.179Z,\n    fn: [Function: fn],\n    sym: Symbol(123)\n  },\n  set: Set(4) { 1, 2, 3, 4 },\n  map: Map(4) { 'a' => 1, 'b' => 2, 'c' => { val: 666 }, 'd' => 4 },\n  obj: [Circular *1]\n} */\n```\n\n当然还有一些问题没解决：\n1. 对象的原型链没处理\n2. 对象的属性描述符没处理\n3. 如果是dom节点，应该使用 `cloneNode` 方法\n4. 对象不可枚举的属性也没处理\n\n### structuredClone\n写递归太麻烦了，也许可以引入第三方库，比如lodash的_.cloneDeep方法。\n\nJS本身也提供了深拷贝**全局**方法 `structuredClone`，且支持循环引用。需要注意[兼容性](https://developer.mozilla.org/zh-CN/docs/Web/API/structuredClone#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7)，Chrome98、Node17 等以上才支持\n\n具有两个参数：\n1. `value` 要克隆的对象：任意结构化可克隆类型。\n2. `transfer` 可转移的对象的数组：其中的[可转移对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Transferable_objects)将被**移动**到新的对象，而不是克隆至新的对象。\n\n```js\nconst obj1 = {\n  date: new Date(),\n  reg: /123/,\n  a: {\n    b: 1\n  }\n}\nobj1.obj = obj1; // 循环引用\nconst obj2 = structuredClone(obj1);\nconsole.log(obj2);\n/* <ref *1> {\n  date: 2024-03-13T07:55:00.334Z,\n  reg: /123/,\n  a: { b: 1 },\n  obj: [Circular *1]\n} */\nobj2.a.b = 2;\nconsole.log(obj1.a.b); // 1\n```\n\n[structuredClone](https://developer.mozilla.org/zh-CN/docs/Web/API/structuredClone) 使用[结构化克隆算法](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)，不能克隆函数、DOM节点、Symbol、不可枚举属性，对象的某些特定参数也不会被保留（属性描述符、setters、getters、原形链上的属性、RegExp对象的lastIndex字段）\n\n### MessageChannel\n[MessageChannel](https://developer.mozilla.org/zh-CN/docs/Web/API/Channel_Messaging_API)用于在不同的浏览器上下文，比如window.open()打开的窗口、iframe、多个work等之间建立通信管道，并通过两端的端口（port1和port2）以DOM Event的形式发送消息，为**宏任务**。兼容性非常好。\n\nVue的nextTick在2.5版本也使用了MessageChannel，setImmediate -> MessageChannel -> setTimeout 0\n\n```js\nif (typeof MessageChannel === 'function') {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = nextHandler;\n  port.postMessage(1);\n}\n```\n\n```js 快速上手\nconst mc = new MessageChannel();\nconst [p1, p2] = [mc.port1, mc.port2];\np2.postMessage(123);\np1.onmessage = (e) => {\n  console.log(e.data); // 123\n  p1.close();\n};\n```\n\n`close` 方法断开该端口的连接，停止流向该端口的消息，也不再能发送消息。\n\n可以使用 `addEventListener` 监听 message 事件，但要显式调用 `start()` 接收在端口上排队的消息，DOM 0级事件 `onmessage` 则会自动开始接收消息。在开始接收消息前，另一个端口发送的消息会进入缓冲区。\n\n消息在发送和接收的过程需要序列化和反序列化，可以实现**深拷贝**，同时也意味着消息只能基本类型或结构化可克隆对象。\n\n```js\nconst mc = new MessageChannel();\nconst [p1, p2] = [mc.port1, mc.port2];\nconst obj1 = {\n  a: { b: 1 },\n};\np1.postMessage(obj1);\np2.onmessage = (e) => {\n  let obj2 = e.data;\n  obj2.a.b = 2;\n  console.log(obj1.a.b); // 1\n  p2.close();\n};\n```\n\n通过 promise 封装深拷贝函数。\n\n```js\nfunction deepClone(obj) {\n  return new Promise((resolve) => {\n    const mc = new MessageChannel();\n    mc.port2.postMessage(obj);\n    mc.port1.onmessage = (e) => {\n      mc.port1.close();\n      resolve(e.data);\n    };\n  });\n}\nconst obj = {\n  a: { b: 1 },\n};\nobj.obj = obj; // 循环引用\ndeepClone(obj).then((res) => {\n  console.log(res === obj); // false\n  console.log(res); // <ref *1> { a: { b: 1 }, obj: [Circular *1] }\n});\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JS"],"categories":["学习笔记"]},{"title":"一点点网络知识","url":"/article/1e4e2709.html","content":"\n# 前言\n**计算机网络：**是一个将**分散**的、具有**独立**功能的**计算机系统**，通过**通信设备**与**线路**连接起来，由功能完善的**软件**实现**资源共享**和**信息传递**的**系统**。\n\n计网的东西很多，但具体底层的东西，现在还没必要去深究，前端中的网络知识更多是关注偏上层的内容，如TCP、HTTP等，以及相关的技术和工具。\n\n# 分层体系结构\n计算机网络是个复杂的系统，**分层**可将复杂的问题转为若干较小的局部问题，易于研究与处理。\n\n常见的分层体系结构：\n1. **OSI七层模型** OSI（Open System Interconnect）开放式系统互联。是ISO（国际标准化组织）组织在1985年研究的网络互连模型。\n2. **TCP/IP四层模型** OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。\n3. **五层原理模型** 便于对计算机网络进行理解和学习的教学模型。\n\nOSI七层模型：\n1. **物理层** 传输数据的物理媒介，如电缆、光纤、无线电波等。\n2. **数据链路层** 传输数据的链路，如以太网、无线局域网等。\n3. **网络层** IP寻址和路由选择。\n4. **传输层** 建立进程间的端到端连接，如TCP、UDP。\n5. **会话层** 建立会话连接。\n6. **表示层** 提供数据格式转换、数据加密、数据压缩等功能。\n7. **应用层** 为应用程序提高网络服务。\n\nTCP/IP四层模型：\n1. **网络接口层** 物理层、数据链路层的合并。\n2. **网际层** 网络层。\n3. **传输层** 传输层。\n4. **应用层**：会话层、表示层、应用层的合并。\n\n而**五层原理模型**是在TCP/IP模型的基础上，将物理层、数据链路层分开，便于理解和学习。\n\n## 术语\n1. **实体** 任何可发送和接收信息的**硬件**或**软件进程**。\n2. **对等实体** **相同层次**中的实体。\n3. **协议** 控制两个**对等实体**进行**逻辑通信**的规则集合。\n\n**协议**的**三要素：**\n1. **语法** 定义所交换信息的格式\n2. **语义** 定义收发双方要完成的操作。\n3. **时序** 定义操作的时序关系。\n\n**服务：**\n1. 本层使用下层的服务，实现本层的协议，并完成对等实体的**逻辑通信**。\n1. 在协议的控制下，两个对等实体进行逻辑通信，使得本层能够向上层提供服务。\n2. 协议是**水平**的，而服务是**垂直**的。\n3. 实体能使用相邻下层提供的服务，但不知道实现服务的具体协议，下层的协议对上层是**透明**的。\n4. **服务访问点** 在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。\n5. **服务原语** 上层使用下层服务的方式（需要交换的**命令**）。\n6. **服务数据单元SDU** 服务访问点之间交换的**数据包**。\n7. **协议数据单元PDU** 对等实体之间交换的**数据包**。\n\n\n## 五层原理模型\n**物理层：**\n1. **数据包：** 比特流\n2. **协议任务：**规定传输媒体的机械、电气、功能和过程特性。\n3. 考虑如何在连接各种设备的**物理传输媒介**上传输数据(**比特流**)。\n4. 为数据链路层屏蔽了各种物理传输媒介的差异，使链路层只需考虑如何完成自己的协议和服务，而不必考虑网络的物理细节。\n\n**数据链路层：**\n1. **数据包：**帧\n2. **服务访问点：**帧的类型字段\n3. **封装成帧：**将网络层的数据包封装成帧，添加**帧头**和**帧尾**。\n4. **透明传输：**对网络层交付的数据没有限制，就好像链路层不存在一样。通过比特填充或字符填充实现。\n5. **差错检测：**使用**差错检测码**，通过奇偶校验、CRC循环冗余校验等方法检测数据的**比特差错**。\n6. **可靠传输：**检测到**误码**后，不可靠传输**直接丢弃**有误码的帧，可靠传输则想办法实现接收到的数据与发送的数据一致。如停止等待协议SW、回退N帧协议GBN、选择重传协议SR。\n7. **有线链路**误码率较低，一般不要求链路层提供可靠传输服务，即使有误码也由上层进行处理。而**无线链路**易受干扰，误码率较高，所以链路层必须提供可靠传输服务。\n8. 可靠传输并不只在链路层实现，各层都有不同的**传输差错**，如分组丢失、分组重复、报文段丢失等，各层都可以根据应用需求，选择提供可靠传输服务。\n9. **点对点PPP协议** 实现了透明传输、差错检测、向上提供**不可靠**传输服务。\n10. **媒体接入控制MAC** 信道复用、CSMA/CD(多址接入、载波监听、碰撞检测)\n11. **MAC地址：**每个主机（接口）的唯一标识，一般被固化在网卡（网络适配器）上，也称为硬件地址。\n\n**网络层：**\n1. **数据包：**IP数据报或分组\n2. **服务访问点：**IP数据报首部的协议字段\n3. **路由选择：**选择合适的路径，将数据包从源主机传输到目的主机。\n4. **分组转发：**将数据包从一个网络节点传输到另一个网络节点。\n5. **IP地址：**每个主机和路由器的唯一标识，由**网络号**和**主机号**组成。\n6. **子网掩码：**用于划分网络号和主机号。\n7. **路由器：**实现了网络层的功能，负责**转发**数据包，**选择**合适的路径，**拥塞控制**等。\n8. **ARP**地址解析协议：将IP地址解析为MAC地址。\n\n**传输层：**\n1. **数据包：**TCP报文段或UDP用户数据报\n2. **服务访问点：**端口号\n3. 面向通信的最高层，面向用户功能的最低层。\n4. 为运行在不同主机上的**应用进程**提供端到端的**逻辑通信**。\n5. **端口：**通过端口号来区分不同的应用进程。将数据包交付给正确的应用进程。\n6. **TCP** 提供**可靠**的、面向**连接**的、**字节流**的**通信服务**。\n7. **UDP** 提供**不可靠**的、无连接的、**数据报**的**通信服务**。\n8. **拥塞控制：**TCP通过**滑动窗口**、**超时重传**、**拥塞窗口**、慢开始和拥塞避免、快重传和快恢复。\n\n**应用层：**\n1. **数据包：**报文\n2. **DHCP**动态主机配置协议：为主机分配IP地址。基于UDP。\n3. **ICMP**网际控制报文协议：报文发送出错的处理。终点不可达、超时、源点抑制等。\n4. 客户/服务器模型：客户端向服务器请求服务，服务器向客户端提供服务。\n5. P2P模型：网络中的每个主机既是客户端也是服务器。数据不再存储在中心服务器上。\n6. DNS域名系统：将域名解析为IP地址。\n7. FTP文件传输协议：文件传输。\n8. 电子邮件：SMTP、POP3、IMAP。\n9.  WWW万维网：基于HTTP协议的分布式信息系统。由URL（统一资源定位符）对资源定位，这些资源通过HTTP协议传输。\n10. HTTP超文本传输协议：使用TCP协议进行可靠传输。\n\n# TCP\n**传输控制协议**（Transmission Control Protocol，简称 TCP）是一种 **面向连接**（连接导向）的、可靠的、 基于 IP 协议的传输层协议。\n1. **面向连接：**每条 TCP 连接只能有两个端点（亦即点对点，不可广播、多播），每一条 TCP 连接只能是一对一。\n2. **可靠的传输服务：**通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达，丢包时通过重传机制进而增加时延实现可靠性。\n3. **全双工通信：**TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。\n4. **字节流：**面向字节流，TCP 中的 流（Stream）指的是流入进程或从进程流出的字节序列。\n5. **流量缓冲：**解决速度不匹配问题。\n\n**数据包结构:**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-1.webp\" width=\"80%\" />\n\nTCP 首部标志比特有 6 个：URG、ACK、PSH、RST、SYN、FIN\n\n| 控制位 | 名称               | 说明                               |\n|--------|--------------------|------------------------------------|\n| URG    | Urgent Flag        | 紧急指针                           |\n| **ACK**    | Acknowledge Flag   | 确认序号有效                       |\n| PSH    | Push Flag          | 尽可能快地将数据送往接收进程       |\n| RST    | Reset Flag         | 可能需要重现创建建 TCP 连接        |\n| **SYN**    | Synchronize        | 同步序号来发起一个连接             |\n| **FIN**    | Finish             | 发送方完成发送任务，要求释放连接   |\n\n两个32位号：\n1. **Seq**(Sequance number) **序列号**，是上次已成功发送的序号+1。\n2. **Ack**() **确认序号**，让发送方(对方)下一次发送的序号，即接收方下一次期望收到的序号。\n\n## 三次握手\nTCP 提供**面向连接**的通信传输，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。\n\n**目的：**\n1. 同步连接双方的 Sequence 序列号和确认号。\n2. 交换 TCP 窗口大小信息，如 MSS、窗口比例因子、选择性确认、指定校验和算法。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-2.webp\" width=\"80%\" />\n\n握手过程中传送的包里不包含数据，但第三次握手可以发送数据。\n\n\n## 四次挥手\n断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。\n\n由于 TCP 连接是**全双工**的，因此，每个方向都必须要单独进行关闭，\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-3.webp\" width=\"80%\" />\n\n在客户端发送最后一个ACK包后，会进入 **TIME_WAIT** 超时等待状态，通常持续1-4分钟，这是为了实现**可靠、稳定的**传输，若该ACK包丢失了，服务端会超时重发FIN包，客户端接收到重发的FIN包后，重新发送ACK包。\n\n# 输入url后\n浏览器输入url后：\n1. **解析URL** 解析出协议、域名、端口、资源路径、参数等。\n2. **[查询缓存]** 如果HTTP缓存命中，则直接返回缓存资源。详见：[浏览器HTTP缓存](/article/7343d222.html)\n3. **DNS解析** 若域名部分是一个主机名，则通过DNS将域名转换为IP地址。\n4. **建立TCP连接** 三次握手。\n5. **[SSL/TLS]** 如果是 HTTPS 协议，还需要进行 SSL/TLS 握手过程，以协商出一个会话密钥，用于消息加密，提升安全性。\n6. **发送HTTP请求** HTTP请求中包含了浏览器需要获取的资源的相关信息，如请求的方法、资源的路径、查询参数、请求头部信息等。服务器收到HTTP请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。\n7. **接收服务器响应** 获取页面所需的各种资源。\n8. **页面渲染** 将静态资源转为可视、可交互的页面，详见：[浏览器渲染流程](/article/4aea0348.html)。\n9. **断开TCP连接** 四次挥手。\n\n## DNS解析\n域名具有**分层结构**，以 `www.baidu.com` 为例\n1. `com` 是顶级域名\n2. `baidu.com` 是主域名、一级域名\n3. `www.baidu.com` 是子域名、二级域名\n\n**DNS 域名解析系统**（Domain Name System）是将域名转换为IP地址的服务器。\n\nDNS 服务器也具有对应的层级结构，每个层的域名上都有自己的域名服务器，最顶层的是根域名服务器。\n1. **本地域名服务器**\tDNS Resolver 或 Local DNS。本地域名服务器是响应来自客户端的递归请求，并最终跟踪直到获取到解析结果的 DNS 服务器。例如用户本机自动分配的 DNS、运营商 ISP 分配的 DNS、谷歌/114 公共 DNS 等。\n2. **根域名服务器**\tRoot NameServer，本地域名服务器在本地查询不到解析结果时，则第一步会向它进行查询，并获取顶级域名服务器的 IP 地址。\n3. **顶级域名服务器**\tTLD（Top-level）NameServer。负责管理在该顶级域名服务器下注册的一级域名。例如 www.example.com、.com 则是顶级域名服务器，在向它查询时，可以返回一级域名 example.com 所在的权威域名服务器地址。\n4. **权威域名服务器**\tAuthoritative NameServer。在特定区域内具有唯一性，负责维护该区域内的域名与 IP 地址之间的对应关系，例如云解析 DNS。\n\n**DNS解析过程：**\n1. 查询浏览器自身DNS。\n2. 操作系统DNS。\n3. 本地 hosts 文件。\n4. 向域名服务器发送请求。\n\n**DNS查询方式：**\n1. **递归查询** 如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。\n2. **迭代查询** 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。\n\n通常**客户端**与**本地域名服务器**之间是**递归查询**，而**本地域名服务器**与**其它层级**之间是**迭代查询**。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-4.webp\" width=\"80%\" />\n\n# 跨域\n老生常谈的**跨域**问题，是由于**浏览器**的**同源策略**导致的。\n\n**详见：**\n[AJAX请求相关-跨域](/article/f3334fd0.html#跨域)\n[Node-回眸[三]-CORS](/article/9b01fd71.html#CORS)\n[跨源资源共享（CORS）-MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n[跨域资源共享 CORS 详解-阮一峰](https://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n同源策略：**协议**、**域名**、**端口** 三者相同，即为同源，否则为跨域。\n\n**解决跨域问题：**\n1. fetch 设置 no-cors 模式，在该模式下，浏览器不会将Origin包含在请求偷中，并且服务器的响应是不透明的，JS无法获取响应内容。此模式适用于不需要服务器响应的情况，例如向第三方分析服务发出请求。\n```js\nfetch('https://share.qcqx.cn/', {\n  mode:  'no-cors' ,\n  method: 'GET',\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error(error))\n```\n1. **JSONP** 利用 script 标签的 src 属性不受同源策略限制的特点，通过动态创建 script 标签，将请求的数据作为查询参数，服务器返回的数据会被当做 JS 代码执行(通常是调用一个函数，将数据作为该函数的参数)。\n```js\nfunction jsonp(url, name) {\n  const script = document.createElement('script');\n  script.src = url + '?callback=' + name;\n  document.body.appendChild(script);\n  return new Promise((resolve, reject) => {\n    // 全局记录回调函数，服务器返回的数据会被当做 JS 代码执行，即执行回调函数\n    window[name] = data => {\n      resolve(data);\n      document.body.removeChild(script);\n    }\n  })\n}\njsonp('https://share.qcqx.cn/', 'callback').then(console.log);\n// 后端部分\nconst data = {\n  name: 'chuckle'\n}\napp.all('/test', (req,res)=>{\n  const { callback } = req.query;\n  // 返回数据，即执行回调函数，将数据作为参数\n  res.end(`callback(${data.name})`);\n})\n```\n1. **CORS**（Cross-Origin Resource Sharing）跨源资源共享，服务器端设置响应头，以允许跨域请求。通常还需要设置允许的请求头、请求方式、是否携带cookie等。\n```js\n// 请求来源白名单\nconst allowedOrigins = [\"127.0.0.1:5500\", undefined];\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  // 判断请求来源是否在白名单内\n  if (\n    (origin && allowedOrigins.some((item) => origin.includes(item))) ||\n    allowedOrigins.includes(origin)\n  ) {\n    // 设置允许跨域的域名，*代表允许任意域名跨域\n    res.header('Access-Control-Allow-Origin', origin);\n    // 允许的header类型，如下设置允许自定义header、允许Content-Type为非默认值等，按需删改\n    res.header('Access-Control-Allow-Headers', \"*, Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n    // 跨域允许的请求方式 \n    res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, PATCH ,OPTIONS');\n    // 跨域的时候是否携带cookie\n    // 需要与 XMLHttpRequest.withCredentials 或 Fetch API 的 Request() 构造函数中的 credentials 选项结合使用\n    res.header(\"Access-Control-Allow-Credentials\", true);\n    if (req.method.toLowerCase() == 'options') {\n      res.send(200); // 让options请求快速结束\n    }\n    else {\n      next();\n    }\n  } else {\n    res.status(403).send('Forbidden');\n  }\n})\n```\n1. **本地代理：**webpack、vite等构建工具都提供了代理配置，将请求代理到本地服务器，再由本地服务器请求真实数据，从而避免跨域问题。只能用于开发环境。\n2. nginx 代理，将请求代理到后端服务器，避免跨域。适合生产环境。\n\n# ajax相关\n详见：[AJAX请求相关](/article/f3334fd0.html)\n\n# SSE\n详见：[Node-回眸[三]-SSE单工通信](/article/9b01fd71.html#SSE单工通信)\n\n# WebSocket\n详见：[Node-回眸[三]-WebSocket双工通信](/article/9b01fd71.html#WebSocket双工通信)\n\n# JWT\n[JWT-JSON Web Token](https://jwt.io/introduction) 用于会话控制、用户认证，**无状态**，通常无需服务端存储。\n\nJWT 以 JSON 对象的形式安全地传输信息。该信息可以被验证和信任，因为它是经过数字签名的。\n\nJWT 由三部分组成，使用 Base64 编码，以点号分隔：\n1. **Header** 头部，包含了两部分：token 的类型（即 JWT）和使用的加密算法（如 HMAC SHA256 或 RSA）。\n2. **Payload** 负载，包含了要传递的信息，如用户 ID、用户名等。\n3. **Signature** 签名，由头部、负载、密钥、加密算法生成，用于验证消息的完整性、防止篡改。\n\n> 可以使用 [jwt.io 调试器](https://jwt.io/#debugger-io)、[jwt解密/加密](https://www.bejson.com/jwt/) 在线验证和生成 JWT。\n\n**Payload** 预先定义了7个**标准字段**，这些字段是推荐的，但不是必须的：\n1. **iss** (issuer)：签发者\n2. **sub** (subject)：主题\n3. **aud** (audience)：受众\n4. **exp** (expiration time)：过期时间\n5. **nbf** (Not Before)：生效时间\n6. **iat** (Issued At)：签发时间\n7. **jti** (JWT ID)：编号\n\n**签名：**\nJWT 会使用**头部中指定的加密算法**（如 HS256）对头部和负载进行签名，作为 **Signature** 部分。\n签名只是用于验证 token 的完整性，在使用密钥加密后可进行验证，防止篡改。\n**校验过程：**使用相同的密钥和算法对头部和负载进行签名，然后与接收到的签名进行比较，若一致则验证通过。\n\n```js HS256签名\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret // 密钥\n)\n```\n\n负载半身并不加密，只是 Base64 编码，所以**不要在 JWT 中存储敏感信息**，如密码等。\n\njwt 通常放在请求头的 `Authorization` 字段中：\n\n```text\nAuthorization: Bearer <token>\n```\n\n在 Node 和 Nest 中使用 JWT，**详见：**\n[NodeJS接口、会话控制#token](/article/a1e193d6.html#token)\n[NestJS[三]-进阶#JWT-token](/article/73b2ab6d.html#JWT-token)\n\n# 前端网络状态\n`navigator.onLine` 返回一个布尔值，表示用户的设备是否与网络连接，即是否在线。\n\n**window 的两个事件：**\n1. **online** 从离线状态变为在线状态时触发。\n2. **offline** 从在线状态变为离线状态时触发。\n\n```js\nwindow.addEventListener('online', () => {\n  console.log('online');\n});\nwindow.addEventListener('offline', () => {\n  console.log('offline');\n});\n```\n\n**区分强弱网络环境：**\n`navigator.connection` 返回 `NetworkInformation` 对象，包含了用户设备的网络信息。\n\n```js\n{\n  downlink: 10 // 预估下行速度，单位Mbps\n  effectiveType: \"4g\" // 网速类型，如 4g、3g、2g、slow-2g\n  onchange: null // 网络状态变化时触发的事件，可监听\n  rtt: 150 // 预估往返时间，单位ms\n  saveData: false // 是否开启数据节省模式\n}\n```\n\n# XSS\nXSS 跨站脚本攻击（Cross-Site Scripting）\n\n**方式：**在目标网站 HTML 页面中注入恶意脚本，并使之执行，从而获取用户 cookie、token 等敏感信息。\n**本质：**恶意代码未经过滤，与网站正常的代码混在一起，被浏览器执行。\n\n可分为三种类型\n1. **反射型** 将恶意脚本放在 URL 中，通常需要用户手动点击。\n2. **存储型** 将恶意脚本存储在数据库中。最严重。\n3. **DOM型** 修改页面的DOM节点，将恶意脚本插入到页面中。\n\n实际上几种类型通常是混合使用的。最后总是要通过漏洞将恶意脚本插入到页面中执行。\n\n**一个XSS靶场：**[xssaq](https://xssaq.com/yx/level1.php)\n\n例子：\n\n```html\n<textarea id=\"input\"></textarea>\n<div id=\"root\"></div>\n<script>\n  const input = document.getElementById('input');\n  const root = document.getElementById('root');\n  input.addEventListener('keydown', function (e) {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      root.innerHTML = input.value;\n      input.value = '';\n    }\n  });\n</script>\n```\n\n用户输入的内容未经过滤就插入到页面中。**有效载荷（Payload）：**\n\n```html\n<script>alert(document.cookie)</script>\n<img src=\"x\" onerror=\"alert(document.cookie)\">\n<input onfocus=\"alert(document.cookie)\" autofocus>\n<a href=\"javascript:alert(document.cookie)\"></a>\n```\n\n**常见攻击漏洞：**\n1. **未过滤的用户输入** 如上例，常见于评论、搜索等，innerHTML 会将输入的内容解析为 HTML。\n2. **标签拼接漏洞** 常见于后端模板渲染时，未进行 HTML 实体字符转义。\n3. **提前闭合标签** 对于 input、textarea 等原生会将输入数据转为字符串的标签，可以通过提前闭合标签绕过。\n4. **0级事件注入**，如 `onerror`、`onload`、`onclick` 等。\n5. 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码\n\n```js\n// 提前闭合标签\nfunction serverRender(input) {\n  const html = `<input type=\"text\" value=\"${input}\">`\n  const root = document.getElementById('root');\n  root.innerHTML = html;\n}\nserverRender('\"><img src=\"x\" onerror=\"alert(document.cookie)\">')\n```\n\n现代化的浏览器通常已经对 XSS 的代码注入进行了一定的防护。HTML5 也规定了不执行由 innerHTML 插入的 script 标签。\n\n## 防护手段\n1. **转义字符** 将特殊字符转义为 [HTML 实体字符](https://developer.mozilla.org/zh-CN/docs/Glossary/Entity)，如 `<` 转为 `&lt;`。\n2. 对 `javascript:` 进行过滤。\n3. Cookie 开启 `HttpOnly`，防止 JS 访问。\n4. **CSP** Content-Security-Policy 内容安全策略，限制页面加载的资源。\n\n```js\nroot.innerHTML = input.value.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n```\n\n实际生产中，应使用成熟的 XSS 防护库，如：[xss](https://www.npmjs.com/package/xss)\n\n# CSP 内容安全策略\n[CSP 内容安全策略(Content Security Policy)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP) 约束可信内容来源，是一种白名单机制，用于削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。\n\n两种配置方式：\n1. **HTTP 头部** 设置 `Content-Security-Policy` HTTP 头部。\n2. **meta 标签** 添加 `<meta http-equiv=\"Content-Security-Policy\" content=\"...\">`。\n\ncontent 为规则，包括指令(限制选项)与值，多个值使用空格分割，指令之间用分号分隔。如果同一个限制选项使用多次，只有首个会生效。\n\n```js\nContent-Security-Policy: script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:\n```\n\n启用后，不符合 CSP 规则的外部资源就会被阻止加载。\n\n## 限制选项\nCSP 提供了很多限制选项，涉及安全的各个方面。\n\n**资源加载限制：**\n1. `script-src`：用于控制脚本资源的加载和执行。\n2. `style-src`：会控制样式表 `@import` 和 `rel` 时所引入的 URI 资源，设置 `unsafe-inline` 规则可以是浏览器拒绝解析内部样式和内联样式定义。并不会阻止链入外部样式表。\n3. `img-src`：可以控制图片资源的连接，包括 img 标签的 src 属性，以及 CSS3 中的 `url()` 和 `image()` 方法，以及 link 标签中的 href 属性（当 rel 设置成与图像相关的值，比如 HTML 支持的 icon）\n4. `font-src`：控制 CSS 中的 @font-face 加载的字体源地址\n5. `frame-src`：设置允许通过类似 `<frame>` 和 `<iframe>` 标签加载的内嵌内容的源地址\n6. `manifest-src`：限制应用声明文件的源地址\n7. `media-src`：控制媒体类型的外部链入资源，如 `<audio>`、`<video>`、`<source>` 和 `<track>` 标签的 src 属性\n8. `object-src`：控制 `<embed>`、`<code>`、`<archive>`、`<applet>` 等对象\n9. `prefetch-src`：指定预加载或预渲染的允许源地址\n10. `connect-src`：控制 XMLHttpRequest 中的 `open()`、WebSocket、EventSource\n\n`default-src` 是一个通用的资源加载限制选项，可以作为其他限制选项的默认值。其它选项的值会覆盖默认值。\n\n**URL 限制：**\n1. `frame-ancestors`：限制嵌入框架的网页\n2. `base-uri`：限制`<base#href>`\n3. `form-action`：限制`<form#action>`\n\n**其他限制：**\n1. `block-all-mixed-content`：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）\n2. `upgrade-insecure-requests`：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议\n3. `plugin-types`：限制可以使用的插件格式\n4. `sandbox`：浏览器行为的限制，比如不能有弹出窗口等。\n5. `report-uri` 向指定url上报违反 CSP 的行为，POST 请求，包含 JSON 数据。仅在使用 HTTP 头部时有效。\n\n## 选项值\n1. `'none'`：禁止加载任何外部资源\n2. `'self'`：只允许加载同源资源\n3. **主机名**：example.org，https://example.com\n4. **路径名**：example.org/resources/js/\n5. **通配符**：\\*.example.org，\\*://\\*.example.com:*（表示任意协议、任意子域名、任意端口）\n6. **协议名**：https:、data:，注意末尾的冒号\n\n## script-src\n`script-src` 控制脚本资源的加载和执行，具有一些额外的特殊值\n\n1. `unsafe-inline`：允许执行页面内嵌的`<script>`标签和事件监听属性，如`onclick`、`onerror`等。\n2. `unsafe-eval`：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。\n3. `nonce-值`：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行\n4. `hash-值`：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。\n\n**nonce值：**\n\n```js\nContent-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3'\n// 页面内嵌脚本，nonce属性必须为该 token 才能执行。\n<script nonce=\"EDNnf03nceIOfn39fn3e9h3\"></script>\n```\n\n**hash值：**\n\n```js\nContent-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='\n// 浏览器会计算脚本内容的哈希值与配置的哈希值进行比对，一致则执行。\n<script type=\"text/javascript\">\n  alert('Hello, world.');\n</script>\n```\n\n`style-src` 也具有类似的特殊值，如 `unsafe-inline`、`nonce-值`、`hash-值`。\n\n# HTTP\nHTTP（HyperText Transfer Protocol）超文本传输协议，基于请求/响应模型、无状态的**应用层协议**。\n\n1. HTTP/0.9 - 1991 单行协议：只支持 GET 方法；没有首部；只能获取纯文本\n2. HTTP/1.0 - 1996 搭建协议框架：增加了首部、状态码、权限、缓存、长连接（默认短连接）等规范\n3. HTTP/1.1 - 1997 默认长连接；缓存字段扩展；强制客户端提供 Host 首部；管线化\n4. SPDY - 2012 强制压缩、多路复用、Pipeling、双向通信、优先级调用\n5. HTTP/2 - 2015 头部压缩、多路复用、Pipelining、Server push（解决 HTTP 队头阻塞）\n6. HTTP/3 - 2018 基于QUIC（UDP），快速握手、可靠传输、有序交付（解决 TCP 队头阻塞）\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-5.webp\" width=\"80%\" />\n\n参考：\n[关于队头阻塞（Head-of-Line blocking），看这一篇就足够了](https://zhuanlan.zhihu.com/p/330300133)\n[面试官：说说 HTTP1.0/1.1/2.0 的区别?](https://vue3js.cn/interview/http/1.0_1.1_2.0.html)\n[HTTP发展史（HTTP1.1，HTTPS，SPDY，HTTP2.0，QUIC，HTTP3.0）](https://juejin.cn/post/6844903988953874445)\n[JavaScript Guidebook-HTTP](https://tsejx.github.io/javascript-guidebook/computer-networks/http/http2)\n[HTTP2基本概念学习笔记](https://juejin.cn/post/6844903589635162120)\n[HTTP 协议入门-阮一峰](https://www.ruanyifeng.com/blog/2016/08/http.html)\n[HTTP/2 服务器推送（Server Push）教程-阮一峰](https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)\n[HTTP/3 原理实战](https://mp.weixin.qq.com/s/MHYMOYHqhrAbQ0xtTkV2ig)\n[深入剖析HTTP3协议](https://www.nginx.org.cn/article/detail/422)\n[QUIC核心原理和握手过程](https://www.bilibili.com/video/BV1Mg411s7mP)\n[QUIC 握手流程梳理](https://juejin.cn/post/7111298133690155038)\n\n## HTTP消息\n[HTTP 消息](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages)是服务器和客户端之间交换数据的方式，分为请求和响应。\n\nHTTP 消息由采用 **ASCII 编码**的**多行文本**构成。在 HTTP/1.1 及早期版本中，这些消息通过连接公开地发送。在 HTTP/2 中，为了优化和性能方面的改进，曾经可人工阅读的消息被分到多个 **HTTP 帧**中。\n\n**消息结构：**\n1. **起始行** 包括请求方法、请求目(url)、HTTP版本、状态码、状态描述短语\n2. [HTTP标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers) 用于描述报文\n3. **空行** 用于分隔头部和主体，表示消息的元数据部分结束\n4. **消息主体** 可选，包含任意数据，如文件、图片、表单数据等\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-6.webp\" width=\"80%\" />\n\n## HTTP1.0\nHTTP1.0 是第一个被广泛使用的版本，它是一个简单的请求/响应协议，**每个请求都会建立一个新的TCP连接**。\n\n在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求头部中没有 Host 字段。但随着虚拟主机技术的发展，一台物理服务器上可以运行多个虚拟主机共享同一个IP，因此需要在请求头部中加入 Host 字段。\n\n缺点：\n1. 连接频繁的建立和断开会消耗时间和资源。\n2. 无法充分利用带宽，TCP协议特点是慢启动，即一开始传输的数据量小，然后逐渐增大，而短连接导致每次都要重新慢启动，难以达到峰值。\n3. [队头阻塞](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E)，同一个域名下的请求会排队等待，需要等待前一个请求完成并断开后才能继续请求下一个资源。\n\n## HTTP1.1\n**1、长连接（持久连接）：**[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#%E9%95%BF%E8%BF%9E%E6%8E%A5)\nHTTP1.1**默认开启长连接**，即默认带上 `Connection: keep-alive` 头部。\n长连接可以让多个请求和响应复用同一个 TCP 连接进行**串行请求**，减少了建立和断开TCP连接的开销，提高了传输效率。\n但仍然存在**队头阻塞**问题，后面的请求必须等待前面的请求完成后才能进行。\n\n**2、流水线Pipelining（管线化）：**[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#http_%E6%B5%81%E6%B0%B4%E7%BA%BF)\nHTTP1.1 支持**流水线**，即支持**请求并发**，不用等待上一次请求结果返回，可以直接发出下一次请求。\n但**响应必须按照请求的顺序返回**，队头阻塞仍然可能发生，如果前一个请求非常耗时甚至超时，那么后续请求的响应仍然会受到影响。\n管线化只解决了请求的队头阻塞问题，但是响应的队头阻塞问题仍然存在，且web的性能问题大多数是由于响应的队头阻塞问题导致的。\n现代浏览器中，流水线是**禁用**的，HTTP1.1传输的信息是文本，且没有逻辑流概念，实现流水线非常复杂，让并发的请求和响应一一对应也是困难的，反而会造成更多问题。\n已被 HTTP/2 中的多路复用（multiplexing）所取代。\n\n3、增加更多的请求头和响应头来完善的功能：\n1. **Host**：指定服务器的域名和端口号。所有 HTTP/1.1 请求报文中必须包含一个Host头字段。\n2. 引入range，允许只请求资源某个部分。\n3. 引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略。\n\n**4、多TCP连接：**[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87)\n单个TCP连接仍然有队头阻塞问题。因此HTTP1.1允许为每个域名建立多个TCP连接，通常为6个，一个请求选择一个连接发送后就不能再换用其它连接。\n**域名分片：**将资源分散到指向同一个服务器的不同的域名下，以便绕过TCP最大连接限制，提高并发请求的数量。这是一个过时的技术，但仍然广泛使用。\n\n**队头阻塞的根本原因：**http1.1是基于文本的协议，文本是不能分割、乱序传输（乱序封装为TCP报文）的，后续将TCP报文按顺序组装成HTTP报文后，文本就错乱了。所以，一个连接中请求响应必须按顺序完成。\n\n## HTTP2\n**旧版本问题:**\n1. **多个 TCP 连接：**虽然 HTTP/1.1 管线化可以支持请求并发，但是浏览器很难实现，主流浏览器厂商都禁用了管线化\n2. **队头阻塞：**TCP 连接上只能发送一个请求，由于单连接上的串行请求，前面的请求未完成前，后续的请求都在排队等待\n3. **头部冗余：**HTTP/1.x 采用文本格式传输，首部未压缩，无状态特性让每个请求都会带上 Cookie、User-Agent 等重复的信息\n4. **不支持服务端推送：**HTTP/1.1 不支持服务推送消息，只能使用轮询的方式解决\n\nHTTP2 引入了**二进制分帧层**，将 HTTP 消息分割为更小的消息和帧，每个帧都是一个二进制块，可以乱序发送，然后在接收端重新组装。\n\n### 二进制分帧\n[HTTP帧](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages#http2_%E5%B8%A7)：HTTP2 通信的最小单位，每个帧包含**帧头部**（固定9字节），用于描述帧的**流ID**、有效载荷的长度、类型等信息。并且将头部和主体分别封装为**头部帧（HEADERS frame）**和**数据帧（DATA frame）**。\n**消息：** 与逻辑请求或响应消息对应的完整的一系列帧。\n**逻辑数据流：**一个虚拟的连接，可以承载双向消息，每个数据流都有一个唯一的标识符。\n**流ID：** 位于帧头，标识出当前帧所属的数据流，接收数据时根据流ID将帧重新组装为完整的消息。\n\n逻辑上多个流在一个 TCP 连接上**并行传输**，实际上，各个流的各个帧混合封装为多个TCP报文按顺序进行传输。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-7.webp\" width=\"80%\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-8.webp\" width=\"80%\" />\n\n### 多路复用 MultiPlexing\n允许**多个消息同时在单个 TCP 连接上传输**，并且不会阻塞或等待其他消息的响应，解决了 HTTP/1.x 的队头阻塞问题。\n支持流的**优先级**（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。\n\n**核心概念：**将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装。\n\n有了二进制分帧后，不再依赖多 TCP 链接、域名分片去实现多流并行，而是通过**逻辑数据流**支持多路复用。\n\n### 标头压缩\n在 HTTP/1.x 中，标头元数据以纯文本形式传输，带来额外的空间开销。HTTP/2 使用 **HPACK 霍夫曼编码**压缩请求和响应标头元数据，减少冗余数据，降低开销。\n**做法：** \n通过HPACK对传输的标头字段进行编码，从而减小了消息的大小。\n要求通讯双方**各自维护一份头域索引表**(首部表)，相同的消息头部字段只发送**索引号**，此索引表随后会用作参考，对之前传输的值进行有效编码。\n[关于 HPACK 头部压缩标准 的制定](https://datatracker.ietf.org/doc/html/rfc7541)\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-9.webp\" width=\"60%\" />\n\n索引表又分为**静态表**和**动态表**，静态表包含常见的标头字段，动态表包含最近发送的其它标头字段。\n1. 静态表是**固定的**，根据主流网站最常用的标头字段创建，并添加了 HTTP/2 特定的伪标头字段（以冒号开头），详见[RFC 7541#HPACK: Header Compression for HTTP/2](https://httpwg.org/specs/rfc7541.html#static.table.definition)\n2. 动态表一开始是空的，随着通信的进行，会不断添加新的标头字段，以便在后续的通信中复用，通常是一些自定义的标头字段。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-9-1.webp\" width=\"90%\" />\n\nHTTP2 中请求行独立为了 :method、:scheme、:authority、:path 等键值对\n\n```text 以淘宝图片请求为例\n:authority: img.alicdn.com\n:method: GET\n:path: /bao/uploaded/i3/3946635813/O1CN01Kkt4xv1soP9fwhG0z_!!0-item_pic.jpg\n:scheme: https\nAccept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nReferer: https://www.taobao.com/\n```\n\n\n### 服务器推送 Server Push\nHTTP2 的服务器推送用于**提前将资源推送至浏览器缓存**。\n并不是类似于现在的 SSE 或者 WebSocket 的推送技术。它是一种服务器根据客户端以前发送的请求来猜测未来的请求，并提前将未来请求的结果推送给客户端的技术。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-10.webp\" width=\"80%\" />\n\n## HTTP3\nHTTP/2 只解决了**应用层** HTTP 的队头阻塞，但**传输层** TCP 仍然存在队头阻塞问题，因为 TCP 是**面向流的**，一个数据包丢失，后续的数据包都要等待重传，导致队头阻塞。\n\n**TCP 层队头阻塞（由于丢失或延迟的数据包）也会最终导致 HTTP 队头阻塞**\nHTTP/2 将多个消息分解为多个帧，若干个帧合并作为TCP报文的载荷，在一个TCP连接上传输，但 TCP 不知道 HTTP 流的，只将所有上层交付的数据作为一个大流，TCP 为了实现**可靠传输**，会对数据包的丢失进行**等待重传**，后续的TCP报文到达后只能进入缓存，需等待重传完成后才能继续操作，即使缓存中数据包内负载的帧已经能重新组装成完整的消息和资源。\n\n实际上，在TCP的**拥塞控制**机制下，单个连接上的 HTTP/2 并没有比6个TCP连接上的 HTTP/1.1 快多少，在数据包丢失率较高的低速网络上可能更慢，因此浏览器仍然可能为同一域名打开多个并行的 HTTP/2 连接。\n\n**总之**，TCP 并不能完美适配 HTTP/2 的多路复用，两者的流概念存在冲突，因此 HTTP/3 诞生了。\n\n### QUIC的多路复用\nGoogle 在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。 而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP/3。\n\nUDP 是**不可靠传输**，数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理，而 QUIC 在 UDP 上实现了 HTTP 流的**可靠传输**。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-11.webp\" width=\"90%\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-12.webp\" width=\"90%\" />\n\n**连接上不存在阻塞：**QUIC 知道自己传输的是 HTTP 流，如上图，当 packet2 丢失，且后续的 packet 已经到达，QUIC 会查看 packet3 的流ID，发现与 packet1 是同一个流（stream1），且字节范围是连续的，因此可以直接将 packet3 交付给浏览器进行处理，而不用等待 packet2 重传。\n\n**单个流上的阻塞：**对于 packet4，它属于 stream2，但其字节范围前缺失了 0-299，因此，QUIC 会缓存 packet4，等待 0-299 的 packet，也就是 packet2 到达后再交付给浏览器。\n\n这意味着，想要发挥出 HTTP/3 的优势，需要在单个TCP连接上经常有多个并发流，这就需要浏览器有一个良好的分配策略。\n\n**存在的问题：**\nQUIC(UDP) 并不保证请求和响应的顺序一致，就像上面的例子，stream2 可能比 stream1 先交付给浏览器进行处理。对于一些重要的资源 121212 的传输顺序可能并不比 111222 好，这是显而易见的。\n\n```\n使用多路复用（较慢）：\n---------------------------\n                              流1（Stream 1）只有到这里才能使用\n                              ▼\t\t\n12121212121212121212121212121212\n                               ▲\n                               流2（Stream 2）在这里下载完毕\n\n未使用多路复用/顺序（流1（Stream 1）更快）：\n------------------------------------------------------\n                 流1（Stream 1）在这里下载完毕，可以更早地使用\n                 ▼\t\t\t   \n11111111111111111122222222222222\n                               ▲\n                               流2（Stream 2）还是在这里下载完毕\n```\n\n数据包的丢失通常是连续的一小段，QUIC的多路复用后，帧的交错传输可能导致两个流恰好都有帧丢失而阻塞。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-13.webp\" width=\"80%\" />\n\n大多数 QUIC 实现很少同时在单个TCP连接上传输多个流。因为如果其中一个数据包丢失，则会立即导致其所含帧所属的流被阻塞。**一个QUIC数据包可能携带了多个来自不同流的帧**，一旦该包丢失，后果是灾难性的。\n\n**多路复用是否重要：**\n虽然仍然存在一些问题，但多路复用绝对是一个有用的特性\n1. 对于[渐进式图像渲染](https://blog.cloudflare.com/parallel-streaming-of-progressive-images/)、文件上传下载、视频等增量处理场景，多路复用可以显著提高性能，基于流与帧的概念，无需等待整个资源加载完毕。\n2. 网页零碎的小文件请求，即使数据包发生丢失，也不会对其他文件造成太多的延迟。\n3. QUIC的多路复用允许改变响应的顺序，并为高优先级的响应中断低优先级的响应。\n4. 配合CDN分发，缓存在CDN上的资源可以更快响应，而未缓存的资源将从服务器获取，但不会阻塞其它流的传输。\n\n### 连接建立\nQUIC 首次连接只需要**1-RTT**，基于 UDP 不需要 TCP 的三次握手，且内部包含了 TLS，它在自己的数据包中携带 TLS 加密等必要参数，加之 QUIC 使用的是 TLS 1.3，因此仅需 **1-RTT** 就可以同时完成建立连接与密钥协商。\n\n在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-14.webp\" width=\"60%\" />\n\n[图解 QUIC 连接](https://cangsdarm.github.io/illustrate/quic)\n\nQUIC 数据包中包含**连接 ID**（Connection ID），这是连接迁移的基础。\n\n### 连接迁移\n基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。\n\n切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间。\n\nQUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。\n\n### 其它\nQUIC 重新实现了 TCP 协议的 Cubic 算法进行**拥塞控制**，也就是慢启动、拥塞避免、快速重传和快速恢复。并在此基础上进行了改进。\n1. **热插拔** TCP 中如果要修改拥塞控制策略，需要在系统层面进行操作。QUIC 修改拥塞控制策略只需要在应用层操作，并且 QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法。\n2. **前向纠错 FEC** QUIC 使用前向纠错(FEC，Forward Error Correction)技术增加协议的容错性。一段数据被切分为 10 个包后，依次对每个包进行异或运算，运算结果会作为 FEC 包与数据包一起被传输，如果不幸在传输过程中有一个数据包丢失，那么就可以根据剩余 9 个包以及 FEC 包推算出丢失的那个包的数据，这样就大大增加了协议的容错性。空间换时间。\n3. **单调递增的 Packet Number** TCP 为了保证可靠性，使用 Sequence Number 和 ACK 来确认消息是否有序到达。发生超时重传时请求的 Seq 不变，响应的 Ack 也不变，无法区分是原始请求的 Ack 还是重传请求的 Ack。QUIC 使用 Packet Number 来区分，每个 Packet Number 都是单调递增的，发生重传时，响应的 Ack 也是唯一的。\n4. **更多的 ACK 块** 接收方收到发送方的消息后都应该发送一个 ACK 回复，表示收到了数据。但每收到一个数据就返回一个 ACK 回复太麻烦，所以一般不会立即回复，而是接收到多个数据后再回复，TCP SACK 最多提供 3 个 ACK block。但有些场景下，比如下载，只需要服务器返回数据就好，但按照 TCP 的设计，每收到 3 个数据包就要“礼貌性”地返回一个 ACK。而 QUIC 最多可以捎带 256 个 ACK block。在丢包率比较严重的网络下，更多的 ACK block 可以减少重传量，提升网络效率。\n\nQUIC 也实现了**流量控制**，两个级别：连接级别（Connection Level）和 Stream 级别（Stream Level）。\n\n# HTTPS\n**超文本传输安全协议**（Hyper Text Transfer Protocol over Secure Socket Layer，HTTPS），是一种通过计算机网络进行**安全通信**的传输协议。HTTPS 经由 HTTP 进行通信，但利用 **SSL / TLS** 来加密数据包。\n\n**目的：**提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n\nHTTP 是明文传输的，数据在传输过程中可能被窃听、篡改，而 HTTPS 则通过 SSL/TLS 协议对数据进行加密，保证数据的**机密性**和**完整性**。\n\n**安全传输层协议**（Transport Layer Security，SSL/TLS），是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议。SSL 是 TLS 的前身。\nSSL 1.0 – 由于安全问题从未公开发布。\nSSL 2.0 – 1995年发布。2011年弃用。存在已知的安全问题。\nSSL 3.0 – 1996年发布。2015年弃用。存在已知的安全问题。\nTLS 1.0 – 1999年作为SSL 3.0的升级发布。计划在2020年弃用。\nTLS 1.1 – 2006年发布。计划在2020年弃用。\nTLS 1.2 – 2008年发布。\nTLS 1.3 – 2018年发布。\n\n参考：\n[TLS 详解握手流程](https://juejin.cn/post/6895624327896432654)\n[图解 HTTPS：RSA 握手过程](https://zhuanlan.zhihu.com/p/344086342)\n[HTTPS ECDHE 握手解析](https://www.xiaolincoding.com/network/2_http/https_ecdhe.html)\n[JavaScript Guidebook-HTTPS](https://tsejx.github.io/javascript-guidebook/computer-networks/http/https)\n\n## TLS握手\n**传统TLS使用RSA握手：**\n1. 客户端发送 **Client Hello** 消息，包含支持的TLS版本、加密套件、客户端随机数**client_random**。\n2. 服务端返回 **Server Hello** 消息，包含确定的TLS版本、选择的加密套件、服务端随机数**server_random**。\n3. 服务端继续发送 **Certificate** 数字证书 (证书中附带**公钥**)。\n4. **Client Finish** 客户端验证证书和签名，若通过则生成一个随机数**pre_random**作为**预主密钥**，并用RSA公钥加密后发送给服务端。\n5. **Server Finish** 服务端通过RSA私钥解密获得pre_random。此 pre_random 只有服务端和客户端知道，除非私钥泄露。\n6. 最后双方根据 client_random、server_random、pre_random 生成**主密钥**，用于后续的通信加密。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-16.webp\" width=\"80%\" />\n\n**TLS1.2使用DH握手：**\n与RSA区别主要在于**pre_random**的生成方式，RSA在客户端生成后使用公钥加密发送给服务端，DH使用**ECDHE密钥交换算法**生成。\n\n```diff DH与RSA握手对比\n1.浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。\n\n// RSA\n-2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件\n-以及数字证书 (证书中附带公钥)。\n// DH\n+2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件\n+以及数字证书 (证书中附带公钥)。\n+同时服务器利用私钥将 client_random，server_random，服务端椭圆曲线公钥(server_params) 签名，\n+生成服务器签名。然后将签名和 server_params 也发送给客户端。 \n\n// RSA\n-3.浏览器接收，先验证数字证书。\n-若通过，接着使用加密套件的密钥协商算法 RSA 算法\n-生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。\n// DH\n+3.浏览器接收，先验证数字证书和签名名。\n+若通过，将 客户端椭圆曲线公钥(client_params) 传递给服务器。\n\n-4.服务器用私钥解密这个被加密后的 pre_random。\n+4.现在客户端和服务器都有 对方的椭圆曲线公钥、自己的椭圆曲线私钥。\n+因 ECDHE 计算基于 “椭圆曲线离散对数”，客户端和服务器都能计算出 pre_random。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-15.webp\" width=\"80%\" />\n\n**TLS1.3握手：**\nTLS1.3将握手过程简化，**只需要1-RTT**，并废除了 RSA 等不安全算法。\n\nRSA 算法的废除不仅因为已经能够被破解，同时还缺少**前向安全性**。\n**前向安全：**能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。\n\n```diff\n// 原 DH 握手\n-1.浏览器向服务器发送 client_random，TLS 版本和供筛选的加密套件列表。\n// TLS1.3 优化\n+1.浏览器向服务器发送 client_params，client_random，TLS 版本和供筛选的加密套件列表。\n\n// 原 DH 握手\n-2...\n// TLS1.3 优化\n+2.服务器返回：server_random、server_params、TLS 版本、确定的加密套件方法以及证书。\n+浏览器接收，先验证数字证书和签名。\n+现在双方都有 client_params、server_params，可以根据 ECDHE 计算出 pre_random 了。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/83-17.webp\" width=\"80%\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["网络"],"categories":["学习笔记"]},{"title":"NestJS[四]-数据库","url":"/article/e18aeaaa.html","content":"\n# ORM\n对象关系映射器**ORM**(Object/Relational Mapping) 通过实例对象的语法，完成关系型数据库的操作。\n\nORM 把数据库映射成对象 [ORM 实例教程-阮一峰](https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html)\n1. 数据库的表（table） --> 类（class）\n2. 记录（record，行数据）--> 对象（object）\n3. 字段（field）--> 对象的属性（attribute）\n\nORM 使用对象，封装了数据库操作，不使用 SQL 语言，只面向对象编程，与数据对象直接交互，在更高的抽象层次上操作数据库。因此可以通过一个 ORM 框架，操作多种数据库。让开发者更专注业务逻辑的处理。\n\n# TypeORM\n[TypeORM](https://github.com/typeorm/typeorm) 是TS生态中最成熟的ORM，[TypeORM中文文档](https://typeorm.bootcss.com/)\n\nNest 提供了与它的紧密集成库 [@nestjs/typeorm](https://www.npmjs.com/package/@nestjs/typeorm)，[文档](https://docs.nestjs.com/techniques/database)\n\n**安装：**`npm i -S @nestjs/typeorm typeorm`\n\n还需要安装node侧的数据库**驱动程序**，如 mysql2、pg、sqlite3 等\n\n**安装：**`npm i -S mysql2`\n\n## 连接数据库\n`TypeOrmModule` 是**全局**动态模块，用于注册数据库连接，并进行一些配置。\n\n`forRoot()` 方法支持 **TypeORM** 中 [DataSource](https://typeorm.io/data-source-options#common-data-source-options) 构造函数暴露的所有配置属性，并且还有一些额外的配置属性。\n\n```ts 基本配置\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: \"mysql\", //数据库类型\n      username: \"root\", //账号\n      password: \"123456\", //密码\n      host: \"localhost\", //host\n      port: 3306, //\n      database: \"test\", //库名\n      entities: [__dirname + '/**/*.entity{.ts,.js}'], //实体文件\n      synchronize:true, //synchronize字段代表是否自动将实体类同步到数据库\n      // 下面三个是Nest提供的额外配置\n      retryDelay:500, //重试连接数据库间隔\n      retryAttempts:10,//重试连接数据库的次数\n      autoLoadEntities:true, //如果为true,将自动加载实体 forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中\n      cache: true, //启用查询缓存\n      // cache: {\n      //   duration: 30000, //默认缓存时间为 1000 毫秒，可以传入数字指定缓存时间\n      // }\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n使用 `forRootAsync()` 异步注册方式，注入 `ConfigService` 进行配置。\n\n```ts\nTypeOrmModule.forRootAsync({\n  useFactory: (configService: ConfigService) => {\n    const config = configService.get<Configuration>(configToken).database;\n    return {\n      type: config.type, //数据库类型\n      username: config.username, //账号\n      password: config.password, //密码\n      host: config.host, //host\n      port: config.port, //\n      database: config.name, //库名\n      // ......其他配置\n    } as TypeOrmModuleOptions;\n  },\n  inject: [ConfigService],\n}),\n```\n\n配置完成后，**TypeORM** 的 `Repository` 对象将可在整个项目中 通过 `@InjectRepository()` 注入（无需导入任何模块）\n\n## 注册实体\n在 `forRoot()` 的 `entities` 选项中统一注册实体文件，支持静态 glob 路径和 entities 数组\n\n```ts\nentities: [__dirname + '/**/*.entity{.ts,.js}'], // 静态 glob 路径数组\nentities: [User], // 实体类数组\n```\n\n也可以开启 `autoLoadEntities` 自动加载实体，并使用 `forFeature()` 方法在不同模块中注册实体，这些局部注册的实体都将自动添加到配置对象的实体数组中。\n\n```ts\n//自动加载实体,forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中\nautoLoadEntities: true,\n// 在其它模块中使用 forFeature() 注册实体\nTypeOrmModule.forFeature([entity])\n```\n\n## 实体\nTypeORM中，实体是由 `@Entity()` 注释类，用于映射数据库表。[文档](https://typeorm.bootcss.com/entities)\n\n提供了 `@Column()` 等实体属性装饰器，用于定义列等数据库表的结构和信息。\n\n```ts\nimport {Entity,Column,PrimaryGeneratedColumn} from 'typeorm'\n@Entity()\nexport class Guard {\n   // 自增主键列\n   @PrimaryGeneratedColumn()\n   id:number\n   // 普通列\n   @Column()\n   name:string\n}\n```\n\n在**开发环境**开启 `synchronize` 配置项，TypeORM 会根据**实体**的定义**自动创建**数据库表，且在每次**应用启动时**都会检查实体类和表的同步状态，如果不同步则会**自动更新**表结构。\n\n```ts\nsynchronize: true, //synchronize字段代表是否自动将实体类同步到数据库\n// 设置为true，表示每次应用启动时都会检查实体类和数据库表的同步状态，如果不同步则会自动更新数据库表结构\n// 生产环境应设置为false，避免自动更新数据库表结构，否则可能会丢失生产数据。\n```\n\n### 实体属性装饰器\n**常用实体属性装饰器：**\n1. `@Entity()` 声明实体\n2. `@PrimaryColumn()` 主键列\n3. `@PrimaryGeneratedColumn()` 自增主键列\n4. `@Column()` 普通列\n5. `@Generated()` 生成列，能自动生成值，如UUID等。\n6. `@CreateDateColumn()`* **特殊列**，自动为实体插入创建时间。\n7. `@UpdateDateColumn()`* **特殊列**，每次save时自动更新时间。\n8. `@DeleteDateColumn`* **特殊列**，软删除标记列，初始值为null，软删除时记录删除时间。\n9. `@VersionColumn()`* **特殊列**，每次save时自动增长实体版本（增量编号）\n\n*特殊列的值将根据内置规则自动设置，无需手动赋值。\n\n```ts user实体 src\\db\\entities\\user.entity.ts\nimport {\n  Column,\n  CreateDateColumn,\n  DeleteDateColumn,\n  Entity,\n  PrimaryGeneratedColumn,\n  UpdateDateColumn,\n} from 'typeorm';\n\n@Entity()\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n  @Column()\n  name: string;\n  @Column()\n  desc: string;\n  @CreateDateColumn({ type: 'timestamp' })\n  create_time: Date;\n  @UpdateDateColumn({ type: 'timestamp' })\n  update_time: Date;\n  @DeleteDateColumn({ type: 'timestamp' })\n  delete_time: Date;\n}\n```\n\n### Column选项\n`@Column()` 装饰器可以接受[ColumnOptions选项](https://typeorm.bootcss.com/entities#%E5%88%97%E9%80%89%E9%A1%B9)，用于定义列的属性。\n\n```\ntype: ColumnType - 列类型。https://typeorm.bootcss.com/entities#列类型\nname: string - 数据库表中的列名。默认情况下，列名称是从属性的名称生成的。 你也可以通过指定自己的名称来更改它。\nlength: number - 列类型的长度。 例如，如果要创建varchar（150）类型，请指定列类型和长度选项。\nwidth: number - 列类型的显示范围。 仅用于MySQL integer types\nonUpdate: string - ON UPDATE触发器。 仅用于 MySQL.\nnullable: boolean - 在数据库中使列NULL或NOT NULL。 默认情况下，列是nullable：false。\nupdate: boolean - 指示\"save\"操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为\"true\"。\nselect: boolean - 定义在进行查询时是否默认隐藏此列。 设置为false时，列数据不会显示标准查询。 默认情况下，列是select：true\ndefault: string - 添加数据库级列的DEFAULT值。\nprimary: boolean - 将列标记为主要列。 使用方式和@ PrimaryColumn相同。\nunique: boolean - 将列标记为唯一列（创建唯一约束）。\ncomment: string - 数据库列备注，并非所有数据库类型都支持。\nprecision: number - 十进制（精确数字）列的精度（仅适用于十进制列），这是为值存储的最大位数。仅用于某些列类型。\nscale: number - 十进制（精确数字）列的比例（仅适用于十进制列），表示小数点右侧的位数，且不得大于精度。 仅用于某些列类型。\nzerofill: boolean - 将ZEROFILL属性设置为数字列。 仅在 MySQL 中使用。 如果是true，MySQL 会自动将UNSIGNED属性添加到此列。\nunsigned: boolean - 将UNSIGNED属性设置为数字列。 仅在 MySQL 中使用。\ncharset: string - 定义列字符集。 并非所有数据库类型都支持。\ncollation: string - 定义列排序规则。\nenum: string[]|AnyEnum - 在enum列类型中使用，以指定允许的枚举值列表。 你也可以指定数组或指定枚举类。\nasExpression: string - 生成的列表达式。 仅在MySQL中使用。\ngeneratedType: \"VIRTUAL\"|\"STORED\" - 生成的列类型。 仅在MySQL中使用。\nhstoreType: \"object\"|\"string\" -返回HSTORE列类型。 以字符串或对象的形式返回值。 仅在Postgres>)中使用。\narray: boolean - 用于可以是数组的 postgres 列类型（例如 int []）\ntransformer: { from(value: DatabaseType): EntityType, to(value: EntityType): DatabaseType } - 用于将任意类型EntityType的属性编组为数据库支持的类型DatabaseType。\n```\n\n注意：大多数列选项都是特定于 RDBMS 的，并且在MongoDB中不可用。\n\n## 操作实体-Repositories\n配置好 `TypeOrmModule` 并注册了实体后，使用 `@InjectRepository()` 注入 `Repository` 存储库类。\n\n每个实体都有自己的 `Repository` 存储库，可以处理其实体的所有操作。通过调用 `Repository` 的方法，实现对数据库的增删改查。\n\n```ts src\\db\\db.service.ts\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from './entities/user.entity';\nimport { Repository } from 'typeorm';\n@Injectable()\nexport class DbService {\n  constructor(\n    @InjectRepository(User) private userRepository: Repository<User>,\n  ) {}\n}\n```\n\n## CURD\n通过实体存储库 `Repository` 实现CURD，[Repository API](https://typeorm.bootcss.com/repository-api)\n\n```ts\n1. `manager` 存储库使用的 `EntityManager`\n2. `metadata` 存储库管理的实体的 `EntityMetadata`\n3. `queryRunner` EntityManager 使用的查询器。仅在 EntityManager 的事务实例中使用。\n4. `target` 此存储库管理的目标实体类。仅在 EntityManager 的事务实例中使用。\n5. `createQueryBuilder()` 创建用于构建 SQL 查询的查询构建器。详见[QueryBuilder](https://typeorm.bootcss.com/select-query-builder)\n6. `hasId()` 检查是否定义了给定实体的主列属性。\n7. `getId()` 获取给定实体的主列属性值。复合主键返回的值将是一个具有主列名称和值的对象。\n8. `create()` 创建一个新的实体实例。可选接收具有实体属性的对象，将写入新创建的实体实例。相当于 `new User()` 后再往实例上添加属性。\n9. `merge()` 将多个实体合并为一个实体。\n10. `preload()` 将给定的实体与数据库中的实体进行比较，并返回一个补全了缺失的属性新的实体。\n11. `save()` 保存(插入)给定实体或实体数组，返回保存后的实体值。若主键已存在，则会更新该实体，否则插入一个新实体。\n12. `insert()` 插入新实体或实体数组。\n13. `update()` 通过给定的更新选项或实体 ID 部分更新实体。\n14. `upsert()` 与 `save()` 类似，但不包含级联、关系和其他操作。\n15. `remove()` 删除给定的实体或实体数组。\n16. `delete()` 根据实体id、id数组或给定的条件删除实体。\n17. `softDelete()` 软删除，参数同 `delete()`。\n18. `softRemove()` 软删除，参数同 `remove()`。\n19. `recover()` 传入实体或实体数组，恢复软删除的实体。\n20. `restore()` 根据实体id、id数组或给定的 `FindOptionsWhere` 条件，恢复软删除的实体。\n21. `increment()` 增加符合条件的实体某些列值。\n22. `decrement()` 减少符合条件的实体某些列值。\n23. `find()` 查询匹配Find选项的实体，适用于大多数查询场景。\n24. `findAndCount()` 查询匹配Find选项实体。还会计算与给定条件匹配的所有实体数量，但是忽略分页设置 (skip 和 take 选项)。\n25. `findOneById()` 按 ID 查询实体。\n26. `findByIds()` 按 ID 查询多个实体。\n27. `findOne()` 查询匹配Find选项的第一个实体。\n28. `findOneOrFail()` 查询匹配Find选项的第一个实体。如果没有匹配，则 Rejects 一个 promise。\n29. `exist()` 检查是否存在匹配Find选项的实体。\n30. `count()` 符合指定条件的实体数量。对分页很有用。\n31. `query()` 执行原始 SQL 语句。\n32. `clear()` 清除给定表中的所有数据。\n```\n\n### 创建/插入\n1. `create()` 创建一个新的实体实例。可选接收具有实体属性的对象，将写入新创建的实体实例。相当于实例化User类后再添加属性。\n2. `save()` 保存(插入)给定实体或实体数组，返回保存后的实体值。若主键已存在，则会更新该实体，否则插入一个新实体。\n3. `insert()` 插入新实体或实体数组。返回 `InsertResult` 对象，包含插入的实体的标识符和生成的映射。\n4. `upsert()` 与 `save()` 类似，但不包含级联、关系和其他操作。\n\n```ts\nasync create(createDbDto: CreateDbDto) {\n  const user = this.userRepository.create({\n    name: createDbDto.name,\n    desc: createDbDto.desc,\n  }); // 创建一个实体\n  const result = await this.userRepository.save(user); // 保存到数据库\n  // const result = await this.userRepository.insert(user); // 插入到数据库\n  return result;\n}\n// save返回保存后的实体值\n// {\n//   \"name\": \"user2\",\n//   \"desc\": \"这是一个用户2\",\n//   \"id\": 15,\n//   \"create_time\": \"2024-02-20T05:10:52.740Z\",\n//   \"update_time\": \"2024-02-20T05:10:52.740Z\"\n// }\n\n// insert返回InsertResult\n// {\n//   \"identifiers\": [\n//     {\n//       \"id\": 14\n//     }\n//   ],\n//   \"generatedMaps\": [\n//     {\n//       \"id\": 14,\n//       \"create_time\": \"2024-02-20T05:09:07.306Z\",\n//       \"update_time\": \"2024-02-20T05:09:07.306Z\"\n//     }\n//   ],\n//   \"raw\": {\n//     \"fieldCount\": 0,\n//     \"affectedRows\": 1,\n//     \"insertId\": 14,\n//     \"info\": \"\",\n//     \"serverStatus\": 2,\n//     \"warningStatus\": 0,\n//     \"changedRows\": 0\n//   }\n// }\n```\n\n### 查询\nRepository 提供了多种**查询方法**，通常返回实体或实体数组。\n1. `find()` 查询匹配Find选项的实体，适用于大多数查询场景。\n2.  `findAndCount()` 查询匹配Find选项实体。还会计算与给定条件匹配的所有实体数量，但是忽略分页设置 (skip 和 take 选项)。\n3.  `findOneById()` 按 ID 查询实体。\n4.  `findByIds()` 按 ID 查询多个实体。\n5.  `findOne()` 查询匹配Find选项的第一个实体。\n6.  `findOneOrFail()` 查询匹配Find选项的第一个实体。如果没有匹配，则 Rejects 一个 promise。\n7.  `exist()` 检查是否存在匹配Find选项的实体。\n8.  `count()` 符合指定条件的实体数量。对分页很有用。\n9.  `query()` 执行原始 SQL 语句。\n\n大部分查询方法能接收 [Find 选项](https://typeorm.bootcss.com/find-options)，用于指定查询条件、排序、分页等。\n一些查询方法还有 `find*By()` 版本，传入 `FindOptionsWhere` 直接根据查询条件查询实体。如 `findBy()`、`findOneBy()` 等。\n\n```ts 常用 Find 选项\nuserRepository.find({\n  select: [\"firstName\", \"lastName\"], // 指定要选择的列\n  relations: [\"profile\", \"photos\", \"videos\"], // 指定要加载的关系\n  where: { // 指定查询条件\n    firstName: \"Timber\", \n    lastName: \"Saw\"\n  },\n  order: { // 指定排序\n    name: \"ASC\", // 升序\n    id: \"DESC\" // 降序\n  },\n  // 分页\n  skip: 5, // 跳过前5个\n  take: 10, // 取10个\n  cache: true // 缓存查询结果，需要在TypeOrmModule配置中启用查询缓存\n  // cache: 60000 // 默认缓存时间为 1000 毫秒，可以传入数字指定缓存时间\n});\n```\n\nTypeORM 还提供了许多[内置运算符](https://typeorm.bootcss.com/find-options#%E8%BF%9B%E9%98%B6%E9%80%89%E9%A1%B9)，可用于创建更复杂的查询。部分运算符与 SQL 同名的关键字差不多。\n1. `Not()` 不等于\n2. `LessThan()` 小于\n3. `LessThanOrEqual()` 小于等于\n4. `MoreThan()` 大于\n5. `MoreThanOrEqual()` 大于等于\n6. `Equal()` 等于\n7. `Like()` 模糊查询，支持 [SQL 通配符](https://www.runoob.com/sql/sql-wildcards.html)\n8. `ILIKE()` 不区分大小写的模糊查询，也支持通配符\n9. `Between()` 在两个值之间\n10. `In()` 在给定的值数组中\n11. `Any()` 在给定的值数组中的任意一个，通常配合其它运算符使用\n12. `IsNull()` 为空\n13. `Raw()` 原始 SQL 语句\n\n### FindAll查询案例\n支持搜索、分页、排序\n\n```ts DTO src\\db\\dto\\find-all.dto.ts\nimport { Transform } from 'class-transformer';\nimport { IsInt, IsOptional, IsString, Min } from 'class-validator';\n\nexport class FindAllDto {\n  @IsString()\n  @IsOptional()\n  keyword?: string;\n  @IsInt()\n  @IsOptional()\n  @Min(1)\n  @Transform((p) => parseInt(p.value, 10))\n  @RequireOtherFields('size') // 当传入了page时，必须同时传入size\n  page?: number;\n  @IsInt()\n  @IsOptional()\n  @Min(0)\n  @Transform((p) => parseInt(p.value, 10))\n  size?: number;\n}\n```\n\n```ts 控制器 src\\db\\db.controller.ts\nimport { FindAllDto } from './dto/find-all.dto';\n@Get()\nfindAll(@Query() query: FindAllDto) {\n  return this.dbService.findAll(query);\n}\n```\n\n```ts 服务 src\\db\\db.service.ts\nasync findAll(options: FindAllDto) {\n  const result = await this.userRepository.find({\n    where: {\n      name: options.keyword ? Like(`%${options.keyword}%`) : undefined,\n    },\n    order: {\n      id: 'ASC',\n    },\n    skip: options.page && options.size && (options.page - 1) * options.size,\n    take: options.size,\n  });\n  const total = await this.userRepository.count();\n  return {\n    users: result,\n    total,\n  };\n}\n// {\n//   \"users\": [\n//     {\n//       \"id\": 1,\n//       \"name\": \"fsfdf\",\n//       \"desc\": \"这是46456户\",\n//       \"create_time\": \"2024-02-19T13:35:28.264Z\",\n//       \"update_time\": \"2024-02-20T06:45:50.000Z\",\n//       \"delete_time\": null\n//     },\n//     {\n//       \"id\": 3,\n//       \"name\": \"user1\",\n//       \"desc\": \"这是一个用户\",\n//       \"create_time\": \"2024-02-19T13:35:38.280Z\",\n//       \"update_time\": \"2024-02-19T13:36:19.896Z\",\n//       \"delete_time\": null\n//     }\n//   ],\n//   \"total\": 16\n// }\n```\n\n### 更新/修改\n1. `update()` 通过给定的更新选项或实体 ID 部分更新实体。\n2. `save()` 保存(插入)给定实体或实体数组，返回保存后的实体值。若主键已存在，则会更新该实体，否则插入一个新实体。\n3. `upsert()` 与 `save()` 类似，但不包含级联、关系和其他操作。\n\n```ts\nasync update(id: number, updateDbDto: UpdateDbDto) {\n  const result = await this.userRepository.update(id, updateDbDto);\n  return result;\n}\n// {\n//   \"generatedMaps\": [],\n//   \"raw\": [],\n//   \"affected\": 1\n// }\n```\n\n若需要条件更新，需要与查询方法配合使用，获取需要更新的实体，使用 `merge()` 合并实体，再调用 `save()` 或 `upsert()`。\n\n```ts\nasync update(id: number, updateDbDto: UpdateDbDto) {\n  // const result = await this.userRepository.update(id, updateDbDto);\n  const oldUser = await this.userRepository.findOneBy({ id });\n  const newUser = this.userRepository.merge(oldUser, updateDbDto);\n  const result = await this.userRepository.save(newUser);\n  return result;\n}\n```\n\n### 删除\n1. `delete()` 根据实体id、id数组或给定的 `FindOptionsWhere` 条件删除实体。\n2. `remove()` 删除给定的实体或实体数组。\n3. `softDelete()` 软删除，参数同 `delete()`。\n4. `softRemove()` 软删除，参数同 `remove()`。\n\n```ts\nasync remove(id: number) {\n  const result = await this.userRepository.delete(id);\n  return result;\n}\n// {\n//   \"raw\": [],\n//   \"affected\": 1\n// }\n```\n\n在实际业务中，可能需要**软删除**，即不真正删除数据，而是标记为已删除。\n使用 `@DeleteDateColumn()` 声明标记删除时间的列。就可以通过 `soft*()` 进行软删除。\n\n```ts\nasync remove(id: number) {\n  const result = await this.userRepository.softDelete(id);\n  return result;\n}\n// {\n//   \"generatedMaps\": [],\n//   \"raw\": [],\n//   \"affected\": 1\n// }\n```\n\n### 恢复软删除\n1. `recover()` 传入实体或实体数组，恢复软删除的实体。\n2. `restore()` 根据实体id、id数组或给定的 `FindOptionsWhere` 条件，恢复软删除的实体。\n\n恢复软删除的实体，即将标记删除时间的列置为null。\n\n```ts\nasync restore(id: number) {\n  const result = await this.userRepository.restore(id);\n  return result;\n}\n// {\n//   \"generatedMaps\": [],\n//   \"raw\": [],\n//   \"affected\": 1\n// }\n```\n\n### 完整案例\n\n```ts 控制器 src\\db\\db.controller.ts\nimport { Controller, Get, Post, Body, Patch, Param, Delete, Query, ParseIntPipe } from '@nestjs/common';\nimport { DbService } from './db.service';\nimport { CreateDbDto } from './dto/create-db.dto';\nimport { UpdateDbDto } from './dto/update-db.dto';\nimport { ApiOperation, ApiTags } from '@nestjs/swagger';\nimport { FindAllDto } from './dto/find-all.dto';\n\n@Controller('db')\n@ApiTags('db')\nexport class DbController {\n  constructor(private readonly dbService: DbService) {}\n\n  @Post()\n  @ApiOperation({\n    summary: '创建',\n    description: '创建一个用户',\n  })\n  create(@Body() createDbDto: CreateDbDto) {\n    return this.dbService.create(createDbDto);\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: '查询所有',\n    description: '查询所有用户',\n  })\n  findAll(@Query() query: FindAllDto) {\n    return this.dbService.findAll(query);\n  }\n\n  @Get(':id')\n  @ApiOperation({\n    summary: '查询单个',\n    description: '根据id查询单个用户',\n  })\n  findOne(@Param('id', ParseIntPipe) id: number) {\n    return this.dbService.findOne(id);\n  }\n\n  @Patch(':id')\n  @ApiOperation({\n    summary: '更新',\n    description: '根据id更新用户',\n  })\n  update(\n    @Param('id', ParseIntPipe) id: number,\n    @Body() updateDbDto: UpdateDbDto,\n  ) {\n    return this.dbService.update(id, updateDbDto);\n  }\n\n  @Delete(':id')\n  @ApiOperation({\n    summary: '删除',\n    description: '根据id删除用户',\n  })\n  remove(@Param('id', ParseIntPipe) id: number) {\n    return this.dbService.remove(id);\n  }\n\n  @Patch('restore/:id')\n  @ApiOperation({\n    summary: '恢复',\n    description: '根据id恢复用户',\n  })\n  restore(@Param('id', ParseIntPipe) id: number) {\n    return this.dbService.restore(id);\n  }\n}\n```\n\n```ts 服务 src\\db\\db.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { CreateDbDto } from './dto/create-db.dto';\nimport { UpdateDbDto } from './dto/update-db.dto';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from './entities/user.entity';\nimport { ILike, Like, Repository } from 'typeorm';\nimport { FindAllDto } from './dto/find-all.dto';\n\n@Injectable()\nexport class DbService {\n  constructor(\n    @InjectRepository(User) private userRepository: Repository<User>,\n  ) {}\n\n  async create(createDbDto: CreateDbDto) {\n    const user = this.userRepository.create({\n      name: createDbDto.name,\n      desc: createDbDto.desc,\n    }); // 创建一个实体\n    // const result = await this.userRepository.save(user); // 保存到数据库\n    const result = await this.userRepository.insert(user); // 插入到数据库\n    return result;\n  }\n\n  async findAll(options: FindAllDto) {\n    const result = await this.userRepository.find({\n      where: {\n        name: options.keyword ? Like(`%${options.keyword}%`) : undefined,\n      },\n      order: {\n        id: 'ASC',\n      },\n      skip: options.page && options.size && (options.page - 1) * options.size,\n      take: options.size,\n    });\n    return result;\n  }\n\n  async findOne(id: number) {\n    const result = this.userRepository.findOneBy({ id });\n    return result;\n  }\n\n  async update(id: number, updateDbDto: UpdateDbDto) {\n    // const result = await this.userRepository.update(id, updateDbDto);\n    const oldUser = await this.userRepository.findOneBy({ id });\n    const newUser = this.userRepository.merge(oldUser, updateDbDto);\n    const result = await this.userRepository.save(newUser);\n    return result;\n  }\n\n  async remove(id: number) {\n    const result = await this.userRepository.softDelete(id);\n    return result;\n  }\n\n  async restore(id: number) {\n    const result = await this.userRepository.restore(id);\n    return result;\n  }\n}\n```\n\n## 关系\n实际业务中，经常有多个实体之间的关系，如用户和角色、用户和订单等。反映到数据库中，就是表与表之间的关联。在 MySQL 中通过主键和外键来建立表格之间的关系。\n\nTypeORM 支持多种关系，如一对一、一对多、多对多等。[文档](https://typeorm.bootcss.com/relations)\n\n**关系装饰器：**\n1. `@OneToOne()` 一对一\n2. `@OneToMany()` 一对多\n3. `@ManyToOne()` 多对一\n4. `@ManyToMany()` 多对多\n\n**参数：**\n1. 第一个参数是一个函数，返回一个实体类，表示关联的实体。如 `@OneToOne(() => Config)`。\n2. 第二个**可选**参数是一个函数，返回一个实体类的属性，表示关联的实体的属性，用于实现双向关系。如 `@OneToOne(() => Config, (config) => config.user)`。\n3. 第三个**可选**参数是[关系选项](https://typeorm.bootcss.com/relations#%E5%85%B3%E7%B3%BB%E9%80%89%E9%A1%B9)。\n\n**关系选项：**[文档](https://typeorm.bootcss.com/relations#%E5%85%B3%E7%B3%BB%E9%80%89%E9%A1%B9)\n1. `eager: boolean` 如果为 true，则在此实体上使用 `find*()`，将始终加载此关系。\n2. `cascade: boolean` 如果为 true，则将插入相关对象并在数据库中更新。\n3. `onDelete: \"RESTRICT\"|\"CASCADE\"|\"SET NULL\"` 指定删除引用对象时外键的行为方式\n4. `primary: boolean` 指示此关系的列是否为主列。\n5. `nullable: boolean` 指示此关系的列是否可为空。默认为true。\n6. `orphanedRowAction: \"nullify\" | \"delete\"` 将子行从其父行中删除后，确定该子行是孤立的（默认值）还是删除的。\n\n**设置外键、中间表：**\n`@JoinColumn()` 设置**外键**，用于一对一、多对一关系。`@JoinTable()` 用于**多对多**关系，自动生成一个**中间表**。\n\n关系可以是单向的和双向的。**单向**是仅在一侧有关系装饰器。**双向**是两侧都有的关系装饰器。但注意 `@JoinColumn()` 只在关系的**一侧**且拥有**外键**的表上使用，另一条关系则称为反向关系。\n\n在一对多、多对一关系中，`@JoinColumn()` 添加至\"一\"的一侧。\n\n### 一对一\n以 `User` 和 `Config` 实体为例，一个用户只有一个配置，一个配置只属于一个用户。[文档](https://typeorm.bootcss.com/one-to-one-relations)\n\n**1、**先实现 `User` **单向关联** `Config`。\n1. 在 `User` 中新增一个 `config` 属性，通过 `@JoinColumn()` 设置为外键。\n2. 在使用 `@OneToOne()` 声明关系，指定关联的实体。\n\n```ts src\\db\\entities\\user.entity.ts\nexport class User {\n  @OneToOne(() => Config)\n  @JoinColumn()\n  config: Config;\n}\n```\n\n完成单向一对一关系后，`User` 表中就会新增一个 **configId** 外键，用于存放 `Config` 的主键(id)。\n\n可以发现，单向的关系仅需处理主实体，不需要在被关联的实体中做任何处理。\n\n**2、**再完成**反向关系**，实现**双向**的一对一关系。\n1. 在被关联的 `Config` 中，新增 `user` 属性(**但不使用`@Column()`注释为列**)，使用 `@OneToOne()` 声明关系，指定关联的实体，以及第二个参数指定关联的实体的属性。\n2. 在主实体 `User` 中，也需要向 `@OneToOne()` 传入第二个参数指定关联的实体的属性。\n\n```ts src\\db\\entities\\config.entity.ts\nexport class Config {\n  @PrimaryGeneratedColumn()\n  id: number;\n  @Column()\n  name: string; // 配置名\n  @OneToOne(() => User, (user) => user.id)\n  user: User;\n}\n```\n\n```ts src\\db\\entities\\user.entity.ts\nexport class User {\n  @OneToOne(() => Config, (config) => config.id, { cascade: true })\n  @JoinColumn()\n  config: Config;\n}\n```\n\n#### 接口案例\n**添加用户配置的接口：**\n\n```ts src\\db\\db.service.ts\nasync setConfig(params: AddConfigDto) {\n  // 获取需要添加配置的用户\n  const user = await this.userRepository.findOneBy({ id: params.userId });\n  // 创建一个配置实体\n  const config = this.configRepository.create({\n    name: params.config.name,\n  });\n  // 若是开启了级联保存，可以省略此步，会自动保存到数据库\n  await this.configRepository.insert(config); // 插入配置实体\n  user.config = config; // 关联用户和配置\n  const result = await this.userRepository.save(user); // 保存到数据库\n  return result;\n}\n// {\n//   \"id\": 1,\n//   \"name\": \"用户1\",\n//   \"desc\": \"这是一个用户\",\n//   \"create_time\": \"2024-02-19T13:35:28.264Z\",\n//   \"update_time\": \"2024-02-20T14:03:13.000Z\",\n//   \"delete_time\": null,\n//   \"config\": {\n//     \"name\": \"配置2\",\n//     \"id\": 2\n//   }\n// }\n```\n\n查询时，需要指定 `relations` 选项，以加载关联的实体，值为数组，元素是实现关联的属性名。\n\n```ts src\\db\\db.service.ts\nconst result = this.userRepository.findOne({\n  relations: ['config'],\n  where: {\n    id,\n  },\n});\n```\n\n### 一对多/多对一\n以 `User` 和 `Category` 实体为例，一个分类下有多个用户，一个用户只属于一个分类。[文档](https://typeorm.bootcss.com/many-to-one-one-to-many-relations)\n\n有了一对一关系的基础，下面直接实现**双向**的一对多/多对一关系。\n\n```ts src\\db\\entities\\user.entity.ts\nexport class User {\n  @ManyToOne(() => Category, (category) => category.users, { cascade: true })\n  @JoinColumn()\n  category: Category;\n}\n```\n\n```ts src\\db\\entities\\category.entity.ts\nexport class Category {\n  @PrimaryGeneratedColumn()\n  id: number;\n  @Column()\n  name: string; // Category名称\n  @OneToMany(() => User, (user) => user.category)\n  users: User[];\n}\n```\n\n完成后，`User` 表中新增了一个 **categoryId** 外键，用于存放 `Category` 的主键(id)。\n\n`@JoinColumn()` 通常与 `@ManyToOne()` 在主实体中一起使用，用于指定外键。\n实际上 `@JoinColumn()` 可以完全省略，除非需要自定义关联列(外键)在数据库中的名称，因为在多对一关系中，外键总是在\"一\"的一侧，TypeORM 会自动添加外键。\n\n### 多对多\n以 `User` 和 `Tag` 实体为例，一个用户有多个标签，一个标签可分配给多个用户。[文档](https://typeorm.bootcss.com/many-to-many-relations)\n\nTypeORM 会为**多对多关系**自动创建一个**中间表**，用于表示两个实体的关联关系，中间表有**两个外键**，分别指向两个实体的**主键**。\n\n`@JoinTable()` 是 `@ManyToMany()` 关系所必需的，可以放在关系的***任意一侧***。用于生成中间表。\n\n下面直接实现**双向**的多对多关系。\n\n```ts src\\db\\entities\\user.entity.ts\nexport class User {\n  @ManyToMany(() => Tag, (tag) => tag.users, { cascade: true }) // 只能一侧设置级联\n  @JoinTable()\n  tags: Tag[];\n}\n```\n\n```ts src\\db\\entities\\tag.entity.ts\nexport class Tag {\n  @PrimaryGeneratedColumn()\n  id: number;\n  @Column()\n  name: string; // tag名称\n  @ManyToMany(() => User, (user) => user.tags)\n  users: User[];\n}\n```\n\n默认自动生成了名为 **user_tags_tag** 的中间表，包含两个外键，分别指向 `User` 和 `Tag` 的主键。\n\n#### 接口案例\n先实现个创建新标签的接口。\n\n```ts src\\db\\db.service.ts\nasync createTag(createTagDto: CreateTagDto) {\n  const tag = this.tagRepository.create({\n    ...createTagDto,\n  }); // 创建一个标签实体\n  const result = await this.tagRepository.save(tag); // 保存到数据库\n  return result;\n}\n```\n\n再实现给用户添加标签的接口。\n\n```ts src\\db\\db.service.ts\nasync addTag(addTagDto: AddTagDto) {\n  // 获取用户和标签\n  const user = await this.userRepository.findOne({\n    where: { id: addTagDto.userId },\n    relations: ['tags'],\n  });\n  const tag = await this.tagRepository.findOne({\n    where: { id: addTagDto.tagId },\n    relations: ['users'],\n  });\n  // 因为启用了级联，所以仅需操作一侧即可\n  user.tags.push(tag); // 关联用户和标签\n  const result = await this.userRepository.save(user); // 保存到数据库\n  return result;\n}\n```\n\n多次添加后，在 `user_tags_tag` 中间表中，就可以看到用户和标签的，通过各自主键关联的多对多关系。\n\n## 事务\n事务是数据库操作的一种机制，用于保证一组操作的**原子性**，要么全部成功，要么全部失败。\n\n**四大特性：**\n1. **原子性**：事务包含的各项操作，是一个不可分割的工作单位，要么全部成功，要么全部失败。任何一项出错都会导致整个事务的失败，同时其它已经执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。\n2. **一致性**：事务开始前和结束后，数据库的完整性约束没有被破坏。即数据库从一个一致性状态转换到另一个一致性状态。\n3. **隔离性**：并发的事务是互相隔离的，一个事务的执行不能被其它事务干扰，不同的事务并发操作**相同的数据**时，每个事务都有各自完整的数据空间。\n4. **持久性**：事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。\n\n### EntityManager\n实体管理器 [EntityManager](https://typeorm.bootcss.com/working-with-entity-manager) 可以操作任何实体，就像是存放实体存储库的集合的地方\n\n[EntityManager API](https://typeorm.bootcss.com/entity-manager-api) 与 `Repository` 的类似，但 `EntityManager` 需要指定操作的实体存储库。\n\n通过任意存储库的 `manager` 属性可以获取 `EntityManager`。\n\n在 TypeORM 中，使用 `EntityManager.transaction()` 来创建并处理事务。\n该方法接收一个回调函数，参数为 `EntityManager`，所有事务内的CURD等操作，都必须通过 `EntityManager` 在回调中执行。\n\n```ts\nthis.mangerRepository.manager.transaction(\n  async (manager) => {\n    // 通过 manager 事务内的操作\n  }\n);\n```\n\n### 转账案例\n转账分为两步，先从A账户扣款，再给B账户加款。需要事务保证两步操作的原子性，若加款失败，扣款也要回滚。\n\n```ts DTO\nexport class CreateMangerDto {\n  name: string; // 用户\n  money: number; // 金额\n}\nexport class TransferMoneyDto {\n  fromId: number; // 发起人\n  toId: number; // 接收人\n  money: number; // 转账金额\n}\n```\n\n```ts src\\manger\\manger.service.ts\nasync transferMoney(transferMoneyDto: TransferMoneyDto) {\n  try {\n    await this.mangerRepository.manager.transaction(async (manager) => {\n      const from = await manager.findOneBy(Manger, {\n        id: transferMoneyDto.fromId,\n      });\n      const to = await manager.findOneBy(Manger, {\n        id: transferMoneyDto.toId,\n      });\n      if (from.money < transferMoneyDto.money) {\n        throw new HttpException('余额不足', 400);\n      }\n      // 进行转账\n      from.money -= transferMoneyDto.money;\n      to.money += transferMoneyDto.money;\n      await manager.save(from);\n      await manager.save(to);\n    });\n  } catch (e) {\n    return {\n      message: e.message,\n    };\n  }\n  return {\n    message: '转账成功',\n  };\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["NestJS","后端"],"categories":["学习笔记"]},{"title":"NestJS[三]-进阶","url":"/article/73b2ab6d.html","content":"\n# Logger日志\nnode服务端常用的日志收集工具：[winston](https://www.npmjs.com/package/winston)、[log4js](https://www.npmjs.com/package/log4js)、[bunyan](https://www.npmjs.com/package/bunyan)、[npmlog](https://www.npmjs.com/package/npmlog)等\n\nNest内置了一个基于文本的日志记录器：[Logger](https://docs.nestjs.com/techniques/logger)\n\n**类结构：**\n1. `LoggerService` 是接口标准，如果要替换掉内置的日志类，最低要求是得符合这个接口。\n2. `ConsoleLogger` 日志主要业务类，主要负责处理格式化日志字符串输出。\n3. `Logger` 更高层封装，加入了输出缓存，并统一管理日志等级。自身有一个ConsoleLogger的默认单例。\n\n## 配置Logger\n在创建Nest应用时,通过`NestApplicationOptions.logger`来配置Logger，用于系统日志记录。\n\n**注意：**这些配置不会影响到**自定义Logger**，只作用于**内置Logger类**。\n\n```ts\nlogger?: LoggerService | LogLevel[] | false;\n```\n\n设置为**false**时，将**禁用**Logger日志\n\n```ts\nconst app = await NestFactory.create(AppModule, {\n  logger: false,\n});\n```\n\n还可以指定输出的**最低日志等级**，优先级更高的也将被输出。\n\n```ts\nconst app = await NestFactory.create(AppModule, {\n  logger: ['log'], // log及以上等级的日志将被输出，如warn、error\n});\n```\n\nLogger默认提供了6个日志等级\n\n```ts\ntype LogLevel = 'log' | 'error' | 'warn' | 'debug' | 'verbose' | 'fatal';\nconst LOG_LEVEL_VALUES = {\n  // 优先级从低到高\n  verbose: 0,\n  debug: 1,\n  log: 2,\n  warn: 3,\n  error: 4,\n  fatal: 5,\n};\n```\n\n## 自定义Logger\n实现了`LoggerService`接口的自定义Logger，可以被Nest应用使用，相当于完全**重写并覆盖**内置Logger\n\n```ts\ninterface LoggerService {\n  log(message: any, ...optionalParams: any[]): any;\n  error(message: any, ...optionalParams: any[]): any;\n  warn(message: any, ...optionalParams: any[]): any;\n  debug?(message: any, ...optionalParams: any[]): any;\n  verbose?(message: any, ...optionalParams: any[]): any;\n  fatal?(message: any, ...optionalParams: any[]): any;\n  setLogLevels?(levels: LogLevel[]): any;\n}\n```\n\n若只需要**扩展**内置的Logger，可以继承`ConsoleLogger`类，覆盖需要扩展的方法\n\n```ts\n// class ConsoleLogger implements LoggerService {}\nclass MyLogger extends ConsoleLogger {\n  error(message: any, stack?: string, context?: string) {\n    super.error(...arguments);\n  }\n}\n```\n\n在Nest应用中使用自定义Logger，用于系统日志记录\n\n```ts\nconst app = await NestFactory.create(AppModule, {\n  logger: new MyLogger(), // 使用自定义Logger\n  // logger: console // 使用console对象\n});\n```\n\n可以通过 `set*()` 等实例方法配置自定义Logger，如 `setLogLevels()` 设置输出的最低日志等级。\n\n```ts\nthis.logger.setLogLevels(['error']);\n```\n\n## 日志格式\nLogger默认的日志格式如下：\n\n```ts\n[AppName] [PID] [Timestamp] [LogLevel] [Context] Message [+ms]\n```\n\n1. **AppName** 应用程序名，被固定为[Nest]\n2. **PID**：系统分配的进程编号\n3. **Timestamp**：当前日志输出的格式化系统时间\n4. **LogLevel**：日志等级文本\n5. **Context**：上下文\n6. **Message**：输出的消息，可以是对象类型输出\n7. **+ms**：两次输出日志的时间间隔，时间戳\n\n## 使用Logger\n通过`Logger`类手动实例化一个Logger对象，用于输出日志，还可以使用`app.useLogger()`\n\n```ts\nclass Logger implements LoggerService {\n  constructor(context: string, options?: {\n    timestamp?: boolean;\n  });\n}\n```\n\n其构造函数接受两个参数：\n1. **context**：上下文，用于标识日志输出的位置\n2. **options**：配置项，只有一个`timestamp`属性，表示是否输出 **+ms**，默认为**false**\n\n其日志方法接收两个参数：\n1. **message**：输出的消息，可以是对象类型，配合`format()`方法，用于格式化输出多个消息\n2. **context**：上下文，用于标识日志输出的位置。\n\n**注意：**当Logger实例也配置了context时，以Logger实例的context为准，并且会在输出的日志中追加一条日志方法的context信息。\n\n```ts\nimport { Logger } from '@nestjs/common';\nconst logger = new Logger('app', {\n  timestamp: true,\n});\nlogger.log(format('%s %s %s', 'GET', '/test', 'test'), 'log');\n// [Nest] 28128  - 2024/02/17 14:08:45     LOG [app] GET /test test +1107ms\n// [Nest] 28128  - 2024/02/17 14:08:45     LOG [app] log +1ms // 追加的日志方法的context信息\n```\n\n## 依赖注入Logger\n手动实例化Logger对象，破坏了单例，不利于统一日志。\n\n包装一层 `LoggerModule`，通过依赖注入的方式，统一管理Logger实例。\n\n```ts\nimport { Module } from '@nestjs/common';\nimport { MyLoggerService } from './my-logger.service';\n\n@Module({\n  providers: [MyLoggerService],\n  exports: [MyLoggerService],\n})\nexport class MyLoggerModule {}\n```\n\n```ts\nimport { ConsoleLogger, Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class MyLoggerService extends ConsoleLogger {}\n```\n\n设置为全局模块，或在需要的地方导入使用，使用 `setContext()` 设置上下文。\n\n```ts\nimport { MyLoggerService } from './my-logger/my-logger.service';\n@Controller()\nexport class AppController {\n  constructor(\n    private readonly logger: MyLoggerService,\n  ) {\n    this.logger.setContext(AppController.name);\n  }\n  @Get('test')\n  getTest() {\n    this.logger.log(format('%s %s %s', 'GET', '/test', 'test'));\n  }\n}\n```\n\n若需用于系统日志记录，还需要通过 `app.useLogger()` 应用自定义Logger，并开启 `bufferLogs` 日志缓冲。\n\n```ts\nconst app = await NestFactory.create(AppModule, {\n  bufferLogs: true,\n});\n// app.get()调用检索MyLoggerService的单例实例，并依赖于首先在另一个模块中注入该实例\napp.useLogger(app.get(MyLoggerService));\n```\n\n`app.get()` 可以检索某个类型的单例实例，依赖于首先在另一个模块中注入该实例。无需再重复实例化。\n\n# ModuleRef模块引用\n[ModuleRef](https://docs.nestjs.com/fundamentals/module-ref) 类用于检索模块中的**提供者实例**，并使用注入令牌作为查找键名来获取实例的引用。\n\n`ModuleRef` 可以通过常规方法注入到类中。\n\n```ts\nimport { ModuleRef } from '@nestjs/core';\nclass AppController {\n  constructor(private readonly moduleRef: ModuleRef) {}\n}\n```\n\n## 获取实例\n`ModuleRef.get()` 使用注入标记/类名检索当前模块中存在（已实例化）的提供者、控制器或可注入项（例如，守卫、拦截器等）\n\n若该提供者是其它模块定义并暴露的，需要将`strict`设置为**false**，从全局上下文中检索。\n\n```ts\nimport { UserService } from './user/user.service';\nmoduleRef.get(UserService, { strict: false });\n```\n\n`ModuleRef` 无视了模块的依赖关系，能直接从全局上下文中检索提供者实例。\n若需要另一个模块的提供者实例，可以不暴露该提供者、不导入该模块，直接通过`ModuleRef`检索。\n\n```ts\n@Controller('download')\nexport class DownloadController {\n  private userService: UserService;\n  constructor(\n    private readonly moduleRef: ModuleRef,\n  ) {\n    this.userService = moduleRef.get(UserService, { strict: false });\n  }\n  @Get()\n  get() {\n    return this.userService.findOne(1);\n  }\n}\n```\n\n**注意：**不能通过`get()`方法检索作用域提供者（瞬态或请求作用域）\n\n## 解析作用域提供者\n通过 `ModuleRef.resolve()` 方法解析作用域提供者，返回该提供者的**唯一实例**(Promise)。\n\n多次调用该方法，返回的是不同的实例。\n\n```ts\nconst transientServices = await Promise.all([\n  this.moduleRef.resolve(TransientService),\n  this.moduleRef.resolve(TransientService),\n]);\nconsole.log(transientServices[0] === transientServices[1]); // false\n```\n\n为了在多个 `resolve()` 调用之间生成**单个实例**，可以通过 `ContextIdFactory` 创建一个上下文标识，并传递给 `resolve()` 方法。相同的上下文标识，返回的是相同的实例。\n\n```ts\nconst contextId = ContextIdFactory.create();\nconst transientServices = await Promise.all([\n  // 传递相同的上下文标识\n  this.moduleRef.resolve(TransientService, contextId),\n  this.moduleRef.resolve(TransientService, contextId),\n]);\nconsole.log(transientServices[0] === transientServices[1]); // true\n```\n\n### 请求提供者\n若通过 `resolve()` 解析**请求作用域提供者**，会导致 `REQUEST` 提供者注入为 `undefined`。因为它们不是由 Nest 依赖注入系统实例化和管理的。\n\n```ts 一个请求作用域提供者\nimport { REQUEST } from '@nestjs/core';\n@Injectable()\nexport class AppService {\n  @Inject(REQUEST)\n  res: Request;\n\n  getHello(): string {\n    console.log(this.res.url); // /value\n    return 'Hello World!';\n  }\n}\n```\n\n需要使用 `registerRequestByContextId()` 方法，先将请求对象注册到上下文中，再通过 `resolve()` 方法解析请求作用域提供者。\n\n```ts\nconst contextId = ContextIdFactory.create();\nthis.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);\nawait this.moduleRef.resolve(TransientService, contextId),\n```\n\n若在请求提供者中解析另一个请求提供者，可以更方便地通过 `getByRequest()` 方法基于请求对象创建一个上下文标识，并将其传递给 `resolve()` 调用：\n\n```ts\nconst contextId = ContextIdFactory.getByRequest(this.request);\nawait this.moduleRef.resolve(TransientService, contextId);\n```\n\n## 动态实例化\n`ModuleRef.create()` 动态实例化一个之前没有注册为提供者的类。\n\n即使该类已经被注册为提供者且已经实例化，也会创建一个新的实例(Promise)。\n\n```ts\nawait this.moduleRef.create(oneService);\n```\n\n与直接 `new` 不同，`create()` 会处理依赖注入，但这些依赖必须是执行 `create()` 所在的模块中能访问到的，缺失的依赖需要导入到该模块中。\n\n# 生命周期事件\nNest 应用以及每个应用元素都有一个由 Nest 管理的生命周期。[文档](https://docs.nestjs.com/fundamentals/lifecycle-events)\n\nNest 提供了许多钩子方法，用于在生命周期的不同阶段执行自定义逻辑。\n1. `onModuleInit()` 一旦解决了模块的依赖，就会调用。\n2. `onApplicationBootstrap()` 在所有模块初始化后调用，但在监听连接之前。\n3. `onModuleDestroy()`* 在收到终止信号（如 SIGINT）或 `app.close()` 后调用。\n4. `beforeApplicationShutdown()`* 在所有 onModuleDestroy 完成后调用。\n5. `onApplicationShutdown()`* 在连接关闭后调用。\n\n**注意：**请求作用域的类没有生命周期钩子。它们专门为每个请求创建，并在发送响应后自动进行垃圾回收。\n\n*若没有显式调用 `app.close()`，则三个关闭钩子默认是不会监听系统信号（如 SIGINT）的，监听系统信号会消耗较多的系统资源。可以通过 `app.enableShutdownHooks()` 启用对系统信号的监听，但信号在windows上可能无法预期地工作。\n\n## 使用钩子\n每个生命周期钩子都由一个接口表示。\n\n以 `onModuleInit()` 为例：需要实现 `OnModuleInit` 接口。\n\n```ts\n@Injectable()\nexport class UserService implements OnModuleInit {\n  onModuleInit() {\n    console.log(`The UserService has been initialized.`);\n  }\n}\n```\n\n如果生命周期钩子返回一个 Promise，Nest 将等待这个 Promise 完成（或者解决）之后再继续生命周期。\n\n所以`onModuleInit()`和`onApplicationBootstrap()`钩子可以是异步的，以**推迟**模块的初始化，可以完成如数据库连接等异步工作后，在完成应用初始化、监听连接。\n\n```ts\nclass UserService implements OnModuleInit {\n  async onModuleInit(): Promise<void> {\n    return await new Promise((resolve) => {\n      setTimeout(() => {\n        console.log('初始化完成');\n        resolve();\n      }, 3000);\n    });\n  }\n}\n```\n\n整体案例：\n\n```ts\nexport class AppModule {\n  onModuleInit(): any {\n    console.log('onModuleInit.');\n  }\n  onApplicationBootstrap(): any {\n    console.log('onApplicationBootstrap down.');\n  }\n  onModuleDestroy(): any {\n    console.log('onModuleDestroy');\n  }\n  beforeApplicationShutdown(signal?: string): any {\n    console.log('beforeApplicationShutdown:', signal);\n  }\n  onApplicationShutdown(signal?: string): any {\n    console.log('OnApplicationShutdown:', signal);\n  }\n}\n```\n\n```shell\nonModuleInit.\nonApplicationBootstrap down.\n[Nest] 20808  - 2024/02/17 18:03:51     LOG [NestApplication] Nest application successfully started\nonModuleDestroy\nbeforeApplicationShutdown: SIGINT\nOnApplicationShutdown: SIGINT\n```\n\n# swagger接口文档\n[Swagger](https://swagger.io/) 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务的接口文档。\n\n[Swagger UI](https://swagger.io/tools/swagger-ui/) 用于将 Swagger 规范生成的文档呈现为交互式的、动态的 API 文档。\n\n在Nset中使用需安装[@nestjs/swagger](https://www.npmjs.com/package/@nestjs/swagger)，`npm i -S @nestjs/swagger`，[文档](https://docs.nestjs.com/openapi/introduction)\n\n使用 `SwaggerModule` 类初始化 Swagger 文档，`DocumentBuilder` 类配置文档。\n\n```ts main.ts 基本使用\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  // 配置Swagger\n  const config = new DocumentBuilder()\n    .setTitle('接口文档')\n    .setDescription('一个API文档')\n    .setVersion('1.0')\n    .build();\n  // 生成文档\n  const document = SwaggerModule.createDocument(app, config);\n  // 启动文档\n  SwaggerModule.setup('api', app, document);\n  await app.listen(3000);\n}\n```\n\n`DocumentBuilder` 提供了一系列的方法用于构建符合 OpenAPI 规范的基本文档。\n\n```ts DocumentBuilder类\nclass DocumentBuilder {\n  private readonly logger;\n  private readonly document;\n  setTitle(title: string): this;\n  setDescription(description: string): this;\n  setVersion(version: string): this;\n  setTermsOfService(termsOfService: string): this;\n  setContact(name: string, url: string, email: string): this;\n  setLicense(name: string, url: string): this;\n  addServer(url: string, description?: string, variables?: Record<string, ServerVariableObject>): this;\n  setExternalDoc(description: string, url: string): this;\n  setBasePath(path: string): this;\n  addTag(name: string, description?: string, externalDocs?: ExternalDocumentationObject): this;\n  addExtension(extensionKey: string, extensionProperties: any): this;\n  addSecurity(name: string, options: SecuritySchemeObject): this;\n  addGlobalParameters(...parameters: ParameterObject[]): this;\n  addSecurityRequirements(name: string | SecurityRequirementObject, requirements?: string[]): this;\n  addBearerAuth(options?: SecuritySchemeObject, name?: string): this;\n  addOAuth2(options?: SecuritySchemeObject, name?: string): this;\n  addApiKey(options?: SecuritySchemeObject, name?: string): this;\n  addBasicAuth(options?: SecuritySchemeObject, name?: string): this;\n  addCookieAuth(cookieName?: string, options?: SecuritySchemeObject, securityName?: string): this;\n  build(): Omit<OpenAPIObject, 'paths'>;\n}\n```\n\n`SwaggerModule.createDocument` 返回的是一个符合[OpenAPI](https://swagger.io/specification/#openapi-document)规范的 `OpenAPIObject` 可序列化对象，不仅可以通过 HTTP 进行托管，还可以将其保存为 JSON/YAML 文件，并以不同的方式使用。\n\n```ts SwaggerModule类\nclass SwaggerModule {\n  private static readonly metadataLoader;\n  static createDocument(app: INestApplication, config: Omit<OpenAPIObject, 'paths'>, options?: SwaggerDocumentOptions): OpenAPIObject;\n  static loadPluginMetadata(metadataFn: () => Promise<Record<string, any>>): Promise<void>;\n  private static serveStatic;\n  private static serveDocuments;\n  static setup(path: string, app: INestApplication, documentOrFactory: OpenAPIObject | (() => OpenAPIObject), options?: SwaggerCustomOptions): void;\n}\ntype OperationIdFactory = (controllerKey: string, methodKey: string, version?: string) => string;\n// 文档选项，createDocument()方法的第三个参数\ninterface SwaggerDocumentOptions {\n  include?: Function[]; // 要包含在规范中的模块列表\n  extraModels?: Function[]; // 额外的模型，应该被检查并包含在规范中\n  ignoreGlobalPrefix?: boolean; // 如果为 `true`，Swagger 将忽略通过 `setGlobalPrefix()` 方法设置的全局前缀\n  deepScanRoutes?: boolean; // 如果为 `true`，Swagger 还将从 `include` 模块导入的模块中加载路由\n  operationIdFactory?: OperationIdFactory; // 用于生成操作 ID 的工厂函数\n}\n// 设置选项，setup()方法的第四个参数\ninterface SwaggerCustomOptions {\n  useGlobalPrefix?: boolean;\n  explorer?: boolean;\n  swaggerOptions?: SwaggerUiOptions;\n  customCss?: string;\n  customCssUrl?: string | string[];\n  customJs?: string | string[];\n  customJsStr?: string | string[];\n  customfavIcon?: string;\n  customSwaggerUiPath?: string;\n  swaggerUrl?: string;\n  customSiteTitle?: string;\n  validatorUrl?: string;\n  url?: string;\n  urls?: Record<'url' | 'name', string>[];\n  jsonDocumentUrl?: string;\n  yamlDocumentUrl?: string;\n  patchDocumentOnRequest?: <TRequest = any, TResponse = any>(req: TRequest, res: TResponse, document: OpenAPIObject) => OpenAPIObject;\n}\n```\n\nSwagger 提供了许多 `@Api*()` 装饰器，用于描述 API，在Swagger UI中显示。\n\n下面是常用的装饰器简介。[详细文档](https://docs.nestjs.com/openapi/introduction)\n\n## ApiTags分组\n`@ApiTags()` 将控制器、路由方法分组。\n\n```ts\n@ApiTags('login')\n@Controller('login')\nexport class LoginController {}\n```\n\n## ApiOperation描述路由\n`@ApiOperation()` 描述路由方法。\n\n```ts\n@ApiOperation({\n  summary: '创建登录', // 接口简介\n  description: '创建登录', // 接口描述\n})\n```\n\n## 描述参数\n有一些装饰器用于描述路由方法的参数，也就是接口所需的参数。作用于路由方法。\n1. `@ApiParam()` 描述动态路由参数。\n2. `@ApiQuery()` 描述查询字符串参数。\n3. `@ApiBody()` 描述请求体参数。\n\n```ts\n// ApiParam描述动态路由参数\n@Get()\n@ApiParam({\n  name: 'id', // 参数名\n  description: '用户id', // 参数描述\n  required: true, // 是否必须\n})\nfindOne(@Param('id', ParseIntPipe) id: number) {}\n\n// ApiQuery描述查询字符串参数\n@Get()\n@ApiQuery({\n  name: 'page', // 参数名\n  description: '页码', // 参数描述\n  required: false, // 是否必须\n})\nfindAll(@Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number) {}\n\n// ApiBody描述请求体参数\n@Post()\n@ApiBody({\n  type: CreateLoginDto, // 请求体类型\n})\ncreate(@Body() createLoginDto: CreateLoginDto) {}\n```\n\n## ApiProperty描述属性\n在Nest中使用DTO来约束、验证请求体的结构。使用 `@ApiProperty()` 描述DTO的属性。\n\n**ApiBody**和**ApiProperty**共同完成请求体的描述。有些时候**ApiBody**可以省略。\n\n```ts\nclass CreateLoginDto {\n  @ApiProperty({\n    description: '用户名', // 属性描述\n    example: 'user1', // 示例\n    minLength: 3, // 最小长度\n    maxLength: 10, // 最大长度\n    required: true, // 是否必填\n  })\n  @IsNotEmpty() // 验证是否为空\n  @IsString() // 验证是否为字符串\n  @Length(3, 10, {\n    message: '用户名长度必须为3到10位', // 自定义错误信息\n  }) // 验证字符串长度\n  username: string;\n  @ApiProperty({\n    description: '密码',\n    example: '123456',\n    required: true,\n  })\n  @IsNotEmpty()\n  @IsString()\n  password: string;\n}\n```\n\n通过 `@ApiProperty()` 可以设置属性的描述、示例、必填等信息，但对每个属性手动添加 `@ApiProperty()` 过于繁琐，且与 `class-validator` 的验证装饰器的意义重复。一旦拥有大量的DTO类，代码会变得冗长且难以维护。\n\nNest提供了[CLI插件](http://nestjs.inode.club/openapi/cli-plugin)(Swagger插件)与 `class-validator` 结合使用，自动生成DTO描述。而无需手动添加 `@ApiProperty()`。\n\n## CLI插件\n[CLI插件](http://nestjs.inode.club/openapi/cli-plugin)(Swagger插件)将自动执行以下操作：\n1. 除非使用`@ApiHideProperty`，否则会对所有DTO属性进行注解，使用`@ApiProperty`。\n2. 根据问号（例如 name?: string）设置required属性（将设置为false）。\n3. 根据类型设置type或enum属性（还支持数组）。\n4. 根据分配的默认值设置default属性。\n5. 根据`class-validator`装饰器设置多个验证规则（如果将`classValidatorShim`设置为true）。\n6. 为每个具有适当状态和type（响应模型）的端点添加响应装饰器。\n7. 根据注释为属性和端点生成描述（如果将`introspectComments`设置为true）。\n8. 根据注释为属性生成示例值（如果将`introspectComments`设置为true）。\n\n修改 `nest-cli.json` 配置文件，启用插件。\n\n```json\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"name\": \"@nestjs/swagger\",\n        \"options\": {\n          \"classValidatorShim\": true,\n          \"introspectComments\": true\n        }\n      }\n    ]\n  }\n}\n```\n\n`options`属性用于自定义插件的行为。\n\n```ts\ninterface PluginOptions {\n  dtoFileNameSuffix?: string[]; // DTO文件名后缀\n  controllerFileNameSuffix?: string[]; // 控制器文件名后缀\n  classValidatorShim?: boolean; // 配合class-validator\n  dtoKeyOfComment?: string; // DTO注释的键名\n  controllerKeyOfComment?: string; // 控制器注释的键名\n  introspectComments?: boolean; // 是否解析注释\n}\n```\n\n启用注释自省`introspectComments`功能后，CLI插件将根据注释为属性生成描述和示例值。\n\n```ts\n/**\n * 用户名\n * @example user1\n */\n// 相当于\n@ApiProperty({\n  description: `用户名`,\n  example: 'user1',\n})\n```\n\n**一些注意事项：**\n1. 文件名必须为 `.dto.ts` 或 `.entity.ts` 后缀，以便插件识别。也可以通过`dtoFileNameSuffix`自定义后缀名。\n2. 在更新插件选项时，请确保删除dist文件夹并重新构建应用程序。\n3. 即使启用了插件，仍然可以手动添加`@ApiProperty()`装饰器，以**扩展**或**覆盖**插件生成的描述。这对于添加描述和示例值非常有用。\n4. 在DTO中使用映射类型工具（例如`PartialType`）时，应该从`@nestjs/swagger`导入，而不是`@nestjs/mapped-types`，以便插件能够获取模式信息。\n5. 如果不使用CLI，而是使用自定义的webpack配置，可以将此插件与`ts-loader`结合使用\n\n## ApiResponse描述响应\n`@ApiResponse()` 描述路由方法的响应。\n\n```ts\n@ApiResponse({\n  status: 200, // 状态码\n  description: '成功', // 响应描述\n  type: String, // 响应体类型\n})\n```\n\nNest提供了一些简写的API响应装饰器，它们都继承自`@ApiResponse`装饰器\n\n```ts\n@ApiOkResponse()\n@ApiCreatedResponse()\n@ApiAcceptedResponse()\n@ApiNoContentResponse()\n@ApiMovedPermanentlyResponse()\n@ApiFoundResponse()\n@ApiBadRequestResponse()\n@ApiUnauthorizedResponse()\n@ApiNotFoundResponse()\n@ApiForbiddenResponse()\n@ApiMethodNotAllowedResponse()\n@ApiNotAcceptableResponse()\n@ApiRequestTimeoutResponse()\n@ApiConflictResponse()\n@ApiPreconditionFailedResponse()\n@ApiTooManyRequestsResponse()\n@ApiGoneResponse()\n@ApiPayloadTooLargeResponse()\n@ApiUnsupportedMediaTypeResponse()\n@ApiUnprocessableEntityResponse()\n@ApiInternalServerErrorResponse()\n@ApiNotImplementedResponse()\n@ApiBadGatewayResponse()\n@ApiServiceUnavailableResponse()\n@ApiGatewayTimeoutResponse()\n@ApiDefaultResponse()\n```\n\n要为请求指定返回模型，必须创建一个DTO类，并将其传递给 `type` 属性。\n\n```ts\nexport class CreateLoginResDto {\n  @ApiProperty({\n    description: '用户名', // 属性描述\n    example: 'user1', // 示例\n  })\n  username: string;\n  @ApiProperty({\n    description: '消息',\n    example: '登陆成功',\n  })\n  message: string;\n}\n```\n\n```ts\n@ApiResponse({\n  status: 200, // 状态码\n  description: '成功', // 响应描述\n  type: CreateLoginResDto, // 响应类型\n})\n```\n\n## ApiHeader描述请求头\n`@ApiHeader()` 描述请求头。`@ApiHeaders()` 传入数组，描述多个请求头。\n\n```ts\n@ApiHeader({\n  name: 'Authorization', // 请求头名称\n  description: 'token', // 请求头描述\n  required: true, // 是否必须\n})\n```\n\n## 全局参数\n`addGlobalParameters()` 添加全局参数，它们将出现在每个路由方法的参数中。\n\n```ts\nnew DocumentBuilder().addGlobalParameters({\n  name: 'Authorization',\n  description: 'token',\n  required: true,\n  in: 'header',\n})\n```\n\n## 安全机制\n`@ApiSecurity()` 定义特定操作应使用的安全机制\n\n```ts\n@ApiSecurity('basic')\n@Controller('login')\nexport class LoginController {}\n```\n\n需要提前在 `DocumentBuilder` 中配置安全机制。\n\n```ts\nnew DocumentBuilder().addSecurity('basic', {\n  type: 'http',\n  scheme: 'basic',\n})\n```\n\n一些常用的身份验证机制是内置的，而不必手动定义，如`basic`、`bearer`等。\n1. `@ApiBasicAuth()` 基本身份验证\n2. `@ApiBearerAuth()` Bearer身份验证\n3. `@ApiOAuth2()` OAuth2身份验证\n4. `@ApiCookieAuth()` Cookie身份验证\n\n还需要在 `DocumentBuilder` 中添加安全定义。\n\n```ts\n@ApiBasicAuth()\nnew DocumentBuilder().addBasicAuth();\n\n@ApiBearerAuth()\nnew DocumentBuilder().addBearerAuth();\n\n@ApiOAuth2(['pets:write'])\nnew DocumentBuilder().addOAuth2();\n\n@ApiCookieAuth()\nnew DocumentBuilder().addCookieAuth('optional-session-id');\n```\n\n# swagger-typescript-api\n[swagger-typescript-api](https://www.npmjs.com/package/swagger-typescript-api) 可以根据 Swagger 规范生成接口的 TS 类型和axios/fetch请求函数。\n\n该库提供了全局命令行工具，也可以导入为模块，使用 `generateApi` 方法生成接口文件。\n\n```ts\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n  // 生成接口\n  await generateApi({\n    name: 'api.ts',\n    output: resolve(process.cwd(), './api'),\n    url: 'http://localhost:3000/api-json',\n    httpClientType: 'axios',\n  });\n}\nbootstrap();\n```\n\n生成的接口文件：\n\n```ts\n/* eslint-disable */\n/* tslint:disable */\n/*\n * ---------------------------------------------------------------\n * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##\n * ##                                                           ##\n * ## AUTHOR: acacode                                           ##\n * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##\n * ---------------------------------------------------------------\n */\n\nexport interface CreateLoginDto {\n  /**\n   * @minLength 3\n   * @maxLength 10\n   */\n  username: string;\n  password: string;\n}\n// ......省略\n```\n\n# JWT token\n一个通用的后端通常使用JWT（JSON Web Token）进行会话控制、身份验证。至于session，详见[session案例](/article/7c45abd.html#session案例)\n\n[NodeJS接口、会话控制-token](/article/a1e193d6.html#token)、[JSON Web Token 入门教程-阮一峰](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n\n**流程：**服务端登陆接口验证账号密码，签发token，客户端携带token访问受保护的资源，服务端通过守卫验证token，放行受保护的路由。在token中保存角色身份，以实现基于角色的鉴权。\n\n## 在Nest中使用JWT\n安装 [@nestjs/jwt](https://www.npmjs.com/package/@nestjs/jwt) 用于生成和验证JWT。[文档](https://docs.nestjs.com/security/authentication)\n\n`JwtModule` 用于配置JWT。\n\n```ts src\\auth\\auth.module.ts\nimport { JwtModule } from '@nestjs/jwt';\n@Module({\n  imports: [\n    JwtModule.register({\n      global: true, // 全局模块\n      secret: '123456', // 密钥，应该由环境变量或配置文件提供\n      // 签名选项\n      signOptions: {\n        expiresIn: 60 * 60 * 24, // 过期时间\n      },\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n`JwtService` 用于生成和验证JWT\n1. `JwtService.sign()` 生成JWT，Async为异步方法\n2. `JwtService.verify()` 验证JWT\n\n在 `AuthService` 中使用 `sign()` 生成token，将用户名、角色、id等信息保存在token中。使用 `verify()` 验证token。\n\n```ts src\\auth\\auth.service.ts\nimport { JwtService } from '@nestjs/jwt';\n@Injectable()\nexport class AuthService {\n  constructor(private readonly jwtService: JwtService) {}\n\n  async signIn(user: any) {\n    const payload = {\n      username: user.username, // 用户名\n      id: user.userId, // 用户id\n      role: user.role, // 用户角色\n    };\n    return {\n      access_token: await this.jwtService.signAsync(payload),\n    };\n  }\n\n  async verifyToken(token: string) {\n    return this.jwtService.verifyAsync(token, {\n      // 密钥，与JwtModule.register中的secret一致\n      // 应该从环境变量或配置文件中获取\n      secret: '123456',\n    });\n  }\n}\n```\n\n测试登陆接口，获取token。实际应该通过账号密码，验证成功后生成token。\n\n```ts\n@Post('testLogin')\ntestLogin() {\n  return this.authService.signIn({\n    username: 'user1',\n    userId: 1,\n    role: 'admin',\n  });\n}\n// {\n//   \"access_token\": \"eyJhbGciOiJIUzI...\"\n// }\n```\n\n生成后的token一般由客户端保存在本地，每次请求时携带token，以一定格式放在请求头 `Authorization` 字段中。\n\n```txt token放在请求头中\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsI....\n```\n\n在 `AuthGuard` 守卫中调用 `AuthService.verifyToken()` 验证token。\n并将用户信息存入请求对象，以便后续守卫(角色鉴权)、路由(获取用户信息)等使用。\n\n```ts src\\auth\\auth.guard.ts\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private readonly authService: AuthService) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest<Request>();\n    const token = this.extractTokenFromHeader(request);\n    if (!token) {\n      throw new UnauthorizedException();\n    }\n    try {\n      // 验证token\n      const payload = await this.authService.verifyToken(token);\n      // 将用户信息存入请求对象，以便路由等使用\n      request['user'] = payload;\n    } catch (e) {\n      throw new UnauthorizedException();\n    }\n    return true;\n  }\n\n  // 从请求头中提取token\n  private extractTokenFromHeader(request: Request): string | undefined {\n    const [type, token] = request.get('authorization')?.split(' ') ?? [];\n    return type === 'Bearer' ? token : undefined;\n  }\n}\n```\n\n测试受保护的路由\n\n```ts\n@ApiBearerAuth()\n@UseGuards(AuthGuard)\n@Get('list')\nlist(@Req() req: Request) {\n  console.log(req['user']);\n  // {\n  //   username: 'user1',\n  //   id: 1,\n  //   role: 'admin',\n  //   iat: 1708243192,\n  //   exp: 1708329592\n  // }\n  return 'list';\n}\n```\n\n# config配置\n一些关键的信息如jwt的加密密钥、数据库链接等，应该通过配置提供，而不是硬编码，[12-Factor应用原则](https://12factor.net/config)\n\n在Node中，可以使用[dotenv](https://www.npmjs.com/package/dotenv)，将环境变量保存在`.env`文件中，通过`process.env`读取。\n\nNest提供了更好的做法，导入 `ConfigModule` 模块，使用 `ConfigService` 服务，该服务加载适当的 `.env` 文件，这样一个通用的配置模块Nest已经提供了[@nestjs/config](https://www.npmjs.com/package/@nestjs/config)，其底层也使用了**dotenv**。[文档](https://docs.nestjs.com/techniques/configuration)\n\n**安装：**`npm i -S @nestjs/config`\n\n键冲突：当一个键同时存在于运行时环境变量和 .env 文件中时，运行时环境变量优先。\n\n## 使用ConfigModule\n`ConfigModule` 模块用于加载配置文件，通常导入到根模块中，并设为全局模块。\n\n```ts\nstatic forRoot(options?: ConfigModuleOptions): DynamicModule;\ninterface ConfigModuleOptions {\n  cache?: boolean; // 缓存环境变量\n  isGlobal?: boolean; // 全局模块\n  ignoreEnvFile?: boolean; // 忽略环境变量文件，只使用运行时环境变量\n  ignoreEnvVars?: boolean; // 忽略所有环境变量\n  envFilePath?: string | string[]; // 环境变量文件\n  validate?: (config: Record<string, any>) => Record<string, any>; // 自定义验证环境变量\n  validationSchema?: any; // 模式验证\n  validationOptions?: Record<string, any>; // 配置验证选项\n  load?: Array<ConfigFactory>; // 自定义加载配置文件\n  expandVariables?: boolean | DotenvExpandOptions; // 扩展变量\n}\n```\n\n该模块使用 `forRoot()` 静态方法来控制其行为。\n1. `isGlobal` 是否全局模块\n2. `envFilePath` 环境变量文件\n3. `ignoreEnvFile` 忽略环境变量文件\n4. `load` 自定义加载配置文件\n5. `expandVariables` 扩展变量\n6. `cache` 缓存环境变量\n7. `validationSchema` 模式验证\n8. `validationOptions` 配置验证选项\n9. `validate` 自定义验证环境变量\n\n```ts 配置案例\nimport { ConfigModule } from '@nestjs/config';\nimport configuration from './configuration';\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true, // 全局模块\n      envFilePath: '.env', // 环境变量文件\n      // ignoreEnvFile: true, // 忽略环境变量文件\n      load: [configuration], // 自定义加载配置文件\n      expandVariables: true, // 扩展变量，允许在.env文件中嵌套变量\n      cache: true, // 缓存环境变量\n      // validationSchema: Joi.object({}), // 模式验证\n      // 配置验证选项\n      validationOptions: {\n        allowUnknown: false, // 是否允许环境变量中存在未知的键\n        abortEarly: true, // 早期中止, 一旦发现错误就停止验证\n      },\n      // 自定义验证，传入配置对象，返回配置对象\n      validate(config) {\n        return config;\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n### env相关选项\n`envFilePath` 用于指定环境变量文件，`string | string[]`。\n\n```ts\nenvFilePath: '.development.env',\nenvFilePath: ['.env.development.local', '.env.development'],\n```\n\n`ignoreEnvFile` 忽略环境变量文件，只使用运行时环境变量。\n`ignoreEnvVars` 忽略所有环境变量。\n\n`expandVariables` 启用扩展变量，允许在env文件中嵌套变量。\n\n```txt\nAPP_URL=mywebsite.com\nSUPPORT_EMAIL=support@${APP_URL} # 'support@mywebsite.com'\n```\n\n### 自定义配置文件\n`load` 用于自定义加载配置文件，值为 `ConfigFactory` 数组，它是一个工厂函数，返回一个配置对象。\n\n在 `ConfigFactory` 中可以访问到已经解析完环境变量的 `process.env`。\n\n```ts src/configuration.ts\nconst configFactory = () => ({\n  port: parseInt(process.env.PORT, 10) || 3000,\n  database: {\n    host: process.env.DATABASE_HOST,\n    port: parseInt(process.env.DATABASE_PORT, 10) || 5432,\n  },\n  jwt: {\n    secret: '123456',\n    expiresIn: 60 * 60 * 24,\n  },\n});\n// 导出配置类型，以便在其他地方使用，通过ReturnType获取函数返回类型\nexport type Configuration = ReturnType<typeof configFactory>;\n// 需要导出一个工厂函数，返回配置对象\nexport default (): Configuration => configFactory;\n```\n\n```ts\nimport configuration from './configuration';\nload: [configuration],\n```\n\n配置文件除了导出一个工厂函数外，还应该导出一个配置类型，以便在其他地方使用，获得类型提示。\n\n**注意：**多个配置文件最终会合并为一个配置对象。要区分不同的配置文件，可以使用命名空间。\n\n### 配置命名空间\n`load` 允许加载多个配置文件，每个配置文件可以返回一个对象，这些对象将被合并到一个配置对象中。\n\n为了避免冲突，可以通过 `registerAs()` 为每个配置文件指定一个命名空间。\n\n```ts\nimport { registerAs } from '@nestjs/config';\nconst configFactory = () => ({\n  port: parseInt(process.env.PORT, 10) || 3000,\n  database: {\n    host: process.env.DATABASE_HOST,\n    port: parseInt(process.env.DATABASE_PORT, 10) || 5432,\n  },\n  jwt: {\n    secret: '123456',\n    expiresIn: 60 * 60 * 24,\n  },\n});\n// 导出配置类型，以便在其他地方使用，通过ReturnType获取函数返回类型\nexport type Configuration = ReturnType<typeof configFactory>;\n// 导出命名空间token(名称)\nexport const configToken = 'configuration';\n// 使用registerAs为该配置文件创建一个命名空间\nexport default registerAs(configToken, configFactory);\n```\n\n## 使用ConfigService\n`ConfigService` 服务使用 `get()` 读取配置对象中的值。\n\n对于普通的 `ConfigFactory` 配置文件，可以直接获取配置对象的属性。\n对于 `registerAs()` 创建的具有命名空间的配置，需要先获取命名空间，再获取属性，或者使用点表示法获取属性。\n\n下面以jwt配置为例。将jwt的密钥通过配置对象获取。\n\n```ts src\\auth\\auth.service.ts\nimport { Configuration, configToken } from 'src/configuration';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private readonly jwtService: JwtService,\n    // 注入ConfigService\n    private readonly configService: ConfigService,\n  ) {}\n\n  async verifyToken(token: string) {\n    return this.jwtService.verifyAsync(token, {\n      // 通过配置对象获取密钥\n      secret: this.configService.get<Configuration>(configToken).jwt.secret,\n    });\n  }\n}\n```\n\n对于 `JwtModule` 的配置，也可以通过 `ConfigService` 获取。\n\n为了注入 `ConfigService`，需使用 `JwtModule.registerAsync()` 异步配置方法。[问题参考](https://stackoverflow.com/questions/54308318/how-to-get-the-configurations-from-within-a-module-import-in-nestjs)\n\n```ts\nimport { JwtModule } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { Configuration, configToken } from 'src/configuration';\n\n@Module({\n  imports: [\n    JwtModule.registerAsync({\n      useFactory: (configService: ConfigService) => ({\n        secret: configService.get<Configuration>(configToken).jwt.secret,\n        signOptions: {\n          expiresIn:\n            configService.get<Configuration>(configToken).jwt.expiresIn,\n        },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n`get()` 方法还可以接收第二个参数，用于定义默认值。当键不存在时，将返回该默认值。\n\n`ConfigService` 可以接收两个泛型\n1. 第一个泛型用于防止访问不存在的配置属性\n2. 第二个泛型为boolean，以消除tsconfig选项 `strictNullChecks` 打开时，可能返回的所有undefined类型\n\n```ts\ninterface EnvironmentVariables {\n  PORT: number;\n  TIMEOUT: string;\n}\nconstructor(private configService: ConfigService<EnvironmentVariables>) {\n  const port = this.configService.get('PORT', { infer: true });\n  // infer: true 根据接口自动推断属性的类型\n}\n```\n\n## validate验证环境变量\n`validate(config)` 是**同步**的，**参数为所有环境变量**，用于验证所需的环境变量是否符合某些验证规则，防止预期之外的环境变量值被传入配置对象。\n\n与自定义类验证管道类似，使用 `class-validator` 和 `class-transformer` 库。\n\n```ts 编写验证类和验证函数\nimport { plainToInstance } from 'class-transformer';\nimport { IsDefined, IsNumber, IsString, validateSync } from 'class-validator';\n\nclass EnvironmentVariables {\n  @IsNumber()\n  PORT?: number;\n  @IsString()\n  @IsDefined()\n  DATABASE_HOST: string;\n  @IsNumber()\n  DATABASE_PORT?: number;\n}\n\nexport function validate(config: Record<string, unknown>) {\n  const validatedConfig = plainToInstance(EnvironmentVariables, config, {\n    enableImplicitConversion: true, // 启用隐式转换，这对于环境变量来说是必要的\n  });\n  const errors = validateSync(validatedConfig, {\n    skipMissingProperties: true, // 是否跳过缺失的属性，关闭后所有所需的环境变量都必须存在\n  });\n\n  if (errors.length > 0) {\n    throw new Error(errors.toString());\n  }\n  return validatedConfig;\n}\n\n```\n\n因为 `validate()` 是**同步**的，所以必须使用 `validateSync()` 同步方法。\n\n```ts 应用验证函数\nimport { validate } from './config.validation';\nConfigModule.forRoot({\n  validate,\n}),\n```\n\n若验证失败，则会直接抛出错误，并终止应用程序。\n\n```shell\nError: An instance of EnvironmentVariables has failed the validation:    \n - property NODE_ENV has failed the following constraints: isEnum        \n,An instance of EnvironmentVariables has failed the validation:\n - property PORT has failed the following constraints: isNumber\n,An instance of EnvironmentVariables has failed the validation:\n - property DATABASE_HOST has failed the following constraints: isNumber \n,An instance of EnvironmentVariables has failed the validation:\n - property DATABASE_PORT has failed the following constraints: isNumber\n```\n\n## 在main中使用\n在 `main.ts` 中通过 `app.get()` 获取已存在的 `ConfigService` 实例引用\n\n```ts\nconst configService = app.get(ConfigService);\nawait app.listen(configService.get<Configuration>(configToken).port);\n```\n\n## 局部注册配置文件\n一些配置文件可能只在特定模块中使用，可以使用 `forFeature()` 方法注册配置文件。而不必将所有配置文件都在 `forRoot()` 中注册。\n\n```ts\nexport default registerAs('db', () => ({\n  s1: 222,\n  s2: 111,\n}));\n\nimport dbConfig from './db.configuration';\n@Module({\n  imports: [ConfigModule.forFeature(dbConfig)],\n})\nexport class DbModule {}\n```\n\n在该模块的控制器中访问配置。\n\n```ts\n@Get()\nfindAll() {\n  console.log(this.configService.get('db').s1);\n  return this.dbService.findAll();\n}\n```\n\n统一注册和局部注册**效果是差不多的**，都能在所需的地方通过注入 `ConfigService` 来访问，只是局部注册需要注意模块依赖和模块的初始化顺序。\n\n若在**依赖该模块**的模块中访问局部注册的配置，可能需要使用 `onModuleInit()` 钩子，而不是在构造函数中，因为 `forFeature()` 方法在模块初始化期间运行，而模块初始化的顺序是不确定的，这些配置所依赖的模块可能尚未初始化。`onModuleInit()` 方法仅在所有依赖的模块都已初始化后才运行，因此是安全的。\n\n> 所以配置文件不是太多的话，还是统一注册比较方便。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["NestJS","后端"],"categories":["学习笔记"]},{"title":"NestJS[二]-核心","url":"/article/c81f9b65.html","content":"\n# 上传文件\nNest内置了Express的 [Multer](https://github.com/expressjs/multer) 中间件，它只处理 `multipart/form-data` 类型的表单数据，主要用于**上传文件**。[文档](https://nest.nodejs.cn/techniques/file-upload#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6)\n\n类型提示：`npm i -D @types/multer`，接着就可以使用 `Express.Multer.File` 类型，表示上传的文件信息\n\n```ts\ninterface File {\n  fieldname: string; // 字段名\n  originalname: string; // 原始文件名\n  encoding: string; // 编码\n  mimetype: string; // 文件类型\n  size: number; // 文件大小\n  stream: Readable; // 文件流\n  destination: string; // 文件存储目录\n  filename: string; // 文件名\n  path: string; // 文件路径\n  buffer: Buffer; // 文件缓存\n}\n```\n\n## 单文件上传\n`@nestjs/platform-express` 提供了 `FileInterceptor()` 拦截器处理单文件上传\n\n```ts\nfunction FileInterceptor(\n  fieldName: string, // 请求体的字段名\n  localOptions?: MulterOptions // Multer的配置项\n): Type<NestInterceptor>;\n```\n\nMulter的配置项：\n\n```ts\ninterface MulterOptions {\n  dest?: string | Function; // 文件存储目录\n  storage?: any; // diskStorage() 配置存储项\n  limits?: { // 限制\n    fieldNameSize?: number;\n    fieldSize?: number;\n    fields?: number;\n    fileSize?: number;\n    files?: number;\n    parts?: number;\n    headerPairs?: number;\n  };\n  preservePath?: boolean; // 保留路径\n  fileFilter?( // 文件过滤\n    req: any, \n    file: {\n      fieldname: string;\n      originalname: string;\n      encoding: string;\n      mimetype: string;\n      size: number;\n      destination: string;\n      filename: string;\n      path: string;\n      buffer: Buffer;\n    }, callback: (\n      error: Error | null, \n      acceptFile: boolean\n    ) => void\n  ): void;\n}\n```\n\n在路由方法上应用该拦截器，再使用 `@UploadedFile()` 参数装饰器获取 `Express.Multer.File` 类型文件对象。\n\n```ts\n@Post('img')\n@UseInterceptors(\n  FileInterceptor('file', {\n    storage: diskStorage({\n      destination: './public/img', // 文件保存的目录\n      // 自定义文件名\n      filename: (req, file, cb) => {\n        const fileParse = path.parse(file.originalname);\n        // 原始文件名+时间戳+文件后缀\n        const fileName = `${fileParse.name}_${new Date().getTime()}${fileParse.ext}`;\n        // 第一个参数为error，如果没有错误，则应该设置为null\n        return cb(null, fileName);\n      },\n    }),\n  }),\n)\nimgUpload(@UploadedFile() file: Express.Multer.File) {\n  return file;\n  // {\n  //   \"fieldname\": \"file\",\n  //   \"originalname\": \"1.png\",\n  //   \"encoding\": \"7bit\",\n  //   \"mimetype\": \"image/png\",\n  //   \"destination\": \"./public/img\",\n  //   \"filename\": \"1_1706689279088.png\",\n  //   \"path\": \"public\\\\img\\\\1_1706689279088.png\",\n  //   \"size\": 787441\n  // }\n}\n```\n\n## 多文件上传-数组\n使用 `FilesInterceptor()` 拦截器处理多文件上传，一个字段上传多个文件。\n\n```ts\nfunction FilesInterceptor(\n  fieldName: string, // 请求体的字段名\n  maxCount?: number, // 最大文件数量\n  localOptions?: MulterOptions // Multer的配置项\n): Type<NestInterceptor>;\n```\n\n使用 `@UploadedFiles()` 参数装饰器获取 `Express.Multer.File[]` 类型文件对象。\n\n```ts\n@Post('images')\n@UseInterceptors(\n  FilesInterceptor('files', 10, {\n    storage: diskStorage({\n      destination: './public/img', // 文件保存的目录\n      // 自定义文件名\n      filename: (req, file, cb) => {\n        const fileParse = path.parse(file.originalname);\n        // 原始文件名+时间戳+文件后缀\n        const fileName = `${fileParse.name}_${new Date().getTime()}${fileParse.ext}`;\n        // 第一个参数为error，如果没有错误，则应该设置为null\n        return cb(null, fileName);\n      },\n    }),\n  }),\n)\nimagesUpload(@UploadedFiles() files: Express.Multer.File[]) {\n  console.log(files);\n  // [\n  //   {\n  //     fieldname: 'files',\n  //     originalname: '3.png',\n  //     encoding: '7bit',\n  //     mimetype: 'image/png',\n  //     destination: './public/img',\n  //     filename: '3_1706687883220.png',\n  //     path: 'public\\\\img\\\\3_1706687883220.png',\n  //     size: 19457170\n  //   },\n  //   {\n  //     fieldname: 'files',\n  //     originalname: '2.jpg',\n  //     encoding: '7bit',\n  //     mimetype: 'image/jpeg',\n  //     destination: './public/img',\n  //     filename: '2_1706687883283.jpg',\n  //     path: 'public\\\\img\\\\2_1706687883283.jpg',\n  //     size: 1127874\n  //   }\n  // ]\n  return 'success';\n}\n```\n\n## MulterModule统一配置\n多个路由都需要上传文件，可以将相同配置提取出来，在模块的 imports 中使用 `MulterModule.register()` 导入配置。\n\n```ts\n@Module({\n  imports: [\n    MulterModule.register({\n      storage: diskStorage({\n        destination: './public/img', // 文件保存的目录\n        // 自定义文件名\n        filename: (req, file, cb) => {\n          const fileParse = path.parse(file.originalname);\n          // 原始文件名+时间戳+文件后缀\n          const fileName = `${fileParse.name}_${new Date().getTime()}${fileParse.ext}`;\n          // 第一个参数为error，如果没有错误，则应该设置为null\n          return cb(null, fileName);\n        },\n      }),\n    }),\n  ],\n  controllers: [UploadController],\n  providers: [UploadService],\n})\nexport class UploadModule {}\n```\n\n```ts\n@Post('img')\n@UseInterceptors(FileInterceptor('file'))\nimgUpload(@UploadedFile() file: Express.Multer.File) {\n  return file;\n}\n\n@Post('images')\n@UseInterceptors(FilesInterceptor('files'))\nimagesUpload(@UploadedFiles() files: Express.Multer.File[]) {\n  return files;\n}\n```\n\n## 任意字段上传\n使用 `AnyFilesInterceptor()` 任意字段上传，请求体中任意字段上传的文件都会被处理\n\n```ts\n@Post('any')\n@UseInterceptors(AnyFilesInterceptor())\nanyUpload(@UploadedFiles() files: Express.Multer.File[]) {\n  return files;\n}\n```\n\n```json\n[\n  {\n    \"fieldname\": \"aa\",\n    \"originalname\": \"2.jpg\",\n    \"encoding\": \"7bit\",\n    \"mimetype\": \"image/jpeg\",\n    \"destination\": \"./public/img\",\n    \"filename\": \"2_1706690551808.jpg\",\n    \"path\": \"public\\\\img\\\\2_1706690551808.jpg\",\n    \"size\": 1127874\n  },\n  {\n    \"fieldname\": \"bb\",\n    \"originalname\": \"5.jpg\",\n    \"encoding\": \"7bit\",\n    \"mimetype\": \"image/jpeg\",\n    \"destination\": \"./public/img\",\n    \"filename\": \"5_1706690551818.jpg\",\n    \"path\": \"public\\\\img\\\\5_1706690551818.jpg\",\n    \"size\": 1473642\n  },\n  {\n    \"fieldname\": \"cc\",\n    \"originalname\": \"8.jpg\",\n    \"encoding\": \"7bit\",\n    \"mimetype\": \"image/jpeg\",\n    \"destination\": \"./public/img\",\n    \"filename\": \"8_1706690551825.jpg\",\n    \"path\": \"public\\\\img\\\\8_1706690551825.jpg\",\n    \"size\": 433466\n  }\n]\n```\n\n## 自定义字段上传\n在多个字段上传单个或多个文件，使用 `FileFieldsInterceptor()` 拦截器，指定字段名和最大文件数量，允许携带其他参数\n\n```ts\n@Post('files')\n@UseInterceptors(\n  FileFieldsInterceptor([\n    { name: 'avatar', maxCount: 1 },\n    { name: 'background', maxCount: 2 },\n  ]),\n)\nuploadFile(\n  @UploadedFiles()\n  files: {\n    avatar?: Express.Multer.File[];\n    background?: Express.Multer.File[];\n  },\n) {\n  return files;\n}\n```\n\n```json\n{\n  \"avatar\": [\n    {\n      \"fieldname\": \"avatar\",\n      \"originalname\": \"5.jpg\",\n      \"encoding\": \"7bit\",\n      \"mimetype\": \"image/jpeg\",\n      \"destination\": \"./public/img\",\n      \"filename\": \"5_1706691247632.jpg\",\n      \"path\": \"public\\\\img\\\\5_1706691247632.jpg\",\n      \"size\": 1473642\n    }\n  ],\n  \"background\": [\n    {\n      \"fieldname\": \"background\",\n      \"originalname\": \"6596.png\",\n      \"encoding\": \"7bit\",\n      \"mimetype\": \"image/png\",\n      \"destination\": \"./public/img\",\n      \"filename\": \"6596_1706691247641.png\",\n      \"path\": \"public\\\\img\\\\6596_1706691247641.png\",\n      \"size\": 1328729\n    },\n    {\n      \"fieldname\": \"background\",\n      \"originalname\": \"14.jpg\",\n      \"encoding\": \"7bit\",\n      \"mimetype\": \"image/jpeg\",\n      \"destination\": \"./public/img\",\n      \"filename\": \"14_1706691247648.jpg\",\n      \"path\": \"public\\\\img\\\\14_1706691247648.jpg\",\n      \"size\": 888767\n    }\n  ]\n}\n```\n\n存在意外字段会返回错误信息\n\n```json\n{\n  \"message\": \"Unexpected field\",\n  \"error\": \"Bad Request\",\n  \"statusCode\": 400\n}\n```\n\n## 没有文件\n要接受multipart/form-data但不允许上传任何文件，需使用`NoFilesInterceptor()`，会将多部分数据设置为请求主体的属性。如果请求中包含文件，将返回BadRequestException异常\n\n```ts\n@Post('noFile')\n@UseInterceptors(NoFilesInterceptor())\nnoFile(@Body() body: any) {\n  console.log(body);\n}\n```\n\n# 静态资源目录\n设置静态目录以访问上传的图片等文件\n\n1. `NestFactory.create<T>` 泛型设置为 `NestExpressApplication`，表示创建一个基于Express的应用\n2. `app.useStaticAssets()` 设置静态资源目录\n\n```ts\nuseStaticAssets(path: string, options?: ServeStaticOptions): this;\ninterface ServeStaticOptions {\n  dotfiles?: string;\n  etag?: boolean;\n  extensions?: string[];\n  fallthrough?: boolean;\n  immutable?: boolean;\n  index?: boolean | string | string[];\n  lastModified?: boolean;\n  maxAge?: number | string;\n  redirect?: boolean;\n  setHeaders?: (res: any, path: string, stat: any) => any;\n  prefix?: string;\n}\n```\n\n```txt\ndotfiles（点文件）:\n  说明: 设置在遇到点文件时如何处理。点文件是以点（\".\"）开头的文件或目录。注意，此检查仅在路径本身进行，而不检查路径在磁盘上是否实际存在。\n  取值:\n  'allow': 对点文件没有特殊处理。\n  'deny': 对任何对点文件的请求返回403。\n  'ignore': 假装点文件不存在，然后调用next()。\n\netag（实体标签）:\n  说明: 启用或禁用ETag生成，默认为true。\n  取值:\n  true: 启用ETag生成。\n  false: 禁用ETag生成。\n\nextensions（文件扩展名）:\n  说明: 设置文件扩展名的回退。当文件不存在时，将给定的扩展名添加到文件名中并搜索。将返回找到的第一个文件。例如：['html', 'htm']。\n  默认值: false。\n\nfallthrough（错误是否穿透）:\n  说明: 让客户端错误穿透为未处理的请求，否则转发客户端错误。\n  默认值: false。\n\nimmutable（是否启用不可变指令）:\n  说明: 启用或禁用Cache-Control响应头中的不可变指令。如果启用，应该同时指定maxAge选项以启用缓存。\n  取值:\n  true: 启用不可变指令。\n\nindex（默认索引文件）:\n  说明: 默认情况下，该模块将在目录请求时发送\"index.html\"文件。可以通过设置为false来禁用，或者提供一个字符串或字符串数组以指定新的索引文件。\n  默认值: true。\n\nlastModified（最后修改时间）:\n  说明: 启用或禁用Last-Modified头，默认为true。使用文件系统的最后修改值。\n  默认值: true。\n\nmaxAge（最大缓存时间）:\n  说明: 提供http缓存的最大时间（毫秒），默认为0。也可以是ms模块接受的字符串。\n  默认值: 0。\n\nredirect（重定向斜杠）:\n  说明: 当路径名是目录时，是否重定向到带有斜杠的路径。默认为true。\n  默认值: true。\n\nsetHeaders（设置自定义头）:\n  说明: 在响应上设置自定义头的函数。更改头需要同步进行。该函数调用格式为fn(res, path, stat)，其中参数为：\n  res - 响应对象。\n  path - 正在发送的文件路径。\n  stat - 正在发送的文件的stat对象。\n\nprefix（虚拟路径前缀）:\n  说明: 创建虚拟路径前缀。\n```\n\n```ts\napp.useStaticAssets(join(__dirname, '..', 'public')); // 静态资源目录\n// 访问./public/img/1.png -> http://localhost:3000/img/1.png\n```\n\n## 复制assets\n在 `nest-cli.json` 中配置 `compilerOptions.assets`，编译时将**静态资源**复制到输出目录。\n\n```json\n\"compilerOptions\": {\n  \"deleteOutDir\": true,\n  \"watchAssets\": true, // 监听静态资源变化\n  \"assets\": [\n    {\n      \"include\": \"../public\", // 静态资源目录，相对于src目录\n      \"outDir\": \"dist/public\" // 输出目录，相对于根目录\n    },\n    {\n      \"include\": \"../views\",\n      \"outDir\": \"dist/views\"\n    }\n  ],\n}\n```\n\n# 返回/下载文件\n既然上传了文件，那返回文件也是常用的\n\n## sendFile\nexpress的`sendFile`封装了下面的过程，属于流式传输。\n\n```ts\nconst writeStream = fs.createReadStream(filePath)\nstream.pipe(response)\n// ....略去一系列setHeader操作\n```\n\n会根据文件的扩展名设置Content-Type，浏览器会直接打开文件，而不是下载。\n\n```ts\n@Get('img')\nfileDownload(@Query('name') name: string, @Res() res: Response) {\n  res.sendFile(name, { root: 'public/img' });\n}\n```\n\n## StreamableFile\n手动操作res可能会让Nest丢失对响应的控制权，让拦截器等不生效\n\n[StreamableFile](https://nest.nodejs.cn/techniques/streaming-files) 是Nest流式文件的包装器，允许在响应中返回流式传输的文件。\n\n但它并不会自动根据文件类型设置Content-Type，默认是**application/octet-stream**\n\n```ts\n@Get('stream')\nasync streamDownload(\n  @Query('name') name: string,\n  @Res({ passthrough: true }) res: Response,\n) {\n  const fd = await fs.promises.open(`public/img/${name}`, 'r');\n  const readStream = fd.createReadStream();\n  const dynamicImport = new Function('specifier', 'return import(specifier)');\n  const mime = await dynamicImport('mime');\n  res.set({\n    'Content-Type': mime.default.getType(fs.stat.name),\n    // 让浏览器下载文件，需加上Content-Disposition\n    // 'Content-Disposition': `attachment; filename=${name}`,\n  });\n  return new StreamableFile(readStream);\n}\n```\n\n使用了[mime](https://www.npmjs.com/package/mime)获取文件类型，但从mime@4开始，只提供了esm导出，nest默认会输出为commonjs，所以需要import()动态引入。\n\n但转为commonjs时，import()会被tsc转为reuqire()，解决问题：[Dynamic import() with \"module\": \"commonjs\" ](https://github.com/TypeStrong/ts-node/discussions/1290)\n\n## download\nExpress提供了`res.download()`方法，可以让浏览器下载文件。\n\nsendFile告知浏览器它是一个流，但没让浏览器下载它。\n而download在响应头里加上了 **Content-Disposition: attachment; filename=\"xxxx\"** 告知浏览器下载文件。\n\n```ts\n@Get('download')\ndownload(@Query('name') name: string, @Res() res: Response) {\n  res.download(`public/img/${name}`);\n}\n```\n\n## 压缩文件下载\n[compressing](https://www.npmjs.com/package/compressing) 压缩文件，StreamableFile 将压缩流返回。并设置 Content-Disposition 让浏览器下载文件。\n\n```ts\nimport compressing from 'compressing';\n@Get('zip')\ndownloadZip(\n  @Query('name') name: string,\n  @Res({ passthrough: true }) res: Response,\n) {\n  const tarStream = new compressing.zip.Stream();\n  tarStream.addEntry(`public/img/${name}`);\n  res.set({\n    'Content-Disposition': `attachment; filename=${path.parse(name).name}.zip`,\n  });\n  return new StreamableFile(tarStream);\n}\n```\n\n# RxJS\n[RxJS](https://rxjs.dev/)(Reactive Extensions for JavaScript) 是一个使用**可观察**(Observable)序列来编写异步和**基于事件**(Event-based)程序的库。即**观察者模式**，编写异步队列和事件处理。[cn文档v5](https://cn.rx.js.org/)\n\n**详见：**[学习笔记-RxJS](/article/c79e1541.html)\n\nNest 内置了 RxJs，如拦截器(**Interceptor**)等功能都是基于 RxJs 实现的。\n\n# Interceptor拦截器\n[Interceptor](https://docs.nestjs.com/interceptors)是具有`@Injectable()`装饰器的类，实现了`NestInterceptor`接口。可以**拦截**请求和响应，对它们进行**转换**和**处理**。\n\n拦截器是面向切面编程**AOP**的一种实现，具有一系列有用的功能：\n1. 函数执行之前/之后绑定额外的逻辑\n2. 转换从函数返回的结果\n3. 转换从函数抛出的异常\n4. 扩展基本函数行为\n5. 根据所选条件完全重写函数 (例如, 缓存目的)\n\n`nest g itc <name>` 创建拦截器\n\n```ts 一个最简单的拦截器\nimport {\n  CallHandler,\n  ExecutionContext,\n  Injectable,\n  NestInterceptor,\n} from '@nestjs/common';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle();\n  }\n}\n```\n\n参考：\n[NestJS10-Interceptors](https://juejin.cn/post/7205585832232255549)\n[NestJs学习之旅(9)——拦截器](https://juejin.cn/post/6844903939196846087)\n[深入了解Nest拦截器](https://juejin.cn/post/6943791344414359560)\n\n## NestInterceptor\n`NestInterceptor`接口定义了一个`intercept`方法，接收两个参数：\n1. `context`：执行上下文，具有一些获取执行信息的方法。\n2. `next`：`CallHandler`类型，它的`handle`方法返回一个`Observable`。\n\n```ts\ninterface NestInterceptor<T = any, R = any> {\n  intercept(context: ExecutionContext, next: CallHandler<T>): Observable<R> | Promise<Observable<R>>;\n}\n```\n\ncontext参数是`ExecutionContext`类型，继承自`ArgumentsHost`，具有一些获取执行信息的方法。\n\n```ts\ninterface ExecutionContext extends ArgumentsHost {\n  getClass<T = any>(): Type<T>; // 获取控制器类\n  getHandler(): Function; // 获取路由处理函数\n}\ninterface ArgumentsHost {\n  getArgs<T extends Array<any> = any[]>(): T; // 获取上下文参数，返回一个数组，0 - 请求对象，1 - 响应对象 2 - next函数\n  getArgByIndex<T = any>(index: number): T; // 通过索引获取参数\n  switchToRpc(): RpcArgumentsHost; // 获取RPC上下文对象\n  switchToHttp(): HttpArgumentsHost; // 获取Http上下文对象\n  switchToWs(): WsArgumentsHost; // 获取WebSocket上下文对象\n  getType<TContext extends string = ContextType>(): TContext; // 获取执行上下文的类型\n}\n```\n\nnext参数是`CallHandler`类型，是对**路由处理函数**的抽象，它的`handle()`方法就是调用路由处理函数，返回一个`Observable`，包装了响应流，可以用Rxjs操作符对其进行处理。\n\n```ts\ninterface CallHandler<T = any> {\n  handle(): Observable<T>;\n}\n```\n\nintercept方法返回`Observable`，即**拦截器**的主要逻辑是对`next.handle()`返回的`Observable`进行处理，返回一个新的`Observable`，而无需订阅它。\n\n## 绑定拦截器\n拦截器可以装饰控制器、路由方法，或是全局的。\n\n`@UseInterceptors()` 在控制器或路由方法上使用拦截器，传入一个或多个拦截器。\n\n```ts 在控制器上使用拦截器\nimport { ConverterInterceptor } from './converter/converter.interceptor';\n@Controller()\n@UseInterceptors(ConverterInterceptor)\nexport class AppController {}\n```\n\n```ts 在路由方法上使用拦截器\nimport { ConverterInterceptor } from './converter/converter.interceptor';\n@Get('value')\n@UseInterceptors(ConverterInterceptor)\ngetValue(){ return 'value'; }\n```\n\n`app.useGlobalInterceptors()` 配置全局拦截器，传入一个或多个拦截器，需要手动实例化。\n\n```ts 全局拦截器\nimport { ConverterInterceptor } from './converter/converter.interceptor';\napp.useGlobalInterceptors(new ConverterInterceptor());\n```\n\n## 格式化响应\n使用Rxjs的操作符可以很方便地拦截加工响应流，实现格式化响应。\n\n```ts\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      map((data) => ({\n        data,\n        code: 200,\n        success: true,\n        message: '请求成功',\n      })),\n    );\n  }\n}\n```\n\n## 记录处理时间\n记录请求的处理时间，对于性能监控很有用。\n\n```ts\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const now = Date.now();\n    return next.handle().pipe(\n      tap(() => console.log(`After... ${Date.now() - now}ms`)), // After... 7ms\n    );\n  }\n}\n```\n\n## 超时与错误处理\n可以设置请求的超时，并对超时等错误进行处理。\n\n```ts\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      timeout(5000), // 设置超时\n      catchError((err) => of('error')), // 捕获错误\n    );\n  }\n}\n```\n\n## 获取请求、响应对象\n可以通过`ExecutionContext`获取请求、响应对象，对它们进行处理。这都是在路由处理函数之前的操作。\n\n尽管能拿到请求、响应对象，但不推荐在拦截器中进行鉴权，那是守卫的职责。拦截器的职责是对请求和响应进行处理。比如实现复杂的缓存拦截器，但实际上，nest已经提供了缓存API。\n\n```ts\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const req = context.switchToHttp().getRequest<Request>();\n    const res = context.switchToHttp().getResponse<Response>();\n    console.log(req.url); // /value\n    res.set({\n      name: 'qx',\n    });\n    return next.handle();\n  }\n}\n```\n\n## 请求链路日志记录\n记录请求链路日志，对于排查问题很有用。\n\n```ts\nimport { Logger } from '@nestjs/common';\nimport { format } from 'util';\n\n@Injectable()\nexport class ConverterInterceptor implements NestInterceptor {\n  private readonly logger = new Logger(); // 实例化日志记录器\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const start = Date.now(); // 请求开始时间\n    return next.handle().pipe(\n      tap((response) => {\n        const request = context.switchToHttp().getRequest<Request>();\n        // 打印请求方法，请求链接，处理时间和响应数据\n        this.logger.log(\n          format(\n            '%s %s %dms %s',\n            request.method,\n            request.url,\n            Date.now() - start,\n            JSON.stringify(response),\n          ),\n        );\n      }),\n    );\n  }\n}\n```\n\n```shell 结果\n[Nest] 19404  - 2024/02/06 23:53:01     LOG GET /value 7ms [1,2,3]\n```\n\n# 执行上下文\n> 在上面的拦截器中出现了执行上下文，这里详细介绍下。\n\nNest实质是一个IoC容器，本身不具备什么功能。是存粹的以一种程序架构理念实现的框架。\n\n在**服务低层**，可以是Express或者Fastify的HTTP服务，也可以是微服务或者是WebSocket应用。无论Nest高层逻辑是什么样的，都与低层松耦合。当需要调取低层的某些功能时，就需要通过**执行上下文**([文档](https://docs.nestjs.com/fundamentals/execution-context))来获取相关对象和信息。\n\n例如**守卫**、**过滤器**和**拦截器**，都需要对整个**请求-响应**过程做出一定的干预和操作，最基本的就需要通过执行上下文来获取请求和响应对象。\n\n`ArgumentsHost` 类提供了一些方法，用于获取执行上下文的信息。\n\n```ts\ninterface ArgumentsHost {\n  getArgs<T extends Array<any> = any[]>(): T; // 获取上下文参数，返回一个数组，0 - 请求对象，1 - 响应对象 2 - next函数\n  getArgByIndex<T = any>(index: number): T; // 通过索引获取参数\n  switchToRpc(): RpcArgumentsHost; // 获取RPC上下文对象\n  switchToHttp(): HttpArgumentsHost; // 获取Http上下文对象\n  switchToWs(): WsArgumentsHost; // 获取WebSocket上下文对象\n  getType<TContext extends string = ContextType>(): TContext; // 获取执行上下文的类型\n}\n```\n\n`ExecutionContext` 继承自 `ArgumentsHost`，并提供了一些额外的方法，主要用于守卫和拦截器。\n\n```ts\ninterface ExecutionContext extends ArgumentsHost {\n  getClass<T = any>(): Type<T>; // 获取控制器类\n  getHandler(): Function; // 获取路由处理函数\n}\n```\n\n```ts\nexport type ContextType = 'http' | 'ws' | 'rpc'; // 执行上下文类型\nexport interface HttpArgumentsHost {\n  getRequest<T = any>(): T; // 获取请求对象\n  getResponse<T = any>(): T; // 获取响应对象\n  getNext<T = any>(): T; // nest函数\n}\nexport interface WsArgumentsHost {\n  getData<T = any>(): T; // 获取数据\n  getClient<T = any>(): T; // 获取客户端\n}\nexport interface RpcArgumentsHost {\n  getData<T = any>(): T; // 获取数据\n  getContext<T = any>(): T; // 获取上下文\n}\n```\n\n执行上下文分为三种类型：`http`、`ws`、`rpc`，分别对应HTTP、WebSocket和RPC(微服务)。\n\n通过 `getType()` 获取当前执行上下文的类型，再使用 `switchTo*()` 获取对应的执行上下文对象。\n\n```ts\nif (host.getType() === 'http') {\n  // HTTP服务\n} else if (host.getType() === 'rpc') {\n  // rpc(微服务)\n} else if (host.getType() === 'ws') {\n  // WebSocket\n}\n```\n\n# 异常处理层\nNest内置**异常处理层**，应用程序没有处理的异常的会被这个层捕获，并且自动的返回一个对用户友好的响应。\n\n异常处理层由 `Exception filters` **异常过滤器**实现，该过滤器处理**HttpException**类型的异常(及其子类)，当有异常被忽略（既不是HttpException也不是继承自HttpException的类），这个内置的异常过滤器会返回默认的JSON\n\n```json\n{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}\n```\n\n## 抛出标准异常\n内置 `HttpException` 类，用于抛出标准的HTTP异常，并发送标准HTTP响应对象。\n\n```ts\nclass HttpException extends Error {\n  constructor(response: string | Record<string, any>, status: number, options?: HttpExceptionOptions);\n  cause: unknown;\n}\ninterface HttpExceptionOptions {\n  cause?: unknown;\n  description?: string;\n}\n```\n\n其**构造函数**接收**三个参数**：\n1. `response`：定义响应体JSON内容，可以是字符串或对象。\n2. `status`：Http状态码，可以传入数字，或`HttpStatus`枚举\n3. `options`：可选参数，包括`cause`和`description`属性，用于记录异常的原因和描述，**不会**添加到响应体中。\n\n默认的情况下，**JSON内容**里面有**2个属性**：\n1. `statusCode`：默认为`status`参数中提供的Http状态码\n2. `message`：Http错误的简短描述，即`response`参数传入的**字符串**\n\n要覆盖JSON响应体，需给`response`参数传入**对象**。Nest将序列化该对象，并将其作为JSON响应体返回。\n\n```ts 抛出HttpException标准错误\n@Get('value')\ngetValue() {\n  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN, {\n    cause: new Error('Error'),\n    description: 'Forbidden',\n  });\n  return \"123\";\n}\n```\n\n```json 响应\n{\n  \"statusCode\": 403,\n  \"message\": \"Forbidden\"\n}\n```\n\n**注意：**路由处理函数中抛出的异常，可以被**拦截器**`catchError`**操作符**捕获，并处理，不会被异常处理层捕获。\n\n## 内置 HTTP 异常\nNest提供了许多继承自`HttpException`的异常类\n\n如果这些异常不满足需求，可以自定义异常，创建一个继承自`HttpException`的类。\n\n```ts\nBadRequestException // 400 请求错误\nUnauthorizedException // 401 未授权\nNotFoundException // 404 未找到\nForbiddenException // 403 禁止访问\nNotAcceptableException // 406 不可接受\nRequestTimeoutException // 408 请求超时\nConflictException // 409 冲突\nGoneException // 410 消失\nHttpVersionNotSupportedException // 505 HTTP版本不支持\nPayloadTooLargeException // 413 负载过大\nUnsupportedMediaTypeException // 415 不支持的媒体类型\nUnprocessableEntityException // 422 无法处理的实体\nInternalServerErrorException // 500 服务器内部错误\nNotImplementedException // 501 未实现\nImATeapotException // 418 不希望处理的请求，超文本咖啡壶控制协议HTCPCP，一个愚人节笑话\nMethodNotAllowedException // 405 方法不允许\nBadGatewayException // 502 错误的网关\nServiceUnavailableException // 503 服务不可用\nGatewayTimeoutException // 504 网关超时\nPreconditionFailedException // 412 前提条件失败\n```\n\n```ts ForbiddenException\nclass ForbiddenException extends HttpException {\n  constructor(objectOrError?: string | object | any, descriptionOrOptions?: string | HttpExceptionOptions);\n}\ninterface HttpExceptionOptions {\n  cause?: unknown;\n  description?: string;\n}\n```\n\n这些内置异常类的**构造函数**接收**两个参数**：\n1. `objectOrError`：定义响应体JSON内容，可以是字符串或对象。和`HttpException`的`response`参数差不多。\n2. `descriptionOrOptions`：可选参数，包括`cause`和`description`属性，用于记录异常的原因和描述，其描述**会**添加到响应体的**error**字段上。\n3. 第二个参数也可以是一个字符串，直接表示`description`。\n\n```ts\n@Get('value')\ngetValue() {\n  throw new ForbiddenException('Forbidden', {\n    cause: new Error('Error'),\n    description: '禁止访问',\n  });\n  return \"123\";\n}\n```\n\n```json\n{\n  \"message\": \"Forbidden\",\n  \"error\": \"禁止访问\",\n  \"statusCode\": 403\n}\n```\n\n## 异常过滤器\n内置的标准异常类已经能够应付大多数异常情况，但也有完全控制异常层的需求，例如在出现异常时记录日志、响应不同的JSON内容等。`Exception filters`**异常过滤器**可以满足需求。\n\n`Exception filters`是具有`@Catch()`装饰器的类，实现了`ExceptionFilter`接口。它可以捕获**指定类型**或**任何类型**异常，不仅限于`HttpException`。\n\n`@Catch()`不传入参数，表示捕获**任何类型**的异常。还可以传入若干**异常类**，表示捕获这些**指定类型**的异常。\n\n**创建异常过滤器：**`nest g f <name>`\n\n```ts 一个最简单的异常过滤器\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';\n@Catch()\nexport class ErrorFilter<T> implements ExceptionFilter {\n  catch(exception: T, host: ArgumentsHost) {}\n}\n```\n\n`ExceptionFilter`接口实现了`catch`方法，接收两个参数：\n1. `exception`：捕获到的异常\n2. `host`：`ArgumentsHost`类型，具有一些获取执行信息的方法。\n\n```ts\ninterface ArgumentsHost {\n  getArgs<T extends Array<any> = any[]>(): T; // 获取路由处理函数的参数\n  getArgByIndex<T = any>(index: number): T; // 通过索引获取参数\n  switchToRpc(): RpcArgumentsHost; // 切换至RPC\n  switchToHttp(): HttpArgumentsHost; // 切换至Http\n  switchToWs(): WsArgumentsHost; // 切换至WebSocket\n  getType<TContext extends string = ContextType>(): TContext; // 'http' | 'ws' | 'rpc'\n}\n```\n\n**注意：**一但绑定了异常过滤器，就会**覆盖**内置的异常过滤器，需要**手动**处理异常、返回响应。\n\n## 绑定过滤器\n过滤器可以装饰控制器、路由方法，或是全局的。\n\n`@UseFilters()` 在控制器或路由方法上使用过滤器，传入一个或多个过滤器。\n\n```ts 在控制器上使用过滤器\nimport { ErrorFilter } from './error/error.filter';\n@Controller()\n@UseFilters(ErrorFilter)\nexport class AppController {}\n```\n\n```ts 在路由方法上使用过滤器\nimport { ErrorFilter } from './error/error.filter';\n@Get('value')\n@UseFilters(ErrorFilter)\ngetValue() {}\n```\n\n`app.useGlobalFilters()` 配置全局过滤器，传入一个或多个过滤器，需要手动实例化。\n\n```ts 全局过滤器\nimport { ErrorFilter } from './error/error.filter';\napp.useGlobalFilters(new ErrorFilter());\n```\n\n## 简单的异常处理\n绑定了异常过滤器后，就意味着需要手动处理异常，并返回响应。\n\n一个最简单的，包含日志记录的异常过滤器。\n\n```ts\nimport {\n  ArgumentsHost,\n  Catch,\n  ExceptionFilter,\n  HttpException,\n  Logger,\n} from '@nestjs/common';\nimport { Request, Response } from 'express';\nimport { format } from 'util';\n\n@Catch(HttpException)\nexport class ErrorFilter<T extends HttpException> implements ExceptionFilter {\n  private readonly logger = new Logger(); // 实例化日志记录器\n  catch(exception: T, host: ArgumentsHost) {\n    // 获取请求和响应对象\n    const ctx = host.switchToHttp();\n    const req = ctx.getRequest<Request>();\n    const res = ctx.getResponse<Response>();\n    // 输出日志\n    this.logger.error(\n      format('%s %s %s', req.method, req.url, exception.getResponse()),\n    );\n    // 响应\n    res.status(exception.getStatus()).json(exception.getResponse());\n    // res.status(exception.getStatus()).json({\n    //   statusCode: exception.getStatus(),\n    //   message: exception.message,\n    // });\n  }\n}\n```\n\n```shell\n[Nest] 30556  - 2024/02/07 17:03:49   ERROR GET /value { message: 'Forbidden', error: '禁止访问', statusCode: 403 }\n```\n\n# pipe管道\n[pipe管道](https://docs.nestjs.com/pipes)是用 `@Injectable()` 注释的类，实现了 `PipeTransform` 接口，具有 `transform()` 方法。\n\n`nest g pi <name>` 创建管道\n\n**颗粒度：**参数、方法、控制器和全局\n\n**作用：**\n1. **转换**：将输入数据转换为所需的形式，无法转换则抛出异常\n2. **验证**：检查输入数据是否符合要求，否则抛出异常\n\n**过程：**在控制器方法上插入管道，管道接收该方法的参数，并进行转换或验证，最后用转换后参数调用该方法(路由处理程序)。\n\n**注意：**当无法转换或验证不通过时，管道会抛出异常，会被**异常处理层**捕获，之后将不会执行任何控制器方法。默认抛出 `BadRequestException(400)` 异常。\n\n## 内置管道\nNest提供了一些内置的管道，用于转换和验证。\n1. `ValidationPipe` 验证管道，基于 `class-validator` 和 `class-transformer`\n2. `ParseIntPipe` 将输入转换为整数\n3. `ParseFloatPipe` 将输入转换为浮点数\n4. `ParseBoolPipe` 将输入转换为布尔值\n5. `ParseArrayPipe` 将输入转换为数组\n6. `ParseUUIDPipe` 将输入转换为UUID\n7. `ParseEnumPipe` 将输入转换为枚举\n8. `DefaultValuePipe` 设置默认值，当参数不存在时使用\n9. `ParseFilePipe` 将上传的文件转换为文件对象\n\n## 绑定转换管道\n**转换管道**如内置的 `Parse*Pipe`，作用于控制器方法的**参数**，将管道类传入参数装饰器。\n\n```ts\nfunction Param(\n  property: string, \n  ...pipes: (Type<PipeTransform> | PipeTransform)[]\n): ParameterDecorator;\n```\n\n使用 `ParseIntPipe` 将参数转换为整数。\n\n```ts\n@Get(':id')\nfindOne(@Param('id', ParseIntPipe) id: number) {\n  console.log(typeof id, id); // number 123456\n  return this.loginService.findOne(id);\n}\n```\n\n无法转换时，抛出 `BadRequestException(400)` 异常。\n\n```json\n{\n  \"message\": \"Validation failed (numeric string is expected)\",\n  \"error\": \"Bad Request\",\n  \"statusCode\": 400\n}\n```\n\n可以手动实例化管道类，传入选项，自定义管道行为。\n\n```ts\ninterface ParseIntPipeOptions {\n  errorHttpStatusCode?: ErrorHttpStatusCode; // 抛出异常的HTTP状态码\n  exceptionFactory?: (error: string) => any;\n  optional?: boolean;\n}\nclass ParseIntPipe implements PipeTransform<string> {\n  constructor(options?: ParseIntPipeOptions);\n}\n```\n\n```ts\n@Param(\n  'id',\n  new ParseIntPipe({\n    errorHttpStatusCode: HttpStatus.NOT_FOUND,\n  }),\n)\n```\n\n## 自定义管道\n管道实现了 `PipeTransform` 接口，具有 `transform()` 方法。\n\n```ts 一个最简单的管道\nimport { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';\n\n@Injectable()\nexport class LoginPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    console.log(value);// 123456\n    console.log(metadata);\n    // { metatype: [Function: Number], type: 'param', data: 'id' }\n    return value;\n  }\n}\n```\n\n`transform()` 方法接收两个参数：\n1. `value`：参数的值\n2. `metadata`：参数的元数据，包括`type`、`metatype`、`data`等\n\n其返回值将作为实际的值传入控制器方法的对应参数。\n\n```ts\ninterface ArgumentMetadata {\n  readonly type: Paramtype; // 指示参数是body, query, param还是自定义参数\n  readonly metatype?: Type<any> | undefined; // 参数的元类型\n  readonly data?: string | undefined; // 传递给装饰器的字符串\n}\ntype Paramtype = 'body' | 'query' | 'param' | 'custom';\n```\n\n实现 `ParseIntPipe` 的简单版本。\n\n```ts\n@Injectable()\nexport class LoginPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    const isNumeric =\n      ['string', 'number'].includes(typeof value) &&\n      !isNaN(parseFloat(value)) &&\n      isFinite(value as any);\n    if (!isNumeric) {\n      throw new BadRequestException(\n        'Validation failed (numeric string is expected)',\n      );\n    }\n    return parseInt(value, 10);\n  }\n}\n```\n\n## 验证\n**DTO**(Data Transfer Object) **数据传输对象**，是一种以类的形式实际为数据的对象，用于前后端或程序间传输数据。\n\n```ts src\\login\\dto\\create-login.dto.ts\nexport class CreateLoginDto {\n  username: string;\n  password: string;\n}\n```\n\n```ts src\\login\\login.controller.ts\nimport { CreateLoginDto } from './dto/create-login.dto';\n@Post()\ncreate(@Body() createLoginDto: CreateLoginDto) {\n  return this.loginService.create(createLoginDto);\n}\n```\n\n这样对于数据结构的限制显然不够，且还需要在控制器中写验证逻辑。\n\n### 类验证器\n**类验证器** [class-validator](https://www.npmjs.com/package/class-validator)和[class-transformer](https://www.npmjs.com/package/class-transformer)两个库，用于验证和转换类的实例。\n\n`class-validator` 提供了一些验证装饰器，用于验证数据。\n\n```ts\nimport { IsString, IsNotEmpty, Length } from 'class-validator';\nexport class CreateLoginDto {\n  @IsNotEmpty() // 验证是否为空\n  @IsString() // 验证是否为字符串\n  @Length(3, 10, {\n    message: '用户名长度必须为3到10位', // 自定义错误信息\n  }) // 验证字符串长度\n  username: string;\n  @IsNotEmpty()\n  @IsString()\n  password: string;\n}\n```\n\nNest内置的 `ValidationPipe` 验证管道，也是基于上面两个库实现的。\n\n```ts\n@Post()\ncreate(@Body(ValidationPipe) createLoginDto: CreateLoginDto) {\n  console.log(createLoginDto);\n  return this.loginService.create(createLoginDto);\n}\n```\n\n当传入的数据不符合规则时，会抛出 `BadRequestException(400)` 异常。\n\n```json\n{\n  \"message\": [\n    \"用户名长度必须为3到10位\"\n  ],\n  \"error\": \"Bad Request\",\n  \"statusCode\": 400\n}\n```\n\n### 自定义类验证管道\nNest提供了 `ValidationPipe` 验证管道，但也可以自定义验证管道，实现更复杂的验证逻辑。\n\n`ValidationPipe` 也是通过 `class-validator` 和 `class-transformer` 实现的。\n\n```ts\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n@Injectable()\nexport class LoginPipe implements PipeTransform {\n  async transform(value: any, metadata: ArgumentMetadata) {\n    // 通过plainToInstance实例化DTO类，并将value反射到DTO类上\n    const DTO = plainToInstance(metadata.metatype, value);\n    // 使用validate验证DTO类，返回错误对象数组\n    const errors = await validate(DTO);\n    // 如果errors数组不为空，抛出异常\n    if (errors.length) {\n      throw new BadRequestException(errors, 'Validation failed');\n    }\n    return value;\n  }\n}\n```\n\n通过 `plainToInstance()` 实例化DTO类（转换参数对象为有类型的对象），并将 `value` 反射到DTO类上，再使用 `validate()` 验证DTO对象，返回错误类型数组，如果数组不为空，抛出异常。\n\n```json\n{\n  \"message\": [\n    {\n      \"target\": {\n        \"username\": \"12\",\n        \"password\": \"123\"\n      },\n      \"value\": \"12\",\n      \"property\": \"username\",\n      \"children\": [],\n      \"constraints\": {\n        \"isLength\": \"用户名长度必须为3到10位\"\n      }\n    }\n  ],\n  \"error\": \"Validation failed\",\n  \"statusCode\": 400\n}\n```\n\n### 自定义验证函数\n`registerDecorator()` 用于注册自定义的验证装饰器，实现更复杂的验证逻辑。\n\n实现 `RequireOtherFields()` 验证指定属性与另一属性的关联性。\n\n例如 `page` 依赖于 `size` 实现分页，所以传入了 `page` 也必须同时传入 `size`。\n\n```ts\nimport {\n  ValidationOptions,\n  registerDecorator,\n  ValidationArguments,\n} from 'class-validator';\n\nfunction RequireOtherFields(\n  field: string, // 依赖的属性\n  validationOptions?: ValidationOptions, // 验证选项\n) {\n  return function (object: object, propertyName: string) {\n    registerDecorator({\n      name: 'requireOtherFields', // 自定义装饰器的名称\n      target: object.constructor, // 装饰的目标\n      propertyName: propertyName, // 装饰的属性\n      constraints: [field], // 传递给验证函数的附加约束\n      options: validationOptions, // 验证选项\n      validator: { \n        // 自定义验证函数\n        validate(value: any, args: ValidationArguments) {\n          const relatedValue = args.object[field]; // 获取依赖的属性的值\n          return (\n            // 验证逻辑，当目标属性的值存在时，依赖的属性的值也必须存在\n            (value !== undefined && relatedValue !== undefined) ||\n            value === undefined\n          );\n        },\n        // 自定义验证失败时的默认消息\n        defaultMessage(args: ValidationArguments) {\n          return `传入 ${args.property} 后也必须传入 ${args.constraints[0]}`;\n        },\n      },\n    });\n  };\n}\n```\n\n```ts 使用\nexport class FindAllDto {\n  @RequireOtherFields('size') // 当传入了page时，必须同时传入size\n  page?: number;\n  size?: number;\n}\n```\n\n### 模式验证\n有许多库实现了以**模式**来描述数据，如[Joi](https://www.npmjs.com/package/joi)、[Zod](https://zod.dev/README_ZH)等，并提供了验证数据的方法。下面以zod为例。\n\n创建模式与DTO，与类验证器类似，装饰器与函数式的区别。\n\n```ts\nimport { z } from 'zod';\nexport const createLoginSchema = z\n  .object({\n    username: z\n      .string()\n      .min(3, {\n        message: '用户名长度至少为3位',\n      })\n      .max(10, {\n        message: '用户名长度最多为10位',\n      }),\n    password: z.string(),\n  })\n  .required();\n\nexport type CreateLoginDto = z.infer<typeof createLoginSchema>;\n```\n\n创建模式验证管道\n\n```ts\nimport { ZodSchema } from 'zod';\n\n@Injectable()\nexport class LoginPipe implements PipeTransform {\n  constructor(private schema: ZodSchema) {}\n  async transform(value: any, metadata: ArgumentMetadata) {\n    try {\n      const parsedValue = this.schema.parse(value);\n      // 若验证失败则抛出ZodError错误\n      return parsedValue;\n    } catch (error) {\n      throw new BadRequestException(error, 'Validation failed');\n    }\n  }\n}\n```\n\n绑定验证管道\n\n```ts\nimport { createLoginSchema, CreateLoginDto } from './dto/create-login.dto';\nimport { LoginPipe } from './login.pipe';\n\n@Post()\n@UsePipes(new LoginPipe(createLoginSchema))\ncreate(@Body() createLoginDto: CreateLoginDto) {\n  console.log(createLoginDto);\n  return this.loginService.create(createLoginDto);\n}\n```\n\n验证失败返回的json\n\n```json\n{\n  \"issues\": [\n    {\n      \"code\": \"too_small\",\n      \"minimum\": 3,\n      \"type\": \"string\",\n      \"inclusive\": true,\n      \"exact\": false,\n      \"message\": \"用户名长度至少为3位\",\n      \"path\": [\n        \"username\"\n      ]\n    }\n  ],\n  \"name\": \"ZodError\"\n}\n```\n\n## 全局管道\n通过 `ValidationPipe` 验证数据是非常常见的，可以将其设置为全局验证管道，不必在每个控制器上单独使用。\n\n```ts\nimport { ValidationPipe } from '@nestjs/common';\nasync function bootstrap() {\n  app.useGlobalPipes(new ValidationPipe());\n}\n```\n\n如果DTO的某些属性是可选的，应该启用 `skipUndefinedProperties`，以跳过对未定义属性的验证。\n\n```ts\nnew ValidationPipe({\n  skipUndefinedProperties: true,\n}),\n```\n\n## 多管道\n同一层级的管道可以有多个，按顺序从左向右执行。\n\n前一个管道的输出作为后一个管道的输入，最后的输出作为控制器方法对应参数的值。\n\n使用 `DefaultValuePipe` 设置默认值，以防止接收到非预期的null或undefined。\n\n```ts\n@Get()\nfindAll(@Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number) {\n  console.log(page); // 1\n  return this.loginService.findAll();\n}\n```\n\n# Guards守卫\n[Guards守卫](https://docs.nestjs.com/guards)是用 `@Injectable()` 注释的类，实现了 `CanActivate` 接口，具有 `canActivate()` 方法。\n\n`nest g gu <name>` 创建守卫\n\n**颗粒度：**方法、控制器和全局\n\n传统的web应用，检测用户登陆、鉴权等，通常在控制层或中间件中处理，但中间件的职责是不明确的，且获取不到执行上下文，不知道调用next后哪个路由将被执行。\n\n**作用：**守卫专门用于鉴权、角色、访问控制等操作，可以获取执行上下文，决定是否放行请求(执行路由)。\n\n**顺序：**守卫的调用在中间件之后，在任何管道和拦截器之前。\n\n## CanActivate\n`CanActivate` 接口定义了 `canActivate()` 方法，该方法接收 `ExecutionContext` [执行上下文](https://docs.nestjs.com/fundamentals/execution-context)参数，返回boolean，表示是否放行请求(执行路由)。\n\n当返回false时，请求将被阻止，并抛出`ForbiddenException`，返回403。\n\n```ts\nexport interface CanActivate {\n  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean>;\n}\n```\n\n一个最简单的守卫\n\n```ts\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class RoleGuard implements CanActivate {\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    return true;\n  }\n}\n```\n\n由于单一职责的关系，路由守卫只能返回boolean来决定是否放行当前请求。虽然可以获取请求、响应对象，但不建议在守卫中修改它们，出现问题较难排查。对于一些必要的附加数据，可以在中间件中完成。\n\n## 使用守卫\n通过 `@UseGuards()` 注释路由方法或控制器，绑定若干个守卫。\n\n```ts\nimport { RoleGuard } from './role/role.guard';\n@Get('testRole')\n@UseGuards(RoleGuard)\ngetTestRole() {\n  return 'testRole';\n}\n```\n\n`app.useGlobalGuards()` 配置**全局守卫**，传入若干个守卫，需要手动实例化。\n\n```ts main.ts\nimport { RoleGuard } from './role/role.guard';\napp.useGlobalGuards(new RoleGuard());\n```\n\n当存在多个守卫时，按顺序执行，任何一个守卫返回false，都会阻止请求。\n\n## 元数据与角色控制RBAC\n守卫通过路由方法上的[元数据](/article/9d362be7.html#元数据)来实现基于**角色**的访问控制（**RBAC**）。\n\n**流程：**前端回传token等信息，后端解析出token中的角色身份，对比路由方法上的元数据(允许的角色)，决定是否放行请求。\n\n`@SetMetadata()` 设置元数据\n\n```ts\nconst SetMetadata: <K = string, V = any>(metadataKey: K, metadataValue: V) => CustomDecorator<K>;\n```\n\n```ts\n@Get('testRole')\n@UseGuards(RoleGuard)\n// 设置元数据，该路由方法只允许admin角色访问\n@SetMetadata<string, string[]>('roles', ['admin'])\ngetTestRole() {\n  return 'testRole';\n}\n```\n\n`Reflector` 反射器，用于获取元数据\n`Reflector.get()` 传入**装饰器引用或元数据key**和**元数据目标上下文**(装饰器目标)获取元数据。\n\n```ts\nimport { Reflector } from '@nestjs/core';\n@Injectable()\nexport class RoleGuard implements CanActivate {\n  constructor(private reflector: Reflector) {} // 注入反射器\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    // 获取当前路由的角色\n    const roles = this.reflector.get<string[]>('roles', context.getHandler());\n    if (!roles || !roles.length) {\n      return true;\n    }\n    // 通过query模拟获取用户角色，实际应该从token等方式获取\n    const request = context.switchToHttp().getRequest<Request>();\n    return roles.includes(request.query.user as string);\n  }\n}\n```\n\n### 自定义元数据装饰器\n为了更加方便，可以自定义一个装饰器，用于设置元数据。\n\n```ts\nfunction Roles<T = string>(...roles: T[]) {\n  return SetMetadata<string, T[]>('roles', roles);\n}\n@Get('testRole')\n@UseGuards(RoleGuard)\n// @SetMetadata<string, string[]>('roles', ['admin'])\n@Roles('admin')\ngetTestRole() {\n  return 'testRole';\n}\n```\n\n`nest g d <name>` 创建装饰器，快速生成一个设置元数据的装饰器。本质是对原有的装饰器进行封装。\n\n```ts role.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\nexport const Role = (...args: string[]) => SetMetadata('role', args);\n```\n\n**最佳实践：**将key值定义为常量并导出，以便在其他地方使用。\n\n```ts\nimport { SetMetadata } from '@nestjs/common';\nexport const RolesKey = 'roles';\nexport const Roles = (...args: string[]) => SetMetadata(RolesKey, args);\n// 获取元数据\nimport { RolesKey } from './role.decorator';\nconst roles = this.reflector.get(RolesKey, context.getHandler());\n```\n\n`SetMetadata` 是低级的元数据设置方法，还可以使用 `Reflector.createDecorator()` 创建一个元数据装饰器。通过它创建的装饰器，可以作为获取元数据的key(装饰器的引用)。\n\n```ts\nimport { Reflector } from '@nestjs/core';\nexport const Roles = Reflector.createDecorator<string[]>();\n// 使用装饰器，这样创建的装饰器仅接收一个参数，一般传入数组\n@Roles(['admin'])\n// 获取元数据\nimport { Roles } from './role.decorator';\nconst roles = this.reflector.get(Roles, context.getHandler());\n```\n\n### 多层次元数据\n\n```ts 多层次设置元数据\n@Roles('user')\n@Controller()\nexport class AppController {\n  @Get('testRole')\n  @UseGuards(RoleGuard)\n  @Roles('admin')\n  getTestRole() {\n    return 'testRole';\n  }\n}\n```\n\n由于可以在多个层次上设置元数据(控制器、方法)，可能需要从多个上下文中提取元数据。\n1. `Reflector.getAll()` 获取所有上下文中的元数据，返回二维数组，如 `[ [ 'admin' ], [ 'user' ] ]`\n2. `Reflector.getAllAndMerge()` 获取所有上下文中的元数据，并**合并**，如 `[ 'admin', 'user' ]`\n3. `Reflector.getAllAndOverride()` 获取上下文数组中**首个**的元数据，如 `[ 'admin' ]`\n\n```ts\nconst contexts = [context.getHandler(), context.getClass()];\nconsole.log(\n  this.reflector.getAll(RolesKey, contexts), // [ [ 'admin' ], [ 'user' ] ]\n  this.reflector.getAllAndMerge(RolesKey, contexts), // [ 'admin', 'user' ]\n  this.reflector.getAllAndOverride(RolesKey, contexts), // [ 'admin' ]\n);\n```\n\n# 自定义装饰器\n[文档](https://docs.nestjs.com/custom-decorators)。在守卫中，就自定义了一个装饰器，用于设置元数据。\n\n`nest g d <name>` 创建装饰器。\n\n## 组合装饰器\n`applyDecorators()` 用于组合装饰器，传入若干个装饰器，返回组合后的新装饰器。以减少控制器代码中重复的装饰器组合。\n\n```ts\nimport { applyDecorators } from '@nestjs/common';\nexport function Auth(...roles: string[]) {\n  return applyDecorators(\n    SetMetadata('roles', roles),\n    UseGuards(RoleGuard),\n  );\n}\n```\n\n## 自定义参数装饰器\n在Node中，将自定义属性附加到请求对象是常见的做法，在路由方法中获取请求对象，是麻烦且非必要的，可以通过 `createParamDecorator()` **自定义参数装饰器**，快速获取自定义属性。\n\n```ts\nimport { ExecutionContext, createParamDecorator } from '@nestjs/common';\nexport const ReqUser = createParamDecorator(\n  (data: string, ctx: ExecutionContext) => {\n    // data是通过装饰器传入的参数，这里用于获取req.user上的属性，ctx是执行上下文。\n    const request = ctx.switchToHttp().getRequest();\n    return data ? request.user?.[data] : request.user;\n  },\n);\n```\n\n自定义的装饰器也可以与管道一起使用，但必须将 **validateCustomDecorators** 设为 **true**，ValidationPipe默认不验证用自定义装饰器注释的参数。\n\n```ts\n@User(new ValidationPipe({ validateCustomDecorators: true }))\n```\n\n\n\n\n\n","tags":["NestJS","后端"],"categories":["学习笔记"]},{"title":"RxJS","url":"/article/c79e1541.html","content":"\n# RxJS\n[RxJS](https://rxjs.dev/)(Reactive Extensions for JavaScript) 是一个使用**可观察**(Observable)序列来编写异步和**基于事件**(Event-based)程序的库。即**观察者模式**，编写异步队列和事件处理。[cn文档v5](https://cn.rx.js.org/)\n\n它提供了一种**核心类型**，即 `Observable`，附属类型(Observer，Scheduler，Subject)和受 `Array`(map、filter、reduce、every 等)启发的**运算符**(Operators)，允许**将异步事件作为集合进行处理**。\n\n```txt\n1. Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n2. Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n3. Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。\n4. Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。\n5. Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n6. Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。\n```\n\nNest 内置了 RxJs，如拦截器(**Interceptor**)等功能都是基于 RxJs 实现的。\n\n**参考：**\n[The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)\n[响应式编程（Reactive Programming）介绍](https://zhuanlan.zhihu.com/p/27678951)\n[响应式编程入门指南 - 通俗易懂 RxJS](https://hijiangtao.github.io/2020/01/13/RxJS-Introduction-and-Actions/)\n[最简Rxjs入门教程--别再被Rxjs的概念淹没了](https://juejin.cn/post/7003328753556258846)\n[5 分钟理解什么是响应式编程 Reactive Programming](https://zhuanlan.zhihu.com/p/46891890)\n[RxJS——给你如丝一般顺滑的编程体验](https://juejin.cn/post/6910943445569765384)\n[流动的数据——使用 RxJS 构造复杂单页应用的数据逻辑](https://github.com/xufei/blog/discussions/69)\n[响应式编程 | 响应式系统 | 响应式设计](https://quickapp.lovejade.cn/reactive-programming-vs-responsive-web-design)\n[RxJS从入门到精通](https://rx.js.cool/)\n\n## 响应式宣言\n在不同的领域深耕的各个组织都独立地发现了一种如出一辙的软件构建模式。这些系统更加的健壮、更加具有回弹性/韧性、更加灵活，也能更好地满足现代化的需求。\n\n[响应式宣言](https://www.reactivemanifesto.org/zh-CN) 阐述了**响应式系统**该有的特质以及实现手段，是一套贯通整个系统的架构设计方案。\n\n**响应式系统特质：**\n1. **响应性**(Responsive)：系统应该尽可能地即时响应客户端的请求；\n2. **回弹性**(Resilient)：系统应该能在出现故障时保持响应能力。\n3. **弹性**(Elastic)：系统在各种负载下都可以响应。自动缩/扩容，能够做到负载均衡。\n4. **消息驱动**(Message Driven)：使用消息，让系统中具体的各功能组件具有松耦合、隔离、位置透明、边界清晰明确的特点。\n\n在服务正常或者异常的情况下，都需要及时的对外部请求做出响应，响应可以是正常内容也可以是异常情况下的 fast throw，借助于**消息或者事件驱动**来达到系统内部异步非阻塞的交互机制，这通常需要系统服务各个分层各个组件都是响应式的。\n\n[Reactive Stream](https://www.reactive-streams.org/) **响应式规范**，是**异步非阻塞且有背压的流处理**标准，它定义了实现响应式编程时的 API。\n\n[ReactiveX](https://reactivex.io/) 是**响应式规范**的一种实现，通过使用可观察序列，组成异步和基于事件的程序。核心是创建并订阅名为 Observable 的数据流。RX 提供了一个函数工具箱，结合观察者和迭代器模式以及函数式编程，可以组合、合并、过滤、转换和创建数据流。\n\n## 响应式编程\n响应式编程是一种用于开发响应式系统的手段，基于事件驱动。\n\n**同步/异步编程：**\n1. 同步编程是一种请求响应模型，调用一个方法，等待其响应返回。\n2. 异步编程发出一个任务后，不等待结果，就继续发出下一个任务。获取结果：主动轮询**Proactive**、被动接收反馈**Reactive**。\n\n在**Reactive**中，上一个任务**执行结果的反馈**就是一个**事件**，这个事件的到来会触发**依赖链**中下一个任务的执行。\n\n**依赖链：**多个异步任务之间的依赖关系，例如一个任务的执行结果是另一个任务的输入。\n\n**响应式编程(Reactive Programming)：**基于**Reactive**，是一种面向**数据流**和**变化传播**的编程范式。即**使用异步数据流进行编程**。\n\n点击页面中的一个按钮，这个点击事件(event)就是一个异步数据流。\n在响应式编程中，任何东西都可以包装为流，如：变量、用户的操作、属性、缓存、数据结构等。\n还有一系列的工具函数，以函数式编程的方式，组合、创建、过滤这些流。\n\n## 流Stream\nStream是响应式编程的核心，本质是一个按**时间**排序的**事件(Events)**序列。\n\n**事件：**一个任务的执行结果的**反馈**，可能是一个值，也可能是一个错误。\n\n**流的三种事件及其结果：**\n1. **Value** 某种类型的值\n2. **Error** 错误\n3. **complete** 已完成信号(Completed Signal)\n\n自然的，可以监听这三个事件，将**事件的结果**(值、错误或已完成信号)交给不同的函数进行处理。\n\n监听一个 Stream 也被称作是**订阅**，定义的处理函数就是**观察者**，Stream则是**被观察者**。这也就是观察者模式。\n\n## Rxjs的流\n在Rxjs中，通过 `Observable` 类，以**迭代器模式**创建一个流(也就是创建了流的**数据或事件的集合**)，而 `Observer` 接口定义了观察者。一个流只有被订阅后才会启动，多次订阅会启动多个**相互独立**的流。即**单播**。\n\n```ts\nimport { Observable, Observer } from 'rxjs';\nconst observable = new Observable((subscriber) => {\n  // 发布\n  subscriber.next(1);\n  subscriber.next(2);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n  subscriber.next(3);\n});\n\n// 观察者\nconst observer: Observer<number> = {\n  next: (value) => console.log('value: ' + value), // 值\n  error: (err) => console.error(err), // 错误\n  complete: () => console.log('done'), // 完成\n};\n// 订阅\nconst subscription = observable.subscribe(observer);\nsetTimeout(() => {\n  // 停止流\n  // subscription.unsubscribe();\n}, 1000);\n// value: 1\n// value: 2\n// value: 3\n// value: 4\n// done\n```\n\n`Observable`类接收一个函数，参数为`Subscriber`**订阅者**对象，它有`next()`、`error()`、`complete()`三个方法，可以触发流中的三个事件。实际是调用了`Observer`**观察者**中定义的三个对应的处理函数。\n\n`Observable`的实例方法`subscribe()`接收`Observer`对象，返回`Subscription`对象。即使用某个观察者去订阅并启动该流。多次调用`subscribe()`会启动多个相互独立的流。\n\n`Subscription`对象上有`unsubscribe()`方法，用于取消订阅并停止该流。\n\n```ts Observable\nclass Observable<T> implements Subscribable<T> {\n\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic)\n\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  lift<R>(operator?: Operator<T, R>): Observable<R>\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n\n  forEach(next: (value: T) => void): Promise<void>;\n  // .....\n  pipe(): Observable<T>;\n  // .....\n  toPromise(): Promise<T | undefined>;\n  // .....\n}\n```\n\n```ts Observer\ninterface Observer<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n```\n\n## Subject主体\n不同于单播模式总是启动一个新流，多播模式无论什么时候订阅，都只会接收到流上实时的数据。\n\n`Subject`是一种特殊的`Observable`，是**可观察对象**和**观察者**的**混合体**，由Subject订阅一个流，再让多个观察者订阅它。通过中间商实现了**多播**。\n\n本质上，`Subject`是一个**事件发射器**，当它接收到流的事件，会将该事件**多播**给所有订阅它的观察者。\n\n```ts\nimport { Subject, interval } from 'rxjs';\nconst observable = interval(1000);\nconst subject = new Subject();\nobservable.subscribe(subject);\n// 通过 subject 订阅同一个实时流\nsubject.subscribe((value) => console.log('A ' + value));\nsetTimeout(() => {\n  subject.subscribe((value) => console.log('B ' + value));\n}, 1000);\n// A 0\n// A 1\n// B 1 // B 比 A 晚了 1 秒开始订阅同一个实时流\n// A 2\n// B 2\n// A 3\n// B 3\n```\n\n## Operators操作符\n`Observable`实际上是创建了流的**数据或事件的集合**，而`Operators`可以对这个集合进行类似`Array`的操作。\n即使用像 map、filter、scan、take 等**纯函数**的操作符，以**函数式编程风格**来处理集合。\n\n操作符是 Observable 类型上的方法，分为**实例操作符**和**静态操作符**。\n1. **实例操作符**：内部使用 this 关键字来指代输入的 Observable，处理后，返回一个新的 Observable。\n2. **静态操作符**：内部不使用 this 关键字，而是完全依赖于传入的参数，接收非 Observable 或多个 Observable 参数，返回一个新的 Observable。如创建操作符和部分组合操作符。\n\n**注意：**在Rxjs中，操作符通常是单独导入使用，而不是在类型上。对流进行处理的操作符，以管道`pipe()`的方式串联使用。就像是Node中对流的管道处理一样。\n\n当操作符被调用时，它们**不会改变**已经存在的 Observable 实例。相反，它们返回一个**新的** Observable，它的 subscription 逻辑基于第一个 Observable。\n\n操作符有以下类型：[操作符分类](https://cn.rx.js.org/manual/overview.html#h213)\n1. **创建操作符**：创建一个新的流，如`of`、`from`、`interval`、`timer`等。\n2. **转换操作符**：对流中的数据进行转换，如`map`、`mergeMap`、`concatMap`等。\n3. **过滤操作符**：过滤掉流中的数据，如`filter`、`take`、`skip`等。\n4. **组合操作符**：将多个流合并成一个流，如`merge`、`concat`、`combineLatest`等。\n5. **多播操作符**：将单播流转为多播流，如`share`、`publish`、`multicast`等。\n6. **错误处理操作符**：处理流中的错误，如`catchError`、`retry`等。\n7. **工具操作符**：进行一些辅助操作，如`do`、`delay`、`timeout`等。\n8. **条件和布尔操作符**：对流中的数据进行条件判断，如`every`、`find`、`isEmpty`等。\n9. **数学和聚合操作符**：对流中的数据进行数学运算，如`count`、`max`、`min`、`reduce`等。\n\n操作符有很多，官网提供了[选择操作符](https://cn.rx.js.org/manual/overview.html#h212)的快捷问答\n\n## 创建操作符\n创建操作符属于**静态操作符**，使用非 Observable 参数创建一个新的流。[文档](https://cn.rx.js.org/manual/overview.html#h39)\n\n### create\ncreate 将 subscribe 函数转化为一个实际的 Observable。已经废弃，推荐直接使用`new Observable()`。\n\n```ts\ncreate<T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n  return new Observable<T>(subscribe);\n};\n```\n\n### from\nfrom 从一个数组、类数组对象、Promise、迭代器对象或者类 Observable 对象创建一个 Observable.\n\n```ts\nfrom<T>(input: any, scheduler?: SchedulerLike): Observable<T>\n```\n\n```ts\nconst observable = from([10, 20, 30]);\nobservable.subscribe((v) => console.log(v));\n// 10 20 30\n```\n\n### of\nof 将若干参数转化成一个 Observable 对象。\n\n```ts\nof<T>(...args: (SchedulerLike | T)[]): Observable<T>\n```\n\n```ts\nconst observable = of(10, 20, 30);\nobservable.subscribe((v) => console.log(v));\n// 10 20 30\n```\n\n### interval\n基于给定时间间隔投射数字序列\n\n```ts\ninterval(period: number = 0, scheduler: SchedulerLike = async): Observable<number>\n```\n\n```ts\nconst observable = interval(1000);\nobservable.subscribe((v) => console.log(v));\n// 0 1 2 3 ... 每隔 1 秒输出一个数字\n```\n\n### timer\n给定持续时间后，再按照指定间隔时间依次投射数字。\n\n```ts\ntimer(\n  dueTime: number | Date = 0,\n  periodOrScheduler?: number | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<number>\n```\n\n```ts\nconst observable = timer(3000, 1000);\nobservable.subscribe((v) => console.log(v));\n// 3 秒后输出 0，之后每隔 1 秒输出数字序列 1 2 3 ...\n```\n\n### range\n创建一个发射给定范围内的数字序列的 Observable。\n\n```ts\nrange(start: number = 0, count: number = 0, scheduler: SchedulerLike = async): Observable<number>\n```\n\n```ts\nconst observable = range(1, 10);\nobservable.subscribe((v) => console.log(v));\n// 1 2 3 4 5 6 7 8 9\n```\n\n### empty\n创建一个不发射任何数据的 Observable，只发射 complete 通知。\n\n```ts\nempty<T>(scheduler: SchedulerLike = async): Observable<T>\n```\n\n```ts\nconst observable = empty();\nobservable.subscribe({\n  next: (v) => console.log(v),\n  complete: () => console.log('complete'),\n});\n// complete\n```\n\n### repeat\n将数据源重复 count 次。\n\n```ts\nrepeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(repeat(2));\nobservable.subscribe((v) => console.log(v));\n// 1 2 3 1 2 3\n```\n\n## 转换操作符\n对流中的数据进行转换，以得到期望的数据。[文档](https://cn.rx.js.org/manual/overview.html#h310)\n\n### buffer\n将一个流产生的数据缓冲到数组中，直到另一个 Observable 发射了数据，然后发射这个数组。\n\n```ts\nbuffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]>\n```\n\n通常与`interval`、`timer`或dom事件等结合使用，每隔一段时间缓冲一次数据。\n\n```ts\nconst clicks = fromEvent(document, 'click');\nconst interval = interval(1000);\nconst buffered = interval.pipe(buffer(clicks));\nbuffered.subscribe((x) => console.log(x));\n```\n\n```ts\nconst observable = interval(1000).pipe(buffer(timer(4000, 3000)));\nobservable.subscribe((v) => console.log(v));\n// [0, 1, 2] [3, 4, 5] [6, 7, 8] ...\n```\n\n### map\n对流中的每个数据应用一个函数，然后发射结果。与数组的`map`类似。\n\n```ts\nmap<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(map((x) => x * x));\nobservable.subscribe((v) => console.log(v));\n// 1 4 9\n```\n\n### mergeMap\n将每个源数据值投射成 Observable ，该 Observable 会合并到输出 Observable 中。\n\n```ts\nmergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: number | ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R),\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O> | R>\n```\n\n```ts\nconst observable = of('a', 'b', 'c').pipe(\n  mergeMap((x) => interval(1000).pipe(map((i) => x + i))),\n);\nobservable.subscribe((x) => console.log(x));\n// 每隔 1 秒输出\n// a0 b0 c0\n// a1 b1 c1\n```\n\n### mapTo\n将每个数据映射为同一个值。已弃用，推荐使用`map`。\n\n```ts\nmapTo<T, R>(value: R): OperatorFunction<T, R>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(mapTo('a'));\nobservable.subscribe((v) => console.log(v));\n// a a a\n```\n\n### pluck\n从每个发射的对象中选择一个属性。已弃用，推荐使用`map`。\n\n```ts\npluck<T, R>(...properties: string[]): OperatorFunction<T, R>\n```\n\n```ts\nconst observable = of({ name: 'a' }, { name: 'b' }).pipe(pluck('name'));\nobservable.subscribe((v) => console.log(v));\n// a b\n```\n\n### scan\n对流中的数据进行累加，然后发射结果。类似数组的`reduce`。\n\n```ts\nscan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(scan((acc, value) => acc + value, 0));\nobservable.subscribe((v) => console.log(v));\n// 1 3 6 每次数据为前面所有数据的累加\n```\n\n### reduce\n将源 Observalbe 序列的值归并为单个值。等同于 scan 和 last 一同使用。\n\n```ts\nreduce<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(reduce((acc, value) => acc + value, 0));\nobservable.subscribe((v) => console.log(v));\n// 6\n```\n\n## 过滤操作符\n过滤流中的数据，以得到期望的数据。[文档](https://cn.rx.js.org/manual/overview.html#h311)\n\n### take\n只发射前 n 个数据。\n\n```ts\ntake<T>(count: number): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = interval(1000).pipe(take(3));\nobservable.subscribe((v) => console.log(v));\n// 0 1 2\n```\n\n### skip\n跳过前 n 个数据，然后发射剩下的数据。\n\n```ts\nskip<T>(count: number): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = interval(1000).pipe(skip(3));\nobservable.subscribe((v) => console.log(v));\n// 3 4 5 ...\n```\n\n### first\n只发射第一个数据，或者满足条件的第一个数据。\n\n```ts\nfirst<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n```\n\n```ts\nconst observable = of(1, 2, 3, 4).pipe(first((value) => !(value % 2)));\nobservable.subscribe((v) => console.log(v));\n// 找到第一个能被 2 整除的数\n```\n\n### debounceTime\n只有在过了指定的时间间隔后，才发射最新的数据。类似于防抖。\n\n如果在延时时间内数据源又发送了一个新数据，这个新的数据就会被先缓存住不会发送，等待发送完数据之后并等待延时时间结束才会发送给订阅者\n\n```ts\ndebounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = interval(1000).pipe(take(3), debounceTime(2000));\nobservable.subscribe((x) => console.log(x));\n// 2\n```\n\n### throttleTime\n在指定的时间间隔内，只发射第一个数据。类似于节流。\n\n唯一和防抖操作符不一致的地方就在于它对于第一个值是不会阻塞的。\n\n```ts\nthrottleTime<T>(duration: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = interval(1000).pipe(throttleTime(2000));\nobservable.subscribe((x) => console.log(x));\n// 0 2 4 ...\n```\n\n### filter\n只发射满足条件的数据。\n\n```ts\nfilter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): OperatorFunction<T, T>\n```\n\n```ts\nconst observable = of(1, 2, 3, 4).pipe(filter((value) => !(value % 2)));\nobservable.subscribe((v) => console.log(v));\n// 2 4 只发射能被 2 整除的数\n```\n\n### distinct\n过滤重复数据。\n\n```ts\ndistinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = of(1, 2, 2, 3, 3, 4).pipe(distinct());\nobservable.subscribe((v) => console.log(v));\n// 1 2 3 4\n```\n\n## 组合操作符\n将多个流合并成一个流。[文档](https://cn.rx.js.org/manual/overview.html#h312)\n\n### concat\n按顺序发射多个 Observable 的值。起到连接多个流的作用。\n\n```ts\nconcat<T, R>(...observables: (ObservableInput<T> | SchedulerLike)[]): Observable<T>\n```\n\n```ts\nconst observable = concat(interval(1000).pipe(take(3)), range(1, 3));\nobservable.subscribe((v) => console.log(v));\n// 0 1 2 1 2 3\n```\n\n### merge\n将多个 Observable 合并成一个 Observable，按照它们开始的时间顺序发射数据。\n\n```ts\nmerge<T, R>(...observables: (ObservableInput<T> | SchedulerLike)[]): Observable<T>\n```\n\n```ts\nconst observable = merge(interval(1000).pipe(take(3)), range(1, 3));\nobservable.subscribe((v) => console.log(v));\n// 1 2 3 0 1 2\n```\n\n### concatAll\n将高阶 Observable 转化为一阶 Observable，**串行**发射。\n\n底层使用 mergeAll。将其并行度设置为 1，即可实现串行发射。\n\n```ts\nfunction concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n```\n\n```ts\nconst observable = of(of(1, 2, 3), of(4, 5, 6)).pipe(concatAll());\nobservable.subscribe((v) => console.log(v));\n// 1 2 3 4 5 6\n```\n\n### mergeAll\n将高阶 Observable 转化为一阶 Observable，**并行**发射。底层使用 mergeMap。\n\n传入一个可选参数，表示并行度。默认为 Infinity。当并行度为 1 时，等同于 concatAll。\n\n```ts\nfunction mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n```\n\n```ts\nconst observable = of(0, 1, 2).pipe(\n  map((x) => interval(1000)),\n  mergeAll(),\n);\nobservable.subscribe((v) => console.log(v));\n// 0 0 0\n// 1 1 1\n// 2 2 2\n```\n\n## 工具操作符\n进行一些辅助操作。[文档](https://cn.rx.js.org/manual/overview.html#h313)\n\n### tap\n在数据流中的每个数据上执行副作用，但不会改变数据流。\n\n```ts\nfunction tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(tap((v) => console.log(v)));\nobservable.subscribe();\n// 1 2 3\n```\n\n### timeout\n如果在指定时间内流没有发射数据，就发射一个错误。\n\n```ts\nfunction timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n```\n\n```ts\nconst observable = interval(2000).pipe(timeout(1000));\nobservable.subscribe({\n  next: (v) => console.log(v),\n  error: (err) => console.log(err),\n});\n// TimeoutError: Timeout has occurred\n```\n\n### delay\n延迟发射数据。\n\n```ts\nfunction delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T>\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(delay(1000));\nobservable.subscribe((v) => console.log(v));\n// 延迟 1 秒后输出 1 2 3\n```\n\n## 错误处理操作符\n处理流中的错误。[文档](https://cn.rx.js.org/manual/overview.html#h314)\n\n### catchError\n捕获错误，然后用另一个 Observable 替换它，或者继续抛出错误。\n\n```ts\nfunction catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(\n  map((v) => {\n    if (v === 3) {\n      throw new Error('error');\n    }\n    return v;\n  }),\n  catchError((err) => of('a', 'b', 'c')),\n);\nobservable.subscribe({\n  next: (v) => console.log(v),\n  error: (err) => console.log(err),\n});\n// 1 2 a b c\n// 从 1 2 到 3 时抛出错误，捕获错误后新的流输出 a b c\n```\n\n### retry\n如果发生错误，就重试。\n\n```ts\nfunction retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nfunction retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\n```\n\n```ts\nconst observable = of(1, 2, 3).pipe(\n  map((v) => {\n    if (v === 3) {\n      throw new Error('error');\n    }\n    return v;\n  }),\n  retry(1),\n);\nobservable.subscribe({\n  next: (v) => console.log(v),\n  error: (err) => console.log(err),\n});\n// 1 2\n// 1 2 这次为重试，仍然出错\n// Error: error\n```\n\n> 更多操作符就多看[文档](https://rxjs.dev/guide/operators#categories-of-operators)吧，还有很多很多~。","tags":["前端","NestJS"],"categories":["学习笔记"]},{"title":"NestJS[一]-基础","url":"/article/7c45abd.html","content":"\n# 引子\nExpress很好用，但它太自由了，每个人的代码组织结构都大不相同，应用一旦变大或需要不断扩展，依赖关系就很容易变得混乱。\n\n基于Node的后端框架很多，但大多都缺少了**架构**。良好的架构设计可以更好的组装代码，模块封装和依赖管理清晰，实现低耦合高内聚，易于修改和维护。\n\n**IOC控制反转**和**DI依赖注入**是NestJS的核心，并且实现了一个更抽象的**模块化**的**AOP架构**。\n\n# 依赖倒置原则\n如果类A依赖类B，传统面向对象中，在类A内直接创建类B的实例，类A和类B**直接耦合**在一起，类A作为高层类直接依赖了低层类B，违反了**依赖倒置原则**。\n\n**依赖倒置原则：**\n1. 高层模块不应该依赖底层模块，二者都应该依赖抽象（例如接口）。\n2. 抽象不应该依赖细节，细节（具体实现）应该依赖抽象。\n\n**例子：**User写代码完成今天的工作需要一台win电脑，然后开机(open)，进行工作(work)\n\n```ts 传统耦合代码\nclass WinComputer {\n  open() { console.log('win open') }\n}\nclass User {\n  computer: WinComputer = new WinComputer()\n  work() { this.computer.open() }\n}\nuser.work() // win open\n```\n\n如果User现在需要一台Linux电脑，就需要修改User类的实现，但这样违反了**开闭原则**，即对扩展开放，对修改关闭。\n\n解决这个问题也很简单，抽象一个Computer类，实现了Computer的类都可以作为User的电脑，在实例化时传入，就不用修改User类的实现了。\n\n```ts\nabstract class Computer {\n  open() { }\n}\nclass WinComputer implements Computer {\n  open() { console.log('win open') }\n}\nclass LinuxComputer implements Computer {\n  open() { console.log('linux open') }\n}\nclass User {\n  computer: Computer\n  constructor(computer: Computer) {\n    this.computer = computer\n  }\n  work() { this.computer.open() }\n}\nconst user = new User(new LinuxComputer())\nuser.work() // linux open\n```\n\n这样貌似没问题了，User只管要电脑，电脑在实例化时传入，换电脑也只需要修改实例化时的参数，而不需要修改User类的实现。\n\n但，很多时候User所依赖的东西不止电脑，还有键盘、鼠标、显示器等等，如果都要在实例化时传入，并且使用一个成员去接收，可想而知代码会很臃肿、复杂。应该有一个专门的管理员来提供这些设备，User仅需要根据需求向管理员索取设备。\n\n控制反转就是解决这个问题的。\n\n# IOC控制反转\n**控制反转(Inversion of Control,IOC)**是面向对象的一种**设计模式**，完全遵守依赖倒置原则，目的是**解耦**。\n\n1. **控制：**对**程序流程**(如生命周期)的控制，以及对**一切资源**(包括但不限于**对象**)的控制。\n2. **反转：**将控制权从原来的对象本身反转到了**外部容器**(IOC容器)，即由外部容器来控制程序流程和资源。\n\nIOC所带来的是系统控制权的转移，将原来**分散**在各个对象内部的控制权，转移到了外部容器**统一**管理和控制。\n\nIOC只解释了应该怎么去做才是最佳实践，但并没有规定应该怎么做，实现的方式有很多，如**依赖注入**、**依赖查找**、**服务定位器**等。\n\nNest、Spring等主流框架使用的是**依赖注入**。\n\n>在可维护性较好的架构中，实现一个新的需求时，往往只需要新增代码，而不需要修改任何现有的代码。\n\n## DI依赖注入\n**依赖注入(Dependency Injection,DI)**是实现控制反转的一种方式。\n\n其核心是实现**IOC容器**，由容器动态管理对象的创建和依赖关系。\n将一个对象所依赖的其他对象通过构造函数、方法参数或者属性注入到该对象中，**被动**地接受依赖对象，而不是在该对象内部直接创建这些依赖对象。\n\n一个最简单的IOC容器实现如下：\n1. 一个Map对象，用于存储依赖名和类的映射关系\n2. 一个注册方法，用于注册可依赖项\n3. 一个解析方法，用于解析依赖项，实例化类并返回\n\n```ts\n// IOC容器\nclass Container {\n  private dependencies: Map<string, any> = new Map()\n\n  // 注册依赖\n  register(key: string, value: any, ...args: any[]) {\n    this.dependencies.set(key, {\n      value,\n      args\n    })\n  }\n\n  // 解析依赖\n  resolve<T = any>(key: string): T {\n    if (!this.dependencies.has(key)) {\n      throw new Error('未注册该依赖')\n    }\n    const { value, args } = this.dependencies.get(key)\n    // 实例化并返回\n    return Reflect.construct(value, args)\n  }\n}\n\nabstract class Computer {\n  open() { }\n}\nclass WinComputer implements Computer {\n  open() { console.log('win open') }\n}\nclass LinuxComputer implements Computer {\n  open() { console.log('linux open') }\n}\n\nconst container = new Container()\n// 注册依赖\ncontainer.register('computer', WinComputer)\n// container.register('computer', LinuxComputer)\n\nclass User {\n  computer: Computer\n  constructor() {\n    // 依赖注入\n    this.computer = container.resolve<Computer>('computer')\n  }\n  work() { this.computer.open() }\n}\nconst user = new User()\nuser.work() // win open\n```\n\nUser只需要一个能open的电脑来完成work，不需要关心电脑是怎么来的，只需要向容器索取即可，容器在代码运行时动态地将依赖注入到User中。当需要提供Linux电脑时，只需要改为注册LinuxComputer即可。\n\n参考：\n[万字长文，讲透彻 NestJS 的设计模式](https://juejin.cn/post/7321049446443221030)\n[依赖注入和控制反转的理解，写的太好了。](https://blog.csdn.net/bestone0213/article/details/47424255)\n[Nest.js入门 —— 控制反转与依赖注入（一）](https://juejin.cn/post/7085614364396355598)\n[学习 Nestjs 前，你需要了解什么是依赖注入（原理详解）](https://juejin.cn/post/7257285697395687461)\n\n# 装饰器\n装饰器就是一个函数，可以注入到类、方法、属性、参数，对象上，扩展其功能，增加了代码的可读性，清晰地表达了意图。\n\n**详见：**[TypeScript笔记-装饰器](/article/9d362be7.html#装饰器)\n\n# @nestjs/cli\nNestjs  是一个用于构建高效、可扩展的 Node.js 服务器端应用程序开发框架，完全支持TypeScript\n\n**文档：**[官方英文](https://docs.nestjs.com/)，[中文](https://docs.nestjs.cn/)，[中文2](http://nestjs.inode.club/)\n\n底层使用了[express](https://expressjs.com/)（默认）和[Fastify](https://fastify.dev/)，在这些框架之上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员，可以轻松使用每个平台的无数第三方模块。\n\n使用[Nest CLI](https://docs.nestjs.com/cli/overview)快速创建项目\n\n```shell\nnpm i -g @nestjs/cli\nnest new project-name [--strict]\n```\n\n如果打开文件报错`Delete ␍ eslint`，需要将endOfLine设为auto，\n详见：[error Delete ·· prettier/prettier #219](https://github.com/prettier/eslint-plugin-prettier/issues/219)\n\n```js \n// .eslintrc.js\nrules: {\n  \"prettier/prettier\": [\"warn\",  {\"endOfLine\": \"auto\"}],\n}\n// 或修改.prettierrc，需要重启vscode才生效\n\"endOfLine\": \"auto\"\n```\n\n## 项目结构\n**一个基本的项目结构：**\n\n```\nsrc\n  app.controller.spec.ts // 测试文件,用于编写和执行测试,以确保代码的可靠性和正确性\n  app.controller.ts // 控制层,处理http请求、控制路由和调用业务层的方法\n  app.module.ts // 根模块,用于处理模块之间的引用和共享,它将AppController和AppService通过@Module进行注入\n  app.service.ts // 业务层,封装与业务相关的逻辑,比如对数据库的CRUD \n  main.ts // 入口文件,使用NestFactory创建Nest应用程序实例\nnest-cli.json // Nest CLI配置文件\n```\n\n**常见后缀解释：**\n\n```\n*.middleware.ts 中间件\n*.controller.ts 控制器\n*.decorator.ts 自定义装饰器\n*.entity.ts 数据对象实例（typeorm）\n*.interface.ts 接口\n*.module.ts Nest模块\n*.service.ts Nest服务对象\n*.pipe.ts Nest管道对象\n*.dto.ts 数据传输对象\n*.spec.ts 单元测试文件\n```\n\n`nest-cli.json` **Nest CLI配置文件**\n\n```json\n{\n  // 指定 JSON 文件的模式（schema），用于验证文件的结构\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  // 指定 Nest CLI 在生成项目文件和模块时要使用的 schematics 集合。\n  // 这告诉 Nest CLI 使用 @nestjs/schematics 集合中的原理图来生成代码。\n  \"collection\": \"@nestjs/schematics\",\n  // 项目源代码的根目录\n  \"sourceRoot\": \"src\",\n  // 针对 TypeScript 编译器的选项配置\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n```\n\n`main.ts` **入口文件**，使用NestFactory创建Nest应用程序实例，并监听端口，启动服务\n\n```ts\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nasync function bootstrap() {\n  // NestFactory创建Nest应用程序实例，将AppModule作为根模块传入，相当于app.vue\n  const app = await NestFactory.create(AppModule);\n  // 监听端口，启动服务\n  await app.listen(3000);\n}\nbootstrap();\n```\n\n`app.module.ts` **根模块**，用于处理模块之间的引用和共享，它将AppController和AppService通过@Module进行注入\n\n每个模块都是一个由@Module()装饰器注释的类，模块间的关系由@Module()装饰器中携带的所有元数据描述。每个 Nest 应用程序至少有一个模块，即根模块（app.module.ts）。\n\n```ts\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n// @Module类装饰器，用于定义模块\n@Module({\n  imports: [], // 导入模块的列表，这些模块导出了此模块中所需提供者\n  controllers: [AppController], // 控制器\n  providers: [AppService], // 由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享\n})\nexport class AppModule {}\n```\n\n`app.controller.ts` **控制层**，处理http请求、控制路由和调用业务层的方法，也可以写一些**单一不可复用**的业务逻辑\n\n```ts\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n// @Controller类装饰器，用于定义控制器\n@Controller() // 可传入路由前缀\nexport class AppController {\n  // 构造函数注入AppService\n  constructor(private readonly appService: AppService) {}\n  // @Get方法装饰器，用于创建路由\n  @Get() // 可传入路由路径\n  getHello(): string {\n    // 调用AppService业务层的方法\n    return this.appService.getHello();\n  }\n}\n```\n\n`app.service.ts` **业务层**，封装与业务相关的**可复用的**逻辑，比如对数据库的CRUD\n\n```ts\nimport { Injectable } from '@nestjs/common';\n// @Injectable类装饰器，用于定义提供者\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n```\n\n## 常见命令\n**1、创建项目** `new(n) [options] [name]`\n\n```txt options\n--directory 指定目标目录\n-d或--dry-run 不输出创建过程中的报告\n-g或--skip-git 不要初始化git仓库（默认是会在项目创建git仓库）\n-s或--skip-install 不要安装依赖哭\n-p或--package-manager [name] 指定包管理工具\n-l或--language [lang] 指定语言JS或者TS\n-c或--collection [name] 用特定的架构生成项目\n```\n\n**2、构建项目** `build [options] [app]` 默认会将TS文件构建到项目的dist目录中\n\n```txt options\n-c或--config [path] 用cli构建时特定的配置文件\n-p或--path [path] tsconfig配置文件\n-w或--watch 实时重加载，观察模式\n--watchAssets 观察非ts文件模式\n--webpackPath [path] webpack的配置文件\n--tsc 使用tsc编译\n```\n\n**3、运行项目** `start [options] [app]`\n\n```txt options\n-c或--config [path] 用cli构建时特定的配置文件\n-p或--path [path] tsconfig配置文件\n-w或--watch 实时重加载，观察模式\n--watchAssets 观察非ts文件模式\n-d或--debug [hostport] 调试模式\n--webpack用webpack编译\n--webpackPath [path] webpack的配置文件\n--tsc 使用tsc编译\n-e或--exec [binary] 以二进制运行（默认用node）\n--preserveWatchOutput tsc的观察模式\n```\n\n**4、更新项目** `update(u) [options]` 更新当前项目的依赖组件\n\n```txt options\n-f或--force 强制重新安装依赖\n-t或--tag 升级被打上(latest | beta | rc | next tag)的组件\n```\n\n**5、生成** `generate(g) [options] <schematic> [name] [path]` 创建一个Nest的元素\n\n**6、其它**\n`add [options] <library>` 添加对外部库的支持\n`info(i)` 获取当前Nest项目的详细情况\n\n## generate命令\nnest generate命令可以快速生成项目、模块、控制器、服务、管道、拦截器、中间件等文件的基本结构\n\n`nest --help` 查看nestjs所有的命令\n\n```shell\nUsage: nest <command> [options]\n\nOptions:\n  -v, --version                                   Output the current version.\n  -h, --help                                      Output usage information.  \n\nCommands:\n  new|n [options] [name]                          Generate Nest application. \n  build [options] [app]                           Build Nest application.    \n  start [options] [app]                           Run Nest application.      \n  info|i                                          Display Nest project details.\n  add [options] <library>                         Adds support for an external library to your project.\n  generate|g [options] <schematic> [name] [path]  Generate a Nest element.\n    Schematics available on @nestjs/schematics collection:\n      ┌───────────────┬─────────────┬──────────────────────────────────────────────┐\n      │ name          │ alias       │ description                                  │\n      │ application   │ application │ Generate a new application workspace         │\n      │ class         │ cl          │ Generate a new class                         │\n      │ configuration │ config      │ Generate a CLI configuration file            │\n      │ controller    │ co          │ Generate a controller declaration            │\n      │ decorator     │ d           │ Generate a custom decorator                  │\n      │ filter        │ f           │ Generate a filter declaration                │\n      │ gateway       │ ga          │ Generate a gateway declaration               │\n      │ guard         │ gu          │ Generate a guard declaration                 │\n      │ interceptor   │ itc         │ Generate an interceptor declaration          │\n      │ interface     │ itf         │ Generate an interface                        │\n      │ library       │ lib         │ Generate a new library within a monorepo     │\n      │ middleware    │ mi          │ Generate a middleware declaration            │\n      │ module        │ mo          │ Generate a module declaration                │\n      │ pipe          │ pi          │ Generate a pipe declaration                  │\n      │ provider      │ pr          │ Generate a provider declaration              │\n      │ resolver      │ r           │ Generate a GraphQL resolver declaration      │\n      │ resource      │ res         │ Generate a new CRUD resource                 │\n      │ service       │ s           │ Generate a service declaration               │\n      │ sub-app       │ app         │ Generate a new application within a monorepo │\n      └───────────────┴─────────────┴──────────────────────────────────────────────┘\n```\n\n`nest g mo` 生成**模块**\n\n它会在src目录下创建一个user目录，包含user.module.ts，然后自动在app.module.ts中导入UserModule\n\n```shell\nnest g mo user\n  CREATE src/user/user.module.ts (85 bytes)\n  UPDATE src/app.module.ts (391 bytes)\n```\n\n`nest g co` 生成**控制器**\n\n会继续在user目录下创建user.controller.ts和user.controller.spec.ts，然后自动在user.module.ts中导入UserController\n\n```shell\nnest g co user\n  CREATE src/user/user.controller.ts (101 bytes)\n  CREATE src/user/user.controller.spec.ts (496 bytes)\n  UPDATE src/user/user.module.ts (170 bytes)\n```\n\n`nest g s` 生成**服务(提供者、业务层)**\n\n会继续在user目录下创建user.service.ts和user.service.spec.ts，然后自动在user.module.ts中导入UserService\n\n```shell\nnest g s user\n  CREATE src/user/user.service.ts (92 bytes)\n  CREATE src/user/user.service.spec.ts (464 bytes)\n  UPDATE src/user/user.module.ts (249 bytes)\n```\n\n`nest g res` 可以代替上面三个命令，快速生成模块的标准结构，并且可选API风格，以及是否生成CRUD结构\n\n```shell\nnest g res list\n  ? What transport layer do you use? REST API\n  ? Would you like to generate CRUD entry points? No\n  CREATE src/list/list.controller.ts (211 bytes)\n  CREATE src/list/list.controller.spec.ts (576 bytes)\n  CREATE src/list/list.module.ts (250 bytes)\n  CREATE src/list/list.service.ts (92 bytes)\n  CREATE src/list/list.service.spec.ts (464 bytes)\n  UPDATE package.json (2049 bytes)\n  UPDATE src/app.module.ts (380 bytes)\n```\n\n# RESTful API\nRESTful 既不是标准也不是协议，只是一种风格。在RESTful中，一切都被认为是资源，每个资源有对应的URL标识，即使用HTTP动词来表示对资源的操作，如GET、POST、PUT、DELETE等。\n\n以往POST一把梭哈的风格，表示对同一资源的不同操作需要多个URL\n\n```\nhttp://localhost:8080/api/get_list?id=1\nhttp://localhost:8080/api/delete_list?id=1\nhttp://localhost:8080/api/update_list?id=1\n```\n\nRESTful使用不同的请求方式表示对同一资源的不同操作，只需要一个URL\n\n```\nhttp://localhost:8080/api/list/1\n查询GET，提交POST，更新 PUT PATCH，删除 DELETE\n```\n\n使用`nest g res`命令生成的控制器默认是RESTful API风格\n\n```ts\n@Controller('list') // 路由前缀\nexport class ListController {\n  constructor(private readonly listService: ListService) {}\n\n  @Post() // 提交\n  create(@Body() createListDto: CreateListDto) {\n    return this.listService.create(createListDto);\n  }\n\n  @Get() // 查询所有\n  findAll() {\n    return this.listService.findAll();\n  }\n\n  @Get(':id') // 查询单个\n  findOne(@Param('id') id: string) {\n    return this.listService.findOne(+id);\n  }\n\n  @Patch(':id') // 更新单个\n  update(@Param('id') id: string, @Body() updateListDto: UpdateListDto) {\n    return this.listService.update(+id, updateListDto);\n  }\n\n  @Delete(':id') // 删除单个\n  remove(@Param('id') id: string) {\n    return this.listService.remove(+id);\n  }\n}\n```\n\n## 版本控制\n在应用迭代更新时，可能会出现接口不兼容的情况，这时就需要对接口进行版本控制，保留或丢弃旧版本的接口，增加新版本的接口。\n\nNestJS提供了版本控制的功能，通过`app.enableVersioning()`开启，[文档](https://docs.nestjs.com/techniques/versioning)\n\n```ts\nimport { NestFactory } from '@nestjs/core';\nimport { VersioningType } from '@nestjs/common';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  // 开启版本控制\n  app.enableVersioning({\n    // type指定版本控制的类型，接收VersioningType枚举类型，\n    type: VersioningType.URI,\n    // export declare enum VersioningType {\n    //   URI = 0, // 版本将在请求的 URI 中传递（默认）\n    //   HEADER = 1, // 通过请求头控制版本\n    //   MEDIA_TYPE = 2, // 请求的Accept标头将指定版本\n    //   CUSTOM = 3 // 自定义控制版本\n    // }\n  });\n  await app.listen(3000);\n}\nbootstrap();\n```\n\n在控制器中使用`@Version()`指定某个接口的版本，或在`@Controller()`中指定整个路由的版本\n\n```ts\n@Controller({\n  path: 'list', // 路由前缀\n  // 路径中会带上v+版本号，在路由前缀之前\n  version: '1', // 路由版本，如：/v1/list\n})\nexport class ListController {\n  // ......\n  @Get()\n  @Version('2') // 控制单个接口的版本\n  // http://127.0.0.1:3000/v2/list/\n  findAll() {\n    return this.listService.findAll();\n  }\n\n  @Get(':id')\n  // http://127.0.0.1:3000/v1/list/123456\n  findOne(@Param('id') id: string) {\n    return this.listService.findOne(+id);\n  }\n}\n```\n\n## Code码规范\n**Code码分类：**\n1. **1xx** Informational（信息状态码）接受请求正在处理\n2. **2xx** Success（成功状态码）请求正常处理完毕\n3. **3xx** Redirection（重定向状态码）需要附加操作已完成请求\n4. **4xx** Client Error（客户端错误状态码）服务器无法处理请求\n5. **5xx** Server Error（服务器错误状态码）服务器处理请求出错\n\n**常用Code码：**\n1. **200** OK\n2. **201** Created 创建成功\n3. **301** Moved Permanently 永久重定向至新URI\n4. **302** Found 临时重定向，URI不变，资源实际位置已改变\n5. **304** Not Modified 协商缓存了\n6. **400** Bad Request 参数错误\n7. **401** Unauthorized token错误\n8. **403** Forbidden 验证失败，无权限访问\n9. **404** Not Found 接口不存在\n10. **500** Internal Server Error 服务端错误\n11. **502** Bad Gateway 上游接口有问题或者服务器问题\n12. **503** Service Unavailable 服务不可用\n\n# Controller控制器\n控制器是添加了`@Controller`装饰器的类，用于处理请求、控制路由、调用服务、返回响应。\n\nNest将Express中的Router抽象成为Controller\n\n`@Controller`有多个重载：\n\n```ts\nController(): ClassDecorator;\nController(options: ControllerOptions): ClassDecorator;\nController(prefix: string | string[]): ClassDecorator;\n```\n\n当传入string时(支持通配符)，表示**路由前缀**，可以传入string数组，表示多个路由前缀。\n\n> 全局前缀由 app.setGlobalPrefix() 设置\n\n还可以传入`ControllerOptions`对象，进行更多配置\n\n```ts ControllerOptions\ninterface ControllerOptions extends ScopeOptions, VersionOptions {\n  path?: string | string[]; // 路由前缀\n  // 要求传入请求的 HTTP 主机匹配某个特定值，如www.example.com\n  host?: string | RegExp | Array<string | RegExp>;\n}\ninterface VersionOptions {\n  version?: VersionValue; // 版本控制\n}\ninterface ScopeOptions {\n  scope?: Scope; // 控制器的作用域\n  durable?: boolean; // 将常规提供程序转变为持久提供程序 \n}\n```\n\n## 处理路径和请求方法\n控制器中使用**请求方法装饰器**来处理不同路径下的各种类型的请求\n\n有：`@Get` `@Post` `@Put` `@Delete` `@Patch` `@Options` `@All`\n\n装饰器仅接收path参数(支持通配符)，表示**路径**，可以传入数组，表示多个路径。默认为根路径。\n\n若传入`:`开头的字符串，则表示**路由参数**，如`@Get(':id')`\n\n```ts\nGet: (path?: string | string[]) => MethodDecorator;\nPost: (path?: string | string[]) => MethodDecorator;\n// .......\n```\n\n**注意：**路径是直接定义在装饰器上的，而与引用关系无关\n\n## 处理请求\nNest提供了**参数装饰器**，用于获取请求体、请求头、请求参数等\n\n1. `@Param(key?: string)` 获取路由参数，相当于`req.params`\n2. `@Query(key?: string)` 获取查询参数，相当于`req.query`\n3. `@Body(key?: string)` 获取请求体，相当于`req.body`\n4. `@Headers(key?: string)` 获取请求头，相当于`req.headers`\n5. `@Request()`、`@Req()` 获取请求对象\n6. `@HostParam(property?: string | (Type | PipeTransform)` 与`@Param`类似，但是从主机参数中获取，需要与@Controller的host选项配合使用\n7. `@Session()` 获取session，相当于`req.session`\n8. `@Ip()` 获取客户端IP，相当于`req.ip`\n\n**1、`@Param`和`@Query`**\n获取的params和query都是对象，可以传入key，获取指定的参数\n\n```ts\n@Get('hello/:id')\ngetHello(\n  @Param() params,\n  @Param('id') id: string,\n  @Query() query,\n  @Query('a') a: string,\n): string {\n  console.log(params); // { id: '123' }\n  console.log(query); // { a: '1', b: '2' }\n  console.log(id); // 123\n  console.log(a); // 1\n  return 'Hello World!';\n}\n```\n\n**2、`@Body`获取请求体**，可选传入key，获取指定的参数\n\n```ts\n@Post('list')\ngetList(@Body() body: object, @Body('name') name: string): object {\n  console.log(body); // { name: 'chuckle' }\n  console.log(name); // chuckle\n  return body;\n}\n```\n\n**3、`@Headers`获取请求头**，可选传入key，获取指定的参数\n\n```ts\n@Post('headers')\ngetHeaders(\n  @Headers() headers: object,\n  @Headers('token') token: string,\n  @Ip() ip: string,\n): object {\n  console.log(token); // 123456789\n  console.log(ip); // ::ffff:127.0.0.1\n  console.log(headers);\n  // {\n  //   \"token\": \"123456789\",\n  //   \"content-length\": \"23\",\n  //   \"accept-encoding\": \"gzip, deflate, br\",\n  //   \"accept\": \"*/*\",\n  //   \"user-agent\": \"Thunder Client (https://www.thunderclient.com)\",\n  //   \"content-type\": \"application/json\",\n  //   \"host\": \"127.0.0.1:3000\",\n  //   \"connection\": \"close\"\n  // }\n  return headers;\n}\n```\n\n**4、`@Request()`、`@Req()`获取请求对象**，拿到req后，操作就和Express一样了\n\n```ts\n@Post('req/:id')\ngetReq(@Req() req: Request): string {\n  console.log(req.url); // /req?a=1&b=2\n  console.log(req.query); // { a: '1', b: '2' }\n  console.log(req.params); // { id: '123' }\n  console.log(req.body); // { name: 'chuckle' }\n  console.log(req.headers); // { 'content-length': ......}\n  return 'req';\n}\n```\n\n### session案例\nsession用于会话控制，在服务器端保存当前访问用户的相关信息，并将session_id以cookie形式返回给浏览器\n\nNestjs是基于Express的，所以session的使用方式与其一样，同样使用[express-session](https://www.npmjs.com/package/express-session)中间件\n\n**详见：**[NodeJS接口、会话控制-session](/article/a1e193d6.html#session)\n\n```shell 安装express-session以及它的TS声明\nnpm i express-session -S\nnpm i @types/express-session -D\n```\n\n在man.ts中使用express-session中间件\n\n```ts\nimport * as expressSession from 'express-session';\napp.use(\n  expressSession({\n    name: 'sid', //设置cookie的name，默认值是：connect.sid\n    secret: 'chuckle', //参与加密的字符串（又称签名）\n    resave: true, //是否在每次请求时重新保存session，用于重置session过期时间\n    rolling: true, //是否在每次请求时重新设置cookie的过期时间\n    // 浏览器端cookie设置\n    cookie: {\n      httpOnly: true, // 开启后前端无法通过 JS 操作\n      maxAge: 1000 * 60, // 不仅控制cookie，也控制session的生命周期\n    },\n  }),\n);\n```\n\n简单测试：\n\n```ts\n@Get('session')\ngetSession(@Session() session) {\n  console.log(session.username); // chuckle\n  if (!session.username) {\n    session.username = 'chuckle'; // 设置session,就是把用户的基本信息传进去\n  }\n  return session.username;\n}\n```\n\n## 返回响应\nNest管理响应对象，会将添加了请求方法装饰器的函数的**返回值**作为响应体，并自动设置MIME等信息\n\n提供了几个方法装饰器：\n1. `@Header(key: string, value: string)` 设置响应头，相当于`res.set()`\n2. `@HttpCode(code: number)` 设置响应码，相当于`res.status()`\n3. `@Redirect(url: string, statusCode?: number)` 重定向，相当于`res.redirect()`\n4. `@Response(option?)`、`@Res(option?)` 获取响应对象\n5. `@Next()` 获取next函数，相当于Express中的`next()`\n6. `@Render()` 渲染模板，相当于`res.render()`\n\n```ts\n@Get('data')\n@Header('name', 'chuckle')\n@HttpCode(500)\n// @Redirect('https://api.github.com', 302)\ngetData() {\n  return 'data';\n}\n```\n\n**注意：**如果使用了`@Res()`获取响应对象，则会失去依赖于 Nest 标准响应处理的功能。\n如：响应返回值、拦截器、处理响应对象的装饰器等，这意味着一切响应操作都需要手动完成。\n\n```ts\n@Get('data')\ngetData(@Res() res: Response) {\n  res.set('name', 'chuckle');\n  res.status(500);\n  // res.redirect(302, 'https://api.github.com');\n  res.json({\n    data: 'data',\n  });\n}\n```\n\n导入express的类型声明以获得智能提示\n\n```ts\nimport { Request, Response } from 'express';\n```\n\n如果希望手动操作Res后，仍然能让Nest接管Res，可以向 `@Res(option)` 传入配置对象，只有一个属性`passthrough`，默认为false，表示是否将响应对象交回给Nest处理（处理管道、发送响应）\n\n```ts\n @Get('data')\ngetData(@Res({ passthrough: true }) res: Response) {\n  res.set('name', 'chuckle');\n  return {\n    data: 'data',\n  };\n}\n\n// 当然不嫌麻烦的话，也可以像下面那样，next到下一个处理方法，也能让Nest接管响应，但没人会想这么用吧\n@Get('data')\ngetData(@Res() res: Response, @Next() next) {\n  res.set('name', 'chuckle');\n  next();\n}\n@Get('data')\nreData() {\n  return {\n    data: 'data',\n  };\n}\n```\n\n### 渲染模板案例\nNest很好的继承了Express所支持的MVC模板，例如pug、hbs、ejs，[相关文档](https://docs.nestjs.cn/10/techniques?id=mvc%e6%a8%a1%e5%9e%8b-%e8%a7%86%e5%9b%be%e6%8e%a7%e5%88%b6%e5%99%a8)，[Express框架-模板引擎ejs](/article/8ddaf637.html#模板引擎ejs)\n\n```shell 安装一个模板引擎,如pug\nnpm install hbs -S # hbs模板\nnpm install pug -S # pug模板\nnpm install ejs -S # pug模板\n```\n\n在main.ts中设置视图目录、使用模板引擎\n\n**注意：**Nest的核心工厂，在创建时一定要定义一个泛型NestExpressApplication，才能使用 useStaticAssets 等方法\n\n```ts 改造main.ts\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { join } from 'path';\nasync function bootstrap() {\n  // Nest的核心工厂，在创建时一定要定义一个泛型NestExpressApplication\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n  app.useStaticAssets(join(__dirname, '..', 'public')); // 静态资源目录\n  app.setBaseViewsDir(join(__dirname, '..', 'views')); // 视图目录\n  app.setViewEngine('pug'); // 使用模板引擎\n}\n```\n\n创建一个index.pug模板\n\n```pug views/index.pug\nhtml\n  head\n    title Pug模板\n  body\n    h1 #{title}\n    p #{message}\n```\n\n最后使用`@Render()`渲染模板，传入模板名，处理方法的返回值必须是一个对象，对象的属性会传递给模板的变量\n\n```ts\n@Get('pug')\n@Render('index')\nrenderPug() {\n  return {\n    title: 'chuckle',\n    message: 'hello world',\n  };\n}\n```\n\n如果需要动态决定渲染的模板，则需要使用express的`res.render()`方法。\n\n# Provider提供者\nProvider是一个具有`@Injectable()`装饰器的类，用于提供各种服务，如CURD、http请求等业务逻辑。\n\n许多基本的 Nest 类都可能被视为 provider，如中间件、拦截器、管道等。它们都可以依赖注入到所需的地方。\n\nController只处理路由和请求，处理业务逻辑的方法，由Provider提供，Nest动态地将其所需的Provider注入。\n\nNest借助TS的元数据，实现了按类型进行解析的依赖注入，通过TS提供的内置元数据，运行时可以拿到如类的构造函数的参数类型、数量、位置等信息。详见：[TypeScript笔记-元数据](/article/9d362be7.html#元数据)\n\n`@Injectable()`只接受一个可选的对象，用于配置作用域和持久化。\n\n```ts\nInjectable(options?: InjectableOptions): ClassDecorator;\ntype InjectableOptions = ScopeOptions;\ninterface ScopeOptions {\n  scope?: Scope; // 作用域\n  durable?: boolean; // 将常规提供程序转变为持久提供程序 \n}\n```\n\n简单的Provider：\n\n```ts\nimport { Injectable } from '@nestjs/common';\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n```\n\n> Nest的依赖注入非常强大，模块中的提供者不仅可以注入到该模块的控制器中，还可以注入到在模块中一切所依赖的地方，如：应用在控制器中的过滤器、拦截器和其它提供者等。\n\n## 注册与自定义名称\n`@Module()`的`providers`属性用于注册提供者。提供者**通常**需要在模块中注册，才能注入到其他模块、控制器。\n\n而中间件、拦截器等特殊的提供者，实现了特殊的内置接口，则拥有各自不同的使用方式。\n\n**类型列表**注册提供者较为方便，无需使用`@Inject()`显式注入，Nest会自动注入到所需的地方\n\n```ts\n@Module({\n  controllers: [AppController], // 注册控制器\n  providers: [AppService], // 注册提供者\n})\n```\n\n**自定义名称：**对象的`provide`属性指定名称，`useClass`属性指定类，也称为**类提供者**\n\n```ts\nproviders: [\n  {\n    provide: 'AppService',\n    useClass: AppService,\n  },\n],\n```\n\n若自定义了名称，则需要使用`@Inject(token)`显式注入到所需的地方\n\n```ts\n@Controller()\nexport class AppController {\n  constructor(@Inject('AppService') private readonly appService: AppService) {}\n}\n```\n\n## 值提供者\n`useValue` 属性指定值，值可以是任意类型的，最终会直接注入到所需的地方，这对于传入一些配置信息、外部库、常量值很有用。\n\n```ts\nproviders: [\n  {\n    provide: 'TestValue',\n    useValue: [1, 2, 3],\n  },\n],\n```\n\n仍然需要使用`@Inject(token)`显式注入\n\n有别于**构造函数注入**，下面使用了**属性注入**，实际上两者作用相同。\n\n```ts\n@Controller()\nexport class AppController {\n  @Inject('TestValue')\n  value: number[];\n\n  @Get('value')\n  getValue(): number[] {\n    console.log(this.value); // [ 1, 2, 3 ]\n    return this.value;\n  }\n}\n```\n\n## 工厂模式\n工厂函数`useFactory()`允许动态创建提供者，返回实际的provider。\n\n一个简单的工厂可能不依赖于其他的提供者。更复杂的工厂可以注入其他提供者的实例来计算结果。\n1. 工厂函数可以接受(可选)参数。\n2. inject 属性接受一个**提供者数组**，在**实例化过程中**，Nest 将解析该数组并将其作为参数传递给工厂函数。\n3. 这两个列表应该是相关的: Nest 将从 inject 列表中以**相同的顺序**将实例作为参数传递给工厂函数。\n\n```ts\nimport { TestService } from './test.service';\nproviders: [\n  TestService,\n  {\n    provide: 'TestService1',\n    // inject的必须是providers中已注册的提供者\n    inject: [TestService],\n    // useFactory接收的提供者已经实例化，可以直接使用\n    useFactory(testService: TestService) {\n      // 在工厂中可以做一些逻辑处理\n      return testService.getHello();\n    },\n  },\n],\n\n@Controller()\nexport class AppController {\n  constructor(@Inject('TestService1') private readonly testService1: string,) {}\n}\n```\n\n工厂可以是异步的，允许返回Promise，Nest会等待Promise完成后再注入\n\n```ts\nuseFactory: async (testService: TestService) => {\n  return await new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(testService.getHello());\n    }, 2000);\n  });\n},\n```\n\n## 别名提供者\n`useExisting` 属性指定一个已经存在的提供者，为其设置别名，提供了多种访问同一提供者的方式\n\n```ts\nproviders: [\n  TestService,\n  {\n    // 为TestService设置别名TestService2\n    provide: 'TestService2',\n    useExisting: TestService,\n  },\n],\n@Controller()\nexport class AppController {\n  constructor(@Inject('TestService2') private readonly testService2: TestService,) {}\n}\n```\n\n## 获取请求对象\n提供者可以通过注入 REQUEST 对象来访问原始请求对象的引用，而不必从控制器中传递它。\n\n**注意：**一旦在提供者中注入了 REQUEST 对象，该提供者将变为**请求作用域**。\n\n```ts\nimport { REQUEST } from '@nestjs/core';\n@Injectable()\nexport class AppService {\n  @Inject(REQUEST)\n  res: Request;\n\n  getHello(): string {\n    console.log(this.res.url); // /value\n    return 'Hello World!';\n  }\n}\n```\n\n# 作用域\n**实例共享**是 Nest 的特点，单例对于Node应用程序是完全安全的，因为Node并不遵循请求/响应多线程无状态模型。\n\n通常需要关注Provider和Controller的作用域，它们默认是**单例**的，即在整个应用程序中共享一个实例，有着同应用程序一样的生命周期。但也可以通过scope配置改变其作用域。[文档-注入作用域](https://docs.nestjs.cn/8/fundamentals?id=%e6%b3%a8%e5%85%a5%e4%bd%9c%e7%94%a8%e5%9f%9f)\n\n**Nest的`Scope`提供三种作用域(注入范围)：**\n1. 默认（`DEFAULT`）：提供者的单个实例在整个应用程序中共享。实例生命周期直接绑定到应用程序生命周期。一旦应用程序启动，所有的单例提供者都已实例化。默认情况下使用**单例作用域**。\n2. 请求（`REQUEST`）：为每个传入的请求创建提供者的新实例。在请求完成处理后，对实例进行垃圾回收。\n3. 瞬态（`TRANSIENT`）：瞬态提供者不会在消费者之间共享。每个注入临时提供者的消费者将收到一个新的**专用实例**。\n\n将枚举类型 `Scope` 的属性传递给装饰器的 scope 选项来指定作用域。在自定义提供者的情况下，必须设置一个额外的范围属性。\n\n```ts\n@Injectable({\n  scope: Scope.REQUEST,\n})\n@Controller({\n  scope: Scope.REQUEST,\n})\n// 在自定义提供者的情况下，必须设置一个额外的范围属性。\nproviders: [\n  {\n    provide: 'AppService',\n    useClass: AppService,\n    scope: Scope.REQUEST,\n  },\n]\n```\n\n## 请求控制器\n控制器通常只配置为默认或请求作用域。对于请求作用域的控制器，将为每个入站请求创建一个新实例，并在请求完成处理后进行垃圾回收。\n\n**作用域链：**作用域在**注入链**上冒泡。依赖于请求提供者的控制器本身也将是请求作用域的，因为控制器依赖于它们完成工作。即**依赖方的作用域会等于被依赖方的作用域。**\n\n**性能影响：**\n使用请求范围的控制器将对应用程序性能产生影响。虽然Nest尝试缓存尽可能多的元数据，但仍然需要在每个入站请求上动态创建各种实例。因此，这会减慢平均响应时间、影响总体基准测试结果。\n\n**若非必要，应该保持使用默认的单例作用域。**\n\n当控制器本身或其所依赖的提供者实例化耗时较长，使用请求作用域就会极大影响性能，需要等待提供者实例化完成后才能实例化控制器去处理请求。\n\n```ts\n{\n  provide: 'TestService1',\n  inject: [TestService],\n  useFactory: async (testService: TestService) => {\n    return await new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(testService.getHello());\n      }, 2000); // 该工厂模式提供者耗时较长\n    });\n  },\n},\n```\n\n# 模块\nNestjs采用模块化来组织应用结构，整个应用由一个根模块(Application Module)和多个功能模块共同组成。\n\n模块是具有 `@Module()` 装饰器的类。装饰器提供了元数据，Nest 用它来组织应用程序结构。\n\n```ts\nModule(metadata: ModuleMetadata): ClassDecorator;\nexport interface ModuleMetadata {\n  imports?: Array<Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference>;\n  controllers?: Type<any>[];\n  providers?: Provider[];\n  exports?: Array<DynamicModule | Promise<DynamicModule> | string | symbol | Provider | ForwardReference | Abstract<any> | Function>;\n}\nProvider<T = any> =\n  | Type<any> // 类型\n  | ClassProvider<T> // 类\n  | ValueProvider<T> // 值\n  | FactoryProvider<T> // 工厂\n  | ExistingProvider<T>; // 别名\n```\n\n`@module()`接受一个描述模块的`ModuleMetadata`对象：\n1. **providers** 由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享\n2. **controllers** 控制器的集合，由 Nest 实例化并注册的\n3. **imports** 该模块所依赖的其它模块的列表\n4. **exports** 由本模块提供的在其他模块中可用的提供者，为providers的子集。\n\n```ts 模块的基本结构\nimport { Module } from '@nestjs/common';\n@Module({\n  providers: [],\n  imports: [],\n  controllers: [],\n  exports: [],\n})\nexport class TestModule {}\n```\n\n**作用：**\n1. controllers和providers是一个模块的基本组成部分，将模块的功能分为了控制和服务两部分。\n2. imports和exports处理模块之间的关系，imports声明本模块所依赖的其他模块，exports声明本模块可向外暴露的服务(提供者)\n\n## 模块共享\n本模块要使用某个服务有多种方式：\n1. **注册提供者：**在providers注册该服务为提供者。\n2. **模块共享：**在imports导入依赖并暴露了该服务的模块。\n\n同一个服务在多个模块中注册为提供者，最终会产生**多个实例**，不符合单例模式。\n而模块共享只会产生**一个实例**，将该实例共享给其他模块使用，符合单例模式。\n\n**案例：**user模块暴露UserService\n\n```ts\nimport { UserService } from './user.service';\n@Module({\n  providers: [UserService],\n  exports: [UserService], // 将UserService(实例)导出，以便其他模块使用\n})\nexport class UserModule {}\n```\n\n在任意模块中导入UserModule，即可使用UserService\n\n```ts\nimport { UserModule } from './user/user.module';\n@Module({\n  imports: [UserModule],\n})\n```\n\n在控制器中使用：\n\n```ts\nimport { UserService } from './user/user.service';\n@Controller()\nexport class AppController {\n  constructor(private readonly userService: UserService,) {}\n  @Get('user/all')\n  getUser(): string {\n    return this.userService.findAll();\n  }\n}\n```\n\n在服务中使用：\n\n```ts\nimport { UserService } from './user/user.service';\n@Injectable()\nexport class AppService {\n  constructor(private readonly userService: UserService) {}\n  getUsers(): string {\n    const users = this.userService.findAll();\n    console.log(users);\n    return users;\n  }\n}\n```\n\n## 全局模块\n`@Global()`装饰器将模块注入到全局，其它模块无需导入即可使用\n\n**注意：**全局模块还是必须要导入一次，通常在根模块中导入\n\n```ts 定义全局模块\n@Global()\n@Module({\n  providers: [\n    {\n      provide: 'Config',\n      useValue: {\n        baseUrl: '/api',\n      },\n    },\n  ],\n  exports: ['Config'],\n})\nexport class ConfigModule {}\n```\n\n```ts 在根模块中导入\n@Module({\n  imports: [ListModule, UserModule, ConfigModule],\n})\nexport class AppModule {}\n```\n\n```ts 使用全局模块\n@Controller()\nexport class AppController {\n  constructor(@Inject('Config') private readonly config,) {}\n  @Get('config')\n  getConfig(): string {\n    console.log(this.config); // { baseUrl: '/api' }\n    return this.config;\n  }\n}\n```\n\n使一切全局化并不是一个好的解决方案。全局模块可用于减少必要模板文件的数量。imports 数组仍然是使模块 API 透明的最佳方式。\n\n## 动态模块\n动态模块也是一个类，至少有一个返回值为 `DynamicModule` 的**静态方法**(允许异步)，通过该方法可以传入若干参数，实现动态创建**自定义模块**。\n\n动态模块一定是全局或共享模块，需由其它模块导入时动态配置使用。\n\n```ts\ninterface DynamicModule extends ModuleMetadata {\n  module: Type<any>; // 模块类型\n  global?: boolean; // 是否为全局模块\n}\ninterface ModuleMetadata {\n  imports?: Array<Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference>;\n  controllers?: Type<any>[];\n  providers?: Provider[];\n  exports?: Array<DynamicModule | Promise<DynamicModule> | string | symbol | Provider | ForwardReference | Abstract<any> | Function>;\n}\n```\n\n定义动态模块：\n\n```ts\nimport { DynamicModule, Module } from '@nestjs/common';\n@Module({})\nexport class ConfigModule {\n  static forRoot(path: string): DynamicModule {\n    return {\n      module: ConfigModule,\n      providers: [\n        {\n          provide: 'Config',\n          useValue: {\n            baseUrl: '/api' + path,\n          },\n        },\n      ],\n      exports: ['Config'],\n      global: true,\n    };\n  }\n}\n```\n\n使用动态模块：调用静态方法，传入参数\n\n```ts\n@Module({\n  imports: [ConfigModule.forRoot('/qx')],\n})\n```\n\n### 扩展模块元数据\n动态模块实际上只是**扩展**了 `@Module()` 中定义的基本模块元数据。\n\n配置了模块元数据后，若不调用静态方法，直接导入，就和之前一样，使用元数据中定义。\n\n扩展元数据的规则：覆盖同名的、保留多余的、添加新的。\n\n```ts\n@Global()\n@Module({\n  providers: [\n    {\n      provide: 'Config',\n      useValue: {\n        baseUrl: '/api',\n      },\n    },\n    {\n      provide: 'Test',\n      useValue: 'test',\n    },\n  ],\n  exports: ['Config', 'Test'],\n})\nexport class ConfigModule {\n  static forRoot(path: string): DynamicModule {\n    return {\n      module: ConfigModule,\n      // 会与元数据中的providers合并\n      providers: [\n        {\n          provide: 'Config',\n          useValue: {\n            baseUrl: '/api' + path,\n          },\n        },\n      ],\n      // 会与元数据中的exports合并\n      exports: ['Config'],\n      global: true,\n    };\n  }\n}\n```\n\n```ts 导入模块\n@Module({\n  imports: [ConfigModule.forRoot('/qx')],\n  // 或\n  imports: [ConfigModule],\n})\n```\n\n```ts 使用动态模块，覆盖了Config，保留了Test\n@Controller()\nexport class AppController {\n  constructor(\n    @Inject('Config') private readonly config,\n    @Inject('Test') private readonly test,\n  ) {}\n  @Get('config')\n  getConfig(): string {\n    console.log(this.config); // { baseUrl: '/api' }\n    console.log(this.test); // test\n    return this.config;\n  }\n}\n```\n\n# 中间件\n中间件是在路由处理程序**之前**调用的函数。Nest的中间件基本上等同于Express。[Express-中间件](/article/8ddaf637.html#中间件)\n\n**中间件规则：**\n1. 可以执行任意代码\n2. 操作request和response对象\n3. 终止请求响应过程\n4. 通过next()函数将**控制权**交给下一个中间件或路由处理程序\n5. 如果不是最后一个环节，则必须执行next()来传递控制权\n\n和Express一样，Nest的中间件可以是一个**函数**，但实现了`NestMiddleware`接口的**Provider**也能作为中间件\n\n## Provider\n`nest g mi <name>` 快速创建一个Provider中间件\n\n该命令会创建同名文件夹，包含 `<name>.middleware.ts`，该文件向外暴露一个实现了`NestMiddleware`接口的类\n\n```ts src\\logger\\logger.middleware.ts\nimport { Injectable, NestMiddleware } from '@nestjs/common';\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n  use(req: any, res: any, next: () => void) {\n    console.log('这是一个中间件')\n    next();\n  }\n}\n```\n\n`NestMiddleware` 接口规定了中间件必须具有 `use()` 方法，该方法接收三个参数：请求对象、响应对象、next函数\n\n```ts\ninterface NestMiddleware<TRequest = any, TResponse = any> {\n  use(req: TRequest, res: TResponse, next: (error?: Error | any) => void): any;\n}\n```\n\n引入Express的类型声明以获得智能提示\n\n```ts\nimport { Request, Response, NextFunction } from 'express';\nuse(req: Request, res: Response, next: NextFunction){ ... }\n```\n\n## 函数式\n如果一个中间件非常简单，没有成员，没有额外的方法，**没有依赖关系**，那么可以将其简单地写成一个函数。\n\n```ts\nexport function logger(req: Request, res: Response, next: NextFunction) {\n  console.log('这是一个中间件')\n  next();\n};\n```\n\n## 路由中间件\n由**模块**控制中间件应用到哪些**控制器**或**路由路径**上。\n\n中间件不能在 `@Module()` 装饰器中列出，要使用中间件的模块需要实现 `NestModule` 接口。\n\n```ts\ninterface NestModule {\n  configure(consumer: MiddlewareConsumer): any;\n}\n```\n\n`NestModule` 要求模块具有 `configure()` 方法。该方法使用 `MiddlewareConsumer` 类来连接中间件到特定的路由。\n\n```ts\ninterface MiddlewareConsumer {\n  apply(...middleware: (Type<any> | Function)[]): MiddlewareConfigProxy;\n}\n```\n\n`MiddlewareConsumer` 的 `apply()` 方法接收若干中间件，返回 `MiddlewareConfigProxy` 对象，使用该对象的方法来配置哪些路由需要应用中间件。\n1. `exclude()` 接收若干路由，排除这些路由，不使用中间件。\n2. `forRoutes()` 接收若干路由，这些路由使用中间件。\n3. 可以链式排除或注册中间件。\n\n```ts\ninterface MiddlewareConfigProxy {\n  exclude(...routes: (string | RouteInfo)[]): MiddlewareConfigProxy;\n  forRoutes(...routes: (string | Type<any> | RouteInfo)[]): MiddlewareConsumer;\n  // 先调用排除，再调用应用\n}\n```\n\n**传入的参数：**\n1. 字符串：表示该**路径**需要应用中间件（或排除）\n2. 类型(控制器)：表示该**控制器的所有路由**都需要应用中间件\n3. `RouteInfo`：可以更细致控制路径、版本、请求方法。\n\n```ts\ninterface RouteInfo {\n  path: string; // 路径\n  method: RequestMethod; // 请求方法，一个枚举类型\n  version?: VersionValue; // 版本\n}\n```\n\n> 中间件无论是被注册在哪个module中，其效果都是一样的。因为都是通过forRoutes和exclude方法来设定需要应用的路由。可以统一注册在根模块中，也可以分散注册。\n\n**例子：**\n\n```ts\nexport class ListModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    // consumer.apply(LoggerMiddleware).forRoutes(ListController);\n    consumer\n      .apply(LoggerMiddleware)\n      .exclude({\n        path: '(.*)',\n        method: RequestMethod.POST,\n        version: '1',\n      })\n      .forRoutes(ListController);\n  }\n}\n```\n\n> Nest中,大部分情况下,使用string作匹配时,都允许插入正则表达式语法,如 (.*) 匹配若干任意字符\n\n## 全局中间件\n全局中间件绑定到**所有路由**上，在每个请求上先于路由中间件执行。\n\n在 **main.ts** 中使用 `app.use()` 注册全局中间件。\n\n```ts\nfunction logger(req: Request, res: Response, next: NextFunction) {\n  console.log('[全局中间件]' + req.url);\n  next();\n}\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n  app.use(logger);\n}\n```\n\n> 从中间件往后，就是Nest的一些高度封装的功能了，如拦截器、管道、守卫、过滤器等，大量使用了Rxjs的API\n\n\n\n\n\n","tags":["NestJS","后端"],"categories":["学习笔记"]},{"title":"qx-tracker","url":"/article/31416cf6.html","content":"\n# 前言\n[qx-tracker](https://github.com/qxchuckle/qx-tracker) 是一个前端监控和埋点SDK，支持自定义埋点和监控。\n\n埋点就是数据采集-数据处理-数据分析和挖掘，如用户停留时间，用户哪个按钮点的多等。使用ts在编译过程中发现问题，减少生产代码的错误。\n\n本文重新解构一下项目实现，复习相关的API。\n\n# 构建环境\n使用 `Rollup` 构建项目，`TypeScript` 编写代码。基本模板为自编写的 [rollup-template](https://github.com/qxchuckle/rollup-template)\n\n## package.json\n**两个npm命令：**\n1. `npm run build` 构建**生产环境**代码，rollup 使用 `rollup.config.prod.mjs` 生产配置文件，并将环境变量 `ENV` 设置为 `production`\n2. `npm run dev` 构建**开发环境**代码，rollup 使用 `rollup.config.dev.mjs` 开发配置文件，并将环境变量 `ENV` 设置为 `development`，`-w` 监听文件变化(热更新)，`-m` 生成sourcemap源映射文件。\n\n```json npm命令\n\"scripts\": {\n  \"build\": \"rollup --config rollup.config.prod.mjs --environment ENV:production\",\n  \"dev\": \"rollup --config rollup.config.dev.mjs -w -m --environment ENV:development\"\n},\n```\n\n最终打包的文件在 `dist` 目录下。\n\n```json\n\"main\": \"dist/index.cjs.js\", // commonjs规范\n\"module\": \"dist/index.esm.js\", // esm模块规范\n\"browser\": \"dist/index.js\", // 浏览器环境，使用umd\n\"types\": \"dist/index.d.ts\", // ts类型声明文件\n```\n\n## rollup配置\n一共有三个配置文件：\n1. `rollup.config.common.mjs` 公共配置文件，包含基础的公共配置，如 input、基础插件。\n2. `rollup.config.dev.mjs` 开发环境配置文件，继承公共配置文件，设置 output、增加插件。\n3. `rollup.config.prod.mjs` 生产环境配置文件，继承公共配置文件，设置 output、增加插件、打包类型声明文件。\n\n```js rollup.config.common.mjs\n// 默认情况下，Rollup 只能处理相对路径的导入，安装node-resolve才能在模块中导入第三方npm模块\nimport nodeResolve from '@rollup/plugin-node-resolve';\n// 将 CommonJS 模块转换为 ES6 模块，因为 Rollup 默认只能处理 ES6 模块\nimport commonjs from '@rollup/plugin-commonjs';\n// 在每次打包之前清空输出目录\nimport clear from 'rollup-plugin-clear';\n// 编译ts，使 Rollup 能处理ts文件\nimport typescript from '@rollup/plugin-typescript';\n// 在源代码中替换一些特定的字符串。\nimport replace from '@rollup/plugin-replace';\n\nexport default {\n  // 入口文件\n  input: {\n    // 名为index的入口文件\n    index: './src/core/index.ts',\n  },\n  // 插件配置\n  plugins: [\n    replace({\n      preventAssignment: true, // 阻止在赋值操作中进行不正确的替换。\n      __env__: JSON.stringify(process.env.ENV) // 替换为环境变量\n    }),\n    nodeResolve(), // 可以导入第三方npm模块\n     // 将 CommonJS 模块转换为 ES6 模块，只处理js和ts文件\n    commonjs({ extensions: ['.js', '.ts'] }),\n    clear({\n      // 需要清空的文件夹\n      targets: ['dist'],\n      // 在监视模式下进行汇总重新编译时是否清除目录\n      watch: false, // default: false\n    }),\n    typescript({}), // 编译ts\n  ],\n};\n```\n\n```js rollup.config.dev.mjs\n// 在开发环境中启动一个 HTTP 服务器\nimport serve from 'rollup-plugin-serve';\n// 在文件改变时自动刷新浏览器\nimport livereload from \"rollup-plugin-livereload\";\n// 生成html文件，方便查看效果\nimport html from '@rollup/plugin-html';\n// 公共配置\nimport common from './rollup.config.common.mjs';\n// html模板\nimport { htmlDevTemple } from './html-temple.mjs';\n\n// 使用Object.assign扩展公共配置\nexport default Object.assign({}, common, {\n  // 输出配置\n  output: [\n    {\n      dir: 'dist', // 输出目录\n      entryFileNames: '[name].js', // 输出文件名\n      format: 'umd', // 输出格式\n      name: \"Tracker\" // umd模块名称，作为全局变量名\n    }\n  ],\n  plugins: [\n    ...common.plugins, // 导入公共配置的插件\n    html(htmlDevTemple), // 生成html文件\n    serve({\n      port: 3000, // 端口\n      contentBase: 'dist', // 服务器的根目录为输出目录\n      openPage: '/index.html', // 打开哪个文件\n      open: false, // 自动打开浏览器\n    }),\n    livereload(), // 自动刷新浏览器\n  ],\n});\n```\n\n```js rollup.config.prod.mjs\n// import html from '@rollup/plugin-html';\n// 压缩\n// import terser from '@rollup/plugin-terser';\n// 公共配置\nimport common from \"./rollup.config.common.mjs\";\n// import { htmlProdTemple } from './html-temple.mjs';\n// 用于生成 TypeScript 的声明文件\nimport dts from \"rollup-plugin-dts\";\n\n// 使用Object.assign扩展公共配置\n// 导出一个数组，数组中包含两个配置对象，rollup允许多入口多个产物\nexport default [\n  Object.assign({}, common, {\n    output: [\n      //打包 AMD CMD UMD\n      {\n        dir: \"dist\",\n        entryFileNames: \"[name].js\",\n        format: \"umd\",\n        name: \"Tracker\",\n      },\n      // 压缩的事还是应该交给用户自己去做\n      // {\n      //   dir: 'dist',\n      //   entryFileNames: '[name].min.js',\n      //   format: 'umd',\n      //   name: \"tracker\",\n      //   plugins: [terser()],\n      // },\n      //打包common js\n      {\n        dir: \"dist\",\n        entryFileNames: \"[name].cjs.js\",\n        format: \"cjs\",\n      },\n      // {\n      //   dir: 'dist',\n      //   entryFileNames: '[name].cjs.min.js',\n      //   format: 'cjs',\n      //   plugins: [terser()],\n      // },\n      //打包esModule\n      {\n        dir: \"dist\",\n        entryFileNames: \"[name].esm.js\",\n        format: \"es\",\n      },\n      // {\n      //   dir: 'dist',\n      //   entryFileNames: '[name].esm.min.js',\n      //   format: 'es',\n      //   plugins: [terser()],\n      // },\n    ],\n    plugins: [\n      ...common.plugins,\n      // html(htmlProdTemple)\n    ],\n  }),\n  {\n    // 打包d.ts\n    input: {\n      index: \"./src/core/index.ts\",\n    },\n    output: {\n      dir: \"dist\",\n      entryFileNames: \"[name].d.ts\",\n      format: \"es\",\n    },\n    plugins: [dts()],\n  },\n];\n```\n\n**tsconfig.json 配置：**\n\n```json tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": false, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n    // \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n    // \"diagnostics\": true, // 打印诊断信息 \n    \"target\": \"esnext\", /* 指定 ECMAScript 目标版本：'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */\n    \"module\": \"esnext\", /* 输出的代码使用什么方式进行模块化： 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    \"lib\": [ /* 指定引用的标准库 */\n      \"esnext\",\n      \"dom\",\n    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n    \"allowJs\": true, // 允许编译器编译JS，JSX文件\n    \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./src\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n    // \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n    // \"declarationDir\": \"./dist/typings\", // 指定生成声明文件存放目录\n    // \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n    \"sourceMap\": false, // 生成目标文件的sourceMap文件\n    // \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n    \"declarationMap\": false, // 为声明文件生成sourceMap\n    // \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n    \"types\": [], // 加载的声明文件包\n    \"removeComments\": true, // 删除注释 \n    // \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n    \"noEmitOnError\": true, // 发送错误时不输出任何文件\n    \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n    \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n    \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n    \"strict\": true, // 开启所有严格的类型检查\n    \"alwaysStrict\": true, // 在代码中注入'use strict'\n    \"noImplicitAny\": true, // 不允许隐式的any类型\n    \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n    \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n    \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n    \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n    \"noImplicitThis\": true, // 不允许this有隐式的any类型\n    \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n    \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n    \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n    \"noImplicitReturns\": true, //每个分支都会有返回值\n    \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n    \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n    \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { // 路径映射，相对于baseUrl\n      // \"@/*\": [\n      //   \"src/*\"\n      // ]\n    },\n    \"rootDirs\": [\n      \"src\"\n    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n    \"listEmittedFiles\": true, // 打印输出文件\n    \"listFiles\": true, // 打印编译的文件(包括引用的声明文件)\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"resolveJsonModule\": true\n  },\n  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n  \"include\": [\n    \"src/**/*\",\n  ],\n  // 指定一个排除列表（include的反向操作）\n  // \"exclude\": [\n  //   \"demo.ts\"\n  // ],\n  // 指定哪些文件使用该配置（属于手动一个个指定文件）\n  // \"files\": [\n  //   \"src/index.d.ts\"\n  // ]\n}\n```\n\n**html-temple.mjs** 配合 `rollup/plugin-html` 生成开发环境测试用的 html 文件，其实感觉也没比新建一个html文件方便。\n\n## 项目结构\n\n```js 主要目录结构\n├───📁 dist/\n│   └───...\n├───📁 server/\n│   └───...\n├───📁 src/\n│   └───...\n└───...\n```\n\n**根目录：**\n1. `dist` 是Rollup输出目录，存放构建打包的产物\n2. `server` 一个简单的后端服务，用于测试数据上报。\n3. `src` 项目源码。\n\n```js src源码目录结构\n├───📁 core/ // 核心源码\n│   ├───📁 tracker/ // tracker相关类\n│   │   ├───📄 dom.ts // dom埋点\n│   │   ├───📄 error.ts // 错误监控\n│   │   ├───📄 index.ts // 统一暴露\n│   │   ├───📄 location.ts // 路由监控\n│   │   ├───📄 navigator.ts // 获取用户信息\n│   │   ├───📄 options.ts // tracker配置\n│   │   ├───📄 performance.ts // 性能监控，主要是dom和资源加载的性能\n│   │   └───📄 trackerCls.ts // 抽象类，控制其它tracker类行为\n│   └───📄 index.ts // 入口文件，Tracker类，管理配置和其它监控类实例。\n├───📁 types/ // 类型\n│   └───📄 index.ts // 定义了一些ts类型\n├───📁 utils/ // 工具函数\n│   ├───📄 beacon.ts // 封装sendBeacon\n│   ├───📄 index.ts // 统一暴露所有工具函数\n│   ├───📄 location.ts // 路由相关函数\n│   ├───📄 log.ts // 开发环境log\n│   ├───📄 navigator.ts // 获取用户信息\n│   ├───📄 performance.ts // 性能相关函数\n│   ├───📄 string.ts // 计算字符串大小\n│   ├───📄 uuid.ts // 获取uuid\n│   └───📄 watch.ts // 监视器，暂时没用到\n└───📄 index.d.ts // 基础类型声明文件\n```\n\n# 入口文件\n解析项目还是由表及里好，先从入口文件 `core/index.ts` 讲起。\n工具函数和类型文件的内容，在各个监控类用到时再穿插讲解。\n\n入口文件导出了一个名为 `Tracker` 的类，我称之为主类，继承自 `TrackerOptions`，主类主要管理着其它监控类实例，并提供了上报数据的方法、与外部环境打交道。\n\n```ts src\\core\\index.ts\n\n```\n\n## TrackerOptions配置类\n`TrackerOptions` 是配置类，管理着所有监控类的配置，如上报地址、功能开启等。所有监控类都要根据配置来执行相应的操作。\n\n```ts src\\core\\tracker\\options.ts\nimport { DefaultOptions, Options, TrackerConfig } from \"../../types\"; // 导入类型\nimport { getCanvasID } from \"../../utils\"; // 导入通过canvas获取uuid的方法\n\nexport default class TrackerOptions {\n  // 存储配置项，protected权限，实例不能访问，子类和自己可以访问\n  protected options: Options\n  \n  // 构造函数，接收配置项\n  constructor(options: Options) {\n    // 合并默认和用户传入设置，用户传入设置优先级高\n    // 通过 Object.assign 合并默认配置和用户配置\n    this.options = Object.assign(this.initDefault(), options);\n  }\n  // 初始化配置项\n  private initDefault(): DefaultOptions {\n    return <DefaultOptions>{\n      requestUrl: \"\", // 上报地址\n      uuid: this.generateUserID(), // 用户唯一标识\n      historyTracker: false, // history模式，开启后会监听路由变化\n      hashTracker: false, // hash模式，开启后会监听路由变化\n      errorTracker: false, // 错误监控\n      domTracker: false, // dom埋点监控\n      // 需要监控的dom事件\n      domEventsList: new Set(['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseup', 'mouseout', 'mouseover']),\n      performanceTracker: false, // 性能监控\n      navigatorTracker: false, // 用户信息监控\n      extra: undefined, // 上报时需要携带的额外信息\n      sdkVersion: TrackerConfig.version, // sdk版本\n      log: true, // 是否在控制台打印日志\n      realTime: false, // 是否实时上报\n      maxSize: 1024 * 50 // 单次上报数据最大值，单位字节\n    }\n  }\n  // 生成uuid\n  public generateUserID(): string | undefined {\n    return getCanvasID()\n  }\n}\n```\n\n先看默认配置项，由私有方法 `initDefault()` 提供，为 `DefaultOptions` 类型。\n\n```ts DefaultOptions\nexport interface DefaultOptions {\n  requestUrl: string, // 上报地址\n  uuid: string | undefined, // 用户唯一标识\n  historyTracker: boolean, // history模式，开启后会监听路由变化\n  hashTracker: boolean, // hash模式，开启后会监听路由变化\n  errorTracker: boolean, // 错误监控\n  domTracker: boolean, // dom埋点监控\n  domEventsList: Set<keyof HTMLElementEventMap>, // 需要监控的dom事件\n  performanceTracker: boolean, // 性能监控\n  navigatorTracker: boolean, // 用户信息监控\n  extra: Record<string, any> | undefined, // 上报时需要携带的额外信息\n  sdkVersion: string | number, // sdk版本\n  log: boolean, // 是否在控制台打印日志\n  realTime: boolean, // 是否实时上报\n  maxSize: number, // 单次上报数据最大值，单位字节\n}\nexport enum TrackerConfig {\n  version = '1.0.0', // 版本\n}\n```\n\n所有功能默认都是关闭的，用户可以根据需要开启。uuid通过 `generateUserID()` 方法获取，domEventsList 已经配置了一些常用的dom事件。sdkVersion 则是通过枚举类型 `TrackerConfig` 获取。\n\n配置类的构造函数传入一个 `Options` 类型的外部配置项，通过 `Object.assign` 合并默认配置和用户配置，用户配置优先级高。\n\n`Options` 类型由 `DefaultOptions` 类型，通过 `Optional` 高级类型加工而来，将 requestUrl 设为必选项，而其它都是可选项，也就是必须传入一个上报地址。\n\n```ts Options\n// 用户传入选项\nexport type Options = Optional<DefaultOptions, 'requestUrl'>\n```\n\nTS并**没有**提供 `Optional` 高级类型，用于将某些属性设为可选项。需要自己实现。\n1. 传入两个泛型参数，`T`为原始类型，`K`为必选项，是 `T` 的属性名。\n2. `Pick` 类型将必选项筛选出来，`Omit` 去掉必选项，再使用 `Partial` 类型将其它属性设为可选项。\n3. 最后通过联合类型 `&` 合并两个类型。\n\n高级类型就像是类型的函数，加工原始类型，返回一个新的类型。\n\n```ts Optional\n/**\n * 选项生成器\n * @param T - 原始类型\n * @param K - 必填类型\n */\ntype Optional<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>;\n```\n\n最后，将合并后的配置项存储在 `options` 属性中。为 `protected` 权限，只能由子类和自己访问。当然，主类也提供了一些方法，允许动态设置一些配置项，如uuid、额外数据等。\n\n## trackerCls\n主类管理着所有具体监控类的实例，而这些监控类都继承自 `trackerCls` 这个抽象类。\n\n```ts\nimport { Options, EventListeners } from \"../../types\";\n\n// 抽象类，具体的监控类需要继承该类，控制监控类的行为\nexport default abstract class TrackerCls {\n  // 存储配置项\n  protected options: Options\n  // 存储上报数据的方法\n  protected reportTracker: Function // 上报数据的方法\n  // 存储事件监听器\n  protected eventListeners: EventListeners = {}\n\n  constructor(options: Options, reportTracker: Function) {\n    // 配置项和上报方法由外部传入\n    this.options = options;\n    this.reportTracker = reportTracker;\n  }\n  // 抽象方法，如何初始化交给具体的监控类去实现。\n  abstract init(): void\n  // 封装addEventListener\n  protected addEventListener(name: string, handler: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = false) {\n    // 如果没有该事件的监听数组，就初始化一个空的\n    !this.eventListeners.hasOwnProperty(name) && (this.eventListeners[name] = [])\n    // 将事件监听器存入数组\n    this.eventListeners[name].push(handler)\n    // 添加事件监听\n    window.addEventListener(name, handler, options)\n  }\n  // 额外需要销毁的内容，由具体的监控类去实现\n  abstract additionalDestroy(): void\n  // 销毁方法，因为有事件监听器，所以需要销毁事件监听器，避免内存泄漏\n  public destroy() {\n    // 遍历eventListeners获取所有事件监听器，然后移除\n    for (const eventName in this.eventListeners) {\n      const listeners = this.eventListeners[eventName];\n      for (const listener of listeners) {\n        window.removeEventListener(eventName, listener);\n      }\n    }\n    // 清空eventListeners\n    this.eventListeners = {};\n    // 调用额外销毁的方法\n    this.additionalDestroy();\n  }\n}\n```\n\n`trackerCls` 控制监控类的基本行为：\n1. 构造函数需要接收从外部（主类）传入的配置项和上报方法。并根据配置项初始化自己，在合适的时候上报数据。\n2. 规定了抽象方法 `init`，具体的监控类需要实现初始化方法。\n3. 提供了 `addEventListener` 方法，封装了 `window.addEventListener`，并存储了事件监听器，方便销毁。\n4. 提供了 `destroy` 方法，用于销毁事件监听器，避免内存泄漏。同时定义了 `additionalDestroy` 抽象方法，额外需要销毁的内容由具体的监控类去实现。\n\n\n## Tracker主类\n再回来看主类 `Tracker`，继承自 `TrackerOptions`，所以拥有配置类的属性和方法。\n\n主类的构造函数同样接收一个 `Options` 类型的配置项，并通过 `super` 调用父类构造函数，初始化配置项。现在，配置项由主类进行管理了。\n\n主类提供了一些 `public` 方法，`setUserID`、`setExtra`，允许动态设置配置项。\n\n```ts\n// 允许外部设置uuid\npublic setUserID<T extends DefaultOptions['uuid']>(uuid: T) {\n  if (this.isDestroy) return;\n  this.options.uuid = uuid;\n}\n// 外部设置额外参数\npublic setExtra<T extends DefaultOptions['extra']>(extra: T) {\n  if (this.isDestroy) return;\n  this.options.extra = extra;\n}\n```\n\n**继续看构造函数：**\n1. 实例化了各种监控类，并存储在了 `trackers` 私有对象的对应属性上。这是为了方便管理和调用类上的方法（初始化、销毁）。\n2. 所有监控类都需要接收配置项和上报方法，上报方法包装了主类的 `reportTracker` 方法。\n\n在设计上，监控类只负责自己的监控职责，并在合适的适合上报数据，不负责数据的具体处理和上报逻辑，具体的上报实现由主类负责。\n\n```ts src\\core\\index.ts\nimport { TrackerOptions, LocationTracker, DomTracker, ErrorTracker, PerformanceTracker, NavigatorTracker } from \"./tracker\";\n// 存储各种Tracker的实例\nprivate trackers: Trackers = {\n  locationTracker: undefined, // 路由监控实例\n  domTracker: undefined, // dom埋点监控实例\n  errorTracker: undefined, // 错误监控实例\n  performanceTracker: undefined, // 性能监控实例\n  navigatorTracker: undefined, // 用户信息监控实例\n}\nconstructor(options: Options) {\n  super(options);\n  // 创建各种Tracker的实例，将配置和上报方法传入\n  this.trackers.locationTracker = new LocationTracker(\n    this.options,\n    <T>(data: T, key: string) => this.reportTracker(data, key)\n  );\n  this.trackers.domTracker = new DomTracker(\n    this.options,\n    <T>(data: T, key: string) => this.reportTracker(data, key)\n  );\n  this.trackers.errorTracker = new ErrorTracker(\n    this.options,\n    <T>(data: T, key: string) => this.reportTracker(data, key)\n  );\n  this.trackers.performanceTracker = new PerformanceTracker(\n    this.options,\n    <T>(data: T, key: string) => this.reportTracker(data, key)\n  );\n  this.trackers.navigatorTracker = new NavigatorTracker(\n    this.options,\n    <T>(data: T, key: string) => this.reportTracker(data, key)\n  );\n  // 调用初始化方法\n  this.init();\n}\n\n// 类型 src\\types\\index.ts\nimport { LocationTracker, DomTracker, ErrorTracker, PerformanceTracker, NavigatorTracker } from \"../core/tracker\";\nexport type Trackers = {\n  locationTracker: LocationTracker | undefined,\n  domTracker: DomTracker | undefined,\n  errorTracker: ErrorTracker | undefined,\n  performanceTracker: PerformanceTracker | undefined,\n  navigatorTracker: NavigatorTracker | undefined,\n}\n```\n\n**初始化：**\n实例化完各种监控类后，调用了 `init()` 私有方法。\n1. 遍历所有Tracker实例，调用其初始化方法。\n2. 如果不是实时上报模式，初始化 `beforeCloseReport`，主类控制在页面关闭前上报。\n\n只要监听了事件，其回调都应该保存起来，以便在合适的时候销毁。这里监听了 `beforeunload` 事件，所以使用 `beforeCloseHandler` 私有属性保存其回调。\n\n```ts 初始化相关属性和方法\n// 存储字符串大小计算方法\nprivate stringSizeCalculation: Function | undefined = undefined\n// 存储beforeCloseHandler，页面关闭前执行的回调\nprivate beforeCloseHandler: EventListenerOrEventListenerObject | undefined = undefined\n// 初始化\nprivate init() {\n  try {\n    // 遍历所有Tracker实例，调用其初始化方法\n    for (const key in this.trackers) {\n      this.trackers[key as keyof Trackers]?.init();\n    }\n    // 如果不是实时上报模式，初始化beforeCloseReport，主类控制在页面关闭前上报\n    if (!this.options.realTime) {\n      // 创建字符串大小计算方法\n      this.stringSizeCalculation = createStringSizeCalculation();\n      this.beforeCloseReport();\n    }\n    // 如果允许log，则打印初始化成功\n    this.options.log && console.log('Tracker is OK');\n  } catch (e) {\n    // console.log(e);\n    // 初始化出错，则直接上报错误\n    sendBeacon(this.options.requestUrl, this.decorateData({\n      targetKey: \"tracker\",\n      event: \"error\",\n      message: e,\n    }));\n    this.options.log && console.error('Tracker is error');\n  }\n}\n// 启动页面关闭前上报\nprivate beforeCloseReport() {\n  // 设置beforeCloseHandler\n  this.beforeCloseHandler = () => {\n    this.sendReport();\n  }\n  // 监听页面关闭前beforeunload事件\n  window.addEventListener(\"beforeunload\", this.beforeCloseHandler);\n}\n```\n\n**销毁：**\n主类提供了公共方法 `destroy`，允许外部销毁监控。主要是调用了各个监控类的销毁方法。\n\n```js\n// 销毁\npublic destroy() {\n  // 如果已经销毁，直接返回\n  if (this.isDestroy) return;\n  // 销毁前把剩余数据传出\n  this.sendReport();\n  // 遍历所有监控类\n  for (const key in this.trackers) {\n    // 调用其销毁方法\n    this.trackers[key as keyof Trackers]?.destroy();\n    // 将其实例置为undefined，以便GC回收\n    this.trackers[key as keyof Trackers] = undefined;\n  }\n  // 移除beforeCloseHandler\n  this.beforeCloseHandler && window.removeEventListener(\"beforeunload\", this.beforeCloseHandler);\n  // 设置属性为undefined，以便GC回收\n  this.stringSizeCalculation = undefined;\n  this.beforeCloseHandler = undefined;\n  // 将销毁标志置为true\n  this.isDestroy = true;\n}\n```\n\n# 数据上报\n上报数据的方法由主类提供，并通过构造函数注入给其它各个监控类。\n\n## 封装sendBeacon\n传统的数据上报方式，如 XMLHttpRequest 或 Fetch API，容易受到页面卸载过程中的阻塞，导致数据丢失。\n\n而 `navigator.sendBeacon` 可以在页面卸载时安全、可靠地发送数据。\n1. 异步执行，不阻塞页面关闭或跳转。\n2. 不受页面卸载过程的影响，确保数据可靠发送。\n3. 无法获取响应，但在发送**简单请求**时天然跨域，就像fetch的no-cors模式一样。\n\n**缺点：**\n1. sendBeacon 只能发送 POST 请求。\n2. **请求类型为 ping**，只能传送少量数据（通常是 **64KB 以内**），无法自定义请求头。\n3. 只能传输 ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams 类型的数据。\n4. 如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效\n\n`sendBeacon(url, data)` 接收两个参数，第一个是地址，第二个是数据。\n\n**返回值：**boolean\n1. true: 数据被异步缓存，但并不保证数据已被成功发送或接收。所以后续考虑只在关闭页面前使用 sendBeacon，其它时候使用 fetch。\n2. false: 数据无法被缓存，通常是因为数据太大或 URL 无效。\n\n**数据类型：**\n如果data是字符串类型，那么**content-type**会自动匹配为`text/plain`，如果是FormData类型，则会自动匹配为multipart/form-data类型。\n\n如果想要发送json数据，则需要借助Blob对象。通过Blob的type参数，可以指定MIME类型，间接达到设置Content-Type的目的。\n\n```ts\nconst blob = new Blob([JSON.stringify(params)], {\n  type: 'application/json'\n});\n```\n\n但这会导致跨域，因为不是原始的三个**Content-Type**。所以不如直接使用`text/plain`，请求体是JSON字符串。后端使用 `JSON.parse` 解析。\n\n```ts\n// 封装sendBeacon，传入url和params，返回上报状态\nexport function sendBeacon(url: string, params: object): boolean {\n  // 判断是否有数据，也就是params是否为空对象\n  if (Object.keys(params).length <= 0) {\n    return false;\n  }\n  // const blob = new Blob([JSON.stringify(params)], {\n  //   type: 'application/json'\n  // });\n  const state = navigator.sendBeacon(url, JSON.stringify(params));\n  return state;\n}\n```\n\n一个简单的 express 后端，使用 `express.text()` 解析请求体的字符串。\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.post('/tracker', express.text(), function (req, res) {\n  console.log(JSON.parse(req.body));\n  res.send('ok');\n});\n\napp.listen(9000, () => {\n  console.log('listening on')\n})\n```\n\n## reportTracker方法\n`reportTracker` 是 `Tracker` 主类上报数据的私有方法，通过构造函数注入给各个监控类。\n\n```ts src\\core\\index.ts\nprivate report: Report = {}; // 暂存上报数据\n// 上报\nprivate reportTracker<T>(data: T, key: string): boolean {\n  // 调用decorateData修饰数据\n  const params = this.decorateData(data);\n  // 如果是实时上报模式，直接调用sendBeacon上报\n  if (this.options.realTime) {\n    return sendBeacon(this.options.requestUrl, params);\n  } else {\n    // 将数据存入report属性中对应key的数组中\n    !this.report.hasOwnProperty(key) && (this.report[key] = []);\n    this.report[key].push(params);\n    // 不是实时上报模式，先判断是否超过最大值，超过则上报\n    const size =\n      this.stringSizeCalculation &&\n      this.stringSizeCalculation(JSON.stringify(this.report));\n    log && log(size, params); // 打印上报数据,方便调试\n    // 判断是否超过最大值，已经超过了则上报\n    if (\n      this.options.maxSize &&\n      size &&\n      size > (this.options.maxSize || 10000)\n    ) {\n      // 调用累积上报方法\n      this.sendReport();\n    }\n    return true;\n  }\n}\n```\n\n首先使用了 `decorateData` 方法修饰数据，加上了uuid、时间戳、路由等统一信息。\n\n```ts\n// 修饰数据，加上统一信息\nprivate decorateData<T>(data: T): object {\n  // 将传入的数据和统一信息合并\n  return Object.assign({}, {\n    uuid: this.options.uuid, // 加上uuid\n    time: new Date().getTime(), // 加上时间戳\n    location: this.trackers.locationTracker?.getLocation(), // 加上当前路由，由路由监控实例提供\n    extra: this.options.extra, // 加上配置项中的额外数据\n  }, data);\n}\n```\n\n如果是实时上报模式，直接调用 `sendBeacon()` 上报数据。\n\n如果不是实时上报模式，先将本次数据存入 `report` 属性对应**key**的数组中，然后通过 `stringSizeCalculation()` 方法判断 `report` 缓存是否超过最大值，超过则调用 `sendReport()` 累积上报方法。\n\n`stringSizeCalculation()` 方法通过 `TextEncoder` 编码器对字符串进行编码，然后返回字节长度，粗略计算字符串大小，单位字节。\n\n```ts src\\utils\\string.ts\nexport function createStringSizeCalculation() {\n  const textEncode = new TextEncoder();\n  return function (str: string) {\n    return textEncode.encode(str).length;\n  }\n}\n```\n\n## sendReport累积上报\n如果不是实时上报模式，则监控数据会缓存在 `report` 对象中，按监控类型，也就是key分类保存在对应属性值（数组）中。\n\n> 大多数情况下应该使用非实时模式，监控数据不会立即上报，而是等待数据累积到一定程度再上报，这样可以减少请求次数，提高性能。\n\n```ts\n// 累积数据上报方法\n// 这是一个公共方法，允许外部调用，用户可以在合适的时候上报数据，而不用等数据累积超过最大值\npublic sendReport(): boolean {\n  // 如果已经销毁，直接返回\n  if (this.isDestroy) return false;\n  // 调用sendBeacon上报数据\n  const state = sendBeacon(this.options.requestUrl, this.report);\n  // 上报成功后清空report\n  state && (this.report = {});\n  // 返回上报状态\n  return state;\n}\n```\n\n`sendReport()` 是一个公共方法，允许外部调用，用户可以在合适的时候上报数据，而不用等数据累积超过最大值。\n\n## sendTracker用户主动上报\n很多情况下，监控需要和业务内容高度耦合，这是通用的监控类或埋点无法做到的，所以主类提供了 `sendTracker()` 方法，允许用户主动上报数据。\n\n```ts\n// 主动上报\npublic sendTracker<T>(targetKey: string = \"manual\", data?: T) {\n  if (this.isDestroy) return;\n  this.reportTracker(\n    {\n      event: \"manual\",\n      targetKey,\n      data,\n    },\n    \"manual\"\n  );\n}\n```\n\n`sendTracker()` 实际上只是调用了 `reportTracker()` 方法，在 `report` 缓存中的 key 为 **manual**。\n\n# LocationTracker类\n监控最重要一点就是知道，当前是在哪个页面，以及用户在当前页面的停留时长。对于SPA或启用了PJAX的站点，还需要监控路由的切换，包括 history 和 hash 的变化。\n\n`LocationTracker` 类就是用来监控路由信息的。\n\n```ts src\\core\\tracker\\location.ts\nimport { Options } from \"../../types\";\nimport TrackerCls from \"./trackerCls\";\nimport { createHistoryMonitoring, getLocation } from \"../../utils\";\n\nexport default class LocationTracker extends TrackerCls {\n  private enterTime: number | undefined = undefined; // 记录用户进入当前页面时的时间戳\n  private location: string | undefined = undefined; // 记录用户当前页面\n\n  constructor(options: Options, reportTracker: Function) {\n    // 调用父类的构造函数\n    super(options, reportTracker);\n    // 初始化用户进入当前页面的时间戳和当前页面\n    this.reLocationRecord();\n  }\n  // 初始化\n  public init() {\n    // 如果开启了history监控，就监听history变化\n    if (this.options.historyTracker) {\n      this.historyChangeReport();\n    }\n    // 如果开启了hash监控，就监听hash变化\n    if (this.options.hashTracker) {\n      this.hashChangeReport();\n    }\n    // 如果开启了任意路由监控，则开启页面关闭前上报关闭信息\n    if (this.options.historyTracker || this.options.hashTracker) {\n      this.beforeCloseRouterReport();\n    }\n  }\n  // 销毁时额外需要销毁的内容\n  additionalDestroy() {\n    this.enterTime = undefined;\n    this.location = undefined;\n  }\n  // 更新当前路径和进入时间\n  private reLocationRecord() {\n    this.enterTime = new Date().getTime();\n    this.location = getLocation();\n  }\n  // 进行location监听\n  private captureLocationEvent<T>(event: string, targetKey: string, data?: T) {\n    // 回调\n    const eventHandler: EventListenerOrEventListenerObject = () => {\n      // 数据\n      const d = {\n        event, // 事件类型\n        targetKey, // 目标key，按后端需要自定义，默认为 history-pv 或 hash-pv\n        location: this.location, // 原路由\n        targetLocation: getLocation(), // 当前路由，也就是目标路由\n        // 用户访问该路由时长\n        duration: new Date().getTime() - this.enterTime!,\n        data, // 额外的数据\n      };\n      // 上报数据\n      this.reportTracker(d, \"router\");\n      // 更新当前路径和进入时间\n      this.reLocationRecord();\n    };\n    // 监听事件\n    this.addEventListener(event, eventHandler);\n  }\n  // 监听history变化\n  private historyChangeReport(eventName: string = \"historyChange\") {\n    // 创建History变化的统一事件\n    createHistoryMonitoring(eventName);\n    // 监听该事件\n    this.captureLocationEvent(eventName, \"history-pv\");\n  }\n  // 监听hash变化\n  private hashChangeReport() {\n    // 也就是监听hashchange事件\n    this.captureLocationEvent(\"hashchange\", \"hash-pv\");\n  }\n  // 页面关闭前上报\n  private beforeCloseRouterReport() {\n    if (!this.options.realTime) {\n      return;\n    }\n    const eventName = \"beforeunload\";\n    const eventHandler: EventListenerOrEventListenerObject = () => {\n      const d = {\n        event: eventName,\n        targetKey: \"close\",\n        location: this.location,\n        duration: new Date().getTime() - this.enterTime!,\n      };\n      this.reportTracker(d, \"router\");\n    };\n    this.addEventListener(eventName, eventHandler);\n  }\n  // 给外部提供页面信息\n  public getLocation(): string {\n    return this.location!;\n  }\n}\n```\n\n## 监听路由变化\n**hash**变化可以直接监听 `hashchange` 事件\n\n而**history**变化则比较特殊。\n1. 全局 `history` 对象上的 `back()`, `forward()` 和 `go()`，浏览器的前进后退按钮，会触发 `popstate` 事件。\n2. 但 `pushState()` 和 `replaceState()` 不会触发 `popstate` 事件。且没有对应的事件可以监听。\n\n所以需要重写这两个方法，在其被调用时，通知监听者。借助 `Event` 类可以很方便地创建一个统一的自定义事件。\n\n```ts src\\utils\\location.ts\n// back()、forward() 和 go() 事件都会触发 popState 事件。\n// 但是 pushState() 和 replaceEstate() 不会触发 popState 事件。因此我们需要做些代码处理让它们都能触发某一个事件\nexport const createHistoryEvent = <T extends keyof History>(\n  type: T,\n  eventName: string\n): (() => any) => {\n  const origin = history[type]; // 保存原始方法\n  const e = new Event(eventName); // 创建自定义事件\n  const typeEvent = new Event(type); // 创建方法同名事件\n  return function (this: any) {\n    // 调用原始方法\n    const res = origin.apply(this, arguments);\n    // 触发自定义事件\n    window.dispatchEvent(typeEvent);\n    window.dispatchEvent(e);\n    return res;\n  };\n};\n/**\n * 创建对history的监听，统一触发指定自定义事件。\n * @param {string} [eventName='historyChange'] history变化统一触发的自定义事件名。\n * @example\n * window.addEventListener('historyChange', () => {\n *  console.log('history changed!')\n * })\n */\nexport function createHistoryMonitoring(eventName: string = \"historyChange\") {\n  // 重写history的pushState方法\n  window.history[\"pushState\"] = createHistoryEvent(\"pushState\", eventName);\n  // 重写history的replaceState方法\n  window.history[\"replaceState\"] = createHistoryEvent(\n    \"replaceState\",\n    eventName\n  );\n  // 在触发popstate事件时，触发自定义事件\n  window.addEventListener(\"popstate\", () => {\n    window.dispatchEvent(new Event(eventName));\n  });\n}\n\n// 获取当前页面的路径\nexport function getLocation(): string {\n  return window.location.pathname + window.location.hash;\n}\n```\n\n现在`pushState`和`replaceState`方法，以及**popstate**事件，都会触发自定义的 `historyChange` 事件，且还有pushState和replaceState两个和方法同名的事件可供监听，当然目前还没用上，统一事件够用了。\n\n# navigatorTracker类\n`navigatorTracker` 类非常简单，就是通过 `navigator` 对象获取用户的一些信息。\n\n```ts src\\core\\tracker\\navigator.ts\nimport { Options } from \"../../types\";\nimport TrackerCls from \"./trackerCls\";\nimport { getNavigatorInfo } from \"../../utils\";\n\nexport default class NavigatorTracker extends TrackerCls {\n  constructor(options: Options, reportTracker: Function) {\n    super(options, reportTracker);\n  }\n  // 初始化\n  public init() {\n    if (this.options.navigatorTracker) {\n      this.navigatorReport()\n    }\n  }\n  additionalDestroy() { }\n  // 用户信息上报\n  private navigatorReport() {\n    this.reportTracker({\n      targetKey: 'navigator',\n      event: null,\n      info: getNavigatorInfo(),\n    }, 'navigator')\n  }\n}\n```\n\n该类的业务核心是通过 `getNavigatorInfo` 工具方法获取信息。因为 `navigator` 对象的属性比较多，需要加工后上报。\n\n```ts src\\utils\\navigator.ts\n// 获取navigator信息\nexport function getNavigatorInfo(): object {\n  // 获取navigator\n  const navigator = window.navigator;\n  // 获取ua\n  const ua = navigator.userAgent;\n  return {\n    userAgent: ua,\n    cookieEnabled: navigator.cookieEnabled,\n    language: navigator.language,\n    browser: getBrowser(ua),\n    os: getOS(ua),\n    isMobile: isMobile(ua),\n    screen: {\n      // 获取屏幕宽高\n      width: window.screen.width,\n      height: window.screen.height,\n    }\n  }\n}\n\n// 获取浏览器信息\nexport function getBrowser(ua: string) {\n  ua = ua.toLowerCase();\n  const browserRegex = {\n    Edge: /edge\\/([\\d.]+)/i,\n    IE: /(rv:|msie\\s+)([\\d.]+)/i,\n    Firefox: /firefox\\/([\\d.]+)/i,\n    Chrome: /chrome\\/([\\d.]+)/i,\n    Opera: /opera\\/([\\d.]+)/i,\n    Safari: /version\\/([\\d.]+).*safari/i\n  };\n  for (const browser in browserRegex) {\n    const match = ua.match(browserRegex[browser as keyof typeof browserRegex]);\n    if (match) {\n      return { name: browser, version: match[1] };\n    }\n  }\n  return { name: \"\", version: \"0\" };\n}\n\n// 获取操作系统信息\nexport function getOS(ua: string) {\n  ua = ua.toLowerCase();\n  const osRegex = [\n    { name: \"windows\", regex: /compatible|windows/i },\n    { name: \"macOS\", regex: /macintosh|macintel/i },\n    { name: \"iOS\", regex: /iphone|ipad/i },\n    { name: \"android\", regex: /android/i },\n    { name: \"linux\", regex: /linux/i }\n  ];\n  for (const os of osRegex) {\n    if (ua.match(os.regex)) {\n      return os.name;\n    }\n  }\n  return \"other\";\n}\n\n// 判断是否为移动端\nexport function isMobile(ua: string) {\n  return !!ua.match(\n    /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i\n  );\n}\n```\n\n对于浏览器、系统、移动端的判断，是通过正则匹配 `userAgent` 字符串。其实可以只把 UA 传给后端，后端再解析。但前端先处理下获取关键信息，也挺好。\n\n# DomTracker类\n`DomTracker` 类通过元素上的埋点，监控用户的指定行为，并上报数据。\n\n```ts src\\core\\tracker\\dom.ts\nimport { Options } from \"../../types\";\nimport TrackerCls from \"./trackerCls\";\n\nexport default class DomTracker extends TrackerCls {\n\n  constructor(options: Options, reportTracker: Function) {\n    super(options, reportTracker);\n  }\n  // 初始化\n  public init() {\n    if (this.options.domTracker) {\n      this.domEventReport()\n    }\n  }\n  additionalDestroy() { }\n  // 监听dom事件，并上报相关数据\n  private domEventReport() {\n    this.options.domEventsList?.forEach(event => {\n      const eventHandler: EventListenerOrEventListenerObject = (e) => {\n        const target = e.target as HTMLElement;\n        // 设置target-events属性，元素层次限制上报的事件\n        const targetEvents = JSON.stringify(target.getAttribute('target-events'));\n        if (targetEvents && !targetEvents.includes(e.type)) {\n          return;\n        }\n        // 获取目标key，设置key分辨不同元素\n        // <button target-key=\"btn\" target-events=\"['click']\">dom事件上报测试</button>\n        const targetKey = target.getAttribute('target-key');\n        if (targetKey) {\n          // console.log(e);\n          this.reportTracker({\n            event,\n            targetKey,\n            // 元素的基本信息，便于定位\n            elementInfo: {\n              name: target.localName ?? target.nodeName,\n              id: target.id || null,\n              class: target.className || null,\n              // innerText: target.innerText,\n            }\n          }, 'dom')\n        }\n      }\n      this.addEventListener(event, eventHandler)\n    })\n  }\n}\n```\n\n核心是 `domEventReport()` 方法，遍历了配置项中的 `domEventsList`，并监听对应的事件。\n\n再看看 `addEventListener` 方法，它是 `TrackerCls` 类提供的方法，封装了 `window.addEventListener`。\n\n```ts src\\core\\tracker\\trackerCls.ts\n// 封装addEventListener\nprotected addEventListener(\n  name: string,\n  handler: EventListenerOrEventListenerObject,\n  options: boolean | AddEventListenerOptions = false\n) {\n  // 如果没有该事件的监听数组，就初始化一个空的\n  !this.eventListeners.hasOwnProperty(name) &&\n    (this.eventListeners[name] = []);\n  // 将事件监听器存入数组\n  this.eventListeners[name].push(handler);\n  // 添加事件监听\n  window.addEventListener(name, handler, options);\n}\n```\n\n所有事件都绑定在 `window` 上，利用冒泡机制，可以监听到所有元素上的大部分事件。\n1. 先判断元素是否有 `target-events` 属性，如果有，则判断当前触发的事件是否在 `target-events` 中，不在则直接返回。\n2. 再判断元素是否有 `target-key` 属性，如果有，就上报监控数据。\n\n也就是有两个埋点**属性**：\n1. `target-key` **必须**，用于标识元素，也是启用埋点的标志。\n2. `target-events` **非必须**，用于在元素上限制可监控的事件，颗粒度更小，应该是配置项的 `domEventsList` 的子集，在 `domEventsList` 之外的事件不会被监控。若没有该属性，则会监控该元素上所有 `domEventsList` 罗列的事件。\n\n这种策略类似一些日志库，除了在初始化日志类时可以指定要输出的最低日志等级，还可以通过装饰器或者其他方式，控制某个区域输出的最低日志等级。\n\n```html 埋点的例子\n<button id=\"btn\" target-key=\"btn\" target-events=\"['click']\">dom事件上报测试</button>\n```\n\n# ErrorTracker类\n`ErrorTracker` 类用于监控错误信息，包括JS错误、资源加载错误、Promise错误。\n\n**注意：**Promise错误并不是一个真正的错误，而是指未处理的rejected状态的Promise，它会触发 `unhandledrejection` 事件。\n\n```ts src\\core\\tracker\\error.ts\nimport { Options } from \"../../types\";\nimport TrackerCls from \"./trackerCls\";\n\nexport default class ErrorTracker extends TrackerCls {\n\n  constructor(options: Options, reportTracker: Function) {\n    super(options, reportTracker);\n  }\n  // 初始化\n  public init() {\n    if (this.options.errorTracker) {\n      this.errorReport()\n    }\n  }\n  additionalDestroy() { }\n  // 启用错误上报\n  private errorReport() {\n    this.errorEvent()\n    this.promiseReject()\n  }\n  // 监听error事件，并上报相关数据\n  private errorEvent() {\n    const eventName = 'error';\n    // 回调\n    const eventHandler: EventListenerOrEventListenerObject = (e) => {\n      const [info, targetKey] = this.analyzeError(e)\n      this.reportTracker({\n        targetKey: targetKey,\n        event: 'error',\n        info: info\n      }, 'error')\n    }\n    // 错误事件不会冒泡，需在捕获阶段监听\n    this.addEventListener(eventName, eventHandler, true)\n  }\n  // 解析错误信息,区分js错误和资源加载错误,返回错误信息和错误分类\n  private analyzeError(event: Event): [object | string, string] {\n    const target = event.target || event.srcElement;\n    // 如果是dom元素,说明是资源加载错误\n    if (target instanceof HTMLElement) {\n      return [{\n        name: target.tagName || target.localName || target.nodeName,\n        class: target.className || null,\n        id: target.id || null,\n        url: (target as any).src || (target as any).href || null,\n      }, \"resourceError\"]\n    }\n    // 如果event是ErrorEvent类型,说明是js错误\n    if (event instanceof ErrorEvent) {\n      return [event.message, \"jsError\"];\n    }\n    // 兜底返回\n    return [event, \"otherError\"];\n  }\n  // 监控未捕获的Promise Reject，可以认为是Promise错误\n  private promiseReject() {\n    const eventName = 'unhandledrejection';\n    // 回调\n    const eventHandler: EventListenerOrEventListenerObject = (event) => {\n      (event as PromiseRejectionEvent).promise.catch(error => {\n        this.reportTracker({\n          targetKey: \"reject\",\n          event: \"promise\",\n          info: error\n        }, 'error')\n      })\n    }\n    this.addEventListener(eventName, eventHandler)\n  }\n}\n```\n\n**区分js和资源加载错误:**\n1. js和资源加载错误都会触发 `error` 事件，但是 `event` 对象的类型不同。js错误是 `ErrorEvent` 类型，资源加载错误是 `Event` 类型。\n2. 脚本运行错误事件是由 `window` 触发的，而资源加载错误事件是由DOM元素触发的，所以可以通过 `event.target` 判断。\n\n**注意：**error事件是不会冒泡的，所以只能在捕获阶段监听。\n\n## error事件\n除了判断类型，还可以分别监听 `error` 事件来区分js和资源加载错误。\n\n**小知识：**\n1. DOM2级事件规定事件流包括三个阶段，事件捕获阶段、处于目标阶段和事件冒泡阶段。\n2. 触发事件的目标对象，不管事件是否支持冒泡，始终可以监听到该事件的触发。\n\n**捕获阶段：**\nwindow => document => 父级元素 => 目标元素。\n\njs 错误是由 `window` 触发的，始终可以监听到，无需在捕获阶段监听。\n\n而资源加载错误是由DOM元素触发的，想要事件委托，那就只能在捕获阶段监听。所以可以在 `document` 上监听 `error` 事件，捕获资源加载错误。\n\n```js\n// 监听脚本运行错误\nwindow.addEventListener('error', runtimeErrorHandler, false);\n// 监听资源加载错误\ndocument.addEventListener('error', resourceErrorHandler, true);\n```\n\n**发生了什么：**\n1. js错误在`window`上触发，目标元素就是`window`，所以可以在`window`上通过冒泡阶段监听js错误。\n2. 资源加载错误的目标元素是dom元素，在 `document` 上通过捕获阶段监听，就可以委托监听资源加载错误。error事件不会冒泡，所以 `window` 上监听不到该错误。\n\n# PerformanceTracker\n`PerformanceTracker` 类用于监控性能，包括dom性能、资源加载性能。\n\n```ts src\\core\\tracker\\performance.ts\nimport { Options, Resource } from \"../../types\";\nimport TrackerCls from \"./trackerCls\";\nimport {\n  getDomPerformance,\n  getResourcePerformance,\n  listenResourceLoad,\n} from \"../../utils\";\n\nexport default class PerformanceTracker extends TrackerCls {\n  // 保存PerformanceObserver性能监控观察者实例。\n  private performanceObserver: PerformanceObserver | undefined = undefined;\n\n  constructor(options: Options, reportTracker: Function) {\n    super(options, reportTracker);\n  }\n  // 初始化\n  public init() {\n    if (this.options.performanceTracker) {\n      this.performanceReport();\n    }\n  }\n  // 开启性能监控上报\n  private performanceReport(accuracy: number = 2) {\n    const eventName = \"load\";\n    const performance = () => {\n      // 页面加载完后上报dom性能数据\n      const domPerformance = getDomPerformance(accuracy);\n      // 页面加载完后上报已加载完毕的资源性能数据\n      const resourcePerformance = getResourcePerformance(accuracy);\n      // 上报的数据\n      const data = {\n        targetKey: \"performance\",\n        event: \"load\",\n        domPerformance,\n        resourcePerformance,\n      };\n      // 上报数据，类型key为performance\n      this.reportTracker(data, \"performance\");\n\n      // load完后开启资源的持续监控，例如后续请求以及图片的懒加载\n      this.performanceObserver = listenResourceLoad(\n        (entry: PerformanceResourceTiming) => {\n          const resource: Resource = {\n            name: entry.name, // 资源名称，通常为url\n            duration: entry.duration.toFixed(accuracy), // 资源加载耗时\n            type: entry.entryType, // 资源类型\n            initiatorType: entry.initiatorType, // 发起资源请求的类型（标签名、请求方式等）\n            size: entry.decodedBodySize || entry.transferSize, // 资源大小\n          };\n          const data = {\n            targetKey: \"resourceLoad\",\n            event: \"load\",\n            resource,\n          };\n          // 上报数据，类型key为performance\n          this.reportTracker(data, \"performance\");\n        }\n      );\n    };\n    const eventHandler: EventListenerOrEventListenerObject = () => {\n      // 将性能监控函数放到微/宏任务队列中执行，这样就能保证在load事件完成之后执行\n      if (typeof Promise === 'function'){\n        Promise.resolve().then(()=>{\n          setTimeout(performance, 0);\n        });\n      } else {\n        setTimeout(performance, 0);\n      }\n    }\n    // 监听load事件\n    this.addEventListener(eventName, eventHandler);\n  }\n  // 销毁时额外需要销毁的内容\n  additionalDestroy() {\n    // 断开资源监控\n    this.performanceObserver?.disconnect();\n  }\n}\n```\n\n对于window对象的load事件来说，当整个HTML页面的所有依赖资源（JS文件、CSS文件、图片等）加载完成时将会触发。\n\n核心方法 `performanceReport` 监听 `load` 事件，在页面加载完后，通过 `getDomPerformance` 获取dom性能，通过 `getResourcePerformance` 获取已加载完毕的资源性能数据，并上报。然后通过性能监控器 `PerformanceObserver` 监控后续资源的加载。\n\n所以性能监控可以分为两部分：\n1. 页面加载完后的性能上报。\n2. 后续资源的持续监控。\n\n## performance API\n`performance` API 提供了非常多的属性和方法，用于获取页面性能数据。这个 API 的内容非常多，这里也只能讲用到的。\n\n兼容的获取方式，但现在大多已经不需要这么做了。\n\n```ts\nwindow.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance || {}\n```\n\n`performance.getEntries()` 用于获页面中的**所有**的性能数据，返回一个包含各种性能对象的数组。\n1. `PerformanceNavigationTiming` 包含有关页面导航和重定向的时间信息，如 unload、redirect、domInteractive 等。\n2. `PerformanceResourceTiming` 提供了有关页面加载过程中每个资源的时间信息，如加载开始时间、结束时间、传输协议等。\n3. `PerformancePaintTiming` 提供有关页面绘制过程中的重要时间点的信息，例如首次绘制（first-paint）和首次内容绘制（first-contentful-paint）。\n\n我们通常不会想一次性获取这么一大堆东西，所以需要使用 `performance.getEntriesByType(type)` 传入 `entryType` 获取指定的性能对象。返回的都是数组。\n1. `navigation` 返回包含**一个**元素的数组，元素类型为 `PerformanceNavigationTiming`\n2. `paint` 返回包含**两个**元素的数组，元素类型都是 `PerformanceResourceTiming`，其中 `[0]` 为首次绘制（first-paint），`[1]` 为首次内容绘制（first-contentful-paint）。\n3. `resource` 返回当前**已加载完**的资源的性能信息数组，元素类型为 `PerformanceResourceTiming`，每个元素都代表一个资源。\n\n**参考：**\n[前端性能精进之优化方法论（一）——测量](https://heapdump.cn/article/5401439)\n[前端性能监控指标](https://fecommunity.github.io/front-end-interview/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.performance%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7.html)\n[前端性能指标浅析](https://juejin.cn/post/7078875439950725128)\n[前端性能指标](https://zhuanlan.zhihu.com/p/584767348)\n[性能监控指标分析](https://juejin.cn/post/6844904112450994189)\n[使用 Performance API 获取页面性能](https://juejin.cn/post/6973567030528065573)\n[Navigation Timing API 入门](https://juejin.cn/post/6844904182202253325)\n[PerformanceObserver前端性能测量方法](https://juejin.cn/post/7268663683881025597)\n[首屏事件计算方式](https://juejin.cn/post/7140171382742548511)\n[你只会用前端数据埋点 SDK 吗？](https://juejin.cn/post/7163046672874864676)\n\n### 导航计时\n导航计时（Navigation Timing） API 是 Web 性能 API 的起点。\n\n**功能：**用于记录并检测用户的设备，网络等环境，以及页面初始资源加载和解析耗时。\n\n在以前通过 `performance.navigation` 和 `performance.timing` 获取，但现在通常使用 `performance.getEntriesByType('navigation')` 获取。\n\n`PerformanceNavigationTiming` 有着更全面的导航信息，且精度更高，包括重定向、卸载、重定向、DNS查询、TCP连接、SSL握手、请求、响应等时间。\n\n```txt PerformanceNavigationTiming 属性\n(1) navigationStart\nnavigationStart 表示同一个浏览器上下文中，上一个文档卸载结束的 UNIX 时间戳。如果没有上一个文档，这个值与 fetchStart 相同。\n\n(2) unloadEventStart\nunloadEventStart 表示 unload 事件抛出时的 UNIX 时间戳。如果没有上一个文档，或者重定向中的一个与当前文档不同源，该值为 0。\n\n(3) unloadEventEnd\nunloadEventEnd 表示 unload 事件处理完成时的 UNIX 时间戳。如果没有上一个文档，或者重定向中的一个与当前文档不同源，该值为 0。\n\n(4) redirectStart\nredirectStart 表示第一个 HTTP 重定向开始时的 UNIX 时间戳。如果没有重定向，或者重定向中的一个不同源，该值为 0。\n\n(5) redirectEnd\nredirectEnd 表示最后一个 HTTP 重定向完成时（即最后一个 HTTP 响应的最后一个比特被接收到的时间）的 UNIT 时间戳。如果额米有重定向，或者重定向中的一个不同源，该值为 0。\n\n(6) fetchStart\nfetchStart 表示浏览器准备好用 HTTP 请求来获取文档的 UNIX 时间戳。这个时间早于检查应用缓存。\n\n(7) domainLookupStart\ndomainLookupStart 表示域名查询开始的 UNIX 时间戳。如果使用了持续连接，或者这个信息被存储到了缓存或本地资源，那么该值与 fetchStart 相同。\n\n(8) domainLookupEnd\ndomainLookupEnd 表示域名查询结束的 UNIX 时间戳。如果使用了持续连接，或者这个信息被存储到了缓存或本地资源，那么该值与 fetchStart 相同。\n\n(9) connectStart\nconnectStart 表示 HTTP 请求开始向服务器发送时的 UNIX 时间戳。如果使用持久连接，则该值与 fetchStart 相同。\n\n(10) connectEnd\nconnectEnd 表示浏览器与服务器之间的连接建立（即握手与认证等过程全部结束）的 UNIX 时间戳。如果使用持久连接，则该值与 fetchStart 相同。\n\n(11) secureConnectionStart\nsecureConnectionStart 表示浏览器与服务器开始安全链接的握手时的 UNIX 时间戳。如果当前网页不要求安全链接，该值为 0。\n\n(12) requestStart\nrequestStart 表示浏览器向服务器发送 HTTP 请求时的 UNIX 时间戳。\n\n(13) responseStart\nresponseStart 表示浏览器从服务器收到（或从本地缓存读取）第一个字节时的 UNIX 时间戳。如果传输层从开始请求后失败并连接被重开，该值会被重置为新的请求的相应的时间。\n\n(14) responseEnd\nresponseEnd 表示浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭的时间）的 UNIX 时间戳。\n\n(15) domLoading\nPerformance.domLoading 表示当前网页 DOM 结构开始解析时（即 Document.readyState 属性变为 loading，相应的 readystatechange 事件触发时）的 UNIX 时间戳。\n\n(16) domInteractive\nPerformance.domInteractive 表示当前网页 DOM 结构解析结束，开始加载内嵌资源时（即 Document.readyState 的属性为 interactive，相应的 readystatechange 事件触发时）的 UNIX 时间戳。\n\n(17) domContentLoadedEventStart\ndomContentLoadedEventStart 表示解析器触发 DomContentLoaded 事件，即所有需要被执行的脚本已经被解析时的 UNIX 时间戳。\n\n(18) domContentLoadedEventEnd\ndomContentLoadedEventEnd 表示所有需要被执行的脚本均已被执行完成时的 UNIX 时间戳。\n\n(19) domComplete\ndomComplete 表示文档解析完成，即 Document.readyState 变为 complete 且相应的 readystatechange 事件被触发时的 UNIX 时间戳。\n\n(20) loadEventStart\nloadEventStart 表示该文档下，load 事件被触发的 UNIX 时间戳。如果还未发送，值为 0。\n\n(21) loadEventEnd\nloadEventEnd 表示该文档下，load 事件结束，即加载事件完成时的 UNIX 时间戳，如果事件未触发或未完成，值为 0。\n```\n\n## 性能指标\n常见的前端性能指标：\n1. **FP**(First paint) **首屏绘制**，常被用来衡量白屏时间。\n2. **FCP**(First Contentful Paint) **首屏内容绘制**，页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。\n3. **LCP**(Largest Contentful Paint) **最大内容绘制**，页面首次开始加载的时间点来报告可视区域内可见的最大图像或者文本块完成渲染的相对时间。\n4. **FID**(First Input Delay) **首次输入延迟时间**，从用户第一次与页面交互，到浏览器对交互作出响应，并实际能够开始处理事件所经过的时间。\n5. **TTI**(Time to Interactive) **首次可交互时间**，页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。\n6. **CLS**(Cumulative Layout Shift) **累计位移偏移**，计算页面的视觉稳定性，即页面整个生命周期中所有发生的预料之外的布局偏移的得分的总和。每当一个可视元素位置发生改变，就是发生了布局偏移。\n7. **TTFB**(Time to First Byte) **首字节时间**，从发起请求到服务器响应后收到的第一个字节的时间差，用于衡量服务器处理能力和网络的延迟。\n\n## getDomPerformance\n`getDomPerformance` 方法用于获取页面加载完后的dom性能数据。\n\n通过 `PerformanceNavigationTiming` 和 `PerformancePaintTiming` 的属性，计算各种性能指标。\n\n```ts\n// 获取dom加载性能指标\nexport function getDomPerformance(accuracy: number = 2): object | null {\n  // 获取导航计时\n  const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming || performance.timing;\n  // 获取首次渲染计时\n  const firstPaintTiming = performance.getEntriesByType('paint')[0];\n  // 获取首次内容渲染计时\n  const firstContentfulPaintTiming = performance.getEntriesByType('paint')[1];\n  console.log(firstContentfulPaintTiming, firstPaintTiming)\n  if (!navigationTiming) return null;\n  // 浏览器与服务器开始SSL安全链接的握手时间\n  const sslTime = navigationTiming.secureConnectionStart;\n  return {\n    // 页面加载开始时间\n    startTime: navigationTiming.startTime.toFixed(accuracy),\n    // 页面加载总耗时\n    duration: (navigationTiming.duration).toFixed(accuracy),\n    // DNS查询耗时\n    DNS: (navigationTiming.domainLookupEnd - navigationTiming.domainLookupStart).toFixed(accuracy),\n    // TCP连接耗时\n    TCP: (navigationTiming.connectEnd - navigationTiming.connectStart).toFixed(accuracy),\n    // SSL连接耗时\n    SSL: (sslTime > 0 ? navigationTiming.connectEnd - sslTime : 0).toFixed(accuracy),\n    // 首字节时间，即服务器响应时间\n    TTFB: (navigationTiming.responseStart - navigationTiming.requestStart).toFixed(accuracy),\n    // 白屏时间，首屏绘制\n    FP: (firstPaintTiming ? firstPaintTiming.startTime - navigationTiming.fetchStart : navigationTiming.responseEnd - navigationTiming.fetchStart).toFixed(accuracy),\n    // 首次内容渲染时间\n    FCP: (firstContentfulPaintTiming ? firstContentfulPaintTiming.startTime - navigationTiming.fetchStart : 0).toFixed(accuracy),\n    // 首次可交互时间\n    TTI: (navigationTiming.domInteractive - navigationTiming.startTime).toFixed(accuracy),\n    // 页面重定向耗时\n    redirect: (navigationTiming.redirectEnd - navigationTiming.redirectStart).toFixed(accuracy),\n    // 重定向次数\n    redirectCount: navigationTiming.redirectCount,\n    // 前一个页面卸载耗时\n    unload: (navigationTiming.unloadEventEnd - navigationTiming.unloadEventStart).toFixed(accuracy),\n    // HTML 加载完成时间\n    ready: (navigationTiming.domContentLoadedEventEnd - navigationTiming.startTime).toFixed(accuracy),\n    // 页面加载总耗时，此时触发完成了onload事件\n    load: (navigationTiming.loadEventEnd - navigationTiming.startTime).toFixed(accuracy),\n    // DOM解析耗时，页面请求完成后，到整个DOM解析完所用的时间\n    dom: (navigationTiming.domContentLoadedEventEnd - navigationTiming.responseEnd).toFixed(accuracy),\n    // html文档完全解析完毕的时间节点\n    domComplete: navigationTiming.domComplete.toFixed(accuracy),\n    // 资源加载耗时\n    resource: (navigationTiming.domComplete - navigationTiming.domInteractive).toFixed(accuracy),\n    // HTML加载完时间，指页面所有 HTML 加载完成（不包括页面渲染时间）\n    htmlLoad: (navigationTiming.responseEnd - navigationTiming.startTime).toFixed(accuracy),\n    // DOMContentLoaded 事件耗时\n    DCL: (navigationTiming.domContentLoadedEventEnd - navigationTiming.domContentLoadedEventStart).toFixed(accuracy),\n    // onload事件耗时\n    onload: (navigationTiming.loadEventEnd - navigationTiming.loadEventStart).toFixed(accuracy),\n  }\n}\n```\n\n## getResourcePerformance\n`getResourcePerformance` 用于获取首屏已经加载完毕的资源的性能信息。\n\n通过 `PerformanceResourceTiming` 数组，遍历每个资源的性能信息，分类并计算各种性能指标。\n\n```ts\n// 获取首屏已经加载完毕的资源的性能信息\nexport function getResourcePerformance(accuracy: number = 2): InitiatorTypeLiteral | null {\n  if (!window.performance) return null;\n  // 获取 PerformanceResourceTiming 数组\n  const data = window.performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n  // 保存资源分类\n  const resources: InitiatorTypeLiteral = {}\n  data.forEach(i => {\n    let key = i.initiatorType || 'other';\n    if (key === 'beacon') return; // 跳过beacon上报请求\n    if (key === 'other') {\n      const extension = urlHandle(i.name, 2)\n      switch (extension) {\n        case 'css': key = 'css'; break;\n        case 'js': key = 'js'; break;\n        case 'json': key = 'json'; break;\n        case 'png': case 'jpg': case 'jpeg': case 'gif': case 'svg': key = 'img'; break;\n        default: break;\n      }\n    }\n    !resources.hasOwnProperty(key) && (resources[key] = [])\n    resources[key].push({\n      name: i.name, // 资源的名称\n      duration: i.duration.toFixed(accuracy), // 资源加载耗时\n      type: i.entryType, // 资源类型\n      initiatorType: i.initiatorType, // 发起资源请求的类型（标签名）\n      size: i.decodedBodySize || i.transferSize, // 资源大小\n    })\n  })\n  return resources;\n}\n// 获取url中需要的数据  type  1: 获取文件名  2：获取后缀  3：获取文件名+后缀  4:获取文件前缀\nfunction urlHandle(url: string, type: number): string | undefined {\n  let filename = url.substring(url.lastIndexOf('/') + 1)\n  switch (type) {\n    case 1: return filename; break;\n    case 2: return filename.substring(filename.lastIndexOf(\".\") + 1); break;\n    case 3: return filename.substring(0, filename.lastIndexOf(\".\")); break;\n    case 4: return url.substring(0, url.lastIndexOf('/') + 1); break;\n    default: return undefined;\n  }\n}\n```\n\n**注意：**若涉及跨域，并且其响应头没有声明 `timing-allow-origin`，那么 `PerformanceResourceTiming` 中的大部分属性可能都是 0。\n可以将 timing-allow-origin 设为星号，或指定域名。\n\n```json\nTiming-Allow-Origin: *\n```\n\n## listenResourceLoad\n`listenResourceLoad` 方法用于监听**后续资源**的加载情况。\n\n通过 `PerformanceObserver` 监控资源加载，当资源加载完毕后，上报资源性能数据。\n\n```ts\n// 监听资源加载\nexport function listenResourceLoad(callback: (arg0: PerformanceResourceTiming) => void): PerformanceObserver {\n  // 创建一个PerformanceObserver性能观察者实例\n  const observer = new PerformanceObserver((list, _observer) => {\n    // 因为只观察了resource，可以将 PerformanceEntryList 作为 PerformanceResourceTiming[] 类型进行遍历\n    (list.getEntries() as PerformanceResourceTiming[]).forEach((e) => {\n      // 如果不是beacon请求，就执行回调\n      if (e.initiatorType !== \"beacon\") {\n        callback(e);\n      }\n    });\n  });\n  // 开始观察entryTypes为resource的性能条目，也就是资源加载性能\n  observer.observe({\n    entryTypes: [\"resource\"],\n  });\n  // 返回观察者实例\n  return observer;\n}\n```\n\n# 其它\n项目中一些其它的内容。\n\n## canvas指纹\n[fingerprint](https://github.com/fingerprintjs/fingerprintjs) 等浏览器指纹识别库太大了，监控项目应该尽量减少第三方依赖，而为了标识用户，canvas 指纹是不错的选择。\n\n不同设备、不同浏览器、不同版本，canvas 生成的图像数据都不同，获取其 Base64 编码的图像数据，然后生成8位hash值，就可以作为浏览器指纹ID。\n\n```ts src\\utils\\uuid.ts\n// 字符串生成8位hash值\nfunction generateHash(str: string): string {\n  // 使用 atob 函数将 Base64 编码的图像数据解码为二进制字符串。\n  str = atob(str);\n  let hash = 0;\n  // 遍历字符串\n  for (let i = 0; i < str.length; i++) {\n    // charCodeAt() 方法可返回指定位置的字符的 Unicode 编码\n    // << 5 位运算符，将二进制数据后向左移动5位，相当于乘以2的5次方\n    // 目的是提高 hash 的复杂度\n    hash = (hash << 5) - hash + str.charCodeAt(i);\n    // 当JS进行位运算时，它会将操作数视为 32 位整数，忽略其它位。\n    hash |= 0; // 位运算符，将 hash 强制转换为 32 位整数\n  }\n  // 一个32位整数的十六进制位8位，所以就生成了一个8位的hash值\n  return Math.abs(hash).toString(16).padStart(8, '0');\n}\n\n// 通过canvas获取浏览器指纹ID\nexport function getCanvasID(str: string = '#qx.chuckle,123456789<canvas>'): string | undefined {\n  const canvas = document.createElement('canvas'); // 创建一个 canvas 元素\n  const ctx = canvas.getContext(\"2d\"); // 获取 canvas 的 2D 渲染上下文\n  if (!ctx) {\n    return undefined;\n  }\n  ctx.font = \"14px 'Arial'\"; // 设置字体\n  ctx.textBaseline = \"bottom\"; // 设置基线\n  ctx.fillStyle = \"#f60\"; // 设置填充颜色\n  // 在 canvas 上绘制一个橙色的矩形，矩形的左上角坐标为 (125, 1)，宽度为 62 像素，高度为 20 像素。\n  ctx.fillRect(125, 1, 62, 20);\n  ctx.fillStyle = \"#069\"; // 设置填充颜色\n  // 在坐标 (2, 15) 的位置绘制深蓝色的文本，文本内容为 str。\n  ctx.fillText(str, 2, 15);\n  ctx.fillStyle = \"rgba(102, 204, 0, 0.7)\"; // 设置填充颜色\n  // 在坐标 (4, 17) 的位置绘制半透明绿色的文本，文本内容为 str。\n  ctx.fillText(str, 4, 17);\n  // toDataURL将canvas转换为dataUrl也就是base64编码的图像数据，并去掉前缀保留数据部分\n  const b64 = canvas.toDataURL().replace(\"data:image/png;base64,\", \"\");\n  return generateHash(b64);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["TS"],"categories":["项目"]},{"title":"Node-回眸[三]","url":"/article/9b01fd71.html","content":"\n# http\n[http](https://nodejs.cn/api/http.html) 模块用于创建HTTP服务器或客户端。\n\n`createServer()`方法创建一个HTTP服务器，该方法返回http.Server实例。\n`http.request()`和`http.get()`用于创建HTTP客户端，返回http.ClientRequest实例。\n\n```js 创建HTTP服务器\nconst server = http.createServer()\n\nserver.on('request', (req, res) => {\n  if(req.method === 'GET'){\n    res.write('GET:')\n    res.end('hello world')\n  }else if(req.method === 'POST'){\n    req.on('data', (chunk) => {\n      console.log(chunk.toString());\n    })\n    res.write('POST:')\n    res.end('hello world')\n  }\n})\n\nserver.listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n});\n```\n\n```js 创建HTTP客户端\nhttp.get('http://localhost:8888', (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  })\n  res.on('end', () => {\n    console.log(data.toString()); // GET:hello world\n    console.log('已获取完毕');\n  })\n})\n\nconst req = http.request({\n  host: 'localhost',\n  port: 8888,\n  path: '/',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n}, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  })\n  res.on('end', () => {\n    console.log(data.toString()); // POST:hello world\n    console.log('已获取完毕');\n  })\n})\nreq.write(JSON.stringify({\"name\": \"tom\"}));\nreq.end(); // 结束请求\n```\n\n更多基本用法，之前已经记录过了：[初识NodeJS--http模块](/article/109cbe0a.html#http模块)\n\n## 反向代理\n**直接访问**：浏览器直接请求最终提供资源的服务器，中间没有经过任何的 http 代理服务器。\n**正向代理(forward proxy)**：代理的对象是客户端，代理服务器代替客户端（浏览器）去访问目标服务器，获取资源返回，并不直接面向最终提供资源的服务器。代理服务器可以对外隐藏客户端细节，代理服务器会对外屏蔽掉客户端信息。通常需要客户端主动配置代理服务器的信息。\n**反向代理(reverse proxy)**：代理的对象是服务端，客户端（浏览器）不需要任何配置。反向代理服务器代替服务端（服务器）接收请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给客户端，此时反向代理服务器和普通的服务器对外就是一个服务器，客户端不需要知道内部网络的信息。也称为**透明代理**。\n\n**反向代理作用：**\n1. **保证内网的安全：**防止外部网络直接访问内网\n2. **负载均衡：**将请求分发到多个后端服务器上，避免某个服务器过载，提高整体性能和可用性\n3. **缓存和性能优化：**将请求的结果和静态资源缓存起来，减少对服务器的请求，还可以资源进行压缩、合并、优化等操作\n4. **高可用：**当某个服务器出现故障时，可以自动将请求转发到其他服务器上\n5. **域名和路径重写：**将请求的域名和路径重写，转发到其他服务器上，提高了灵活性和可维护性\n\n通过http模块可以直接实现反代，但通常用第三方库，例如：[http-proxy-middleware](https://www.npmjs.com/package/http-proxy-middleware)\n\n先写好一个简单的后端服务器：\n\n```js server.js\nhttp.createServer((req, res) => {\n  res.end('101010101')\n}).listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n})\n```\n\n写好反代规则：\n\n```js config.js\nmodule.exports = {\n  server: {\n    proxy: {\n      //代理的路径\n      '/api': {\n        target: 'http://localhost:8888', //转发的地址\n        changeOrigin: true, //是否有跨域\n      }\n    }\n  }\n}\n```\n\n再配置反向代理服务器：\n\n```js proxy.js\nconst http = require('http')\nconst { createProxyMiddleware } = require('http-proxy-middleware')\nconst url = require('url')\n\nconst config = require('./config')\nconst proxyList = config.server.proxy\n\nhttp.createServer((req, res) => {\n  const pathname = url.parse(req.url).pathname;\n  // 判断是否需要代理\n  if (Object.keys(proxyList).includes(pathname)) {\n    // 创建代理对象并转发请求\n    const proxy = createProxyMiddleware(config.server.proxy[pathname]);\n    proxy(req, res);\n    return;\n  }\n  res.end('hello world')\n}).listen(80, () => {\n  console.log('Server is running on http://localhost:80');\n})\n```\n\n结果：\n\n```txt\n[HPM] Proxy created: /  -> http://localhost:8888\n请求 http://localhost/ 返回 hello world\n请求 http://localhost/api 返回 101010101\n```\n\n## 动静分离\n动静分离是指将动态资源和静态资源分开处理和分发，以提高服务器的性能和安全性。\n\n**动态资源：**指每次请求时动态生成的资源，例如：API接口、动态页面等。\n**静态资源：**指长时间不会变化的资源，例如：html、css、js、图片、视频、音频等。\n\n静态资源通常使用GET请求获取，[mime](https://www.npmjs.com/package/mime)模块可以根据文件后缀名获取MIME类型。\n\n```js\nimport http from 'http';\nimport fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport mime from 'mime';\n\nconst __filename = url.fileURLToPath(import.meta.url)\nconst __dirname = path.dirname(__filename)\n\nhttp.createServer((req, res) => {\n  const { pathname } = url.parse(req.url, true);\n  if (req.method === 'GET') {\n\n    // 请求静态资源目录\n    if (req.url.startsWith(\"/public\")) {\n      const filePath = path.normalize(__dirname + pathname);\n      console.log(filePath)\n      if (!fs.existsSync(filePath)) {\n        res.statusCode = 404;\n        res.end('404');\n        return;\n      }\n      res.writeHead(200, {\n        // 根据资源类型设置MIME类型\n        'Content-Type': mime.getType(pathname)\n      })\n      return fs.createReadStream(filePath).pipe(res);\n      \n    } else {\n      return res.end('GET:hello world')\n    }\n  } else if (req.method === 'POST') {\n    return res.end('POST:hello world')\n  }\n  res.statusCode = 404;\n  return res.end('404');\n}).listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n})\n```\n\n常见MIME类型:\n\n```txt\n-   文本文件：\n  -   text/plain：纯文本文件\n  -   text/html：HTML 文件\n  -   text/css：CSS 样式表文件\n  -   text/javascript：JavaScript 文件\n  -   application/json：JSON 数据\n\n-   图像文件：\n  -   image/jpeg：JPEG 图像\n  -   image/png：PNG 图像\n  -   image/gif：GIF 图像\n  -   image/svg+xml：SVG 图像\n\n-   音频文件：\n  -   audio/mpeg：MPEG 音频\n  -   audio/wav：WAV 音频\n  -   audio/midi：MIDI 音频\n\n-   视频文件：\n  -   video/mp4：MP4 视频\n  -   video/mpeg：MPEG 视频\n  -   video/quicktime：QuickTime 视频\n\n-   应用程序文件：\n  -   application/pdf：PDF 文件\n  -   application/zip：ZIP 压缩文件\n  -   application/x-www-form-urlencoded：表单提交数据\n  -   multipart/form-data：多部分表单数据\n```\n\n\n## 邮件服务\n[nodemailer](https://www.npmjs.com/package/nodemailer)是一个简单易用的NodeJS邮件发送库。[文档](https://nodemailer.com/about/)\n\n[QQ邮件服务文档](https://wx.mail.qq.com/list/readtemplate?name=app_intro.html#/agreement/authorizationCode)，需开启POP3/SMTP，并生成授权码。\n\n`createTransport()` 创建邮件传输器对象，`transport.sendMail()` 发送邮件。\n\n```js\nimport nodemailer from 'nodemailer'\nimport http from 'http'\nimport url from 'url'\nimport email from './email.json' assert { type: \"json\" }\n\nconst transport = nodemailer.createTransport({\n  service: \"qq\", // 邮箱服务商\n  port: 587, // SMTP 端口\n  host: 'smtp.qq.com', // QQ邮箱的SMTP地址\n  secure: true, // 当设置为 true 时，表示使用安全连接（Secure Connection），\n  // 通常是通过 TLS 或 SSL 协议来加密邮件传输。\n  auth: {\n    user: email.user, // 邮箱账号\n    pass: email.pass // 邮箱授权码 | 密码\n  }\n})\n\nhttp.createServer((req, res) => {\n  const { pathname } = url.parse(req.url, true);\n  if (req.method === 'POST' && pathname === '/email') {\n    let data = '';\n    req.on('data', (chunk) => {\n      data += chunk.toString();\n    })\n    req.on('end', () => {\n      const { to, subject, text } = JSON.parse(data);\n      transport.sendMail({\n        from: email.user,\n        to,\n        subject,\n        text\n      }).then(() => {\n        res.end('发送成功')\n      }).catch((err) => {\n        res.end('发送失败')\n      })\n    })\n    res.end('hello world')\n  } else {\n    res.statusCode = 404;\n    res.end('404');\n  }\n}).listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n})\n```\n\n# express\n> 使用http模块写服务端太麻烦了，所以有了express等 web 应用框架。\n\n[express](https://expressjs.com/)是一个最小且灵活的 Node.js Web 应用程序框架，提供了路由、中间件等功能，支持模板引擎。\n\n基本用法之前已经记录过了：[Express框架](/article/8ddaf637.html)\n\n```js 快速回顾\nimport express from 'express'\nimport path from 'path'\nimport url from 'url'\n\nconst __filename = url.fileURLToPath(import.meta.url)\nconst __dirname = path.dirname(__filename)\n\n// 创建一个 express 实例\nconst app = express()\n\n// get 请求接口\napp.get('/txt', (req, res) => {\n  //express兼容http原生操作\n  console.log(req.method);//请求方法\n  console.log(req.url);//请求url\n  console.log(req.httpVersion);//http版本\n  console.log(req.headers);//请求头\n  //express封装方法\n  console.log(req.path);//请求路径\n  console.log(req.query);//查询字符串\n  console.log(req.ip);//用户ip\n  console.log(req.get('host'));//获取特定请求头的属性值\n  // 响应文本\n  res.send('hello get')\n})\n\n// 路由参数\napp.get('/user/:id', (req, res) => {\n  console.log(req.params.id)\n  res.send(req.params.id)\n})\n\n// 设置静态资源目录，会自动添加Mime类型\napp.use(express.static(path.resolve(__dirname, 'public')))\n// 一般用路由响应动态资源，如搜索结果等，用静态资源中间件响应静态资源，如html、css等\n\n// 解析请求体需要使用中间件\napp.use(express.json()) // 解析 json 格式的请求体\napp.use(express.urlencoded({ extended: true })) // 解析表单格式的请求体\n\n// post 请求接口\napp.post('/login', (req, res) => {\n  console.log(req.body)\n  res.send('hello post')\n})\n\n// 创建中间件，本质上是一个回调函数\nconst logger = (req, res, next) => {\n  console.log('logger')\n  next()\n}\n\n// 创建路由，每个路由都相当于一个小的 express 实例\nconst router = express.Router();\n\n// 使用中间件\nrouter.get('/list', logger, (req, res) => {\n  // 响应 json 数据\n  res.json({\n    code: 0,\n    msg: 'ok',\n    data: [1, 2, 3]\n  })\n})\n\n// 使用路由，指定路由前缀\napp.use('/api', router)\n\n// 监听端口，启动服务\napp.listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n})\n```\n\n# log4js\nnode服务端常用的日志收集工具：[winston](https://www.npmjs.com/package/winston)、[log4js](https://www.npmjs.com/package/log4js)、[bunyan](https://www.npmjs.com/package/bunyan)、[npmlog](https://www.npmjs.com/package/npmlog)等\n\n[log4js](https://www.npmjs.com/package/log4js) 较为灵活、配置多样但轻量，可以将日志输出到文件、控制台、邮件等。[文档](https://log4js-node.github.io/log4js-node/)\n\n`log4js.configure()` 配置日志记录器、分类，`log4js.getLogger()` 获取指定分类的日志记录器。\n\n```js\nimport express from 'express'\nimport log4js from 'log4js'\n\n// 配置日志记录器\nlog4js.configure({\n  appenders: {\n    // 控制台输出\n    out: {\n      type: \"stdout\",\n      layout: {\n        type: \"colored\"\n      }\n    },\n    // 日志文件\n    file: {\n      type: \"file\",\n      // 日志文件路径\n      filename: \"server.log\"\n    }\n  },\n  // 日志分类\n  categories: {\n    // 默认分类\n    default: {\n      // 输出方式：控制台、日志文件\n      appenders: [\"out\", \"file\"],\n      // 只有日志等级大于或等于当前配置的日志等级时，才会输出\n      level: \"debug\"\n    }\n  },\n});\n// 获取default分类的日志记录器\nconst logger = log4js.getLogger(\"default\")\n\nconst app = express()\n\nconst LoggerMiddleware = (req, res, next) => {\n  logger.debug(`[${req.method}] ${req.url}`)\n  // [2024-01-19T22:11:10.053] [DEBUG] default - [GET] /\n  next()\n}\n\n// 全局使用中间件\napp.use(LoggerMiddleware)\n\napp.get('*', (req, res) => {\n  res.send('hello world')\n})\n\napp.listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n})\n```\n\n## 日志分级Level\n日志分级可以将不同级别的日志在控制台中采用不同的颜色，也可以帮助在生产时有选择地生成不同级别的日志。\n\nlog4js默认的日志分级有9级，也可以自定义级别。\n\n```js 默认日志级别，value为优先级，从低到高\nLevel.addLevels({\n  ALL: { value: Number.MIN_VALUE, colour: 'grey' },\n  TRACE: { value: 5000, colour: 'blue' },\n  DEBUG: { value: 10000, colour: 'cyan' },\n  INFO: { value: 20000, colour: 'green' },\n  WARN: { value: 30000, colour: 'yellow' },\n  ERROR: { value: 40000, colour: 'red' },\n  FATAL: { value: 50000, colour: 'magenta' },\n  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53\n  OFF: { value: Number.MAX_VALUE, colour: 'grey' },\n});\n```\n\n在`categories.default.level`中配置日志等级，只会输出级别相等或更高级别的日志。\n\nALL OFF 这两个等级并不会直接在业务代码中使用。其它级别分别对应 Logger 实例的七个方法。在调用这些方法的时候，就相当于为这些日志定了级。\n\n1. `logger.trace()` 详细信息\n2. `logger.debug()` 调试信息\n3. `logger.info()` 一般信息\n4. `logger.warn()` 警告信息\n5. `logger.error()` 错误信息\n6. `logger.fatal()` 致命信息\n7. `logger.mark()` 标记信息\n\n**自定义级别：**\nlevels属性用于定义自定义日志级别，或重新定义现有日志级别\n\n```js\nlog4js.configure({\n  levels: {\n    custom: {\n      value: 10000, // 数值越大优先级越高\n      colour: \"blue\", // 代表的颜色\n    }\n  },\n});\n```\n\n## 日志分类Category\n除了日志分级，还可以对日志进行分类[Category](https://log4js-node.github.io/log4js-node/categories.html)，两个维度对日志进行区分。\n\n`log4js.configure(config)` 传入配置对象，用于配置日志记录器、分类、输出方式等。config下有两个属性：\n1. **appenders**：用于配置日志输出方式，可以配置多个输出方式，例如：控制台、日志文件、邮件等。\n2. **categories**：用于配置日志分类，每个分类可以设置多个appender，也可以配置日志等级。\n\n`log4js.getLogger(category)`获取指定分类的日志记录器。\n1. 若不传入，则会使用default分类配置。\n2. 若传入不存在的分类名，也使用default，但输出时仍然是传入的分类名。\n\n```js 配置分类\n\nlog4js.configure({\n  appenders: {\n    console: {\n      type: \"console\",\n    },\n    out: {\n      type: \"stdout\",\n    },\n    err: {\n      type: \"stderr\",\n    },\n  },\n  categories: {\n    // 必须配置名为default的分类，否则会报错\n    default: {\n      // 该分类使用的输出方式\n      appenders: [\"console\"],\n      // 只有日志等级大于或等于当前配置的日志等级时，才会输出\n      // 可输出的等级：debug、info、warn、error、fatal、mark\n      level: \"debug\", // 不区分大小写\n    },\n    access: {\n      appenders: [\"out\"],\n      level: \"info\",\n    },\n    error: {\n      appenders: [\"err\"],\n      level: \"error\",\n      // 输出调用栈信息，默认为false\n      enableCallStack: true,\n    },\n  }\n})\n```\n\n```js 使用\n// 获取default日志记录器\nconst defaultLogger = log4js.getLogger() // 不指定分类，默认为default\ndefaultLogger.debug(\"Time:\", new Date());\n// 蓝色 [2024-01-20T12:00:11.508] [DEBUG] default - Time: 2024-01-20T04:00:11.507Z\n\n// 指定不存在的分类，会使用default分类，但输出时会保留传入的分类名\nconst otherLogger = log4js.getLogger(\"other\")\notherLogger.debug(\"Time:\", new Date());\n// [2024-01-20T12:02:43.564] [DEBUG] other - Time: 2024-01-20T04:02:43.564Z\n\n// 获取access日志记录器\nconst accessLogger = log4js.getLogger(\"access\")\naccessLogger.debug(\"Time:\", new Date()); // 不会输出，因为debug等级低于info\naccessLogger.info(\"Time:\", new Date());\n// 绿色 [2024-01-20T12:01:09.590] [INFO] access - Time: 2024-01-20T04:01:09.590Z\n\n// 获取error日志记录器\nconst errorLogger = log4js.getLogger(\"error\")\nerrorLogger.error(\"Time:\", new Error(\"error\"));\n// 红色 [2024-01-20T12:01:52.282] [ERROR] error - Time: 2024-01-20T04:01:52.282Z\n// at file:///c:/chuckle/qx/NodeJS-new/express/%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB.mjs:53:28\n// at ModuleJob.run (node:internal/modules/esm/module_job:218:25)\n// at async ModuleLoader.import (node:internal/modules/esm/loader:329:24)\n// at async loadESM (node:internal/process/esm_loader:28:7)\n// at async handleMainPromise (node:internal/modules/run_main:113:12)\n```\n\n## 日志落盘Appender\n[Appender](https://log4js-node.github.io/log4js-node/appenders.html)用于配置日志输出方式\n\n**默认Appenders：**若不进行任何配置，日志将输出到标准输出，但也定义了默认日志级别OFF，这意味着实际上不会输出任何日志。\n\n**自定义Appenders：**传入一个对象，key为Appender名，value为Appender配置。\n\n常用的Appender.type:\n1. `console`：通过V8的console输出到控制台\n2. `stdout`：通过标准输出到控制台\n3. `stderr`：通过标准错误输出到控制台\n4. `file`：输出为指定日志文件\n5. `dateFile`：按照特定日期滚动生成多个日志文件\n6. `multiFile` 动态配置不同category下或者不同变量控制下，落盘到不同文件\n7. `smtp` 将日志输出到邮件\n\n```js\nlog4js.configure({\n  // 配置多个日志输出方式\n  appenders: {\n    out: { // Appender名\n      // 控制台输出\n      type: \"stdout\", // console | stdout | stderr\n      // 通过 layout 可以自定义日志输出的格式\n      // 所有appender都可以配置 layout\n      layout: {\n        type: \"colored\" // 给日志加上颜色，默认使用\n        // basic [默认] 在日志的内容前面会加上时间、日志的级别和类别\n        // messagePassThrough 仅格式化日志事件数据，不输出时间戳、级别或类别\n        // colored 在 basic 的基础上给日志加上颜色\n        // pattern 自定义格式化字符串，使用 %r 替换日志级别，%p 替换日志类别，%c 替换日志内容等\n      }\n    },\n    file: {\n      // 输出为日志文件\n      type: \"file\",\n      // 日志文件路径，相对于当前工作区\n      filename: \"server.log\",\n      // 单个日志文件最大大小，单位字节，如果未指定或为 0，则不会发生日志滚动。\n      maxLogSize: 1024 * 1024 * 10, // 10MB，默认为未定义\n      // 日志滚动期间要保留的旧日志文件的数量\n      backups: 3, // 默认为 5\n      /* 下面还有一些流的配置 */\n      // 文件编码\n      encoding: \"utf-8\", // 默认为 \"utf-8\"\n      // 使用 gzip 压缩备份文件（备份文件将具有.gz扩展名）\n      compress: true, // 默认为 false\n      // 滚动日志文件时保留文件扩展名\n      // file.log变为file.1.log而不是file.log.1\n      keepFileExt: true, // 默认为 false\n      // 滚动时的文件名分隔符\n      fileNameSep: \"-\", // 设置为file-1.log，默认为\".\"\n      // 从 log4js 版本 4.x 开始，file也可以采用dateFile的任何选项。因此可以同时按日期和大小滚动文件。\n    },\n    date: {\n      type: \"dateFile\",\n      filename: \"app.log\",\n      // 用于确定何时滚动日志的模式，同时也是日志文件名的一部分\n      pattern: \"yyyy-MM-dd\", // 默认为yyyy-MM-dd\n      /* 还有一些流的配置，和file差不多 */\n    },\n    multi: {\n      type: \"multiFile\", // 分割日志，多文件输出\n      base: \"logs/\", // 日志文件的基本路径\n      // 用于分割文件的值\n      property: \"categoryName\", // 按日志类别分割\n      extension: \".log\", // 日志文件的扩展名\n      // 可选活动超时（毫秒），之后文件将被关闭。\n      timeout: 0,\n      // multiFile在底层使用file因此它还可以使用file的几乎所有选项\n    },\n    error: {\n      // 日志等级过滤器\n      type: \"logLevelFilter\",\n      // 使用的日志记录器\n      appender: \"file\",\n      // 只有日志等级大于或等于当前配置的日志等级时，才会输出\n      // 即只输出error以上的日志到file\n      level: \"error\",\n    },\n  },\n  // 日志分类\n  categories: {\n    // 默认分类\n    default: {\n      // debug以上的日志输出到out，其中error还会输出到文件（这对于将错误输出到邮件很有用）\n      appenders: [\"out\", \"error\"],\n      // 只有日志等级大于或等于当前配置的日志等级时，才会输出\n      level: \"debug\"\n    },\n    // date分类\n    date: {\n      appenders: [\"out\", \"date\"],\n      level: \"debug\"\n    },\n    // multi分类\n    multi: {\n      appenders: [\"out\", \"multi\"],\n      level: \"debug\"\n    },\n  },\n});\n\n// 获取default分类的日志记录器\nconst defaultLogger = log4js.getLogger()\n// 获取date分类的日志记录器\nconst dateLogger = log4js.getLogger('date')\n// 获取multi分类的日志记录器\nconst multiLogger = log4js.getLogger('multi')\n// 输出日志\ndefaultLogger.debug('Time:', new Date()) // 只输出到控制台\ndefaultLogger.error('Time:', new Error('error')) // 输出到控制台和server.log\ndateLogger.debug('Time:', new Date()) // app.log\nmultiLogger.debug('Time:', new Date()) // logs/multi.log\n```\n\n对于日志滚动和日期日志，先创建一个原名日志文件，当发生滚动或日期变更时，重命名该文件为**原名+序号**或**原名+日期**，然后创建一个新的原名日志文件继续写入，依次循环。\n\n## 其它接口\n`log4js.isConfigured()` 返回boolean，表示log4js.configure()先前是否成功调用（getLogger()也会隐式调用configure()）\n\n```js\nconsole.log(log4js.isConfigured()) // false\nlog4js.getLogger() // 隐式调用configure()\nconsole.log(log4js.isConfigured()) // true\n```\n\n`log4js.shutdown(cb)` 接受一个回调，当 log4js 关闭所有附加程序并完成写入日志事件时将调用该回调。当程序退出时使用此选项，以确保所有日志都写入文件、套接字已关闭等。\n\n```js\nlog4js.shutdown(() => {\n  console.log('log4js shutdown');\n})\n```\n\n`log4js.addLayout(type, fn)` 添加自定义布局，type为布局名，fn为布局处理函数。[详见](https://log4js-node.github.io/log4js-node/layouts.html)\n\n```js\nlog4js.addLayout(\"json\", function (config) {\n  return function (logEvent) {\n    return JSON.stringify(logEvent) + config.separator;\n  };\n});\nlog4js.configure({\n  appenders: {\n    out: { type: \"stdout\", layout: { type: \"json\", separator: \",\" } },\n  },\n  categories: {\n    default: { appenders: [\"out\"], level: \"info\" },\n  },\n});\nconst logger = log4js.getLogger(\"json-test\");\nlogger.info(\"this is just a test\");\n// {\"startTime\":\"2024-01-20T05:40:05.325Z\",\"categoryName\":\"json-test\",\"data\":[\"this is just a test\"],\n// \"level\":{\"level\":20000,\"levelStr\":\"INFO\",\"colour\":\"green\"},\"context\":{},\"pid\":22684},\n```\n\n# HTTP标头\n[HTTP 标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)（header）允许客户端和服务器通过 HTTP 请求（request）或者响应（response）传递**附加信息**\n\nHTTP 标头由它的名称（不区分大小写）后跟随一个冒号（:），冒号后跟随它具体的值。该值之前的空格会被忽略。\n\n根据不同的消息上下文，标头可以分为：\n1. [请求标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header)包含有关要获取的资源或客户端或请求资源的客户端的更多信息。\n2. [响应标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header)包含有关响应的额外信息，例如响应的位置或者提供响应的服务器。\n3. [表示标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Representation_header)包含资源主体的信息，例如主体的 MIME 类型或者应用的编码/压缩方案。\n4. [有效负荷标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Payload_header)包含有关有效载荷数据表示的单独信息，包括内容长度和用于传输的编码。\n\n## 请求表头\nHTTP请求头（HTTP request headers）是在HTTP请求中发送的元数据信息，用于描述请求的特性、内容和行为。\n\n**常见请求头：**\n1. **Accept**：客户端能够处理的媒体类型，值：`text/html`、`application/json`等\n2. **Accept-Encoding**：客户端能够处理的编码方式，值：`gzip`、`deflate`等\n3. **Accept-Language**：客户端能够处理的语言，值：`zh-CN`、`en-US`等\n4. **Connection**：连接方式，值：`keep-alive`、`close`等\n5. **Content-Type**：请求体的MIME类型，值：`text/html`、`application/json`等\n6. **Content-Length** 请求体的长度，单位字节\n7. **Host**：请求的主机名，值：`www.baidu.com`、`localhost:8888`等\n8. **Referer**：请求来源，值：`https://www.baidu.com`、`http://localhost:8888`等\n9. **User-Agent**：客户端信息，值：`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36`等\n10. **Cache-Control** 缓存控制，值：`no-cache`、`max-age=3600`等\n11. **Cookie** 请求携带的cookie，值：`name=tom;`等\n12. **Range** 用于断点续传，值：`bytes=0-1023`等，指定第一个字节的位置和最后一个字节的位置\n13. **Sec-Ch-Ua** 浏览器的 UA 字符串，值：`\"Google Chrome\";v=\"120\"`等\n14. **Sec-Ch-Ua-Mobile** 浏览器是否为移动端，值：`?0`、`?1`等\n15. **Sec-Fetch-Dest** 请求的目标资源类型，值：`document`、`image`等\n16. **Sec-Fetch-Mode** 请求的模式，值：`navigate`、`cors`等\n17. **Sec-Fetch-Site** 请求的站点类型，值：`same-origin`、`cross-site`等\n18. **Sec-Ch-Ua-Platform** 浏览器的平台，值：`\"Windows\"`、`\"macOS\"`等\n\n## 响应标头\nHTTP响应头（HTTP response headers）是在HTTP响应中发送的元数据信息，用于描述响应的特性、内容和行为。\n\n**常见响应头：**\n1. **Content-Type**：响应体的MIME类型，值：`text/html`、`application/json`等\n2. **Content-Length**：响应体的长度，单位字节\n3. **Content-Encoding**：响应体的编码方式，值：`gzip`、`deflate`等\n4. **Content-Language**：响应体的语言，值：`zh-CN`、`en-US`等\n5. **Content-Disposition**：响应体的附加信息，值：`attachment; filename=\"filename.jpg\"`，表示附件，浏览器会提示下载\n6. **Location**：重定向的地址，值：`https://www.baidu.com`\n7. **Set-Cookie**：设置cookie，值：`name=tom;`等\n8. **Cache-Control**：缓存控制，值：`no-cache`、`max-age=3600`等\n9.  **Expires**：缓存过期时间，值：`Wed, 21 Oct 2024 07:28:00 GMT`\n10. **Last-Modified**：资源最后修改时间，值：`Wed, 21 Oct 2024 07:28:00 GMT`\n11. **Etag**：资源的唯一标识，例如：`\"5d8b9b4e-2a\"`，用于缓存验证\n12. **Access-Control-Allow-Origin**：允许跨域的域名，值：`*`、`http://localhost:8080`等\n13. **Access-Control-Allow-Methods**：允许跨域的请求方法，值：`GET`、`POST`等\n14. **Access-Control-Allow-Headers**：允许跨域的**请求头**，值：`Content-Type`、`Authorization`等\n15. **Access-Control-Allow-Credentials**：是否允许跨域携带cookie，值：`true`、`false`等\n16. **Access-Control-Max-Age**：预检请求的有效期，单位秒，值：`3600`等\n17. **Access-Control-Expose-Headers**：允许跨域的**响应头**，值：`Content-Type`、`Authorization`等，若请求没有携带凭据（Cookie或认证信息），`*`才会被当作一个特殊的通配符，否则会被简单地当作标头名称。默认情况下，仅暴露[CORS安全列表的响应标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)\n18. **Strict-Transport-Security**：强制使用HTTPS，值：`max-age=31536000; includeSubDomains`，表示一年内所有子域名都必须使用HTTPS\n19. **X-Frame-Options**：防止网页被嵌入到iframe中，值：`DENY`、`SAMEORIGIN`等\n20. **X-XSS-Protection**：防止XSS攻击，值：`1; mode=block`、`0`等\n21. **X-Content-Type-Options**：防止MIME类型被修改，值：`nosniff`等\n22. **Referrer-Policy**：控制referer的发送，值：`no-referrer`、`strict-origin-when-cross-origin`等\n23. **Content-Security-Policy**：控制资源加载，值：`default-src 'self'`、`script-src 'self'`等\n24. **X-Powered-By**：服务器信息，值：`Express`、`PHP/7.4.3`等\n25. **Server**：服务器信息，值：`nginx/1.18.0`、`Apache/2.4.46`等\n26. **Date**：响应时间，值：`Wed, 21 Oct 2024 07:28:00 GMT`\n27. **Connection**：连接方式，值：`keep-alive`、`close`等\n28. **Transfer-Encoding**：传输编码，值：`chunked`、`gzip`等\n29. **Vary**：缓存策略，值：`Accept-Encoding`、`User-Agent`等\n\n### CORS\n跨域资源共享（Cross-Origin Resource Sharing，CORS）用于在**浏览器**中实现跨域请求访问资源的权限控制。\n\n当一个网页发起跨域请求时，浏览器会根据同源策略（Same-Origin Policy）进行限制。同源策略要求请求的源（**协议、域名和端口**）必须与资源的源相同，否则请求会被浏览器拒绝。\n\n[AJAX请求相关-跨域](/article/f3334fd0.html#跨域)\n\n```js express设置CORS\n// 请求来源白名单\nconst allowedOrigins = [\"127.0.0.1:5500\", undefined];\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  // 判断请求来源是否在白名单内\n  if (\n    (origin && allowedOrigins.some((item) => origin.includes(item))) ||\n    allowedOrigins.includes(origin)\n  ) {\n    // 设置允许跨域的域名，*代表允许任意域名跨域\n    res.header('Access-Control-Allow-Origin', origin);\n    // 允许的header类型，如下设置允许自定义header、允许Content-Type为非默认值等，按需删改\n    res.header('Access-Control-Allow-Headers', \"*, Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n    // 跨域允许的请求方式 \n    res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, PATCH ,OPTIONS');\n    // 跨域的时候是否携带cookie\n    // 需要与 XMLHttpRequest.withCredentials 或 Fetch API 的 Request() 构造函数中的 credentials 选项结合使用\n    res.header(\"Access-Control-Allow-Credentials\", true);\n    if (req.method.toLowerCase() == 'options') {\n      res.send(200); // 让options请求快速结束\n    }\n    else {\n      next();\n    }\n  } else {\n    res.status(403).send('Forbidden');\n  }\n})\n```\n\n### 跨域使用Cookie\n1. **服务端**将`Access-Control-Allow-Credentials`设为 **true**\n2. **客户端**请求时，设置`XMLHttpRequest.withCredentials`为 **true** 或 Fetch API 的 `credentials` 选项为 **include**\n\n```js\nfetch('http://127.0.0.1:8888/api', {\n  method: 'GET',\n  credentials: 'include', // 跨域允许携带Cookie\n}).then(res => res.text())\n  .then(data => console.log(data))\n```\n\n**注意：**此时服务端不能设置`Access-Control-Allow-Origin`为`*`，必须指定具体的域名，否则会报CORS错误\n\n```txt\nindex.html:1 Access to fetch at 'http://127.0.0.1:8888/api' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: \nThe value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'.\n```\n\n**Cookie属性：**\n\n```txt\n1. 名称：Cookie的name。\n2. 值：Cookie的value。\n3. Domain： Cookie的域。如果设成xxx.com(一级域名)，那么子域名x.xxx.com(二级域名)，都可以使用xxx.com的Cookie。\n4. Path：Cookie的路径。如果设为/，则同域名全部路径均可使用该Cookie。如果设为/xxx/，则只有路径为/xxx/可以使用该Cookie。\n5. Expires / Max-Age：Cookie的超时时间。如果值为时间，则在到达指定时间后Cookie失效。如果值为Session(会话)，Cookie会同Session一起失效，当整个浏览器关闭的时候Cookie失效。\n6. Size：Cookie的大小。\n7. HttpOnly：值为true时，Cookie只会在Http请求头中存在，不能通过doucment.cookie(JavaScript)访问Cookie。\n8. Secure：值为true时，只能通过https来传输Cookie。\n9. SameSite：\n  值为Strict，完全禁止第三方Cookie，跨站时无法使用Cookie。\n  值为Lax，允许在跨站时使用Get请求携带Cookie，下面有一个表格介绍Lax的Cookie使用情况。\n  值为None，允许跨站跨域使用Cookie，前提是将Secure属性设置为true。\n10. Priority ：Cookie的优先级。值为Low/Medium/High，当Cookie数量超出时，低优先级的Cookie会被优先清除。\n```\n\n一些额外的情况，可能还需要进行如下操作，才能跨域使用Cookie：\n将Cookie的SameSite值设为None，Secure值改为true，并且使用https。\n\n### 自定义响应头\n默认情况下，仅暴露[CORS安全列表的响应标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)\n\n其它响应头包括自定义的，需要使用 `Access-Control-Expose-Headers` 配置。\n\n只有当请求没有携带凭据（Cookie或认证信息），`*`才会被当作一个特殊的通配符，否则会被简单地当作标头名称。\n\n## 预检请求\n[预检请求](https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request)（preflight request）是浏览器在发送真正的请求之前，先发送一个OPTIONS请求，用于检查服务器是否支持 CORS 即跨域资源共享。\n\n存在以下情况时，浏览器会发送预检请求：\n1. 使用了自定义的请求头（非简单请求）\n2. 使用了非简单请求方法（PUT、DELETE等）\n3. Content-Type不是application/x-www-form-urlencoded、multipart/form-data、text/plain之一\n\n`Access-Control-Allow-Headers` 如下设置允许自定义header、允许Content-Type为非默认值等：\n`\"*, Origin, X-Requested-With, Content-Type, Accept, Authorization\"`\n\n# SSE单工通信\n[Server-Sent Events](https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events)（SSE）服务器发送**事件**，也称为**事件流**，用于服务器向客户端单向实时、持续地发送消息。属于单工通信。可以使用自定义事件（Custom Events）来发送具有特定类型的事件数据。\n\nSSE 基于 **HTTP** 协议，利用了其长连接特性，在客户端与服务器之间建立一条持久化连接，并通过这条连接实现服务器向客户端的单向实时数据推送。\n\n[Server-Sent Events 教程-阮一峰](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n\n使用SSE需要设置**响应头：**\n\n```js\nres.set('Content-Type', 'text/event-stream');\nres.set('Cache-Control', 'no-cache');\nres.set('Connection', 'keep-alive');\n```\n\n一个后端示例：\n\n```js\napp.get('/sse', (req, res) => {\n  // 使用SSE必要的响应头\n  res.set('Content-Type', 'text/event-stream');\n  res.set('Cache-Control', 'no-cache');\n  res.set('Connection', 'keep-alive');\n  let i = 1;\n  // 模拟实时发送数据给客户端\n  setInterval(() => {\n    // events: 自定义事件类型名，默认为 message\n    res.write('event: test\\n'); // 消息内部使用\\n分隔\n    // id: 事件ID，也可以是每一条数据的编号\n    res.write(`id: ${i++}\\n`); // 别漏了\\n\n    // retry: 重连时间间隔\n    res.write('retry: 3000\\n'); // 出错时的重连时间间隔，如网络错误导致连接中断\n    // data: 该事件附带的数据\n    res.write(`data: ${JSON.stringify({\n      time: new Date().toLocaleString(),\n    })}\\n\\n`); // 消息之间以\\n\\n分隔\n  }, 1000);\n});\n```\n\n`res.write`**发送消息：**\n每一次发送的信息，由**若干个message**组成，每个message之间用`\\n\\n`分隔。\n每个message内部由**若干行**组成，每行格式：`[field]: value\\n`，每行之间用`\\n`分隔。\n\n`[field]`可以取四个值：\n1. **event**：事件类型名，默认为 message。\n2. **id**：事件的ID，也可以是每一条数据的编号。\n3. **retry**：出错的重连时间间隔，单位毫秒。\n4. **data**：事件的数据，必须是字符串，如果数据有多行，使用\\n分隔。\n\n此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。\n如 `: This is a comment\\n`\n\n**id的作用：**\n每个message都应该有一个独特的id，浏览器用lastEventId属性读取id的值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的Last-Event-ID头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。\n\n## EventSource\n前端使用`EventSource(url, options)`创建SSE对象，监听对应事件，获得服务端响应的数据。\n\n本质是发送了一次GET请求，但是不会关闭连接，而是保持连接，等待服务端推送数据。\n\n**options 配置项：**\n1. `withCredentials` Boolean，是否允许发送 Cookie 和 HTTP 认证信息。默认为 false。\n2. `headers` Object，要发送的请求头信息。\n3. `retryInterval` Number，与服务器失去连接后，重新连接的时间间隔。默认为 1000 毫秒。\n\n```js\nconst sse = new EventSource('http://localhost:8888/sse', {\n  withCredentials: true // 允许跨域携带cookie\n});\nconsole.log('连接中', sse.readyState); // 连接中 0\nsse.addEventListener('open', () => {\n  console.log('连接已建立', sse.readyState); // 连接已建立 1\n});\nsse.addEventListener('test', (e) => {\n  console.log(e.type); // 事件名 test\n  console.log(e.lastEventId); // 当前该事件的ID\n  console.log(JSON.parse(e.data)); // 事件数据\n  // {time: '2024/1/21 22:54:03'}\n});\nsetTimeout(() => {\n  sse.close(); // 关闭连接\n  console.log('连接已关闭', sse.readyState); // 连接已关闭 2\n}, 4000);\n```\n\n`EventSource.readyState`，表明连接的当前状态。\n1. **0**：相当于常量`EventSource.CONNECTING`，表示连接还未建立，或者断线正在重连。\n2. **1**：相当于常量`EventSource.OPEN`，表示连接已经建立，可以接受数据。\n3. **2**：相当于常量`EventSource.CLOSED`，表示连接已断，且不会重连。\n\n**事件：**\n1. `open` EventSource 对象已经和服务器建立了连接，并开始接收来自服务器的数据，此时 readyState 为 1。\n2. `error` 在建立连接或接收服务器数据时发生了错误。\n3. `message` 服务器发送了一个没有指定事件名的消息，此时 event.type 为 message。\n4. 自定义事件名：服务器发送了一个指定事件名的消息，此时 event.type 为自定义事件名。\n\n# WebSocket双工通信\n**WebSocket** 是建立在单个 **TCP** 连接上的**全双工通信协议**，允许客户端和服务器之间进行实时双向通信。\n\n[WebSocket 教程-阮一峰](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n[你不知道的 WebSocket-阿宝哥](https://juejin.cn/post/6854573221241421838)\n\n**特点：**\n1. 建立在 TCP 协议之上，服务器端的实现比较容易。\n2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n3. 数据格式比较轻量，性能开销小，通信高效。\n4. 有状态的协议，之后通信时可以省略部分状态信息\n5. 可以发送文本，也可以发送二进制数据。\n6. 没有同源限制，客户端可以与任意服务器通信。\n7. 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/76-1.webp\" width=\"60%\" />\n\n## 客户端\n**WebSocket** 对象用于创建 WebSocket 连接，通过该连接可以发送和接收数据。\n\n```js\nconst ws = new WebSocket('ws://localhost:8080');\nws.onopen = () => {\n  console.log('Connected');\n};\n```\n\n`readyState` 属性\n1. **0**：相当于常量`WebSocket.CONNECTING`，表示连接还未建立，或者断线正在重连。\n2. **1**：相当于常量`WebSocket.OPEN`，表示连接已经建立，可以通讯。\n3. **2**：相当于常量`WebSocket.CLOSING`，表示连接正在关闭。\n4. **3**：相当于常量`WebSocket.CLOSED`，表示连接已断，且不会重连。\n\n**事件：**\n1. `open` WebSocket 连接已建立。\n2. `message` 接收到服务器发送的数据。\n3. `error` 连接出错。\n4. `close` 连接关闭。\n\n**方法：**\n1. `send(data)` 向服务器发送数据。\n2. `close()` 关闭连接。\n\n## 请求和响应头\n**1、请求头：**\n1. **Upgrade** 指定为`websocket`，表示要升级协议为 WebSocket（HTTP 协议提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议）\n2. **Connection** 指定为`Upgrade`，表示要升级连接。\n3. **Sec-WebSocket-Key** Base64编码的16字节随机字符串，用于验证服务器是否正确处理了握手请求。\n4. **Sec-WebSocket-Version** WebSocket协议的版本号，当前为13。\n5. **Sec-WebSocket-Extensions** 指定扩展，如压缩等。\n\n```text\nGET ws://localhost:8080/ HTTP/1.1\nHost: localhost:8080\nConnection: Upgrade\nPragma: no-cache\nCache-Control: no-cache\nUpgrade: websocket\nOrigin: http://127.0.0.1:5500\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: iXGVJiUgpjqmAIMXKj592w==\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\n```\n\n**2、响应头：**\n1. **101 Switching Protocols** 101 状态码，表示协议切换成功。\n2. **Upgrade** 指定为`websocket`，表示要升级协议为 WebSocket。\n3. **Connection** 指定为`Upgrade`，表示要升级连接。\n4. **Sec-WebSocket-Accept** 通过ws协议指定算法处理后的`Sec-WebSocket-Key`，表示ws已握手成功，后续消息收发使用ws协议。\n\n```text\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: Ifs+JScoZK0aP3knDahEYlTi9Eg=\n```\n\n## 服务端\n[ws 模块](https://www.npmjs.com/package/ws)是 Node.js 的 WebSocket 模块，用于创建 WebSocket 服务器。\n\n```shell\npnpm i ws\npnpm i @types/ws -D\n```\n\n使用该模块，省去了手动处理 WebSocket 握手、消息解析等繁琐的工作，抽象出了各种事件，方便使用。\n\n```ts\nimport webSocket from 'ws'; // 引入ws\n\n// 创建一个ws服务器\nconst ws = new webSocket.Server({ \n  port: 8080 // 监听8080端口\n}, () => {\n  console.log('ws服务器启动成功');\n});\n\n// 监听客户端的连接\nws.on('connection', (client) => {\n  console.log('有客户端连接');\n  // 监听客户端发来的消息\n  client.on('message', (msg) => {\n    console.log('有消息', msg);\n    // 向客户端发送消息\n    client.send('服务器收到了消息');\n  });\n});\n```\n\n**webSocket服务事件：**\n1. `connection` 客户端连接事件，参数为客户端对象。\n2. `close` 客户端关闭事件。\n3. `error` 服务器出错事件。\n4. `headers` 客户端请求头事件，参数为请求头对象。\n5. `listening` 服务器监听事件。\n\n**client 客户端事件：**\n1. `message` 客户端消息事件，参数为消息内容。\n2. `close` 客户端关闭事件。\n3. `error` 客户端出错事件。\n4. `open` 客户端打开事件。\n5. `ping` 客户端ping事件。\n6. `pong` 客户端pong事件。\n7. `unexpected-response` 客户端响应事件。\n8. `upgrade` 客户端协议升级事件。\n\n## 简易公共聊天室\n后端：\n\n```ts\nimport webSocket from 'ws'; // 引入ws\n\n// 创建一个ws服务器\nconst ws = new webSocket.Server({ \n  port: 8080 // 监听8080端口\n}, () => {\n  console.log('ws服务器启动成功');\n});\n\n// 监听客户端的连接\nws.on('connection', (client) => {\n  console.log('新客户端连接');\n  // 监听客户端发来的消息\n  client.on('message', (msg) => {\n    console.log('新消息：', msg.toString());\n    // 向所有客户端广播消息\n    ws.clients.forEach((client) => {\n      client.send(msg.toString());\n    });\n  });\n  // 监听客户端断开连接\n  client.on('close', () => {\n    console.log('有客户端断开连接');\n  });\n});\n```\n\n前端：\n\n```html\n<body>\n  <div>\n    <ul id=\"list\"></ul>\n    <input type=\"text\" id=\"input\">\n    <button id=\"send\">发送</button>\n  </div>\n  <script src=\"index.js\"></script>\n</body>\n```\n\n```js\nconst ws = new WebSocket('ws://localhost:8080');\n\nconst list = document.getElementById('list');\nconst input = document.getElementById('input');\nconst send = document.getElementById('send');\n\nsend.addEventListener('click', () => {\n  if (!input.value) {\n    return;\n  }\n  ws.send(input.value);\n  input.value = '';\n});\n\nws.onmessage = (event) => {\n  const li = document.createElement('li');\n  li.textContent = event.data;\n  list.appendChild(li);\n};\n```\n\n当 socket 连接长时间不使用、发生网络波动、弱网环境可能导致连接断开，通常还需要实现心跳检测，以保持连接、检测连接断开后重连。\n\n在服务端或客户端实现均可，没有一个固定的实现方式，通常是在客户端使用定时器发送心跳包。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"Node-回眸[二]","url":"/article/9b981f17.html","content":"\n# events\nNode是事件驱动的，事件模型采用了**发布订阅设计模式**，EventListener、Vue2 evnetBus都是这种模式\n\n发布订阅模式有三个角色参与\n1. 发布者（Publisher）：发布消息，制定消息的主题名\n2. 订阅者（Subscriber）：通过消息主题订阅消息，先订阅再等待发布消息，否则会错过消息\n3. 调度中心（Broker）：维护一个消息列表，并提供发布和订阅消息的方法，通过消息主题将发送者和接收者连接起来，四个基本的方法：on、once、off、emit\n\n发布者和订阅者之间完全解耦，不再直接依赖于彼此，可以独立地扩展自己，消息的传递则依靠调度中心。发布者不会将消息直接发送给订阅者，而是通过调度中心将消息和其主题广播出去，订阅了该主题则可以接收到消息\n\n实现一个简单的发布订阅：\n\n```ts\n// 订阅方法\ninterface EventFun {\n  (...args: any[]): any\n}\ninterface EventCls {\n  // 订阅消息\n  on(name: string, callback: EventFun): void\n  // 发布消息\n  emit(name: string, ...args: any[]): void\n  // 取消订阅\n  off(name: string, fn: EventFun): void\n  // 只订阅一次\n  once(name: string, fn: EventFun): void\n}\ntype CallbackArr = Array<EventFun>\n// 保存所有消息\ninterface EventList {\n  // 消息名:订阅的方法集合\n  [key: string]: CallbackArr,\n}\nclass SubPub implements EventCls {\n  list: EventList\n  constructor() {\n    this.list = {}\n  }\n  on(name: string, callback: EventFun) {\n    const callbackList: CallbackArr = this.list[name] || [];\n    callbackList.push(callback)\n    this.list[name] = callbackList\n  }\n  emit(name: string, ...args: any[]) {\n    const callbackList: CallbackArr = this.list[name]\n    if (callbackList) {\n      if (callbackList.length <= 0) {\n        console.warn(\"该消息没有订阅者\")\n        return;\n      }\n      callbackList.forEach(callback => {\n        callback.apply(this, args)\n      })\n    } else {\n      console.warn(\"没有该消息\")\n    }\n  }\n  off(name: string, fn: EventFun) {\n    const callbackList: CallbackArr = this.list[name]\n    if (callbackList) {\n      if (callbackList.length <= 0) {\n        console.warn(\"该消息没有订阅者\")\n        return;\n      }\n      const index = callbackList.findIndex(fns => fns === fn)\n      index > -1 ? callbackList.splice(index, 1) : null\n    } else {\n      console.warn(\"没有该消息\")\n    }\n  }\n  once(name: string, fn: EventFun) {\n    const decor: EventFun = (...args) => {\n      fn.apply(this, args)\n      this.off(name, decor)\n    }\n    this.on(name, decor)\n  }\n}\n```\n\n测试：\n\n```ts\nconst subPub = new SubPub()\n// 测试on和off\nsubPub.emit('abc', 678) // 没有该消息\nconst fn: EventFun = (...arg) => {\n  console.log(arg);\n}\nsubPub.on('abc', fn)\nsubPub.emit('abc', 131, true) // [ 131, true ]\nsubPub.emit('abc', 678, false, 'qx') // [ 678, false, 'qx' ]\nsubPub.off('abc', fn)\nsubPub.emit('abc', 321, 'qx') // 该消息没有订阅者\nconsole.log(\"=======================\");\n// 测试once\nsubPub.emit('a', 678) // 没有该消息\nsubPub.once('a', (...arg) => {\n  console.log(arg);\n})\nsubPub.emit('a', 678, 'abc') // [ 678, 'abc' ]\nsubPub.emit('a', 123, 'qx') // 该消息没有订阅者\nsubPub.on('a', (...arg) => {\n  console.log(arg);\n})\nsubPub.emit('a', 123, 'qx') // [ 123, 'qx' ]\n```\n\n## EventEmitter\nNode内置的 [events](https://nodejs.cn/api/events.html) 模块提供了 EventEmitter 类用于处理事件的发布与订阅\n\nNode中许多类都继承自它，比如 Process、Stream、HTTP 等，这些类都提供了事件处理机制，允许注册监听器以响应特定的事件，从而构建异步、事件驱动的程序\n\n在Node中，消息<->事件，订阅消息<->监听事件，发布消息<->触发事件\n\n常用方法：\n1. `on(event, listener)` 为指定事件添加一个监听器到监听器数组的**尾部**\n2. `addListener(event, listener)` 与on等效\n3. `once(event, listener)` 为指定事件注册一个单次监听器到监听器数组的**尾部**，该监听器触发后立刻被移除\n4. `emit(event, ...argv)` 触发事件，传递参数，如果事件有注册监听返回 true，否则返回 false。\n5. `off(event, listener)` 移除指定事件的某个监听器，在监听器数组中**从后往前**找\n6. `removeListener(event, listener)` 与off等效\n7. `removeAllListeners([event])` 移除所有事件(或指定事件)的所有监听器\n8.  `setMaxListeners(n)` 设置单个事件最大监听器数量，默认10，超过将发出警告，有助于排查内存泄漏，设置为 Infinity（或 0）以表示无限数量\n9.  `listeners(event)` 返回指定事件的所有监听器组成的数组\n10. `rawListeners(event)` 与listeners差不多，但会将once注册的监听器标记出来\n11. `listenerCount(event)` 返回指定事件的监听器数量\n12. `eventNames()` 返回事件名列表数组\n13. `prependListener(event, listener)` 为指定事件添加一个监听器到监听器数组的**头部**\n14. `prependOnceListener(event, listener)` 为指定事件注册一个单次监听器到监听器数组的**头部**\n\n```js\nconst EventEmitter = require('events')\nconst event = new EventEmitter()\nconst listener = (...args) => {\n  console.log(args)\n}\n// 监听事件\nevent.on('test', listener)\nevent.once('test', listener)\nconsole.log(event.eventNames()) // [ 'test' ]\nconsole.log(event.listeners('test')) \n// [ [Function: listener], [Function: listener] ]\nconsole.log(event.rawListeners('test'))\n// [\n//   [Function: listener],\n//   [Function: bound onceWrapper] { listener: [Function: listener] }\n// ]\nconsole.log(event.listenerCount('test')) // 2\n// 触发事件，传递信息\nevent.emit('test', 1, 2, 3, 4, 5)\nevent.emit('test', 1, 2, 3, 4, 5)\n// [ 1, 2, 3, 4, 5 ] 两次on一次once\n// [ 1, 2, 3, 4, 5 ]\n// [ 1, 2, 3, 4, 5 ]\n```\n\n默认情况下，每个事件最多注册 10 个监听器，超过 10 个监听器会发出警告\n\n```js\nfor (let i = 0; i < 20; i++) {\n  event.on('test', () => {\n    console.log(`test${i}`)\n  })\n}\nevent.emit('test')\n// (node:40112) MaxListenersExceededWarning: \n// Possible EventEmitter memory leak detected. \n// 11 test listeners added to [EventEmitter]. \n// Use emitter.setMaxListeners() to increase limit\n```\n\n使用 setMaxListeners(num) 设置单个事件最大监听器数量\n\n```js\nevent.setMaxListeners(20)\n```\n\n## 错误事件\n当 EventEmitter 实例中发生错误时，会触发 error 事件\n\n如果没有为 error 事件注册监听器，则会抛出错误，打印堆栈跟踪，然后 Node 进程退出\n\n最佳实践：应始终为 error 事件添加监听器\n\n```js\nevent.on('error', (err)=>{\n  console.log('message:', err.message) // message: 错误信息\n})\nevent.emit('error', new Error('错误信息'));\n```\n\n使用 events.errorMonitor 安装监听器，可以在不消费触发的错误的情况下监视 error 事件(错误会穿透监听)\n\n```js\nconst { errorMonitor } = require('events')\nevent.on(errorMonitor, (err) => {\n  console.log('message:', err.message) // message: 错误信息\n})\nevent.emit('error', new Error('错误信息'));\n// Error: 错误信息\n//     ......\n// Emitted 'error' event at:\n//     ......\n```\n\n## new/removeListener事件\n**newListener** 当有新的监听器**将要**注册，触发该事件\n**removeListener** 当有监听器被移除后，触发该事件\n\n```js\nevent.on('newListener', (event, listener) => {\n  console.log(event, listener)\n  // removeListener [Function (anonymous)]\n  // test [Function: listener]\n})\nevent.on('removeListener', (event, listener) => {\n  console.log(event, listener)\n  // test [Function: listener]\n})\nconst listener = () => { }\nevent.on('test', listener)\nevent.off('test', listener)\n```\n\n## process底层\n\n```js\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto, EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter, process);\n  ObjectDefineProperty(process, SymbolToStringTag, {\n    __proto__: null,\n    enumerable: false,\n    writable: true,\n    configurable: false,\n    value: 'process',\n  });\n\n  // Create global.process as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis, 'process', {\n    __proto__: null,\n    get() {\n      return _process;\n    },\n    set(value) {\n      _process = value;\n    },\n    enumerable: false,\n    configurable: true,\n  });\n}\n```\n\nObjectGetPrototypeOf() 即 Object.getPrototypeOf()，获取某个对象原型上的属性\n\n在源码中，通过该API获取了process的原型\n\n```js\nclass A {}\nA.prototype.name = 'A';\nconst a = new A();\nconsole.log(Object.getPrototypeOf(a));\n// { name: 'A' }\nconsole.log(a.__proto__);\n// { name: 'A' }\n```\n\nObjectSetPrototypeOf() 即 Object.setPrototypeOf()，用于设置对象的原型\n\n在源码中，将 EventEmitter 的原型对象设置为 process 的原型的原型，让 process 也能使用 events 的一些方法\n\n```js\nclass A {}\nA.prototype.name = 'A';\nconst a = new A();\nObject.setPrototypeOf(a, { name: 'B' });\nconsole.log(Object.getPrototypeOf(a));\n// { name: 'B' }\n```\n\nFunctionPrototypeCall() 即 Function.prototype.call()，改变 this 指向并调用函数\n\n在源码中，调用 EventEmitter 构造函数，使 process 也拥有 EventEmitter 的功能\n\n```js\nfunction A() {\n  this.name = 'A';\n  this.a = 1;\n}\n\nfunction B() {\n  this.name = 'B';\n  this.age = 18;\n}\n\n// 创建 A 的实例，并使用 call 将当前实例作为上下文传递给 B 的构造函数，使 B 的构造函数内的 this 指向 a 实例对象\nconst a= new A();\nB.call(a);\n\nconsole.log(a.a);    // 输出: 1\nconsole.log(a.name);  // 输出: B\nconsole.log(a.age);   // 输出: 18\n```\n\n通过 FunctionPrototypeCall() 和 ObjectSetPrototypeOf()，使 process 继承自 EventEmitter\n\n最后，通过 ObjectDefineProperty() 将process挂载到全局变量上\n\n\n# util\n[util](https://nodejs.cn/api/util.html) 提供了很多实用的、工具类型的API，方便快速开发\n\n## 类型判断\nutil.types 上有很多 is\\*\\*\\*() 的方法用于判断类型，返回 boolean\n\n与 instanceof 不同，util.types 不会受到原型链的影响\n\ninstanceof 运算符用于检查一个对象是否是某个构造函数的实例。具体而言，它检查一个对象的原型链中是否出现了指定构造函数的原型。\n\n```js\nconsole.log(util.types.isDate(new Date())) // true\nconsole.log(util.types.isPromise(new Promise(() => { }))) // true\n\nconst date = new Date() \nconsole.log(date instanceof Date) // true\nObject.setPrototypeOf(date, {})\nconsole.log(date instanceof Date) // false\nconsole.log(util.types.isDate(date)) // true\n```\n\n## promisify\npromisify(fn) 用于将回调函数的模式转为promise模式\n\n原回调函数的参数除err外，都作为对象的属性返回\n\n```js\nconst execPromise = util.promisify(childProcess.exec)\nexecPromise('node -v')\n  .then(({ stdout, stderr }) => {\n    // 原回调函数的参数除err外，都作为对象的属性返回\n    console.log(stdout) // v21.2.0\n  })\n  .catch(err => {\n    console.log(err)\n  })\n```\n\n手写 promisify\n\n```js\nconst promisify = (fn) => {\n  // 返回一个函数，参数与原函数相同\n  return (...args) => {\n    // 返回一个 Promise\n    return new Promise((resolve, reject) => {\n      // 执行原函数，传入原函数的参数，最后一个参数为回调函数\n      fn(...args, (err, ...values) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(...values)\n        }\n      })\n    })\n  }\n}\n\nconst execPromise = promisify(childProcess.exec)\nexecPromise('node -v')\n  .then((stdout, stderr) => {\n    console.log(stdout) // v21.2.0\n  })\n  .catch(err => {\n    console.log(err)\n  })\n```\n\n自己写 promisify 是无法获取到 key 名（原参数名）的，也就不能像 util.promisify 那样resolve一个对象\n\n在底层通过 kCustomPromisifyArgsSymbol 获取 key 名，但该 API 仅Node内部使用\n\n## callbackify\ncallbackify(fn) 将promise模式转为回调函数的模式\n\n```js\nconst fn = (type) => {\n  return new Promise((resolve, reject) => {\n    if (type === 'error') {\n      reject(new Error('error'))\n    }\n    resolve(type)\n  })\n}\nconst newFn = util.callbackify(fn)\nnewFn('test', (err, value) => {\n  if (err) {\n    console.log(err)\n    return;\n  }\n  console.log(value) // test\n})\n```\n\n手写 callbackify\n\n```js\nconst fn = (type) => {\n  return new Promise((resolve, reject) => {\n    if (type === 'error') {\n      reject(new Error('error'))\n    }\n    resolve(type)\n  })\n}\n// const newFn = util.callbackify(fn)\nconst callbackify = (fn) => {\n  return (...args) => {\n    // 将回调函数取出\n    const callback = args.pop()\n    fn(...args)\n      .then(value => {\n        callback(null, value)\n      })\n      .catch(err => {\n        callback(err)\n      })\n  }\n}\nconst newFn = callbackify(fn)\nnewFn('test', (err, value) => {\n  if (err) {\n    console.log(err)\n    return;\n  }\n  console.log(value) // test\n})\n```\n\n## inspect\n[inspect](https://nodejs.cn/api/util.html#utilinspectobject-options) 将对象转换为字符串，通常用于调试和错误输出\n\n`util.inspect(object[, options])`\n\noptions配置项：\n\n```\n1. showHidden <boolean> 如果值为 true，则 object 的不可枚举符号和属性包含在格式化的结果中。WeakMap 和 WeakSet 条目以及用户定义的原型属性（不包括方法属性）也包括在内。默认值：false。\n2. depth <number> 表示最大递归的层数，如果对象很复杂，可以指定层数以控制输出对象的深度。如果不指定depth，默认会递归 2 层，指定为 null 表示将不限递归层数完整遍历对象（递归到最大调用堆栈大小）。\n3. color  <boolean> 如果为 true，输出格式将会以 ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。[自定义 inspect 颜色](https://nodejs.cn/api/util.html#customizing-utilinspect-colors)\n4. breakLength <integer> 输入值在多行中拆分的长度。 设置为 Infinity 以将输入格式化为单行（结合 compact 设置为 true 或任何数字 >= 1）。 默认值： 80。\n5. showProxy <boolean> 如果 true，Proxy 检查包括 target 和 handler 对象。默认值：false。\n6. compact <boolean> 如果为 true，则输出将尽可能紧凑，例如在数组和对象周围省略空格。默认值：false。\n7. sorted <boolean> 如果为 true，则输出的对象属性将按属性名排序。默认值：false。\n8. getters <boolean> 如果为 true，则输出将包括对象的 getter 函数的返回值。默认值：false。\n9. maxArrayLength <integer> 指定要格式化的数组的最大长度 设置为 Infinity 可以完整遍历数组。默认值：100。\n10. maxStringLength <integer> 指定要格式化的字符串的最大长度 设置为 Infinity 可以完整遍历字符串。默认值：100。\n11. breakLength <integer> 输入值在多行中拆分的长度。设置为 Infinity 以将输入格式化为单行（结合 compact 设置为 true 或任何数字 >= 1）。默认值：80。\n```\n\n```js\nconst obj = {\n  name: 'qx',\n  a: { b: { c: { d: 1 } } },\n  arr: [1, 2, 3, 4, 5]\n}\nconsole.log(util.inspect(obj, {\n  depth: 2,\n  colors: true,\n  showHidden: true,\n  compact: true,\n  maxArrayLength: 3,\n  showProxy: false,\n  sorted: false,\n}))\n// { name: 'qx',\n// a: { b: { c: [Object] } },\n// arr: [ 1, 2, 3, ... 2 more items, [length]: 5 ] }\n```\n\n## format\n类似C中的 printf 的格式字符串\n\n使用第一个参数作为类似 printf 的格式字符串（其可以包含零个或多个格式说明符）来返回格式化的字符串。每个说明符都替换为来自相应参数的转换后的值\n\n```js\nutil.format(format, ...args)\n```\n\n格式说明符：\n\n```\n1. `%s`: String 将用于转换除 BigInt、Object 和 -0 之外的所有值。 BigInt 值将用 n 表示，没有用户定义的 toString 函数的对象使用具有选项 { depth: 0, colors: false, compact: 3 } 的 util.inspect() 进行检查。\n2. `%d`: Number 将用于转换除 BigInt 和 Symbol 之外的所有值。\n3. `%i`: parseInt(value, 10) 用于除 BigInt 和 Symbol 之外的所有值。\n4. `%f`: parseFloat(value) 用于除 Symbol 之外的所有值。\n5. `%j`: JSON。 如果参数包含循环引用，则替换为字符串 '[Circular]'。\n6. `%o`: Object。 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 { showHidden: true, showProxy: true } 的 util.inspect()。 这将显示完整的对象，包括不可枚举的属性和代理。\n7. `%O`: Object。 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 util.inspect()。 这将显示完整的对象，但不包括不可枚举的属性和代理。\n8. `%c`: CSS。 此说明符被忽略，将跳过任何传入的 CSS。\n9. `%%`: 单个百分号 ('%')。 这不消费参数。\n```\n\n没有匹配到的格式说明符的参数将按空格分隔的列表形式附加到字符串中，每个未匹配的参数都使用 util.inspect() 转换为一个字符串\n\n```js\nconsole.log(util.format('%s:%s', 'foo', 'bar', 'baz', { a: 1 }));\n// foo:bar baz { a: 1 }\n```\n\n# pngquant\n[pngquant](http://pngquant.com/) 是一个用于压缩 PNG 图像文件的工具，基于 Median Cut 算法\n\n三个参数：\n1. `--output` `-o` 输出文件路径\n2. `--ext` 为输出文件名设置自定义后缀/扩展名\n3. `--quality min-max` 设置压缩质量，0-100，值越大图片越大，效果越好\n4. `--speed 1-11` 设置压缩速度，1最慢，11最快，可能会导致输出图像质量稍微降低，默认3\n5. `--force` `-f` 强制覆盖已存在的输出文件\n6. `--skip-if-larger` 仅当压缩后的文件比原始文件更小或者压缩后的文件比原始文件更大但是质量更好时才输出文件\n7. `--strip` 去除所有的元数据，包括png文件头信息\n8.  `--verbose` `-v` 输出状态信息\n\n封装函数：\n\n```js\nconst pngquant = (str) => {\n  execFile('pngquant', str.split(\" \"), {\n    cwd: __dirname\n  }, (err, stdout) => {\n    if (err) {\n      console.log(err)\n      return;\n    }\n    console.log(\"done\")\n  })\n}\n```\n\n```js\npngquant('./1.png --output ./2.png -f')\n// quality表示图片质量0-100值越大图片越大效果越好\npngquant('./1.png --quality=82 -o ./3.png -f')\n// --speed=1: 最慢的速度，产生最高质量的输出图像。\n// --speed=11: 最快的速度，但可能导致输出图像质量稍微降低。\npngquant('./1.png --speed=11 --quality=80 -o ./4.png -f')\n// --ext 为输出文件名设置自定义后缀/扩展名\npngquant('./1.png --ext new.png -f -v') // 1new.png\n```\n\n# fs\n[fs](https://nodejs.cn/api/fs.html) 文件系统模块，提供了与文件系统进行交互的能力\n\n所有文件系统操作方法都具有同步、异步回调和基于 promise 的形式\n\n绝大部分方法都能传入options配置项，用于指定编码格式、文件模式等，如果 options 是字符串，则指定编码格式（encoding）\n\n默认返回Buffer，可以通过指定编码格式获取字符串\n\n```js fs的多种策略\nconst fs = require('fs')\nconst fsPromises = require('fs/promises') // 引入promise版本\nconst path = require('path')\n// 异步\nfs.readFile(path.resolve(__dirname, './1.txt'), (err, data) => {\n  console.log(data) // <Buffer 31 32 33 34 35 36 0d 0a 36 35 34 33 32 31>\n})\n// 同步，且指定编码格式获取字符串\nconst data = fs.readFileSync(path.resolve(__dirname, './1.txt'), 'utf-8')\nconsole.log(data) // 123456\n// promise\nfsPromises.readFile(path.resolve(__dirname, './1.txt')).then(data => {\n  // 手动将buffer转换为字符串\n  console.log(data.toString()) // 123456\n}).catch(err => {})\n```\n\n## 线程池使用\n所有基于回调和 promise 的文件系统 API（fs.FSWatcher() 除外）都使用 libuv 的线程池，在事件循环线程之外执行文件系统操作。这些操作不是同步的也不是线程安全的。对同一文件执行多个并发修改时必须小心，否则可能会损坏数据。\n\n## flag文件系统标志\n以下标志在 flag 选项接受字符串的任何地方都可以使用\n1. `a`: 打开文件进行追加。如果文件不存在，则创建该文件。\n2. `ax`: 类似于 'a' 但如果路径存在则失败。\n3. `a+`: 打开文件进行读取和追加。如果文件不存在，则创建该文件。\n4. `ax+`: 类似于 'a+' 但如果路径存在则失败。\n5. `as`: 以同步模式打开文件进行追加。如果文件不存在，则创建该文件。\n6. `as+`: 以同步模式打开文件进行读取和追加。如果文件不存在，则创建该文件。\n7. `r`: 打开文件进行读取。如果文件不存在，则会发生异常。\n8. `rs`: 打开文件以同步模式读取。如果文件不存在，则会发生异常。\n9.  `r+`: 打开文件进行读写。如果文件不存在，则会发生异常。\n10. `rs+`: 以同步模式打开文件进行读写。指示操作系统绕过本地文件系统缓存。这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。如果需要同步操作，应该使用类似 fs.openSync() 的东西。\n11. `w`: 打开文件进行写入。创建（如果它不存在）或截断（如果它存在）该文件。\n12. `wx`: 类似于 'w' 但如果路径存在则失败。\n13. `w+`: 打开文件进行读写。创建（如果它不存在）或截断（如果它存在）该文件。\n14. `wx+`: 类似于 'w+' 但如果路径存在则失败。\n\n简单记忆：\n1. r：读取\n2. w：写入\n3. s：同步\n4. +：增加相反操作\n5. x：排他方式\n\n## fd文件描述符\n在 POSIX 系统上，对于每个进程，内核维护一个当前打开的文件和资源表。每个打开的文件都分配有一个简单的数字标识符，称为文件描述符。在系统级，所有文件系统操作都使用这些文件描述符来识别和跟踪每个特定文件。Windows 系统使用不同但概念上相似的机制来跟踪资源。为了方便用户，Node.js 抽象了操作系统之间的差异，并为所有打开的文件分配了一个数字文件描述符。\n\n在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2三个比较特殊的描述符，分别代表 stdin（标准输入）、stdout（标准输出）和 stderr（错误输出）。\n\n基于回调的 fs.open() 和同步 fs.openSync() 方法打开一个文件并分配一个新的文件描述符。分配后，文件描述符可用于从文件读取数据、向文件写入数据或请求有关文件的信息。\n\n```js\nfs.open(path.resolve(__dirname, './1.txt'), 'r', (err, fd) => {\n  console.log(fd) // 3，数字文件描述符\n  // 将文件描述符传入，获取文件信息\n  fs.fstat(fd, (err, stat) => {\n    console.log(stat) // 文件信息\n  })\n  // 关闭文件\n  fs.close(fd, (err) => {\n    console.log('关闭成功')\n  })\n})\n```\n\n操作系统限制在任何给定时间可能打开的文件描述符的数量，因此在操作完成时关闭描述符至关重要。否则将导致内存泄漏，最终导致应用崩溃。\n\n## fsPromises\n基于 promise 的操作会返回一个当异步操作完成时被履行的 promise。\n\n通常不直接使用 fsPromises 操作文件，而是用 fsPromises.open() 创建一个 FileHandle（数字文件描述符的封装） 对象，每个描述符都会绑定到一个特定的文件。然后使用 FileHandle 执行文件操作。\n\n使用 FileHandle 好处：\n1. FileHandle 对象可以在多个操作之间共享，从而避免了在每个操作中打开和关闭文件的开销。\n2. 可以精确地控制文件的打开和关闭。\n3. 一些文件操作可能在底层实现上更为高效。\n4. 封装、代替数字文件描述符。FileHandle对象由系统更好地管理，以确保资源不泄漏。但仍然应该显示调用 close() 方法来关闭 FileHandle 对象，以便释放系统资源。当 FileHandle 已关闭且不再可用时，会触发 close 事件。\n\n```js\nconst fd = await fsPromises.open(path.resolve(__dirname, './1.txt'), 'r')\nconst data = await fd.readFile('utf-8')\nconsole.log(data) // 123456\nawait fd.close();\n```\n\n## access\n`access(path[, mode], callback)` 测试用户对 path 指定的文件或目录的权限。\n\nmode 值为[文件访问常量](https://nodejs.cn/api/fs.html#file-access-constants)，指定要执行的可访问性检查。默认值：fs.constants.F_OK\n1. F_OK 指示文件对调用进程可见的标志。用于确定文件是否存在，但没有说明 rwx 权限。\n2. R_OK\t指示文件可以被调用进程读取的标志。\n3. W_OK\t指示文件可以被调用进程写入的标志。\n4. X_OK\t指示文件可以被调用进程执行的标志。这对 Windows 没有影响（将表现得像 fs.constants.F_OK）。\n\n```js\nconst file = path.resolve(__dirname, './1.txt')\nfs.access(file, fs.constants.F_OK, (err) => {\n  console.log(`${file} ${err ? 'does not exist' : 'exists'}`);\n});\nfs.access(file, fs.constants.R_OK, (err) => {\n  console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);\n});\nfs.access(file, fs.constants.W_OK, (err) => {\n  console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);\n});\nfs.access(file, fs.constants.R_OK | fs.constants.W_OK, (err) => {\n  console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);\n});\n// c:\\chuckle\\qx\\NodeJS-new\\fs\\1.txt exists\n// c:\\chuckle\\qx\\NodeJS-new\\fs\\1.txt is readable\n// c:\\chuckle\\qx\\NodeJS-new\\fs\\1.txt is writable\n// c:\\chuckle\\qx\\NodeJS-new\\fs\\1.txt is readable and writable\n```\n\n在调用 fs.open()、fs.readFile() 或 fs.writeFile() 等文件操作之前，不要使用 fs.access() 检查文件的可访问性。这样做会引入竞争条件，因为其他进程可能会在两次调用之间更改文件的状态。而是，用户代码应直接打开/读取/写入文件，并处理无法访问文件时引发的错误。\n\n## readFile文件读取\nreadFile用于读取文件内容\n\n```js 同步\nconst data = fs.readFileSync(path.resolve(__dirname, './1.txt'), 'utf-8')\nconsole.log(data) // 123456\n```\n\n```js 异步\nfs.readFile(path.resolve(__dirname, './1.txt'), 'utf-8', (err, data) => {\n  console.log(data) // 123456\n})\n```\n\n```js promise\nfsPromises.readFile(path.resolve(__dirname, './1.txt'), 'utf-8')\n  .then(data => {\n    console.log(data) // 123456\n  })\n```\n\n## createReadStream\n`createReadStream(path[, options])` 创建可读流读取文件，返回一个可读流对象\n\n适合读取大文件，因为不会一次性将文件读取到内存中，而是分块读取\n\n```txt options配置项\n1、flags (标志) <string>:\n意义：指定文件系统标志。它定义了打开文件的行为，比如只读、只写、追加等。\n默认值：'r'，表示只读。\n\n2、encoding (编码) <string>:\n意义：指定用于解码文件数据的字符编码。如果未提供，则返回原始的 Buffer 数据。\n默认值：null，表示使用原始的 Buffer 数据。\n\n3、fd (文件描述符) <integer> | <FileHandle>:\n意义：提供一个现有的文件描述符或 FileHandle 对象，用于打开文件。\n默认值：null，表示通过文件路径打开。\n\n4、mode (权限掩码) <integer>:\n意义：指定文件的权限掩码（权限位）。用于在使用 fd 参数时设置文件权限。\n默认值：0o666，表示八进制权限掩码。\n\n5、autoClose (自动关闭) <boolean>:\n意义：指定是否在流结束时自动关闭文件描述符。\n默认值：true，表示流结束时自动关闭文件。\n\n6、emitClose (触发关闭事件) <boolean>:\n意义：指定是否在文件关闭时触发 'close' 事件。\n默认值：true，表示触发 'close' 事件。\n\n7、start (起始位置) <integer>:\n意义：指定从文件的哪个位置开始读取。\n默认值：未指定，从文件开头开始读取。\n\n8、end (结束位置) <integer>:\n意义：指定读取到文件的哪个位置为止。读取将在达到此位置时停止。\n默认值：Infinity，表示读取整个文件。\n\n9、highWaterMark (高水位标记) <integer>:\n意义：指定每次读取的最大字节数。当内部缓冲区的数据低于此值时，将继续读取。\n默认值：64 * 1024，表示每次最多读取 64 KB。\n\n10、fs (文件系统) <Object> | <null>:\n意义：提供一个自定义的文件系统对象。可以用于替代 Node.js 的默认文件系统模块。\n默认值：null，使用 Node.js 的默认文件系统模块。\n\n11、signal (中止信号) <AbortSignal> | <null>:\n意义：指定一个 AbortSignal 对象，用于中止文件读取操作。\n默认值：null，表示不使用中止信号。\n```\n\n```js\nconst readStream = fs.createReadStream(path.resolve(__dirname, './1.txt'), 'utf-8')\nreadStream.on('data', (data) => {\n  console.log(data) // 123456\n})\n```\n\n### readStream\n可读流对象 [ReadStream](https://nodejs.cn/api/fs.html#%E7%B1%BBfsreadstream) 是使用 fs.createReadStream() 创建的\n\nReadStream 继承自 [Readable](https://nodejs.cn/api/stream.html#%E5%8F%AF%E8%AF%BB%E6%B5%81)，因此它具有所有可读流的方法和事件\n\n事件：\n1. `open` 当文件被打开时触发\n2. `close` 当文件被关闭时触发\n3. `ready` 当底层资源（比如文件描述符）被分配时触发\n4. `data` 当有数据可读时触发\n5. `end` 当没有更多的数据可读时触发\n6. `error` 当在接收和写入数据的过程中发生错误时触发\n7. `pause` 当调用 stream.pause() 时触发，暂停读取数据\n8. `resume` 当调用 stream.resume() 时触发，恢复读取数据\n9. `readable` 当有数据可读时触发，必须显式调用stream.read()方法来从流中读取数据片段。\n\n属性：\n1. `bytesRead` 已读取的字节数\n2. `path` 文件路径或文件描述符\n3. `pending` 读取操作是否正在等待底层资源（比如文件描述符），如果底层文件尚未打开，即在触发 'ready' 事件之前，则此属性为 true。\n\n```js\nconst readStream = fs.createReadStream(path.resolve(__dirname, './1.txt'), 'utf-8')\nconsole.log(readStream.path) // c:\\chuckle\\qx\\NodeJS-new\\fs\\1.txt\nconsole.log(readStream.bytesRead) // 0\nconsole.log(readStream.pending) // true\n// 监听读取数据\nreadStream.on('data', (data) => {\n  console.log(readStream.bytesRead) // 14\n  console.log(readStream.pending) // false\n  console.log(data) // 123456\n})\n// 监听读取完成\nreadStream.on('end', () => {\n  console.log('读取完成')\n})\nreadStream.on('pause', () => {\n  console.log('暂停读取')\n}) // 监听暂停事件\nreadStream.pause() // 暂停读取\nreadStream.resume() // 恢复读取\nreadStream.on('resume', () => {\n  console.log('恢复读取')\n}) // 监听恢复事件\n```\n\n## writeFile文件写入\n`writeFile(file, data[, options], (err)=>{})` 将 data 写入到文件指定的 file 中，如果文件已存在则替换该文件\n\n```txt options配置项\n1. encoding <string>:\n意义：指定写入文件的字符编码。\n默认值：'utf8'。\n\n1. mode <integer>:\n意义：指定文件的权限掩码（权限位）。不会应用于已存在的文件。\n默认值：0o666。\n\n1. flag <string>:\n意义：指定用于打开文件的标志。\n默认值：'w'。\n\n1. signal <AbortSignal>:\n意义：指定一个 AbortSignal 对象，用于中止写入操作。\n默认值: null。\n\n1. flush <integer>:\n意义：如果所有数据都成功写入文件，并且 flush 是 true，则使用 fs.fsync() 来刷新数据。\n默认值： false。\n```\n\n```js\nfs.writeFile(path.resolve(__dirname, './1.txt'), '123456', (err) => {\n  console.log('写入成功')\n})\n```\n\n修改flag为a，表示追加写入\n\n```js\nfs.writeFile(path.resolve(__dirname, './2.txt'), \"123456\", {\n  flag: 'a'\n}, (err) => {\n  console.log('追加写入成功')\n})\n```\n\n## appendFile追加写入\n`appendFile(path, data[, options], (err)=>{})` 异步地将数据追加到文件，如果该文件尚不存在，则创建该文件\n\n```txt options配置项\n1. encoding <string>:\n意义：指定写入文件的字符编码。\n默认值：'utf8'。\n\n2. mode <integer>:\n意义：指定文件的权限掩码（权限位）。不会应用于已存在的文件。\n默认值：0o666。\n\n3. flag <string>:\n意义：指定用于打开文件的标志。\n默认值：'a'。\n\n4. flush <AbortSignal>:\n意义：如果是 true，则在关闭基础文件描述符之前将其刷新。\n默认值: false。\n```\n\n```js\nfs.appendFile(path.resolve(__dirname, './1.txt'), '123456', (err) => {\n  console.log('追加写入成功')\n})\n```\n\n## createWriteStream\n`createWriteStream(path[, options])` 创建一个可写流写入文件，返回一个可写流对象\n\n适合大内容的写入，因为不会一次性将内容写入文件，而是分块写入\n\n```txt options配置项\n1、flags (标志) <string>:\n意义：指定文件系统标志。它定义了打开文件的行为，比如只读、只写、追加等。\n默认值：'w'，表示只写。\n\n2、encoding (编码) <string>:\n意义：指定用于解码文件数据的字符编码。如果未提供，则返回原始的 Buffer 数据。\n默认值：null，表示使用原始的 Buffer 数据。\n\n3、fd (文件描述符) <integer> | <FileHandle>:\n意义：提供一个现有的文件描述符或 FileHandle 对象，用于打开文件。\n默认值：null，表示通过文件路径打开。\n\n4、mode (权限掩码) <integer>:\n意义：指定文件的权限掩码（权限位）。用于在使用 fd 参数时设置文件权限。\n默认值：0o666，表示八进制权限掩码。\n\n5、autoClose (自动关闭) <boolean>:\n意义：指定是否在流结束时自动关闭文件描述符。\n默认值：true，表示流结束时自动关闭文件。\n\n6、emitClose (触发关闭事件) <boolean>:\n意义：指定是否在文件关闭时触发 'close' 事件。\n默认值：true，表示触发 'close' 事件。\n\n7、start (起始位置) <integer>:\n意义：指定从文件的哪个位置开始写入。\n默认值：未指定，从文件末尾开始写入。\n\n8、signal (中止信号) <AbortSignal> | <null>:\n意义：指定一个 AbortSignal 对象，用于中止文件写入操作。\n默认值：null，表示不使用中止信号。\n\n9、highWaterMark (高水位标记) <number>:\n意义：指定每次写入的最大字节数。当内部缓冲区的数据低于此值时，将继续写入。\n默认值：16 * 1024，表示每次最多写入 16 KB。\n\n10、flush (刷新) <boolean>:\n意义：如果是 true，则在关闭基础文件描述符之前将其刷新\n默认值：false，表示不刷新。\n```\n\n```js\nconst writeStream = fs.createWriteStream(path.resolve(__dirname, './1.txt'), 'utf-8')\nwriteStream.write('123456', (err) => { })\nwriteStream.end();\nwriteStream.close();\n```\n\n### writeStream\n可写流对象 [WriteStream](https://nodejs.cn/api/fs.html#%E7%B1%BBfswritestream) 是使用 fs.createWriteStream() 创建的\n\nWriteStream 继承自 [Writable](https://nodejs.cn/api/stream.html#%E5%8F%AF%E5%86%99%E6%B5%81)，因此它具有所有可写流的方法和事件\n\n事件：\n1. `open` 当文件被打开时触发\n2. `close` 当文件被关闭时触发\n3. `ready` 当底层资源（比如文件描述符）被分配时触发\n4. `drain` 当 write() 方法返回 false 时触发\n5. `error` 当在接收和写入数据的过程中发生错误时触发\n6. `finish` 在调用 stream.end() 之后，而且缓冲区数据都已经传给底层系统之后触发。\n7. `pipe` 当调用 stream.pipe() 时触发\n8. `unpipe` 当调用 stream.unpipe() 时触发\n\n属性：\n1. `bytesWritten` 到目前为止写入的字节数。不包括仍在排队等待写入的数据。\n2. `close(err=>{})` 关闭 writeStream。触发close事件。\n3. `write(chunk[, encoding][, callback])` 写入数据，返回boolean表示是否可以继续写入。返回false需邓艾drain事件触发后再继续写入。\n4. `end([chunk[, encoding]][, callback])` 结束写入，之后不可再写入。触发finish事件\n5. `path` 流正在写入的文件的路径，即 fs.createWriteStream() 的第一个参数。\n6. `pending` 写入操作是否正在等待底层资源（比如文件描述符），如果底层文件尚未打开，即在触发 'ready' 事件之前，则此属性为 true。\n\n```js\nconst writeStream = fs.createWriteStream(path.resolve(__dirname, './1.txt'), 'utf-8')\nwriteStream.on('open', () => {\n  console.log('写入流打开')\n})\nwriteStream.on('ready', () => {\n  console.log('准备写入')\n})\n// 监听写入完成\nwriteStream.on('finish', () => {\n  console.log('写入完成')\n})\nwriteStream.on('close', () => {\n  console.log('写入流关闭')\n  writeStream.destroy();\n})\n// 写入数据\nwriteStream.write('123456', (err) => {\n  console.log(writeStream.bytesWritten) // 6\n  writeStream.close();\n})\nwriteStream.end(); // 结束写入，表示不再有数据写入（end之后不能调用write）\n```\n\n### drain事件\n可以连续调用 `writeStream.write()` 向流中写入数据，但缓冲区是有限的，当缓冲区满时，`writeStream.write()` 将返回 false，表示不应再写入数据，直到触发 **drain** 事件，表示缓冲区已清空，可以继续写入数据\n\n```js\nconst writableStream = fs.createWriteStream('example.txt', { \n  highWaterMark: 30 // 指定缓冲区大小为 30 字节\n});\n// 要写入的数据数组\nconst dataToWrite = [\n  '待到秋来九月八 ',\n  '我花开后百花杀 ',\n  '冲天香阵透长安 ',\n  '满城尽带黄金甲 '\n];\n// 递归写入数据的函数\nfunction writeDataArray(dataArray, index) {\n  if (index < dataArray.length) {\n    // 当前数据\n    const currentData = dataArray[index];\n    console.log(`正在写入数据: ${currentData}`);\n    // 尝试写入数据\n    if (!writableStream.write(currentData)) {\n      console.log('缓冲区已满，后续写入需等待本次写入完成...');\n      // 在 drain 事件触发后继续写入下一条数据\n      writableStream.once('drain', () => {\n        console.log(`成功写入数据: ${currentData}`);\n        console.log('缓冲区已空，可以继续写入...');\n        writeDataArray(dataArray, index + 1);\n      });\n    } else {\n      console.log(`成功写入数据: ${currentData}`);\n      // 数据已经完全写入，递归调用写入下一条数据\n      writeDataArray(dataArray, index + 1);\n    }\n  } else {\n    // 所有数据都已写入，结束可写流\n    console.log('所有数据都已写入');\n    writableStream.end();\n  }\n}\n// 调用写入函数，从数组的第一条数据开始\nwriteDataArray(dataToWrite, 0);\n```\n\n```\n正在写入数据: 待到秋来九月八 \n缓冲区已满，后续写入需等待本次写入完成...\n成功写入数据: 待到秋来九月八\n缓冲区已空，可以继续写入...\n\n正在写入数据: 我花开后百花杀\n缓冲区已满，后续写入需等待本次写入完成...\n成功写入数据: 我花开后百花杀\n缓冲区已空，可以继续写入...\n\n正在写入数据: 冲天香阵透长安\n缓冲区已满，后续写入需等待本次写入完成...\n成功写入数据: 冲天香阵透长安\n缓冲区已空，可以继续写入...\n\n正在写入数据: 满城尽带黄金甲\n缓冲区已满，后续写入需等待本次写入完成...\n成功写入数据: 满城尽带黄金甲\n缓冲区已空，可以继续写入...\n\n所有数据都已写入\n```\n\n## 创建文件\nNode没有创建文件的方法，但可以通过open和writeFile方法创建文件\n\n```js\n// 将flag设置为a，表示读取和追加，若文件不存在则创建\nfs.openSync(path.resolve(__dirname, './2.txt'), 'a+')\nfs.writeFileSync(path.resolve(__dirname, './3.txt'), \"\", {\n  flag: 'a+'\n})\n```\n\n## mkdir创建目录\n`mkdir(path[, options], callback)` 创建目录\n\n```txt options配置项\n1. recursive <boolean>:\n意义：指示是否应创建父目录（递归创建多级目录）。如果为 true，则缺少的目录将被创建。\n默认值：false。\n\n2. mode <integer>:\n意义：设置目录的权限掩码（权限位）。不会应用于已存在的目录。Windows 上不支持\n默认值：0o777。\n```\n\n```js\nfs.mkdir(path.resolve(__dirname, './test'), (err) => {\n  console.log('创建成功')\n})\nfs.mkdir(path.resolve(__dirname, './a/b/c'), {\n  recursive: true // 递归创建多级目录\n}, (err) => {\n  console.log('创建成功')\n})\n```\n\n## rm删除文件或目录\n`rm(path[, options], callback)` 删除文件或目录\n\n```txt options配置项\n1. force <boolean>:\n意义：当为 true 时，如果 path 不存在，则异常将被忽略\n默认值：false。\n\n2. maxRetries <integer>:\n意义：如果遇到 EBUSY、EMFILE、ENFILE、ENOTEMPTY 或 EPERM 错误，Node.js 将在每次尝试时以 retryDelay 毫秒的线性退避等待时间重试该操作。如果为 0，则不会重试。如果 recursive 选项不为 true，则忽略此选项\n默认值：0。\n\n3. recursive <boolean>:\n意义：指示是否应递归删除目录。如果为 false，则不会删除目录。\n默认值：false。\n\n4. retryDelay <integer>:\n意义：重试之间等待的毫秒数。如果 recursive 选项不为 true，则忽略此选项。\n默认值：100。\n```\n\n如果要删除目录，recursive 选项必须为 true\n\n```js\nfs.rm(path.resolve(__dirname, './a.txt'), (err) => {\n  console.log('删除成功')\n})\nfs.rm(path.resolve(__dirname, './a'), {\n  recursive: true // 递归删除目录\n}, (err) => {\n  console.log('删除成功')\n})\n```\n\n## rename文件重命名和移动\n`rename(oldPath, newPath, callback)` 将 oldPath 处的文件重命名为作为 newPath 提供的路径名。如果 newPath 已经存在，则它将被覆盖。\n\n```js\nfs.renameSync(\n  path.resolve(__dirname, './2.txt'), \n  // 重命名并移动文件，test文件夹需要存在\n  path.resolve(__dirname, './test/22.txt')\n)\n```\n\n## watch监视文件\n`watch(filename[, options][, listener]): <fs.FSWatcher>`\n\nfs.watch API 跨平台并非 100% 一致，并且在某些情况下不可用，详见：[注意事项](https://nodejs.cn/api/fs.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)\n\n在 Windows 上，如果监视目录被移动或重命名，则不会触发任何事件。 删除监视目录时报 EPERM 错误\n\n```txt options配置项\n1. persistent <boolean>:\n意义：指示只要正在监视文件，进程是否应继续运行。\n默认值：true。\n\n2. recursive <boolean>:\n意义：指示是应监视所有子目录，还是仅监视当前目录。 这在指定目录时适用，并且仅适用于受支持的平台。\n默认值：false。\n\n3. encoding <string> | <null>:\n意义：指定用于传递回调的文件名的字符编码。如果未指定，则返回原始的 Buffer。\n默认值：null。\n\n4. signal <AbortSignal> | <null>:\n意义：指定一个 AbortSignal 对象，用于中止监视器。\n默认值：null。\n```\n\n监视器回调接受eventType事件类型、filename文件名两个参数\n\n```js\nconst watcher = fs.watch(path.resolve(__dirname, './1.txt'),\n  (eventType, filename) => {\n    console.log(eventType, filename) // change 1.txt\n  }) // 监听文件变化\n// watcher.on('change', (eventType, filename) => {\n//   console.log(eventType, filename)\n// })\nwatcher.on('close', () => {\n  console.log('关闭watch')\n})\n// 修改文件，文件已存在会先替换再写入，触发两次change事件\nfs.writeFile(path.resolve(__dirname, './1.txt'), '123456', (err) => {\n  console.log('写入成功')\n  watcher.close() // 关闭监听\n})\n```\n\n## readdir读取目录\n`readdir(path[, options], (err, files)=>{})` 获取一个文件夹下所有文件名的数组\n\n```txt options配置项\n1. encoding <string>:\n意义：指定用于解码文件名的字符编码。\n默认值：'utf8'\n\n2. withFileTypes <boolean>:\n意义：如果为 true，则将结果数组中的条目替换为 fs.Dirent 对象。\n默认值：false\n\n3. recursive <boolean>:\n意义：指示是否应递归读取子目录。如果为 true，则返回的数组将包含子目录中的文件的名称。\n默认值：false\n```\n\n```js\nfs.readdir(path.resolve(__dirname, './'),{\n  recursive: true // 递归读取目录\n}, (err, files) => {\n  console.log(files)\n  // [ '1.txt', '2.txt', 'index.js', 'test', 'test\\\\a.txt' ]\n})\nfs.readdir(path.resolve(__dirname, './'),{\n  withFileTypes: true // 返回Dirent对象\n}, (err, files) => {\n  console.log(files)\n  // [\n  //   Dirent {\n  //     name: '1.txt',\n  //     path: 'c:\\\\chuckle\\\\qx\\\\NodeJS-new\\\\fs',\n  //     [Symbol(type)]: 1\n  //   }\n  // ......\n  // ]\n})\n```\n\n批量重命名文件，在文件名前加上0\n\n```js\nfs.readdir(__dirname + '/rename', (err, data)=>{\n    data.forEach((item, index)=>{\n        let data = item.split('.');\n        let [num, suffix] = data;\n        if(Number(num)<10){\n            num = '0' + num;\n        }\n        fs.renameSync(`${__dirname}/rename/${item}`, `${__dirname}/rename/${num}.${suffix}`);\n    });\n});\n```\n\n## 软/硬链接\n链接实际上是一种文件共享的方式\n\n`linkSync(existingPath, newPath)` 创建硬链接，newPath 指向 existingPath，两个文件共享同一份数据\n`symlinkSync(target, path[, type])` 创建软链接，path 指向 target，target 可以是绝对路径或相对路径，type 仅在 Windows 上有效，默认为 'file'，可以是 'dir' 或 'junction'\n\n```js\nconst file = path.resolve(__dirname, './1.txt')\nfs.linkSync(file, path.resolve(__dirname, 'index2.txt')) //硬链接\nfs.symlinkSync(file, path.resolve(__dirname, 'index3.txt')) //软连接\n```\n\n`unlink(path, err=>{})` 删除文件或符号链接\n\n```js\nfs.unlinkSync(path.resolve(__dirname, './index.txt')) // 删除文件\nfs.unlinkSync(path.resolve(__dirname, './index2.txt')) // 删除硬链接\nfs.unlinkSync(path.resolve(__dirname, './index3.txt')) // 删除软连接\n```\n\n硬链接：\n1. **文件共享**：硬链接允许多个文件指向同一个文件（同一个 inode），这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的修改会反映在所有引用文件上。\n2. **文件备份**：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始文件保持同步。\n3. **文件重命名**：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。\n\n只有删除原始文件和所有硬链接后，才会真正删除文件\n\n软链接：\n1. 软链接实际上是保存了一个绝对路径\n1. **跨文件系统**：软链接可以跨越文件系统，而硬链接不能。硬链接只能在同一文件系统上工作，因为它们指向的是 inode，而 inode 只在文件系统内部唯一。\n2. **符号链接**：软链接是一个特殊类型的文件，它包含指向另一个文件的路径名。软链接可以指向任何类型的文件，包括目录，而硬链接只能指向普通文件。\n\n重命名或移动原始文件的位置，会导致软链接失效，需要更新目标路径，而硬链接仍然有效\n\n### inode\n**inode (index node)**是指在许多类Unix文件系统中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、socket、管道等）。每个inode保存了文件系统对象数据的属性和磁盘块（block）位置。文件系统对象属性包含了各种元数据（如：最后修改时间），也包含用户组（owner ）和权限数据。\n\n文件储存在硬盘上，硬盘的最小存储单位叫做\"扇区\"（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个\"块\"（block）。这种由多个扇区组成的\"块\"，是文件存取的最小单位。\"块\"的大小，最常见的是4KB，即连续八个 sector组成一个 block。\n\n简单的说：每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。\n1. 文件的字节数\n2. 文件拥有者的User ID\n3. 文件的Group ID\n4. 文件的读、写、执行权限\n5. 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。\n6. 链接数，即有多少文件名指向这个inode\n7. 文件数据block的位置\n\n打开文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取inode 信息，然后根据 inode 信息中的文件数据所在 block 读出数据。\n\n`statSync(path[, options])` 可以查看文件的inode信息，返回 [fs.Stats](https://nodejs.cn/api/fs.html#class-fsstats)\n\n```txt options配置项\n1. bigint <boolean>:\n意义：指示是否应该返回 fs.BigInt 类型的数值，否则返回 number 类型的整数。\n默认值：false。\n\n2. throwIfNoEntry <boolean>:\n意义：如果文件系统条目不存在，是否会抛出异常，而不是返回 undefined\n默认值：false。\n```\n\n```js\nconst stat = fs.statSync(path.resolve(__dirname, './1.txt'))\nconsole.log(stat)\nconsole.log(stat.isDirectory()); // 是否是文件夹\nconsole.log(stat.isFile()); // 是否是普通文件\nconsole.log(stat.isSymbolicLink()) // 是否是软连接\nconsole.log(stat.isBlockDevice()) // 是否是块设备\nconsole.log(stat.isCharacterDevice()) // 是否是字符设备\nconsole.log(stat.isFIFO()) // 是否是FIFO\nconsole.log(stat.isSocket()) // 是否是Socket\n// Stats {\n//   dev: 1552965699,\n//   mode: 33206,\n//   nlink: 3,\n//   uid: 0,\n//   gid: 0,\n//   rdev: 0,\n//   blksize: 4096,\n//   ino: 10696049115741484,\n//   size: 6,\n//   blocks: 0,\n//   atimeMs: 1705127903632.4563,\n//   mtimeMs: 1705127903632.4563,\n//   ctimeMs: 1705127903632.4563,\n//   birthtimeMs: 1705043183050.7405,\n//   atime: 2024-01-13T06:38:23.632Z,\n//   mtime: 2024-01-13T06:38:23.632Z,\n//   ctime: 2024-01-13T06:38:23.632Z,\n//   birthtime: 2024-01-12T07:06:23.051Z\n// }\n```\n\n# Stream流\n[stream](https://nodejs.cn/api/stream.html)（流）是一种抽象的数据结构。就像数组或字符串一样，流是数据的集合。\n\n[一文搞定 Node.js 流 （Stream）](https://juejin.cn/post/6854573219060400141)\n\nstream 就像是水流，但默认是没有水的。stream.write 可以让水流中有水，也就是写入数据。\n\n**作用：**大文件资源拆分成小块（chunk），一块一块的运输，资源就像水流一样进行传输，无需将文件整个读入内存，减轻服务器压力。\n\n四种类型的流：\n1. [Readable](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamreadable) 可读流\n2. [Writable](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamwritable) 可写流\n3. [Duplex](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamduplex) 可读可写流，读和写是各自独立的\n4. [Transform](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamtransform) 可读可写流，读写在同一个流中，在读写过程中可以修改和变换数据\n\nNode中Stream无处不在，对服务器发起 http 请求的 request/response 对象也是 Stream。\n\n## Readable可读流\n[Readable](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamreadable)\n\n可读流中分为2种模式\n1. 流动模式：监听data事件，一旦有数据就会触发data事件，数据作为回调的参数，直到数据全部读取完毕\n2. 暂停模式：监听readable事件，当流有了新数据或到了流结束之前触发readable事件，需要显示调用read([size])读取数据\n\n暂停模式切换到流动模式：\n1. 监听 data 事件\n2. 调用 stream.resume()方法\n3. 调用 stream.pipe()方法将数据发送到可写流\n\n流动模式切换到暂停模式：\n1. 如果不存在管道目标，调用 stream.pause() 方法\n2. 如果存在管道目标，调用 stream.unpipe() 并取消 data 事件监听\n\n```js Readable简单示例\nconst { Readable } = require('stream')\nconst inStream = new Readable() // 可以在其中实现_read方法\ninStream.push('hello world') // 写入数据\ninStream.push('hello node')\ninStream.push(null) // 没有数据了\n// 将这个可读流，导入到可写流 process.stdout。\ninStream.pipe(process.stdout)\n```\n\n**详见fs中的[createReadStream](#createreadstream)**\n\n## Writable可写流\n[Writable](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamwritable)\n\n```js Writable简单示例\nconst { Writable } = require('stream')\nconst outStream = new Writable({\n  // 实现_write方法\n  write(chunk, encoding, callback) {\n    console.log(chunk.toString())\n    callback() // 通知流处理继续\n  }\n})\nprocess.stdin.pipe(outStream);\n```\n\n**详见fs中的[createWriteStream](#createwritestream)**\n\n## Duplex流\n[Duplex](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamduplex) 可读可写流，读和写是独立的，各自独立缓存区，既可当成可读流来使用，也可当成可写流来使用\n\nDuplex 拥有 Writable 和 Readable 所有方法和事件，可以同时实现 read() 和 write() 方法。\n\n```js\nconst { Duplex } = require('stream')\n\nconst duplex = new Duplex({\n  // 可读端底层读取逻辑\n  read(size) {\n    if (this.currentCharCode > 90) {\n      this.push('\\n')\n      this.push(null) // null 代表流没有数据了，不会触发data事件\n    } else {\n      // 通过push方法将数据推送到可读流，每次push都会触发一次data事件\n      this.push(String.fromCharCode(this.currentCharCode++))\n    }\n  },\n  // 可写端底层写逻辑\n  write(buf, enc, next) {\n    process.stdout.write('write: ' + buf.toString().toUpperCase())\n    next() // 通知流处理继续\n  }\n})\n\nduplex.currentCharCode = 65;\nduplex.pipe(process.stdout);\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\nprocess.stdin.pipe(duplex);\n// 小写输入转为大写\n// aaaa\n// write: AAAA\n```\n\n## Transform流\n[Transform](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamtransform) 流属于 [Duplex](https://nodejs.cn/api/stream.html#%E7%B1%BBstreamduplex) 流，其中输出以某种方式从输入计算得出。\n例如进行压缩、加密或解密数据的 [zlib](https://nodejs.cn/api/zlib.html) 流或 [crypto](https://nodejs.cn/api/crypto.html) 流。\n\n使用也很简单，`new Transform({ transform() })`，传入包括实现了 transform() 方法的对象，该方法接收三个参数：chunk、encoding、callback\n1. chunk：读取到的数据块\n2. encoding：编码方式\n3. callback：回调函数，通知流处理继续\n\n读数据：`chunk.toString()`\n写数据 `this.push(xxx)`\n\n```js 以大写的格式打印任何键入的字符\nconst {Transform} = require('stream')\n\nconst upperCaseTr = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase())\n    callback();\n  }\n})\n\nprocess.stdin\n  .pipe(upperCaseTr) \n\t.pipe(process.stdout)\n```\n\n## pipe管道\npipe 管道可以连接两个流，将一个流的输出作为另一个流的输入\n\n`stream1.pipe(stream2)`\nstream1 是发出数据的流，一个可读流。\nstream2 是写入数据的流，一个可写流。\n\nreadable.pipe() 方法将 Writable 流绑定到 readable，使其自动切换到流动模式并将其所有数据推送到绑定的 Writable。数据流将被自动管理，以便目标 Writable 流不会被更快的 Readable 流漫过。\n\n例如响应大文本和大图片：\n\n```js\nconst fs = require('fs')\nconst http = require('http')\nconst path = require('path')\n\nconst server = http.createServer();\n\nserver.on('request', (request, response) => {\n  // 根据请求路径判断是文本请求还是图片请求\n  if (request.url === '/txt') {\n    const stream = fs.createReadStream(path.resolve(__dirname, './big_data.txt'));\n    // 通过管道方式写入响应，读多少传多少\n    stream.pipe(response);\n  } else if (request.url === '/img') {\n    const stream = fs.createReadStream(path.resolve(__dirname, './big_img.png'));\n    // 设置响应头，告诉浏览器这是一个图片\n    response.setHeader('Content-Type', 'image/png');\n    stream.pipe(response);\n  } else {\n    // 处理其他请求或返回 404 Not Found\n    response.statusCode = 404;\n    response.end('Not Found');\n  }\n});\n\nserver.listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n});\n```\n\n**链式操作：**一个水流可以经过无限个管道，数据流也一样。在链式操作过程中可以对数据进行转换、压缩等处理。\n\n```js\nconst fs = require('fs');\nconst path = require('path');\nconst zlib = require('zlib');\nconst stream = require('stream');\n\n// 创建可读流\nconst readStream = fs.createReadStream(path.resolve(__dirname, 'input.txt'));\n// 创建可写流\nconst writeStream = fs.createWriteStream(path.resolve(__dirname, 'output.txt.gz'));\n\n// 创建转换流，将文本内容转换为大写\nconst upperCaseTransform = new stream.Transform({\n  transform(chunk, encoding, callback) {\n    // 将数据转换为大写\n    const upperCaseData = chunk.toString().toUpperCase();\n    // 将转换后的数据推送到可读流\n    this.push(upperCaseData);\n    // 转换完成后调用回调函数，通知流处理继续\n    callback();\n  }\n});\n\n// 创建压缩流\nconst gzipStream = zlib.createGzip();\n\n// 将各个流连接起来形成管道链式操作\nreadStream\n  .pipe(upperCaseTransform) // 转换为大写\n  .pipe(gzipStream) // 压缩\n  .pipe(writeStream) // 写入文件\n\n// 监听完成事件\nwriteStream.on('finish', () => {\n  console.log('文件处理完成');\n});\n```\n\n既然都是 stream 那么其它流方法也能套在链式过程中\n\n```js\nfs.createReadStream(path.resolve(__dirname, 'big_data.txt'))\n  .pipe(zlib.createGzip())\n  // 每次产生一块压缩数据时，执行提供的回调函数\n  .on('data', () => process.stdout.write(\".\")) // 打出进度条\n  .pipe(fs.createWriteStream(path.resolve(__dirname, 'big_data.txt.gz')))\n```\n\n## 管道原理\n管道可以认为是两个事件的封装\n1. 监听 data 事件，stream1 一有数据就塞给 stream2\n2. 监听 end 事件，当 stream1 停了，就停掉 stream2\n\n```js\nstream1.on('data', (chunk) => {\n\tstream2.write(chunk)\n})\nstream1.on('end', () => {\n\tstream2.end()\n})\n```\n\n# crypto\n[crypto](https://nodejs.cn/api/crypto.html) 模块提供了加密功能，其中包括了用于 OpenSSL 散列、HMAC、加密、解密、签名、以及验证的函数的一整套封装。\n\ncrypto有非常多的API，但主要有几个类，每个类都有许多[模块方法](https://nodejs.cn/api/crypto.html#nodecrypto-%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7)（`create***()`）去生成其实例，然后调用实例的方法去实现加密解密等功能\n1. [Cipher](https://nodejs.cn/api/crypto.html#%E7%B1%BBcipher)类的实例用于对称加密数据\n2. [Decipher](https://nodejs.cn/api/crypto.html#%E7%B1%BBdecipher)类的实例用于解密数据\n3. [Hash](https://nodejs.cn/api/crypto.html#%E7%B1%BBhash)类是用于创建数据的哈希摘要的实用工具\n4. [Hmac](https://nodejs.cn/api/crypto.html#%E7%B1%BBhmac)类是用于创建加密 HMAC 摘要的实用工具\n5. [KeyObject](https://nodejs.cn/api/crypto.html#%E7%B1%BBkeyobject)类表示对称或非对称密钥，每种密钥暴露不同的功能\n6. [Sign](https://nodejs.cn/api/crypto.html#%E7%B1%BBsign)类是用于生成签名的实用工具\n7. [Verify](https://nodejs.cn/api/crypto.html#%E7%B1%BBverify)类是用于验证签名的实用工具\n\n本文后面需要加密的data都为 'hello world'\n\n## 摘要Hash\n摘要（digest）：将长度不固定的消息作为输入，通过运行hash函数，生成固定长度的输出，这段输出就叫做摘要，具有唯一性。通常用来验证消息完整、未被篡改。摘要运算是不可逆的，但可以撞库破解。\n\n摘要算法：MD5、SHA1、SHA256、SHA512\n\n`crypto.getHashes()` 返回支持的哈希算法名称的数组\n\n```js\nconsole.log(crypto.getHashes())\n// [\n//   'RSA-MD5',\n//   'RSA-RIPEMD160',\n//   'RSA-SHA1',\n//   'RSA-SHA1-2',\n//   'RSA-SHA224',\n//   'RSA-SHA256',\n//   'RSA-SHA3-224',\n//   'RSA-SHA3-256',\n//   'RSA-SHA3-384',\n//   'RSA-SHA3-512',\n//   'RSA-SHA384',\n//   'RSA-SHA512',\n//   'RSA-SHA512/224',\n//   'RSA-SHA512/256',\n//   'RSA-SM3',\n//   'blake2b512',\n//   'blake2s256',\n//   'id-rsassa-pkcs1-v1_5-with-sha3-224',\n//   'id-rsassa-pkcs1-v1_5-with-sha3-256',\n//   'id-rsassa-pkcs1-v1_5-with-sha3-384',\n//   'id-rsassa-pkcs1-v1_5-with-sha3-512',\n//   'md5',\n//   'md5-sha1',\n//   'md5WithRSAEncryption',\n//   'ripemd',\n//   'ripemd160',\n//   'ripemd160WithRSA',\n//   'rmd160',\n//   'sha1',\n//   'sha1WithRSAEncryption',\n//   'sha224',\n//   'sha224WithRSAEncryption',\n//   'sha256',\n//   'sha256WithRSAEncryption',\n//   'sha3-224',\n//   'sha3-256',\n//   'sha3-384',\n//   'sha3-512',\n//   'sha384',\n//   'sha384WithRSAEncryption',\n//   'sha512',\n//   'sha512-224',\n//   'sha512-224WithRSAEncryption',\n//   'sha512-256',\n//   'sha512-256WithRSAEncryption',\n//   'sha512WithRSAEncryption',\n//   'shake128',\n//   'shake256',\n//   'sm3',\n//   'sm3WithRSAEncryption',\n//   'ssl3-md5',\n//   'ssl3-sha1'\n// ]\n```\n\n```js\nconst data = 'hello world'\n// 创建哈希对象，并使用 MD5 算法\nconst hash = crypto.createHash('md5')\n// 更新哈希对象的数据\nhash.update(data)\n// 计算哈希值，并以十六进制字符串形式输出\nconst digest = hash.digest('hex')\nconsole.log(digest) // 5eb63bbbe01eeed093cb22bb8f5acdc3\n```\n\n## MAC、HMAC\nMAC（Message Authentication Code）：消息认证码，用以保证数据的完整性。运算结果取决于消息本身、秘钥。\n\nMAC可以有多种不同的实现方式，比如Hash、HMAC。\n\nHMAC（Hash-based Message Authentication Code）：可以粗略地理解为带秘钥的Hash函数。主要是为了防止Hash碰撞攻击。\n\n```js\nconst hmac = crypto.createHmac('md5', '123456')\nhmac.update(data)\nconst digest = hmac.digest('hex')\nconsole.log(digest) // 5eb63bbbe01eeed093cb22bb8f5acdc3\n```\n\n## 对称加密\n**加密/解密：**给定明文，通过一定的算法，产生加密后的密文，这个过程叫加密。反过来就是解密。\n\n**秘钥：**为了进一步增强加/解密算法的安全性，在加/解密的过程中引入了秘钥。秘钥可以视为加/解密算法的参数，在已知密文的情况下，如果不知道解密所用的秘钥，则无法将密文解开。\n\n根据加密、解密所用的秘钥是否相同，可以将加密算法分为对称加密、非对称加密。\n\n常见的对称加密算法：DES、3DES、AES、Blowfish、RC5、IDEA。\n\n`createCipher()`(已弃用) 或 `createCipheriv()` 方法用于创建 Cipher 实例，使用初始化向量IV增加加密强度，IV 通常只是添加到未加密的密文消息中，解密后会被删除。\n\n`createDecipher()`(已弃用) 或 `createDecipheriv()` 方法用于创建 Decipher 实例，使用相同的密钥和IV进行解密。\n\n```js 加密过程\n// 生成一个随机的 16 字节的初始化向量 (IV)\nconst iv = crypto.randomBytes(16)\n// 生成一个随机的 32 字节的密钥\nconst key = crypto.randomBytes(32)\n// 创建一个 AES-256-CBC 加密算法的 cipher 对象\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv)\n// 对输入数据进行加密，并输出加密结果的十六进制表示\n// 可以使用新数据多次调用 cipher.update() 方法，直到调用 cipher.final()\ncipher.update(data, \"utf-8\", \"hex\")\n// 以十六进制表示输出加密结果\n// 一旦调用了 cipher.final() 方法，则 Cipher 对象就不能再用于加密数据\nconst result = cipher.final('hex')\nconsole.log(result) // 5eb63bbbe01eeed093cb22bb8f5acdc3\n```\n\n```js 解密过程\n// 创建一个 AES-256-CBC 解密算法的 decipher 对象，使用相同的密钥和IV\nconst decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)\n// 对加密数据进行解密，并输出解密结果的 UTF-8 字符串\n// 可以使用新数据多次调用 decipher.update() 方法，直到调用 decipher.final()\ndecipher.update(result, \"hex\", \"utf-8\")\n// 以 UTF-8 字符串表示输出解密结果\n// 一旦调用了 decipher.final() 方法，则 Decipher 对象就不能再用于解密数据\nconst decrypted = decipher.final('utf-8')\nconsole.log(decrypted) // hello world\n```\n\n### 分组加密\n常见的对称加密算法，如AES、DES都采用了分组加密模式，三个重要概念：模式、初始化向量、填充。\n\n**分组加密：**将（较长的）明文拆分成固定长度的块，然后对拆分的块按照特定的模式进行加密。\n\n常见**模式**有：ECB（不安全）、CBC（最常用）、CFB、OFB、CTR等\n\n**初始化向量IV：**\n为了增强算法的安全性，部分分组加密模式（CFB、OFB、CTR）中引入了初始化向量（IV），使得加密的结果随机化。也就是说，对于同一段明文，IV不同，加密的结果不同。\n以CBC为例，每一个数据块，都与前一个加密块进行异或运算后，再进行加密。对于第一个数据块，则是与IV进行异或。\nIV的大小跟数据块的大小有关（128位，16字节），跟秘钥的长度无关。\n\n**填充padding：**\n部分加密模式，当最后一个块的长度小于128位时，需要通过特定的方式进行填充。（ECB、CBC需要填充，CFB、OFB、CTR不需要填充）\n\n## 非对称加密\n对称加密的密钥是相同的，如果密钥泄露，加密的数据就不安全了。\n\n非对称加密使用一对密钥，公钥和私钥，公钥加密，私钥解密。\n公钥是公开的，任何人都可以获得，并对数据进行加密。私钥是保密的，只有私钥的拥有者才能解密。\n\n**生成密钥对：**`crypto.generateKeyPairSync(type[, options])`，type为加密算法，options为配置项，返回一个对象，包含公钥和私钥。\n**加密函数：**`crypto.publicEncrypt(publicKey, buffer)`，publicKey为公钥，buffer为要加密的数据，返回加密后的数据。\n**解密函数：**`crypto.privateDecrypt(privateKey, buffer)`，privateKey为私钥，buffer为要解密的数据，返回解密后的数据。\n\n```js\nconst { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {\n  modulusLength: 2048, // 模数长度，默认 2048 位，越长安全性越高，但是性能越差\n}); // 生成 RSA 密钥对\n// 使用公钥加密数据\nconst encrypted = crypto.publicEncrypt(publicKey, Buffer.from(data, 'utf-8'))\nconsole.log(encrypted.toString('hex')) // 227d9e20fe66d854ec9ddda.......\n// 使用私钥解密数据\nconst decrypted = crypto.privateDecrypt(privateKey, encrypted)\nconsole.log(decrypted.toString('utf-8')) // hello world\n```\n\n### generateKeyPairSync\n`generateKeyPairSync(type, options)` 用于生成密钥对\n\n```txt\ntype: <string> 必须是 'rsa'、'rsa-pss'、'dsa'、'ec'、'ed25519'、'ed448'、'x25519'、'x448' 或 'dh'。\noptions: <Object>\n  modulusLength: <number> 以位为单位的密钥大小（RSA、DSA）。\n  publicExponent: <number> 公共指数 (RSA)。 默认值： 0x10001。\n  hashAlgorithm: <string> 消息摘要的名称 (RSA-PSS)。\n  mgf1HashAlgorithm: <string> MGF1 (RSA-PSS) 使用的消息摘要的名称。\n  saltLength: <number> 以字节为单位的最小盐长度 (RSA-PSS)。\n  divisorLength: <number> q 的大小（以位为单位）(DSA)。\n  namedCurve: <string> 要使用的曲线的名称 (EC)。\n  prime: <Buffer> 主要参数 (DH)。\n  primeLength: <number> 以位 (DH) 为单位的素数长度。\n  generator: <number> 自定义生成器 (DH)。 默认值： 2。\n  groupName: <string> Diffie-Hellman 组名 (DH)。 参见 crypto.getDiffieHellman()。\n  paramEncoding: <string> 必须是 'named' 或 'explicit' (EC)。 默认值： 'named'。\n  publicKeyEncoding: <Object> 参见 keyObject.export()。\n  privateKeyEncoding: <Object> 参见 keyObject.export()。\n返回： <Object>\n  publicKey: <string> | <Buffer> | <KeyObject>\n  privateKey: <string> | <Buffer> | <KeyObject>\n```\n\n如果指定了 publicKeyEncoding 或 privateKeyEncoding，则此函数的行为就像对其结果调用了 [keyObject.export(options)](https://nodejs.cn/api/crypto.html#keyobjectexportoptions)，两者参数也与其一致。否则，密钥的相应部分将作为 KeyObject 返回。\n\n对公钥进行编码时，建议使用 'spki'。 对私钥进行编码时，建议使用强密码的 'pkcs8'，并对密码进行保密。\n\n```js\nconst { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {\n  modulusLength: 2048, // 模数长度，默认 2048 位，越长安全性越高，但是性能越差\n  publicKeyEncoding: { // 公钥的输出格式\n    type: 'spki', // 密钥编码类型\n    format: 'pem' // 输出格式\n  },\n  privateKeyEncoding: { // 私钥的输出格式\n    type: 'pkcs8', // 密钥编码类型\n    format: 'pem' // 输出格式\n  }\n});\nconsole.log(privateKey)\n// -----BEGIN PRIVATE KEY-----\n// MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCs/KwPf39GSmgc\n// ......\n// WcDOr4jH76xt0OwEZNVn2A==\n// -----END PRIVATE KEY-----\nconsole.log(publicKey)\n// -----BEGIN PUBLIC KEY-----\n// MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArPysD39/RkpoHLHiXTSQ\n// ......\n// dwIDAQAB\n// -----END PUBLIC KEY-----\n```\n\n## 数字签名\n数字签名属于非对称加密，用于验证数据的**完整性**和**来源**，私钥签名，公钥验证。\n\n发送方生成签名：\n  1. 计算原始信息的摘要。\n  2. 通过私钥对摘要进行签名，得到电子签名。\n  3. 将原始信息、电子签名，发送给接收方。\n\n接收方验证签名：\n  1. 通过公钥解开电子签名，得到摘要D1。（如果解不开，信息来源主体校验失败）\n  2. 计算原始信息的摘要D2。\n  3. 对比D1、D2，如果D1等于D2，说明原始信息完整、未被篡改。\n\n```js\nconst { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {\n  modulusLength: 2048,\n  publicKeyEncoding: {\n    type: 'spki',\n    format: 'pem'\n  },\n  privateKeyEncoding: {\n    type: 'pkcs8',\n    format: 'pem'\n  }\n});\n// 创建签名对象，使用 SHA256 算法\nconst sign = crypto.createSign('RSA-SHA256');\n// 更新签名对象的数据\nsign.update(data);\n// 私钥计算签名值，并以十六进制字符串形式输出\nconst signature = sign.sign(privateKey, 'hex');\nconsole.log(signature) // 847f62482332b9abaa3a......\n\n// 创建验证对象，使用 SHA256 算法\nconst verify = crypto.createVerify('RSA-SHA256');\n// 更新验证对象的数据\nverify.update(data);\n// 公钥验证签名值是否正确，以及数据是否被篡改\nconst result = verify.verify(publicKey, signature, 'hex');\nconsole.log(result); // true，验证成功，数据没有被篡改\n```\n\n# 脚手架\n脚手架是一种自动化的工具，用于快速生成项目的基础结构，包括目录结构、配置文件、代码规范等。\n例如vue-cli、create-react-app、express-generator\n\n作用：\n1. 快速初始化项目\n2. 保证协作团队项目的统一\n3. 添加通用的组件或者配置\n\n脚手架一般通过命令行的方式使用，例如vue-cli，通过`vue create <name>`命令创建项目，首先设置项目名称，然后可以选择预设的模板，如是否需要使用TS、是否需要使用eslint等，最后会自动下载依赖、模板，创建项目。\n\n重要的就是与命令行的交互，以及模板的下载。\n可以使用readline和fs去实现，但是非常麻烦，也不好看，还是使用现成的库方便。\n1. [commander](https://www.npmjs.com/package/commander) 执行复杂的命令\n2. [inquirer](https://www.npmjs.com/package/inquirer)\t问答交互\n3. [download-git-repo](https://www.npmjs.com/package/download-git-repo) 下载远程模板\n4. [chalk](https://www.npmjs.com/package/chalk) 让 console.log 带颜色，比如成功时的绿色\n5. [ora](https://www.npmjs.com/package/ora) 命令行 loading 效果\n\n在入口文件添加特殊注释`#!/usr/bin/env node`告诉终端，这个文件要使用 node 去执行\n\n然后在package.json中添加bin字段，指定命令的入口文件，在本地测试时，使用`npm link`将命令链接到全局\n\n```json\n{\n  \"bin\": {\n    \"test-cli\": \"index.js\"\n  }\n}\n```\n\n编写代码完成脚手架的功能\n\n```js index.js\n#!/usr/bin/env node\nimport chalk from 'chalk'\nimport inquirer from 'inquirer'\nimport { Command } from 'commander'\nimport * as util from './util.js'\nimport pkg from './package.json' assert { type: \"json\" };\n\n// 创建命令行对象\nconst program = new Command()\n\n// 定义 --version 参数\nprogram.version(pkg.version)\n\n// 定义命令\nprogram.command('create <name>')\n  .alias('c') // 命令别名\n  .description('创建项目') // 命令描述\n  .action((name) => {\n    inquirer.prompt([\n      {\n        type: 'input', // 类型为input输入框\n        name: 'projectName', // 问题名称\n        message: '请输入项目名称', // 问题描述\n        default: name // 默认值\n      },\n      {\n        type: 'confirm',\n        name: 'isTS',\n        message: '是否使用TypeScript',\n        default: false\n      }\n    ]).then(res => {\n      // 结果返回一个{ <name>: <value> }对象\n      if (util.checkDirExist(res.projectName)) {\n        console.log(chalk.red('文件夹已存在'))\n        return\n      }\n      const repo = \"github:qxchuckle/rollup-template\"\n      if (res.isTS) {\n        util.downloadTemplate('main', repo, res.projectName)\n      } else {\n        util.downloadTemplate('main', repo, res.projectName)\n      }\n    })\n  })\n\n// 解析命令行参数\nprogram.parse(process.argv)\n```\n\n```js util.js\nimport fs from 'fs'\nimport downloadGitRepo from 'download-git-repo'\nimport ora from 'ora'\n\n// 检查路径是否存在\nexport function checkDirExist(path) {\n  try {\n    return fs.existsSync(path)\n  } catch (error) {\n    return false\n  }\n}\n\nexport function downloadTemplate(branch, repo, dest) {\n  return new Promise((resolve, reject) => {\n    const spinner = ora('正在下载模板...')\n    spinner.start()\n    downloadGitRepo(`${repo}#${branch}`, dest, {\n      clone: true\n    }, (err) => {\n      if (err) {\n        spinner.fail('下载失败')\n        reject(err)\n      } else {\n        spinner.succeed('下载成功')\n        resolve()\n      }\n    })\n  })\n}\n```\n\n# markdown渲染\nmarkdown渲染是常见的需求，使用[marked](https://www.npmjs.com/package/marked)、[marked-highlight](https://www.npmjs.com/package/marked-highlight)、[highlight](https://www.npmjs.com/package/highlight.js)，将markdown转换为html并高亮代码，再使用[ejs](https://www.npmjs.com/package/ejs)模板引擎渲染完整页面、[browser-sync](https://www.npmjs.com/package/browser-sync)实现构建网站时保持多个浏览器和设备同步\n\n```js index.js\nimport { Marked } from \"marked\";\nimport { markedHighlight } from \"marked-highlight\";\nimport hljs from 'highlight.js';\nimport fs from \"fs\";\nimport path from \"path\";\nimport { fileURLToPath } from 'url';\nimport browserSync from \"browser-sync\";\nimport ejs from \"ejs\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// 生成marked实例，用于渲染md\nconst marked = new Marked(\n  markedHighlight({\n    langPrefix: 'hljs language-', // 紧接在代码块打开标记之后找到的语言标记被附加到它，形成类属性\n    highlight(code, lang, info) {\n      const language = hljs.getLanguage(lang) ? lang : 'plaintext';\n      return hljs.highlight(code, { language }).value;\n    }\n  })\n);\n// 读取文件\nconst readFile = (file) => {\n  return fs.readFileSync(path.resolve(__dirname, file), 'utf8');\n}\n// 启动服务\nconst server = () => {\n  globalThis.browser = browserSync.create()\n  browser.init({\n    server: {\n      baseDir: __dirname,\n      index: 'index.html',\n    }\n  })\n}\n// 防抖\nconst debounce = (func, delay) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func(...args);\n    }, delay);\n  };\n};\n// 监听文件变化，实现热更新\nconst watch = () => {\n  const debouncedInit = debounce(() => {\n    init(() => {\n      browser.reload();\n    });\n  }, 100);\n  fs.watch(path.resolve(__dirname, './01.md'), (eventType, filename) => {\n    // 修改文件会连续触发多次change事件，使用防抖函数，只执行最后一次\n    debouncedInit();\n  });\n}\n\n// css资源\nconst css = [\n  'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css',\n  'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css',\n];\n\nfunction init(callback) {\n  // 模板渲染\n  ejs.renderFile(path.resolve(__dirname, 'index.ejs'), {\n    title: 'Markdown',\n    content: marked.parse(readFile('01.md')),\n    css,\n  }, (err, str) => {\n    if (err) {\n      console.log(err);\n      return;\n    }\n    const writeStream = fs.createWriteStream(path.resolve(__dirname, './index.html'), 'utf-8');\n    writeStream.on('ready', () => {\n      console.log('开始写入')\n    });\n    writeStream.write(str, () => {\n      console.log('写入完成')\n      callback && callback();\n      writeStream.destroy();\n    });\n    writeStream.end(); // 结束写入，表示不再有数据写入（end之后不能调用write）\n  });\n}\n// 启动\ninit(() => {\n  server(); // 启动服务\n  watch(); // 启动监听\n});\n```\n\n```html index.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>\n    <%= title %>\n  </title>\n  <% css.forEach(function(cssPath) { %>\n    <link rel=\"stylesheet\" href=\"<%= cssPath %>\">\n    <% }); %>\n</head>\n<body>\n  <article class=\"markdown-body\">\n    <%- content %>\n  </article>\n</body>\n</html>\n```\n\n# zlib\n[zlib](https://nodejs.cn/api/zlib.html) 模块提供了使用 Gzip、Deflate/Inflate、以及 Brotli 实现的压缩功能。\n\n常用的两个压缩算法：gzip、deflate。分别对应 `zlib.createGzip()`、`zlib.createDeflate()` 进行压缩，`zlib.createGunzip()`、`zlib.createInflate()` 进行解压。\n\n通过管道可以很方便的实现压缩和解压缩\n\n```js 压缩\nfs.createReadStream(path.join(__dirname, 'big_data.txt'))\n  .pipe(zlib.createGzip()) // 使用gzip压缩\n  .pipe(fs.createWriteStream(path.join(__dirname, 'big_data.txt.gz')))\n\nfs.createReadStream(path.join(__dirname, 'big_data.txt'))\n  .pipe(zlib.createDeflate()) // 使用Deflate压缩\n  .pipe(fs.createWriteStream(path.join(__dirname, 'big_data.txt.deflate')))\n```\n\n```js 解压\nfs.createReadStream(path.join(__dirname, 'big_data.txt.gz'))\n  .pipe(zlib.createGunzip()) // 使用gzip解压\n  .pipe(fs.createWriteStream(path.join(__dirname, 'big_data.txt')))\n\nfs.createReadStream(path.join(__dirname, 'big_data.txt.deflate'))\n  .pipe(zlib.createInflate()) // 使用Deflate解压\n  .pipe(fs.createWriteStream(path.join(__dirname, 'big_data.txt')))\n```\n\ndeflate是一种使用了LZ77算法与哈夫曼编码（Huffman Coding）实现的无损数据压缩算法。它是一个无专利的，可以自由使用的算法。\ngizp是一种以0x1F8B标志开头的数据格式，其内部通常采用DEFLATE算法对数据进行压缩。\n\n> \"Deflate\" 和 \"DEFLATE\" 实际上是指相同的压缩算法，区别在于对待大小写的不同。\"Deflate\" 是一般的术语，表示该压缩算法。而 \"DEFLATE\" 则是一个特定的字母大小写形式，通常用于指代该算法在特定上下文中的实现或特定文件格式中的使用，比如在 gzip 文件格式中\n\n## http请求压缩\n客户端在向服务端发起请求时，会在请求头中添加**accept-encoding**字段，其值标明客户端**支持**的压缩内容编码格式\n服务端在对返回内容执行压缩后，通过在响应头中添加**content-encoding**，来告诉浏览器内容**实际**压缩使用的编码算法\n\ngzip 的核心是 Deflate，而它使用了 LZ77 算法与 Huffman 编码来压缩文件，**重复度越高的文件可压缩的空间就越大**。\n对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。主要用于 HTTP 文件传输中，比如 JS、CSS 等，但一般不会压缩图片。\n\n```js\nconst server = http.createServer();\nconst zipList = {\n  gzip: zlib.createGzip(),\n  deflate: zlib.createDeflate(),\n  br: zlib.createBrotliCompress()\n}\n\nserver.on('request', (req, res) => {\n  const acceptedEncodings = req.headers['accept-encoding'].split(', ');\n  console.log(acceptedEncodings); // gzip, deflate, br\n  const stream = fs.createReadStream(path.resolve(__dirname, './big_data.txt'));\n  if (acceptedEncodings && acceptedEncodings.length > 0) {\n    const encoding = acceptedEncodings[0].trim();\n    res.setHeader('Content-Encoding', encoding);\n    stream.pipe(zipList[encoding]).pipe(res);\n  } else {\n    stream.pipe(res);\n  }\n});\n\nserver.listen(8888, () => {\n  console.log('Server is running on http://localhost:8888');\n});\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"Node-回眸[一]","url":"/article/98a1db82.html","content":"\n# 书接上回\n虽然去年已经学习了NodeJS，并且也能用Express+Mongodb写一些后端业务，但这更多是业务逻辑上的，比如会话控制、前后端交互这些，对于NodeJS本身，社区、内置模块、进程、事件循环等等，仍是一知半解。\n\nNodeJS非常强大，那就再次看看它吧。文档：[cn](https://www.nodejs.com.cn/)、[en](https://nodejs.org/en)\n\n**学习资料：**\n[Node.js-小满zs](https://www.bilibili.com/video/BV1cV4y1B7P4)\n[《深入理解Node.js：核心思想与源码分析》](https://yjhjstz.gitbooks.io/deep-into-node/content/)\n\n# 体系结构\nNodeJS是使用C++编写的基于ChromeV8引擎，开源、跨平台的JavaScript运行环境。\n\n现在，可以将上面这句话稍微扩展下了。\n\nNode主要分为四大部分，**Node Standard Library**，**Node Bindings**，**V8**，**Libuv**，架构图如下:\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/74-1.webp width=\"60%\">\n\n**Node Standard Library** 是标准库，如fs、http模块，直接提供给开发者调用。\n**Node Bindings** 是沟通JS和C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务。\n最底层是支撑Node运行的关键，由 C/C++ 实现：\n- **V8** Google开发的JavaScript引擎，提供JavaScript运行环境。\n- **Libuv** 是专门为Node开发的一个封装库，提供跨平台的异步I/O能力。\n- **C-ares**：提供了异步处理 DNS 相关的能力。\n- **http_parser**、**OpenSSL**、**zlib** 等：提供包括 http 解析、SSL、数据压缩等其他的能力。\n\n**一些基本概念：**\n- NodeJS适合IO密集型应用，而不适合CPU密集型。\n- Libuv提供了强大的、跨平台的异步I/O能力，使得Node可以高效地处理大量并发请求。\n- Node是单线程无法利用CPU多核，易造成CPU占用率高。若要做CPU密集型工作（编解码、计算、影音处理），应使用C/C++插件或内置模块**Cluster**（为Node程序开启多核，并创建多个工作进程）。\n\n# Npm\n[Npm](https://www.npmjs.com/)（Node Package Manager）是Node的包管理工具。[npm 中文文档](https://www.npmjs.cn/)\n\n包，即package，是一组特定功能的源码集合。管理包，即对包进行下载、安装、删除、上传操作。\n使用包管理工具用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。\n\n[初识NodeJS-包管理工具](/article/109cbe0a.html)\n\n常用命令：\n\n```shell\nnpm -v # 查看版本\nnpm help # 列出所有命令\nnpm -l # 列出所有命令及简单用法\nnpm init # 初始化项目，创建package.json\nnpm install / i <包名@版本号> # 安装\nnpm i --save / -S # 生产依赖，默认\nnpm i --save-dev / -D # 开发依赖\nnpm i -g  # 全局安装\nnpm i <package-name> --registry=https://registry.npmmirror.com # 指定安装源\nnpm update # 更新依赖\nnpm uninstall / r # 移除依赖\nnpm prune # 清除未使用的模块\nnpm run <script-name> # 执行脚本命令\nnpm start # 执行start脚本命令\nnpm search <keyword> # 关键字搜索包\nnpm info <package-name> # 查看指定包的详细信息\nnpm list # 列出项目所有依赖包\nnpm ls -g # 查看全局安装的包\nnpm outdated # 列出需要更新的包\nnpm audit # 检查依赖项是否存在安全漏洞\nnpm adduser # 注册npm账户\nnpm login # 登录npm账户\nnpm logout # 登出\nnpm publish # 发布包\nnpm link # 将本地模块链接到全局的node_modules目录下\n# npm config\nnpm config list # 列出npm配置信息\nnpm config set <key> <value> [-g]  # 给配置参数key设置值为value，-g配置全局.npmrc\nnpm config get <key> # 获取配置参数key的值\nnpm set <key> <value> [-g] # 给配置参数key设置值为value\nnpm get <key> # 获取配置参数key的值\nnpm get registry # 查看安装源\nnpm get userconfig # 获取用户配置文件路径\nnpm get prefix # 获取全局node_modules路径\nnpm config delete <key> # 删除置参数key及其值\nnpm config list [-l] # 显示npm的所有配置参数的信息\nnpm config edit # 编辑配置文件\n# npm version\nnpm version patch # 2.0.0 -> 2.0.1\nnpm version minor # 2.0.1 -> 2.1.0\nnpm version major # 3.1.0 -> 4.0.0\nnpm version prerelease # 1.0.0 -> 1.0.1-0, 1.0.1-0 -> 1.0.1-1\nnpm version prepatch # 1.0.1-1 -> 1.0.2-0\nnpm version preminor # 1.0.2-0 -> 1.1.0-0\nnpm version premajor # 4.0.0 --> 5.0.0-0\n```\n\n[package.json 配置完全解读](https://juejin.cn/post/7145001740696289317)\n\n## 依赖管理\n目前npm采用**扁平化**的依赖管理方式，但在npm@3之前并没有压平依赖树\n\n```\nnode_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n```\n\n尽管这样的依赖结构清晰明了，但也导致了两个严重的问题：\n**1、深目录：**包经常创建太深的依赖树，导致路径过长。\n**2、多副本：**当不同的依赖项需要相同的包时，它们会被复制粘多次到各自的node_modules中\n\n在linux下深目录结构也许没有问题，但在windows下有[最长路径限制](https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry)，可能会无法处理，导致包找不到等各种问题。\n且相同的包存在多个副本，过多的占用了存储空间，这也太糟糕了，我们都知道就算是扁平化后的node_modules也还是比黑洞还重的东西（bushi）\n\n## npm@3\nnpm@3压平了依赖树，尽可能将依赖都放到顶层node_modules，这样就不会造成各个依赖嵌套过深，导致很多重复依赖文件等问题。\n\nnpm install时，广度优先遍历依赖树，首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，将依赖树尽可能拉平，直到所有依赖都被处理完毕。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本，这就会导致局部的非扁平化。\n\n解决了前两个问题，但又出现了三个新的问题：\n**1、幽灵依赖：**一些没有显式安装的包也能直接引用，安装包时会将该包的依赖也放到顶层node_modules，这些依赖虽然没有显式安装，但存在于顶层node_modules那么就能被引用，当卸载该包时，连通该包的依赖一起删除，若代码中引用了幽灵依赖，代码则会无法运行。\n**2、版本冲突：**扁平化的策略是让不同的依赖尽可能地都放到顶层node_modules，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在于依赖包的node_modules中，这样就会导致出现重复资源\n**3、算法复杂：**拉平算法过于复杂，以至于安装新包时会有明显卡顿感，依赖结构仍然复杂且难以预料\n\n```\n├── package-A @1.0\n|── package-B @1.0\n├── package-C @1.0\n│   └── package-A @2.0\n│   └── package-B @2.0\n├── package-D @1.0\n│   └── package-A @2.0\n│   └── package-B @2.0\n```\n\n## pnpm\n[pnpm](https://pnpm.io/)通过**store + link**组织依赖的目录结构\n1. store就是依赖的实际存储位置，当多个项目使用的是同一个依赖时，无需重复下载，极大的减少了存储空间。`pnpm store path`输出store的位置\n2. link是指符号链接(软链接)(**SymbolicLink**)和硬链接(**HardLink**)\n  - SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件。\n  - 相比于SymbolicLink，HardLink不是引用文件，而是引用inode，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件。\n\n[《为什么我们应该使用 pnpm？》](https://www.kochan.io/nodejs/why-should-we-use-pnpm.html)\n\n试着执行`pnpm add vue`\n\n现在node_modules有两个主要的文件，**.pnpm**和**vue**。\n1. .pnpm将所有依赖放在同一层文件夹中，每个包都可以通过`.pnpm/<name>@<version>/node_modules/<name>`找到，然后通过硬链接(HardLink)的方式在store中引用依赖文件。\n2. vue是一个符号链接(SymbolicLink)，Node会找到vue的真实位置`.pnpm/vue@3.4.5/node_modules/vue`。\n\n```\n├── .modules.yaml\n├── .pnpm\n│   ├── lock.yaml\n│   ├── picocolors@1.0.0\n│   │   └── node_modules\n│   ├── node_modules\n│   │   ├── .bin\n│   │   └── picocolors -> ../picocolors@1.0.0/node_modules/picocolors\n│   └── react@18.2.0\n│       └── node_modules\n└── vue -> .pnpm/vue@3.4.5/node_modules/vue\n```\n\n顶层node_modules下不会存在未显式安装的依赖，也就不存在幽灵依赖问题。\n不同版本的不同依赖都在.pnpm文件夹下扁平化存在。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/74-2.webp width=\"100%\">\n\n## install后续\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/74-3.webp width=\"100%\">\n\n**.npmrc**是npm运行时配置文件，一台电脑中有多个.npmrc，按如下顺序读取\n1. 项目配置文件：在项目根目录中新建一个.npmrc。\n2. 用户配置文件：`npm config get userconfig`获取该文件的位置，一般位于当前用户目录。\n3. 全局配置文件：位于`$PREFIX/etc/npmrc`，使用`npm config get prefix`获取$PREFIX。不曾配置过全局文件，则该文件不存在。\n4. npm内嵌配置文件：npm内置的配置，一般用不到\n\n```\nregistry=http://registry.npmjs.org/\n# 定义npm的registry，即npm的包下载源\n\nproxy=http://proxy.example.com:8080/\n# 定义npm的代理服务器，用于访问网络\n\nhttps-proxy=http://proxy.example.com:8080/\n# 定义npm的https代理服务器，用于访问网络\n\nstrict-ssl=true\n# 是否在SSL证书验证错误时退出\n\ncafile=/path/to/cafile.pem\n# 定义自定义CA证书文件的路径\n\nuser-agent=npm/{npm-version} node/{node-version} {platform}\n# 自定义请求头中的User-Agent\n\nsave=true\n# 安装包时是否自动保存到package.json的dependencies中\n\nsave-dev=true\n# 安装包时是否自动保存到package.json的devDependencies中\n\nsave-exact=true\n# 安装包时是否精确保存版本号\n\nengine-strict=true\n# 是否在安装时检查依赖的node和npm版本是否符合要求\n\nscripts-prepend-node-path=true\n# 是否在运行脚本时自动将node的路径添加到PATH环境变量中\n```\n\n## package-lock\nnpm@5引入了**package-lock.json**用于锁定版本并记录依赖树详细信息。\n\npackage.json单纯记录本项目的依赖, 而没有记录依赖的依赖信息, 并且依赖之间的版本号又没有明确固定, 无法保证依赖环境一致。package-lock.json用于解决该问题, 它会详细的记录项目依赖的版本号及依赖的依赖的版本号。\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.0\"\n  }\n}\n```\n\n向上标号^意为**向后（新）兼容依赖**，package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，指定版本为^4.18.0，实际下载的可能是最新的4.18.2，向后兼容大多数情况下是没有问题的。但为了稳定性考虑，应该锁定版本号，package-lock.json就提供了这样的功能。\n\n`npm install xxx@x.x.x`更新依赖，package和package-lock也随之更新\n\n```\nversion 当前包的版本号\nresolved 当前包的下载地址\nintegrity 用于验证包的完整性\ndev 是否为开发依赖包\nbin 当前包中可执行文件的路径和名称\nengines 当前包所依赖的Node.js版本范围\n```\n\nnpm使用包的**name + version + integrity**信息生成唯一key，使用该key可以在index-v5（缓存索引目录）下找对应的缓存记录，若存在，则去content-v2目录下找到缓存，将对应的二进制文件解压到node_modeules\n\nwindows下缓存路径默认在`%user%\\AppData\\Roaming\\npm-cache`\n\n## npm run\n**npm run**会读取package.json中scripts对应的脚本命令。\n[npm scripts 使用指南--阮一峰](https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)\n\n```json\n\"scripts\": {\n  \"dev\": \"vite\"\n},\n```\n\n所有可执行脚本都位于项目的node_modules/.bin目录中，包通过package.json中的bin配置命令文件，而node会自动向.bin目录注入.sh、.cmd、.ps1三个可执行脚本。\n\n```json\n\"bin\": {\n  \"vite\": \"bin/vite.js\"\n},\n```\n\n可执行脚本的查找顺序：当前项目node_modules -> 全局node_modules -> 环境变量 -> 报错。\n\n每当执行npm run，就会自动新建一个Shell，在这个Shell里面执行指定的脚本命令。因此，只要是Shell可以运行的命令，就可以写在 npm 脚本里面。npm run会将node_modules/.bin加入当前Shell的PATH变量，执行结束后，再将PATH变量恢复原样。\n\nnpm run还有**pre**和**post**两个钩子，将其加到原本的命令名前形成新的命令配置，pre表示在该命令之前执行，post则是在该命令之后执行。\n\n```json\n\"scripts\": {\n  \"dev\": \"node index.js\",\n  \"predev\": \"node pre.js\",\n  \"postdev\": \"node post.js\"\n},\n```\n\n## npx\nnpm@5.2新增了[npx](https://www.npmjs.com/package/npx)功能，[npx 使用教程--阮一峰](https://www.ruanyifeng.com/blog/2019/02/npx.html)\n\nnpx用于调用项目内部安装的模块。它会到node_modules/.bin路径和环境变量$PATH中，检查命令是否存在并调用。\n\n相比于新增scripts脚本并使用npm run调用，npx更加方便快捷。\n\n```shell\n# 调用vite命令\nnpm run dev # \"dev\": \"vite\"\nnpx vite\n```\n\nnpx还可以避免全局安装模块，只要 npx 调用的模块无法在本地发现，就会下载同名模块的最新版本（也可以指定版本），使用后自动删除，避免了占用磁盘空间以及版本更新不及时等问题。\n\n两个参数：\n- `--no-install` 强制使用本地模块。\n- `--ignore-existing` 忽略本地的同名模块。\n\n使用指定版本的node执行代码：\n`npx node@0.12.8 index.js` npx会临时下载[node模块](https://www.npmjs.com/package/node)，并使用它运行js代码。\n\n## npm init\n`npm init` 用于初始化一个新的项目，生成一个 package.json 文件，包含项目的基本信息。\n\n在 npx 出现后，init 命令也可以创建一些特定结构的包。就像 `npm init vite` 这样。\n\n```shell\nnpm init <initializer> # npm create 是其别名\n```\n\n`<initializer>` 实际上所指的包名是 `create-<initializer>`，npm 会自动下载该包，并执行 package.json 中 bin 字段对应的脚本。例如 [create-vite](https://www.npmjs.com/package/create-vite)。\n\n```json vite/packages/create-vite/package.json\n\"bin\": {\n  \"create-vite\": \"index.js\",\n  \"cva\": \"index.js\"\n},\n```\n\n另外，并非空目录下才能使用 npm init，它实际上是**添加性操作**，所以已有的字段和值都会被保留下来。\n\n若是指定了初始化程序，init 行为就得看包的实现了。[@eslint/create-config](https://www.npmjs.com/package/@eslint/create-config) 就是增量式的修改。可以很方便地通过 npm 命令在项目中初始化一些配置。\n\n\n## npm私服\n为什么需要npm私服：\n1. 内部使用的组件、模块不能公开，但仍然需要npm进行依赖管理。\n2. 组件化，模块化，工程化，团队建设，都需要私有源配合。\n3. 确保npm服务快速、稳定，减少开发人员和CI服务器的重复下载量并提高下载速度。\n4. 控制npm模块质量和安全，对于下载、发布npm包有对应的权限管理。\n\nnpm私服搭建工具：[Verdaccio](https://verdaccio.org/)、[Nexus](https://help.sonatype.com/repomanager3)、[sinopia](https://github.com/rlidwka/sinopia)\n\nVerdaccio为例，安装模块`npm i verdaccio -g`，直接运行`verdaccio`命令即可。\n\n之后执行命令时带上私有源`--registry http://localhost:4873`，或新建项目级的.npmrc指定npm源。\n\n其它常用命令：\n\n```shell\nverdaccio --listen 9999 # 指定端口\nnpm adduser --registry http://localhost:4873/ # 创建账户\nnpm publish --registry http://localhost:4873/ # 发布包\nnpm i --registry http://localhost:4873 # 安装时指定源\n```\n\n# 模块化\n以往的笔记：\n- [ES6查缺补漏-#Module模块化](/article/383b041f.html#Module模块化)\n- [Webpack-#模块化](/article/764f33bc.html#模块化)\n\n## CommonJS\n1. 支持引入内置模块例如 http os fs child_process 等nodejs内置模块。\n2. 支持引入第三方模块express md5 koa 等。\n3. 支持引入自己编写的模块 ./ ../ 等。\n4. 支持引入addon C++扩展模块 .node文件。\n\n```cjs\nconst fs = require('node:fs');  // 导入核心模块\nconst express = require('express');  // 导入 node_modules 目录下的模块\nconst myModule = require('./myModule.js');  // 导入相对路径下的模块\nconst nodeModule = require('./myModule.node');  // 导入扩展模块\nmodule.exports = {\n  name: chuckle\n}\nexports.a = 1\n```\n\n在cjs中也可以使用esm的import()动态引入模块。\n\n```cjs\nimport('./data.json', {\n  assert: { type: 'json' }\n}).then(data => {\n  console.log(data.default) // { name: 'data' }\n})\n```\n\n## ESM\n\n```mjs\nimport { stat, exists, readFile } from 'fs';\nconst name = '张三';\nexport const age = 18;\nexport default name;\nimport { age } from './index.js';\nimport name from './index.js';\n```\n\n引入json文件需增加断言并且指定类型json。\n\n```mjs\nimport data from './data.json' assert { type: \"json\" };\nconsole.log(data)\n```\n\n引入addon C++扩展模块 .node文件需要特殊处理。\n\n```mjs\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\nconst addon = require('./addon.node');\n```\n\nCJS 与 ESM 的区别：\n1. CJS是基于运行时的同步加载，esm是基于编译时的异步加载。\n2. CJS是可以修改值的，esm值不可修改（只读的）。\n3. CJS无法tree shaking，esm支持tree shaking。\n4. CJS中顶层的this指向这个模块本身，而ES6中顶层this指向undefined。\n\n## CJS源码\n`lib\\internal\\modules`是Node@18实现模块化的源码，其中`cjs\\loader.js`是实现**CommonJS**的主要源码。\n\n参考：\n[Node.js 模块系统源码探微](https://mp.weixin.qq.com/s?__biz=Mzg3NTcwMTUzNA==&mid=2247486229&idx=1&sn=fdd2c3874c7157fce10d73f47df4ef2b&source=41#wechat_redirect)\n[nodejs部分源码解析--小满](https://juejin.cn/post/7264044879209775141#heading-3)\n\n每个文件都被视为一个独立的模块。模块被加载时，都会初始化为 Module 对象的实例，模块对外暴露自己的 exports 属性作为使用接口。\n\n```js\nfunction Module(id = '', parent) {\n  // 模块 id,通常为模块的绝对路径\n  this.id = id;\n  this.path = path.dirname(id);\n  // exports\n  setOwnProperty(this, 'exports', {});\n  // 当前模块调用者\n  moduleParentCache.set(this, parent);\n  updateChildren(parent, this, false);\n  this.filename = null;\n   // 模块是否加载完成\n  this.loaded = false;\n  // 当前模块所引用的模块\n  this.children = [];\n  // ......\n}\n```\n\n### require函数\nModule._load 实现了加载模块的主要逻辑\n\n```js\nModule.prototype.require = function(id) {\n  // 验证 id 是否为字符串类型且非空\n  validateString(id, 'id');\n  // 如果 id 为空字符串，抛出一个错误，要求 id 为非空字符串\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id', id,\n                                    'must be a non-empty string');\n  }\n  // requireDepth记载模块加载的深度，在达到一定深度时进行一些特殊处理\n  // 自增表示当前模块的加载深度增加了一个层次\n  requireDepth++;\n  try {\n    // 调用 Module._load 方法加载指定的模块，isMain 参数设为 false\n    // isMain用于在模块加载过程中区分出主模块和其他模块\n    return Module._load(id, this, /* isMain */ false);\n  } finally {\n    // 自减表示当前模块的加载深度减少了一个层次\n    requireDepth--;\n  }\n};\n```\n\n### Module._load\n步骤的简单说明：\n1. Module._load首先处理内建模块，直接返回其exports对象\n2. 解析出模块的全路径，如果找到缓存的模块，且已被加载，则直接返回该模块缓存的exports\n3. 尝试加载没有以 'node:' 开头导入的内建模块，两次加载内建模块的核心都是loadBuiltinModule函数\n4. 获取该模块的缓存（已缓存但未加载），或创建一个新的 Module 实例\n5. 调用module.load加载模块\n6. 最后返回加载好的模块的exports对象\n\n```js\nModule._load = function(request, parent, isMain) {\n  let relResolveCacheIdentifier;\n  // 优化相同目录下懒加载的模块的加载过程\n  if (parent) {\n    // .....\n  }\n\n  // 内建模块处理\n  // 如果模块请求以 'node:' 开头，表示模块为内建模块\n  if (StringPrototypeStartsWith(request, 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(request, 5);\n\n    const module = loadBuiltinModule(id, request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n    // 加载内建模块并返回其 exports \n    return module.exports;\n  }\n\n  // 解析出模块的全路径\n  const filename = Module._resolveFilename(request, parent, isMain);\n\n  // 如果找到缓存的模块，如果已被加载，则直接返回该模块缓存的exports\n  // 否则将其标记为已加载，后续再去处理缓存的加载\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    // 更新父模块的子模块列表\n    updateChildren(parent, cachedModule, true);\n    // 检查模块是否已经加载\n    if (!cachedModule.loaded) {\n      // 如果模块尚未加载\n      // 获取缓存的 CommonJS 模块的解析结果对象\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      // 如果解析结果对象不存在，或者解析结果对象已经加载过\n      if (!parseCachedModule || parseCachedModule.loaded)\n        // 返回处理循环 require 的情况的导出对象\n        return getExportsForCircularRequire(cachedModule);\n      // 将解析结果对象标记为已加载\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  // 尝试加载没有以 'node:' 开头导入的内建模块\n  const mod = loadBuiltinModule(filename, request);\n  if (mod?.canBeRequiredByUsers &&\n      BuiltinModule.canBeRequiredWithoutScheme(filename)) {\n    return mod.exports;\n  }\n\n  // 获取模块的缓存，或创建一个新的 Module 实例\n  const module = cachedModule || new Module(filename, parent);\n\n  // 如果是主模块，则标记主模块\n  if (isMain) {\n    setOwnProperty(process, 'mainModule', module);\n    setOwnProperty(module.require, 'main', process.mainModule);\n    module.id = '.';\n  }\n\n  // 通知监视模式有关模块状态的变化\n  reportModuleToWatchMode(filename);\n\n  // 模块实例缓存\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    // 调用module.load加载模块\n    module.load(filename);\n    threw = false;\n  } finally {\n    // 进行一些清理工作\n    // ......\n  }\n\n  // 返回导出对象\n  return module.exports;\n};\n```\n\n模块的缓存、加载策略：\n1. 缓存命中，且已被加载过，直接返回exports\n2. 内建模块，直接返回其exports\n3. 已缓存但未加载的模块、使用文件或第三方代码生成的模块，加载后并缓存，下次同样的访问就会去使用缓存而不是重新加载\n\n### module.load\nmodule.load分析模块的后缀，并将模块交给特定的文件后缀名解析函数处理\n\n针对不同后缀的模块，Node.js 的加载方式是不同的\n\n```js\nModule.prototype.load = function(filename) {\n  // 调试信息，输出加载模块的文件名和模块的标识符\n  debug('load %j for module %j', filename, this.id);\n\n  // 确保模块是未被加载过的\n  assert(!this.loaded);\n  // 设置模块的文件名和路径列表\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  // 寻找并确定文件名的扩展名\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  // 如果文件名以 '.mjs' 结尾，并且没有针对 '.mjs' 的扩展处理函数，抛出错误\n  if (StringPrototypeEndsWith(filename, '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename, true);\n\n  // 执行特定文件后缀名解析函数 如 js / json / node\n  Module._extensions[extension](this, filename);\n  // 表示该模块加载成功\n  this.loaded = true;\n\n  // ... esm 模块的支持\n};\n```\n\n### 处理.json\nJSON文件的内容会被解析为JS对象，并赋值给module.exports，从而能够被其他模块引用。\n\n```js\nModule._extensions['.json'] = function(module, filename) {\n  // 读取文件内容，返回utf8字符串\n  const content = fs.readFileSync(filename, 'utf8');\n\n  // 存在安全策略时，进行内容完整性验证\n  if (policy?.manifest) {\n    // 获取文件的模块 URL\n    const moduleURL = pathToFileURL(filename);\n    // 进行内容完整性验证\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n\n  try {\n    // stripBOM移除字符串中的BOM（字节顺序标记）\n    // JSONParse解析JSON字符串为JS对象\n    // setOwnProperty设置module的exports属性为该JS对象\n    // 以前的代码是这么做的module.exports = JSONParse(stripBOM(content));\n    setOwnProperty(module, 'exports', JSONParse(stripBOM(content)));\n  } catch (err) {\n    // 如果解析失败，将文件名和错误信息拼接后抛出错误\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n```\n\n### 处理.node\n.node 文件是一种由 C/C++ 实现的原生模块，通过 `process.dlopen()` 读取。\n\n```js\nModule._extensions['.node'] = function(module, filename) {\n  // 存在安全策略时，进行内容完整性验证\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  // 使用 process.dlopen 方法加载模块\n  return process.dlopen(module, path.toNamespacedPath(filename));\n};\n```\n\n`process.dlopen()` 实际上调用了 C++ 写的 `DLOpen()`。\n\n```c++ src\\node_process_methods.cc\nSetMethod(context, target, \"dlopen\", binding::DLOpen);\n```\n\n`DLOpen()` 又调用了 `uv_dlopen()`，uv_dlopen是 libuv 库提供的函数，unix下调用dlopen接口，而在win下调用LoadLibraryExW接口，作用是在运行时打开一个共享库文件（插件），并返回一个句柄，使得程序能够调用该库中的函数或使用其中的符号。\n\n```c++ src\\node_binding.cc\nbool DLib::Open() {\n  int ret = uv_dlopen(filename_.c_str(), &lib_);\n  // ......\n}\nvoid DLOpen(const FunctionCallbackInfo<Value>& args) {\n  // ......\n  env->TryLoadAddon(*filename, flags, [&](DLib* dlib) {\n    // ......\n    const bool is_opened = dlib->Open();\n    // ......\n    if (!is_opened) {\n      std::string errmsg = dlib->errmsg_.c_str();\n      dlib->Close();\n    }\n  }\n  // ......\n}\n```\n\n### 处理.js\n如果缓存过这个模块就直接从缓存中读取，否则使用fs读取文件，并且判断如果是cjs但是type为module就报错，并且从父模块读取详细的行号进行报错，如果没问题就调用 _compile加载js模块\n\n```js\nModule._extensions['.js'] = function(module, filename) {\n  // If already analyzed the source, then it will be cached.\n  // 从cjsParseCache中获取已经解析过的模块源码\n  // const cjsParseCache = new SafeWeakMap();\n  const cached = cjsParseCache.get(module);\n  let content; // 保存源码内容的变量\n  // 如果已缓存，则直接使用缓存的源码。\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    // 否则，fs读取文件内容\n    content = fs.readFileSync(filename, 'utf8');\n  }\n  // 如果是.js文件，还需进行type检查，cjs或mjs就直接交给_compile处理\n  if (StringPrototypeEndsWith(filename, '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    // 如果package.json中type为module，则抛出错误，因为ESM不应该使用require\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path, 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename, usesEsm, parentPath,\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      // 如果抛出了错误，它还会尝试重构父模块的 require 调用堆栈，\n      // 以提供更详细的错误信息。它会读取父模块的源代码，并根据错误的行号和列号，\n      // 在源代码中找到相应位置的代码行，并将其作为错误信息的一部分展示出来。\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath, 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack, StringPrototypeIndexOf(\n              err.stack, '    at ')), '\\n', 1)[0];\n          const { 1: line, 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/, errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource, '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' ', col - 1)}^\\n`;\n            setArrowMessage(err, frame);\n          }\n        }\n      }\n      // 抛出错误\n      throw err;\n    }\n  }\n  // 调用_compile继续处理js模块的加载\n  module._compile(content, filename);\n};\n```\n\n### module._compile\nmodule._compile调用wrapSafe函数，向模块内部注入__dirname等公告变量，并将模块内容包装为一个安全的可执行的全局上下文函数，然后通过Reflect.apply调用该函数，将需要的5个参数传入，最后返回执行完的结果\n\n```js\nModule.prototype._compile = function(content, filename) {\n  // 如果启用了策略，则获取模块的 URL 和相关信息\n  let moduleURL;\n  let redirects;\n  const manifest = policy?.manifest;\n  if (manifest) {\n    // 将模块文件名转换为URL格式\n    moduleURL = pathToFileURL(filename);\n    // redirects是一个URL映射表，用于处理模块依赖关系\n    redirects = manifest.getDependencyMapper(moduleURL);\n    // manifest则是一个安全策略对象，用于检测模块的完整性和安全性\n    manifest.assertIntegrity(moduleURL, content);\n  }\n  // 向模块内部注入公共变量 __dirname / __filename / module / exports / require\n  // 并将模块内容包装为一个安全的可执行函数\n  // compiledWrapper得到一个可执行的全局上下文函数\n  const compiledWrapper = wrapSafe(filename, content, this);\n\n  let inspectorWrapper = null;\n  // ... 对于 Inspector 调试模式的支持\n\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this, redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    // 调用compiledWrapper，将需要的5个参数传入，最后返回执行完的结果\n    result = inspectorWrapper(compiledWrapper, thisValue, exports,\n                              require, module, filename, dirname);\n  } else {\n    // Reflect.apply调用compiledWrapper，将需要的5个参数传入，最后返回执行完的结果\n    result = ReflectApply(compiledWrapper, thisValue,\n                          [exports, require, module, filename, dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n```\n\n### wrapSafe\nwrapSafe将模块内容包装为一个安全的可执行函数，并对ESM的import()函数提供支持，用来动态加载模块，最后返回一个可执行的全局上下文函数\n\n```js\nfunction wrapSafe(filename, content, cjsModuleInstance) {\n  // 如果已经打过补丁（重要的也是这部分)\n  if (patched) {\n    // wrap函数：将模块内容包装为一个安全的可执行函数\n    const wrapper = Module.wrap(content);\n    // 创建 vm.Script 对象，表示可执行JS代码的node虚拟机\n    const script = new Script(wrapper, {\n      filename,\n      lineOffset: 0,\n      // 在CJS中支持ESM的import()，用来动态加载模块\n      importModuleDynamically: async (specifier, _, importAssertions) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier, normalizeReferrerURL(filename),\n                             importAssertions);\n      },\n    });\n\n    // Cache the source map for the module if present.\n    // 如果模块包含源映射，缓存源映射信息\n    if (script.sourceMapURL) {\n      maybeCacheSourceMap(filename, content, this, false, undefined, script.sourceMapURL);\n    }\n\n    // vm.runInThisContext此方法用于创建一个独立的沙箱运行空间\n    // code 内的代码可以访问外部的 global 对象，但是不能访问其他变量\n    // 返回一个可执行的全局上下文函数\n    return script.runInThisContext({\n      displayErrors: true,\n    });\n  }\n\n  // 没有打过补丁\n  try {\n    // 调用 internalCompileFunction 函数将模块内容编译为一个函数\n    const result = internalCompileFunction(content,\n      // 传递给编译的函数的参数列表\n      [\n      'exports',\n      'require',\n      'module',\n      '__filename',\n      '__dirname',\n    ], {\n      filename,\n      // 在CJS中支持ESM的import()，用来动态加载模块\n      importModuleDynamically(specifier, _, importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier, normalizeReferrerURL(filename),\n                             importAssertions);\n      },\n    });\n\n    // Cache the source map for the module if present.\n    // 如果模块包含源映射，缓存源映射信息\n    if (result.sourceMapURL) {\n      maybeCacheSourceMap(filename, content, this, false, undefined, result.sourceMapURL);\n    }\n\n    // 返回一个可执行的全局上下文函数\n    return result.function;\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err, content);\n    throw err;\n  }\n}\n```\n\nwrap函数用于将模块内容包装为一个安全的可执行函数，采用了字符串拼接的方式，使用需要Node公共变量为参数的函数包裹模块内容\n\n```js\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\nconst wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\\n});',\n];\n```\n\n### 总结\nCJS模块化核心是require的实现：\n1. 读取需要引入的文件\n2. 读取到文件后，将代码封装成一个可执行函数\n3. 通过 vm.runInThisContext 将其转为 JS 代码（沙箱）\n4. 代码调用\n\n# 全局变量&API\nNode中使用**global**关键字定义全局变量，就像浏览器中使用window一样。\n\n不同环境下，全局变量的关键字不同，为了统一，ECMA2020 提出了**globalThis**全局变量，会自动适配环境。\n\n全局变量在任何一个模块都能够访问到，但require是动态的，还要注意代码执行顺序。\n\n```js\nglobal.a = 1;\nglobalThis.b = 2;\nconsole.log(a, b) // 1 2\n```\n\nNode还有一些内置的全局变量，**__dirname**、**__filename**、exports、require、module\n\n```js\n// 当前模块的所在目录的绝对路径\nconsole.log(__dirname) // c:\\***\\***\n// 当前模块文件的绝对路径，包括文件名和文件扩展名\nconsole.log(__filename) // c:\\***\\***\\index.js\n```\n\n**全局API：**由于Node中没有DOM和BOM，除了这些API，其他的ECMA的API基本都能用，此外Node还有一些内置的全局API，如process、Buffer\n\n# like DOM\nNode环境没有DOM和BOM，但可以借助[jsdom](https://www.npmjs.com/package/jsdom)等第三方库构建一个DOM，并实现类似的DOM API操作，这对于SSR、爬虫等领域是非常有用的\n\n```ts\nconst fs = require('fs')\nconst path = require('path')\nconst { JSDOM } = require('jsdom')\n\n// 读取html文件的内容\nconst content = fs.readFileSync(path.join(__dirname, 'index.html'), 'utf-8')\n// 构建dom对象\nconst dom = new JSDOM(content)\n// 全局挂载API方便使用\nglobalThis.window = dom.window\nglobalThis.document= dom.window.document\n// dom操作\ndocument.querySelector('#app').innerHTML = 'hello world'\n// 覆写html文件\nfs.writeFileSync(path.join(__dirname, 'index.html'), dom.serialize())\n```\n\n## 渲染模式与SEO\n上面这种服务端处理dom、渲染数据、构建html页面的操作就是**SSR**(Server-Side Rendering)\n\n而Vue、React等单页应用(SPA)则是在客户端完成dom操作、数据渲染，即是**CSR**(Client-Side Rendering)\n\n非常通透的一篇文章：[极速加载还是绝佳SEO？探索CSR、SSR、SSG等渲染模式的优劣对决](https://juejin.cn/post/7233699680490799162/)\n\n**SEO:** 搜索引擎优化（Search Engine Optimization）。是一种利用搜索引擎规则，提高网站在搜索引擎内自然排名的技术。对大多数搜索引擎，不识别JavaScript 内容，只识别 HTML 内容。\n\n**MPA：**多页应用（multiple page application）。各个页面相互独立，需要单独维护多个 html 页面，每个请求都直接返回 html，对 SEO 友好，但切换页面就会重载，将带来巨大的重启性能消耗，切换页面比较慢。\n**SPA：**单页面应用（single page application）。动态重写当前的页面来与用户交互，而不需要重新加载整个页面。单页应用做到了前后端分离，后端只负责处理数据提供接口，页面逻辑和页面渲染都交给了前端。CSR、SSR、SSG 都是基于 SPA。\n\n**CSR：**客户端渲染(Client Side Render)。渲染过程全部交给浏览器进行处理，服务器不参与任何渲染。页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。\n**SSR：**服务端渲染(Server Side Render)。DOM树在服务端生成，而后返回给前端。即当前页面的内容是服务器生成好一次性给到浏览器的进行渲染的。\n\n**SSG：**静态站点生成（Static Site Generation）。与SSR的原理非常类似，但不同之处在于HTML文件是预先生成的，而不是在服务器实时生成。\n**ISR：**增量式网站渲染（Incremental Static Regeneration）。结合了SSG和SSR的优势，静态页面的构建仍然是在构建时完成的，类似于SSG。但ISR允许某些页面在构建后仍保持动态，并在用户首次访问时进行服务端渲染。一旦渲染完成，生成的静态页面被缓存，并在后续的请求中被直接提供，以提高性能和响应速度。\n**同构：**SSR和CSR的结合，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于接管页面交互(绑定事件)，核心解决SEO和首屏渲染慢的问题。采用同构思想的框架：Nuxt.js（基于Vue）、Next.js（基于React）。\n\n# POSIX\n**POSIX：**可移植操作系统接口（Portable Operating System Interface of UNIX），是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，以方便软件程序在不同操作系统上的移植。\n\nWindows也遵守这套标准，但又没有完全遵守，在路径表示等方面就不同于POSIX。\nWindows路径分隔符为反斜杠（\\），而POSIX使用的正斜杠（/）。\n\n## Path模块\n[Path](https://nodejs.cn/api/path.html)用于对路径的操作\n\n常用方法：\n1. `sep` 获取当前系统的路径分隔符\n2. `basename` 获取路径的基础名称\n3. `dirname` 获取路径的目录名\n4. `extname` 获取文件的扩展名\n5. `join` 拼接路径，使用当前系统的分隔符\n6. `resolve` 解析路径，返回绝对路径\n7. `parse` 解析路径并返回对象\n8. `format` 从对象中解析出路径，和 parse 相反\n9. `isAbsolute` 判断是否为绝对路径\n10. `relative` 获取 from 到 to 的相对路径\n11. `normalize` 规范化路径，将不符合规范的路径经过格式化转换为标准路径\n\n```js 方法详解\nconst path = require('path')\n\n// 1、sep 获取当前系统的路径分隔符\nconsole.log(path.sep); // \\\n\n// 2、basename 获取路径的基础名称\nconsole.log(path.basename(__filename)); // index.js\n\n// 3、dirname 获取路径的目录名\nconsole.log(path.dirname(__filename)); // c:\\chuckle\\qx\\NodeJS-new\\path\n\n// 4、extname 获取文件的扩展名\nconsole.log(path.extname(__filename)); // .js\nconsole.log(path.extname(\"/a/b/index.min.js\")); // .js 多个.只会获取最后一个\nconsole.log(path.extname(\"/a/b/index\")); // 没有扩展名返回空字符串\n\n// 5、join 拼接路径，使用当前系统的分隔符\nconsole.log(path.join(__dirname, 'index.js')); // c:\\chuckle\\qx\\NodeJS-new\\path\\index.js\n// 支持路径操作符号\nconsole.log(path.join('a', 'b', '../')); // a\\\n// 如果连接后的路径字符长度为0，则返回 '.'，表示当前工作目录\nconsole.log(path.join('')) // '.'\n\n// 6、resolve 解析路径，返回绝对路径\n// 返回工作目录的绝对路径+相对路径\nconsole.log(path.resolve('a', 'b')); // C:\\chuckle\\qx\\NodeJS-new\\a\\b\n// 多个绝对路径，返回最后一个，并忽略前面的相对路径\nconsole.log(path.resolve('a', '/b', '/c', 'd')); // C:\\c\\d\n// 如果解析后的路径字符长度为0，则返回工作目录的绝对路径\nconsole.log(path.resolve('')); // C:\\chuckle\\qx\\NodeJS-new\n// 常用\nconsole.log(path.resolve(__dirname, 'index.js')); // c:\\chuckle\\qx\\NodeJS-new\\path\\index.js\n\n// 7、parse 解析路径并返回对象\nconsole.log(path.parse(__filename));\n// {\n//   root: 'c:\\\\',\n//   dir: 'c:\\\\chuckle\\\\qx\\\\NodeJS-new\\\\path',\n//   base: 'index.js',\n//   ext: '.js',\n//   name: 'index'\n// }\n// ┌──────────────────┬────────────┐\n// │          dir     │    base    │\n// ├──────┬           ├──────┬─────┤\n// │ root │           │ name │ ext │\n// \"  /    foo/bar/baz/ index  .js \"\n\n// 8、format 从对象中解析出路径，和 parse 相反\nconsole.log(path.format(path.parse(__filename))); // c:\\chuckle\\qx\\NodeJS-new\\path\\index.js\n\n// 9、isAbsolute 判断是否为绝对路径\nconsole.log(path.isAbsolute('/foo')); // true\nconsole.log(path.isAbsolute('\\\\foo')); // true\nconsole.log(path.isAbsolute('C:/foo')); // true\nconsole.log(path.isAbsolute('./a')); // false\n\n// 10、relative 获取 from 到 to 的相对路径\nconsole.log(path.relative('/foo/bar/baz', '/foo/bar/dir/file.js')) // ..\\dir\\file.js\n// from 或 to 任何一方为空,则使用当前工作目录代替其空路径\nconsole.log(path.relative('', '/foo/bar/dir/file.js')) // ..\\..\\..\\foo\\bar\\dir\\file.js\nconsole.log(path.relative('/foo/bar/dir/file.js', '')) // ..\\..\\..\\..\\chuckle\\qx\\NodeJS-new\n\n// 11、normalize 规范化路径，将不符合规范的路径经过格式化转换为标准路径\nconsole.log(path.normalize('c:\\\\a\\\\b\\\\c\\\\index.js')); // c:\\a\\b\\c\\index.js\nconsole.log(path.normalize('c:\\\\\\\\\\a/\\\\\\\\b\\\\\\c/\\\\/index.js')); // c:\\a\\b\\c\\index.js\nconsole.log(path.normalize('c:/a/../b/c')); // c:\\b\\c\n```\n\nwindows兼容正反斜线作为路径分隔符，但POSIX只允许使用正斜线（/），path模块提供了兼容方法\n\n```js\n// 若需要在POSIX中处理windows路径，使用 win32 进行兼容\nconsole.log(path.win32.basename('c:\\\\a\\\\b\\\\c\\\\index.js')); // index.js\n// 也可以在windows下使用 posix 规范\nconsole.log(path.posix.basename('c:\\\\a\\\\b\\\\c\\\\index.js')); // c:\\a\\b\\c\\index.js，posix无法处理windows路径\nconsole.log(path.posix.basename('c:/a/b/c/index.js')); // index.js\n```\n\n# OS\n[os](https://nodejs.cn/api/os.html)模块用于与操作系统进行交互\n\n常用方法：\n1. `platform` 获取当前系统平台\n2. `type` 获取当前系统名称\n3. `release` 获取当前系统版本号\n4. `version` 获取当前系统版本名称\n5. `EOL` 返回操作系统的换行符，\"\\n\" 或 \"\\r\\n\"\n6. `arch` 获取当前系统的 CPU 架构\n7. `constants` 返回操作系统的常量，如错误码、信号码等\n8. `homedir` 获取当前用户的主目录\n9. `cpus` 获取CPU的线程以及详细信息\n10. `networkInterfaces` 获取网络接口列表\n11. `freemem` 获取系统空闲内存，单位字节\n12. `totalmem` 获取系统总内存，单位字节\n13. `hostname` 获取主机名\n14. `uptime` 获取系统正常运行时间，单位秒\n15. `userInfo` 获取当前用户信息\n16. `loadavg` 获取系统平均负载，数组包含 1、5、15 分钟的平均负载\n17. `tmpdir` 获取系统临时目录\n18. `endianness` 获取系统字节序\n19. `getPriority(pid)` 获取进程优先级\n20. `setPriority(pid, priority)` 设置进程优先级\n\n```js 方法详解\n// 1、platform 获取当前系统平台\nconsole.log(os.platform()); // win32\n// type Platform = 'aix' | 'android' | 'darwin' | 'freebsd' | 'haiku' | 'linux' | 'openbsd' | 'sunos' | 'win32' | 'cygwin' | 'netbsd';\n\n// 2、type 获取当前系统名称\nconsole.log(os.type()); // Windows_NT\n// returns `'Linux'` on Linux, `'Darwin'` on macOS, and `'Windows_NT'` on Windows.\n\n// 3、release 获取当前系统版本号\nconsole.log(os.release()); // 10.0.19044\n\n// 4、version 获取当前系统版本名称\nconsole.log(os.version()); // Windows 10 Pro\n\n// 5、EOL 返回操作系统的换行符，\"\\n\" 或 \"\\r\\n\"\nconsole.log(JSON.stringify(os.EOL)); // \"\\r\\n\"\n\n// 6、arch 获取当前系统的 CPU 架构\nconsole.log(os.arch()); // x64\n//  ‘arm’, ‘arm64’, ‘ia32’, ‘mips’, ‘mipsel’, ‘ppc’, ‘ppc64’, ‘riscv64’, ‘s390’, ‘s390x’, ‘x64’ 等。\n\n// 7、constants 返回操作系统的常量，如错误码、信号码等\nconsole.log(os.constants); // { UV_UDP_REUSEADDR: 4, ... }\n\n// 8、homedir 获取当前用户的主目录\nconsole.log(os.homedir()); // C:\\Users\\64507\n// 底层原理是通过环境变量获取，USERPROFILE 或 HOME\n// > printenv USERPROFILE\n\n// 9、cpus 获取CPU的线程以及详细信息，返回数组，元素个数为线程数(逻辑处理器个数)\nconsole.log(os.cpus()); // [ { model: 'AMD Ryzen 7 5800U with Radeon Graphics ... } ]\nconsole.log(os.cpus().length); // 16 线程数\n// {\n//   model: 'AMD Ryzen 7 5800U with Radeon Graphics', // CPU型号\n//   speed: 1896, // CPU速度，以MHz或GHz为单位\n//   times: { // CPU时间（毫秒）\n//     user: 3473453, // 用户态时间\n//     nice: 0, // 低优先级用户态时间\n//     sys: 5935453, // 系统态时间\n//     idle: 437847828, // 空闲时间\n//     irq: 704953 // 硬中断时间\n//   }\n// },\n\n// 10、networkInterfaces 获取网络接口列表\nconsole.log(os.networkInterfaces()); // { '本地连接* 1': [ { address: '127.0.0.1', ... } ] }\n// {\n//   address: '127.0.0.1', // IP地址\n//   netmask: '255.0.0.0', // 子网掩码\n//   family: 'IPv4', // IP协议版本\n//   mac: '00:00:00:00:00:00', // MAC地址\n//   internal: true, // 是否为内部地址\n//   cidr: '127.0.0.1/8' // CIDR表示法\n// }\n\n// 11、freemem 获取系统空闲内存，单位字节\nconsole.log(os.freemem()); // 4641640448\n\n// 12、totalmem 获取系统总内存，单位字节\nconsole.log(os.totalmem()); // 16442781696\n\n// 13、hostname 获取主机名\nconsole.log(os.hostname()); // DESKTOP-3JQKQ0O\n\n// 14、uptime 获取系统正常运行时间，单位秒\nconsole.log(os.uptime()); // 1017.283\n\n// 15、userInfo 获取当前用户信息\nconsole.log(os.userInfo()); // { uid: -1, gid: -1, username: '64507', homedir: 'C:\\\\Users\\\\64507', shell: null }\n\n// 16、loadavg 获取系统平均负载，数组包含 1、5、15 分钟的平均负载\nconsole.log(os.loadavg()); // [ 0, 0, 0 ]\n// 它只在Linux和macOS上返回有意义的值。\n\n// 17、tmpdir 获取系统临时目录\nconsole.log(os.tmpdir()); // C:\\Users\\64507\\AppData\\Local\\Temp\n\n// 18、endianness 获取系统字节序\nconsole.log(os.endianness()); // LE\n// 取决于Node是用Big Endian还是Little Endian编译的。\n\n// 19、getPriority(pid) 获取进程优先级\nconsole.log(os.getPriority(0)); // 0\n\n// 20、setPriority(pid, priority) 设置进程优先级\nconsole.log(os.setPriority(0, 10)); // undefined\n```\n\n获取到设备和操作系统信息后，方便程序进行兼容处理。不同系统的shell命令差异较大，就需要程序对系统类型进行判断。\n\n```js 兼容不同系统的打开浏览器命令\nconst childProcess = require('child_process')\nconst os = require('os')\n\n// 兼容不同系统的打开浏览器命令\nconst open = (url) => {\n  const cmd = {\n    darwin: 'open',\n    win32: 'start',\n    linux: 'xdg-open'\n  }\n  childProcess.exec(`${cmd[os.platform()]} ${url}`)\n}\n\nopen('https://www.baidu.com')\n```\n\n# 非阻塞\n我们常说Node是单进程单线程的应用，这里的单线程，意思是只有一个线程用于解释执行JS代码，而Node进程还是包含有多个线程的，其它的线程用于处理I/O操作等任务\n\nJS总是一种同步(阻塞)的单线程语言，但是我们可以通过编程使JS异步运行。\n\n在理解Node的非阻塞前，或许应该先复习下浏览器环境下的同步与异步：[Promise异步编程--同步与异步](/article/7a1fbbc5.html#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5)\n\nJS引擎维护了一个调用栈，当该调用栈被一个JS脚本（task）占用时，无法再执行其它脚本。\n\n```js\nconsole.log(\"task开始\")\nsetTimeout(() => {\n  console.log(\"setTimeout\")\n}, 1000)\nwhile (true) { }\nconsole.log(\"task结束\")\n```\n\n上面的代码只会输出\"task开始\"，然后被死循环阻塞。\n\n下面是一个伪代码：\n\n```js\ncreate(server) // 创建一个web服务\nparse(query) // 解析请求获取参数\nread(data) // I/O操作，从系统磁盘读取文件内容\nsend(result) // 将结果返回给用户\n```\n\n同步状态下的执行流程：\n1. create(server)创建一个web服务，初始化调用栈，启动一个线程，等待请求\n2. 当服务器接收到了一个请求，脚本task入栈，线程开始工作\n3. parse(query)入栈，耗时1ms完成解析请求，执行完后出栈\n4. 然后read(data)入栈，耗时50ms读取文件完成，出栈\n5. 接着send(result)入栈，耗时1ms将结果返回，出栈\n6. 最后脚本task出栈，清空调用栈\n\n整个过程耗时52ms，看起来是很短，但如果同时有一千个请求，每个请求的task排队入栈，整个服务的响应将会变得非常慢。\n\nNode要想在单线程上更快得处理请求，实现高并发，就需要将I/O等耗时任务尽快出栈。\n将特定的耗时任务作为异步任务，交给Node中其它特定的线程去处理，最后再将任务的回调入栈处理，显然是个好办法，实际上浏览器环境也是这么做的。\n\n何时处理回调，如何处理各种不同的异步任务、优先级，这需要一个管理者。\n**事件循环**就充当了这么一个角色。\n\n# 事件循环\n**事件循环是Node处理非阻塞I/O操作的机制。**\n\n参考：\n[一张图带你搞懂Node事件循环](https://juejin.cn/post/7010308647792148511)\n[从源码了解 Node.js 事件循环](https://zhuanlan.zhihu.com/p/622381734)\n\nNode是**事件驱动**的，从设计模式上来说，类似观察者模式。\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\n事件循环是基于libuv的，它提供了跨平台的异步I/O能力，当然，对于底层的C++实现，现在谈还过早了。\n\n**一图流：**\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/74-4.webp width=\"60%\">\n\n**JS的执行过程:**\n1. 同步任务进入调用栈，异步任务交给异步模块处理\n2. 异步任务处理完后，将回调交给事件循环中对应的队列\n3. 同步任务执行完毕，开启事件循环。\n\n**事件循环流程：**\n1. 检查并清空nextTick和微任务队列\n2. 然后依次清空Timer->poll队列\n3. 接着判断其它队列是否有回调待执行，即队列是否为空\n4. 若其它队列为空，则在该空的poll队列等待，这是为了优先处理I/O事件。（若等待时间过长，也会继续循环）\n5. 若其它队列不为空了，则继续循环，往下依次清空队列\n6. 一次Tick结束后，检查是否有还有异步任务，有则开启下一次Tick\n\n总之，事件循环就是在同步任务都结束后，循环处理异步回调，并优先处理I/O事件，直到所有异步任务都结束。\n\n```js\nsetTimeout(() => {\n  console.log(\"setTimeout1\")\n}, 2000)\n\nPromise.resolve().then(()=>{\n  console.log('promise')\n})\n\nprocess.nextTick(()=>{\n  console.log('nextTick')\n})\n\nsetTimeout(() => {\n  console.log(\"setTimeout2\")\n}, 1000)\n\nsetImmediate(()=>{\n  console.log('setImmediate')\n})\n\nsetTimeout(() => {\n  console.log(\"setTimeout3\")\n}, 0)\n\nfs.writeFile('./test.txt', 'test', () => {\n  console.log('writeFile')\n})\n```\n\n运行结果：\n\n```js\n// nextTick\n// promise\n// setTimeout3\n// setImmediate\n// writeFile\n// setTimeout2\n// setTimeout1\n```\n\n# process\n[process](https://nodejs.cn/api/process.html) 提供有关当前 Node.js 进程的信息，并对其进行控制的**全局**API\n\n进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器\n\n**1、异步：**`nextTick(fn)`\n\n```js\nconsole.log('1');\nprocess.nextTick(function(){\n    console.log('2');\n});\nconsole.log('3');\n// 1 3 2\n```\n\n**2、获取命令行参数：**`argv`\n返回一个数组，第一个元素是 node.exe 的路径，第二个元素是当前执行的 js 文件的路径，其余的元素是命令行参数，但不包括 node specific 参数\n\n```js\nconsole.log(process.argv)\n// 第一个元素是 node.exe 的路径，第二个元素是当前执行的 js 文件的路径，其余的元素是命令行参数\n// [\n//   'C:\\\\Program Files\\\\nodejs\\\\node.exe', // node.exe 的路径\n//   'c:\\\\chuckle\\\\qx\\\\NodeJS-new\\\\process\\\\index.js', // 当前执行的 js 文件的路径\n//   '--version' // 命令行参数\n// ]\nconsole.log(process.argv.includes('--version') ? '1.0.0' : null) // node index.js --version\n```\n\n**3、获取node specific参数：**`execArgv`\n返回数组，只包含 node specific 参数\n\n```js\n// node --harmony .\\execArgv.js -a -b -c\nconsole.log(process.execArgv);\n// [ '--harmony' ]\nconsole.log('------------------');\nconsole.log(process.argv);\n// [\n//   'C:\\\\Program Files\\\\nodejs\\\\node.exe',\n//   'C:\\\\chuckle\\\\qx\\\\NodeJS-new\\\\process\\\\execArgv.js',\n//   '-a',\n//   '-b',\n//   '-c'\n// ]\n```\n\n**4、获取和切换工作目录：**\n`cwd()` 获取当前工作目录\n`chdir(dir)` 切换工作目录\n\n```js\n// 取当前工作目录\nconsole.log(process.cwd()) // C:\\chuckle\\qx\\NodeJS-new 获取当前工作目录\nconsole.log(path.resolve()) // C:\\chuckle\\qx\\NodeJS-new 获取当前工作目录\nconsole.log(__dirname) // c:\\chuckle\\qx\\NodeJS-new\\process 获取当前文件所在的目录\n// 切换工作目录\nconsole.log(process.chdir('..')) // 修改当前工作目录\nconsole.log(process.cwd()) // C:\\chuckle\\qx\n```\n\n**5、当前进程信息：**\n`pid` 获取当前进程的 pid\n`ppid` 当前进程对应的父进程的 pid\n`title` 获取当前进程的名称，可修改，用于区分Node进程\n\n```js\nconsole.log(process.pid) // 45736\nconsole.log(process.ppid) // 37716\n\nconsole.log(process.title) // 管理员: C:\\windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\nprocess.title = 'node'\nconsole.log(process.title) // node\n```\n\n**6、进程运行和资源占用情况：**\n`uptime()` 获取当前进程运行的时间，单位秒\n`memoryUsage()` 获取内存使用情况\n`cpuUsage([previousValue])` CPU使用时间耗时，单位为微秒\n`hrtime([time])` 一般用于做性能基准测试\n\n```js\nconsole.log(process.uptime()) // 0.0367208\n\nconsole.log(process.memoryUsage())\n// {\n//   rss: 36507648, // 常驻内存，物理内存存量\n//   heapTotal: 6369280, // V8给分配的堆内存总量\n//   heapUsed: 5690504, // 已使用的堆内存\n//   external: 429451, // 外部内存使用量 c、c++ 使用的\n//   arrayBuffers: 17378 // ArrayBuffer 的总内存\n// }\nconsole.log(os.freemem()); // 获取系统空闲内存\nconsole.log(os.totalmem()); // 获取系统总内存\n\nconst startUsage = process.cpuUsage();\nconst now = Date.now();\nwhile (Date.now() - now < 500);\nconsole.log(process.cpuUsage(startUsage)); // { user: 500000, system: 0 }\n// user表示用户程序代码运行占用的时间，system表示系统占用时间\n// 如果当前进程占用多个内核来执行任务，那么数值会比实际感知的要大\n```\n\n**7、node可执行程序相关信息：**\n`execPath` node可执行程序的绝对路径\n`version` 获取当前Node版本\n`versions` 获取Node及其依赖库的版本\n`release` 当前node发行版本的相关信息\n`config` 当前node版本编译时的参数\n\n```js\nconsole.log(process.execPath) // C:\\Program Files\\nodejs\\node.exe\nconsole.log(process.version) // v18.12.1\nconsole.log(process.versions)\n// {\n//   node: '18.12.1',\n//   v8: '10.2.154.15-node.12',\n//   ......\n// }\nconsole.log(process.release)\n// {\n//   name: 'node',\n//   lts: 'Hydrogen',\n//   ......\n// }\nconsole.log(process.config) // [......]\n```\n\n**8、进程运行环境：**\n`arch` 获取 CPU 架构\n`platform` 获取操作系统平台\n\n```js\nconsole.log(process.arch) // x64\nconsole.log(os.arch()) // x64\n\nconsole.log(process.platform) // win32\nconsole.log(os.platform()) // win32\n```\n\n**9、警告信息：**`emitWarning(warning)`\n\n```js\nprocess.emitWarning('warning!');\n// 可以给警告信息加个名字，便于分类\nprocess.emitWarning('warning!', 'CustomWarning');\n// 也可以传入Error对象\nconst myWarning = new Error('Warning!');\nmyWarning.name = 'CustomWarning';\nprocess.emitWarning(myWarning);\n// 监听warning\nprocess.on('warning', (warning) => {\n  console.warn(warning.name); // 'CustomWarning'\n  console.warn(warning.message); // 'warning!'\n  console.warn(warning.stack); // CustomWarning: Warning! at Object.<anonymous> ......\n});\n```\n\n**10、终止进程：**\n`exit([exitCode])` 立即退出进程，\n`exitCode` 设置退出码，然后等进程自动退出\nexit() 往往是不保险的，如果在执行exit之前，还有异步操作没有执行完，那么这些异步操作将不会执行，如果程序出现异常，必须退出不可，可以抛出一个未被捕获的error，来终止进程\n\n```js\nprocess.exit(1) // 退出当前进程，退出码为1\nprocess.exitCode = 1 // 退出码为1\n```\n\n**11、向进程发送信号：**`kill(pid, [signal])`\nkill 不同于它的名字，虽然可以用来退出进程，但实际作用是向进程发送特定信号[signal-events](https://nodejs.cn/api-v16/process.html#signal-events)\n\nWindows不支持信号（但部分信号也能使用）\n\n退出进程的信号：\n1. `SIGTERM` 默认信号，可监听，退出之前重置终端模式\n2. `SIGINT` 键盘Ctrl+C，可监听，如果安装了监听器，其默认行为将被删除（Node将不再退出）\n3. `SIGKILL` 它会无条件地终止Node，无法监听\n\n其它信号：\n1. `0` 可以发送来测试进程是否存在，如果进程存在则没影响，如果进程不存在则抛出错误\n\n```js\nprocess.kill(process.pid); // 默认是 SIGTERM 信号，杀死进程，退出之前重置终端模式\nprocess.kill(process.pid, 'SIGINT') // Ctrl+C 退出进程\nprocess.kill(process.pid, 0)\n\n// 例子\n// 从标准输入开始读取，因此进程不会退出。\nprocess.stdin.resume();\n\nprocess.on('SIGINT', () => {\n  console.log('不能使用 Ctrl + C 退出了');\n});\n\n// 使用单个函数处理多个信号\nfunction handle(signal) {\n  console.log(`Received ${signal}`);\n}\n\nprocess.on('SIGINT', handle);\nprocess.on('SIGTERM', handle);\n```\n\n## 进程事件监听\n`on(event, handle)` 监听[进程事件](https://nodejs.cn/api/process.html#%E8%BF%9B%E7%A8%8B%E4%BA%8B%E4%BB%B6)\n\nNode中有许多进程事件：\n\n**1、**`beforeExit`\n当 Node 清空其事件循环并且没有额外的工作时，会触发该事件，表示Node进程**将要**退出\n\n其监听器回调将 exitCode 值作为唯一的参数传入\n\n对于导致显式终止的条件，例如调用 exit() 或未捕获的异常，不会触发该事件\n\n```js\nsetTimeout(() => {\n  console.log(\"setTimeout1\")\n}, 2000)\nprocess.exitCode = 1\n// 两秒后，事件循环清空，触发beforeExit事件\nprocess.on('beforeExit', (code) => {\n  console.log(code) // 1\n})\n```\n\n注册在该事件上的监听器可以进行异步的调用，从而使 Node 进程继续\n\n```js\nprocess.on('beforeExit', (code) => {\n  setTimeout(() => {\n    console.log(\"setTimeout\")\n  }, 2000)\n})\n// setTimeout\n// setTimeout\n// ......\n```\n\n上面的代码中，事件循环被清空，触发beforeExit，表示Node进程将要退出，但回调中又使用异步任务（setTimeout）激活了事件循环，于是2秒后执行异步任务的回调，然后清空事件循环，事件循环一被清空又触发beforeExit，循环往复\n\n**2、**`exit`\n当 Node 进程退出时触发，即使是exit()显式终止\n\n其监听器回调将 exitCode 值作为唯一的参数传入\n\nbeforeExit 先于 exit 触发\n\n```js\nsetTimeout(() => {\n  console.log(\"setTimeout1\")\n}, 2000)\nprocess.exitCode = 1\n\nprocess.on('exit', (code) => {\n  console.log('exit', code)\n  setTimeout(() => {\n    console.log(\"setTimeout2\")\n  }, 2000)\n})\n\nprocess.on('beforeExit', (code) => {\n  console.log('beforeExit', code)\n})\n```\n\n执行结果：\nexit表示Node进程的结束，Node不会再等回调中的异步任务执行完毕，调用栈清空后直接退出进程\n\n```js\n// setTimeout1\n// beforeExit 1\n// exit 1\n```\n\n**3、**`disconnect`\n如果 Node进程是使用 IPC 通道生成的（[子进程](https://nodejs.cn/api/child_process.html)），当 IPC 通道关闭时将触发该事件\n\n**4、**`warning`\n每当 Node 触发进程警告时，都会触发该事件\n\n回调接收一个warning对象，有三个属性\n1. name <string> 警告的名称\n2. message <string> 警告描述\n3. stack <string> 代码中触发警告的位置的堆栈跟踪\n\n```js\nsetTimeout(() => {\n  const err = new Error('错误信息')\n  err.name = 'CustomError'\n  process.emitWarning(err)\n}, 2000)\nprocess.on('warning', (warning) => {\n  console.log(warning.name)\n  console.log(warning.message)\n  console.log(warning.stack)\n})\n// (node:40184) CustomError: 错误信息\n// (Use `node --trace-warnings ...` to show where the warning was created)\n// CustomError\n// 错误信息\n// CustomError: 错误信息\n//     at Timeout._onTimeout (c:\\chuckle\\qx\\NodeJS-new\\process\\进程事件.js:21:15)\n//     at listOnTimeout (node:internal/timers:564:17)\n//     at process.processTimers (node:internal/timers:507:7)\n```\n\n**5、信号事件：**\n`process.on()` 还可以监听信号事件，本质上也属于进程事件，Windows不支持信号（但部分信号也能使用），但Node提供了 kill 方法模拟发送信号\n\n当 Node 进程收到信号时，将触发信号事件\n\n```js\nsetTimeout(() => {\n  process.kill(process.pid) // 默认信号为SIGTERM\n  console.log('kill') // 在win上不会执行\n}, 2000)\n// 在windows上会直接退出进程，而不会监听到SIGTERM信号\nprocess.on('SIGTERM', (signal) => {\n  console.log(`Received ${signal}`)\n})\n```\n\n## 标准输入输出\n`stdin` 标准输入流，它是程序的输入源\n`stdout` 标准输出流，它是程序的输出源\n`stderr` 标准错误流，用于由程序发出的错误信息和诊断\n\n[在Node.js中使用stdout、stdin和stderr的方法](https://juejin.cn/post/7111724587410259998)\n\n标准流：当程序执行时，它们在程序和环境之间互连输入和输出通信通道\n[可读流Readable](https://nodejs.cn/api/stream.html#%E5%8F%AF%E8%AF%BB%E6%B5%81)、[可写流Writable](https://nodejs.cn/api/stream.html#%E5%8F%AF%E5%86%99%E6%B5%81)\n\n```js\nprocess.stdin.setEncoding('utf8'); // 设置编码格式\nprocess.stdin.resume() // 开启输入流\n// 通过监听data事件来处理输入。每当用户输入一些数据时，就会触发data事件\nprocess.stdin.on(\"data\", data => { // 监听输入\n  process.stdout.write(`data: ${data.toString()}`) // 输出输入\n  // process.stdin.pause() // 暂停输入流\n})\n// 当有可从流中读取的数据或已到达流的末尾时，则将触发 readable 事件。\n// 表明流有新的信息。如果数据可用，则 stream.read() 将返回该数据。\nprocess.stdin.on('readable', () => {\n  let chunk;\n  while ((chunk = process.stdin.read()) !== null) {\n    process.stdout.write(`readable: ${chunk}`);\n  }\n});\n// 当标准输入流结束时触发，即输入流中没有更多数据可供读取时，win上不一定会触发\nprocess.stdin.on('end', () => {\n  console.log('输入结束');\n});\n```\n\n上述程序会创建一个事件监听器来监听命令行中数据输入，并将用户的输入打印到终端。\n\n可以通过监听输入流的 data 或 readable 事件获取输入流的数据\n\n通过`process.stdout.write()`将数据写入标准输出流，比console.log更底层、更灵活\n1. 不会自动添加换行符\n2. 不会添加额外的空格\n3. 不可以直接输出对象\n\n```js\nprocess.stdout.write(`hello `) // 需要手动添加空格\nprocess.stdout.write(`world${os.EOL}`) // 需要手动添加换行符\n// hello world\nconsole.log(\"hello\")\nconsole.log(\"world\") // console.log会自动在输出末尾添加换行符\n// hello\n// world\n// console.log会自动在不同的输出之间添加空格\nconsole.log(\"hello\", \"world\")\n// hello world\nconst obj = { name: 'obj' }\nprocess.stdout.write(JSON.stringify(obj) + os.EOL) // 需要手动将对象转换为字符串\nconsole.log(obj) // console.log可以直接输出对象\n// {\"name\":\"obj\"}\n```\n\n### readline\n[readline](https://nodejs.cn/api/readline.html) 模块用于**一次一行**地读取可读流（如 process.stdin）中的数据\n\n通过 `readline.createInterface(options)` 构造 readline.Interface 类的实例，每个实例都与单个 input 可读流和单个 output 可写流相关联\n\n```txt options配置项\n1. input <stream.Readable> 要监听的可读流\n2. output <stream.Writable> 要写入 readline 数据的可写流\n3. completer <Function> 可选的用于Tab制表符自动补全的函数\n4. terminal <boolean> 如果 input 和 output 流应该被视为终端，并且写入了 ANSI/VT100 转义码，则为 true。默认值：在实例化时检查 output 流上的 isTTY。\n5. history <string[]> 历史行的初始列表。仅当 terminal 由用户或内部的 output 检查设置为 true 时，此选项才有意义，否则历史缓存机制根本不会初始化。默认值：[]。\n6. historySize <number> 保留的最大历史行数。要禁用历史记录，则将此值设置为 0。仅当 terminal 由用户或内部的 output 检查设置为 true 时，此选项才有意义，否则历史缓存机制根本不会初始化。默认值：30。\n7. removeHistoryDuplicates <boolean> 如果为 true，则不会将重复的历史记录添加到历史记录中。默认值：false。\n8. prompt <string> 要使用的提示字符串。默认值：'> '。\n9. crlfDelay <number> 读取行时要使用的延迟毫秒数，用于确定输入行何时结束。默认值：100。\n10. escapeCodeTimeout <number> 读取转义序列时要使用的超时毫秒数\n11. tabSize <number> 一个制表符等于的空格数（最小为 1）。默认值：8。\n12. signal <AbortSignal> 允许使用中止信号关闭接口。中止信号将在内部调用接口上的 close。\n```\n\nInterface常用实例方法：\n1. `question(query[, options], (answer)={})` 向用户提问，并将答案作为回调的**首个参数**传回\n2. `write(data)` 向output流写入字符串\n3. `close()` 关闭Interface实例，放弃对 input 和 output 流的控制，触发 close 事件，但不会立即阻止其它由Interface实例触发的事件，如line\n4. `pause()` 暂停 input 流\n5. `resume()` 恢复 input 流\n6. `prompt([preserveCursor])` 为用户提供新行，恢复input流，并等待用户输入。preserveCursor 如果为 true，则防止光标位置重置为 0\n7. `setPrompt(prompt)` 设置prompt提示字符串，prompt为字符串，当调用prompt()时，会将prompt字符串写入output流\n8. `getPrompt()` 获取当前prompt提示字符串\n9. `clearLine(dir)` 清除当前行，dir为方向，-1：从光标向左，1：从光标向右，0：整行\n10. `commit()` 将所有待处理的操作发送到关联的 stream 并清除待处理操作的内部列表。\n\n事件：\n1. `line` 当 input 流接收到换行符（\\n、\\r 或 \\r\\n）时触发，通常在用户按下 Enter 键或 Return 键时触发\n2. `close` 当 input 流接收到 Ctrl + C 或 Ctrl + D 时触发\n3. `pause` 当 input 流被暂停时触发\n4. `resume` 当 input 流恢复时触发\n5. `history` 当历史数组发生更改时触发\n6. `SIGCONT` 当之前使用 Ctrl+Z 移入后台的 Node.js 进程（即 SIGTSTP）随后使用 fg(1p) 返回前台时触发\n7. `SIGINT` 当 input 流接收到 Ctrl + C 时触发，如果在 input 流接收到 SIGINT 时没有注册该事件监听器，则触发 pause 事件。\n8. `SIGTSTP` 当 input 流接收到 Ctrl + Z 时触发，如果 input 流接收到 SIGTSTP 时没有注册该事件监听器，则 Node.js 进程将被发送到后台。\n\n```js\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin, // 设置输入流\n  output: process.stdout, // 设置输出流\n});\nrl.question('今天星期几：', (answer) => {\n  // 对答案进行处理\n  console.log(`答：${answer}`);\n  rl.close();\n});\n```\n\n```js\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  prompt: '> ',\n});\nrl.prompt();\nrl.on('line', (line) => {\n  console.log(`你输入了：${line}`);\n  rl.prompt();\n}).on('close', () => {\n  rl.clearLine(0);\n  console.log('再见');\n  process.exit(0);\n});\n```\n\n当然还有 promise 版本的 readline\n\n```js\nconst readline = require('readline/promises')\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\nrl.question('今天星期几：').then(answer => {\n  console.log(`答：${answer}`)\n  rl.close()\n})\n```\n\n## 环境变量env\n`process.env` 用于读取操作系统所有的环境变量，也可以**修改（只在当前线程生效）**和查询环境变量\n\n```js\nconsole.log(process.env)\n// { ALLUSERSPROFILE: 'C:\\\\ProgramData'......\nconsole.log(process.env.NVM_HOME)\n// C:\\Users\\64507\\AppData\\Roaming\\nvm\n```\n\n**区分开发与生产环境：**使用[cross-env](https://www.npmjs.com/package/cross-env)库设置环境变量\n\n```json cross-env设置环境变量\n\"scripts\": {\n  \"dev\": \"cross-env NODE_ENV=dev node env.js\",\n  \"build\": \"cross-env NODE_ENV=prod node env.js\"\n},\n```\n\n```js 在JS中读取NODE_ENV\nif (process.env.NODE_ENV === 'dev') {\n  console.log('开发环境')\n} else if (process.env.NODE_ENV === 'prod') {\n  console.log('生产环境')\n} else {\n  console.log('未知环境')\n}\n```\n\ncross-env 底层调用了不同系统的设置环境变量的命令\n\n```shell\nset NODE_ENV=prod  #windows\nexport NODE_ENV=prod #posix\n```\n\n还可以使用[dotenv](https://www.npmjs.com/package/dotenv)库，从.env文件加载环境变量到process.env，配合[cross-env](https://www.npmjs.com/package/cross-env)更好的区分开发和生产环境的环境变量\n\n[node项目环境变量](/article/f12f59c3.html#node%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n\n# child_process\n使用[child_process](https://nodejs.cn/api/child_process.html)模块可以很方便地创建子进程，而且子进程之间可以通过事件消息系统进行互相通信\n\n[Node.js的进程管理](https://segmentfault.com/a/1190000017804200#)\n[Node Guidebook 子进程](https://tsejx.github.io/node-guidebook/system/process/child-process/)\n[你应该了解的Node child_process](https://juejin.cn/post/6978477054366842916)\n\n一个CPU一个进程不足以处理庞大的I/O工作(从网络读取、访问数据库或文件系统) 。无论服务器多么强大，一个线程仅仅能够支持有限的处理能力。\nNode运行模式虽然是单线程，但是同样可以利用多个进程，当然也能使用集群。Node设计的初衷也是利用多个节点构建分布式应用程序。\n\n在任何子进程中，都能做的事（非常适合处理Cpu密集型工作）：\n1. 可以通过执行系统命令去访问控制操作系统\n2. 可以控制子进程的输入流，监听子进程的输出流\n3. 可以控制传给底层操作系统命令的参数\n4. 可以使用命令做任何事情\n\n子进程的应用场景：\n1. 计算密集型应用\n2. 前端构建工具利用多核 CPU 并行计算，提升构建效率\n3. 进程管理工具，如：PM2 中部分功能\n\nchild_process提供了三个同步(Sync)方法和四个异步方法来创建子进程\n1. `exec`、`execSync` 执行命令，适用于小量数据，maxBuffer 默认值为1mb，超出会报错\n2. `spawn`、`spawnSync` 执行命令，适用于返回大量数据，例如图像处理，二进制数据处理\n3. `execFile`、`execFileSync` 执行可执行文件\n4. `fork` 创建node子进程，每个进程之间是相互独立的，都有自己的V8实例、内存，通常根据CPU核心数设置\n5. exec底层通过execFile实现，而execFile底层通过spawn实现\n\n在Node标准库中，方法末尾加上**Sync**就是异步方法的同步版本，返回Buffer，而异步方法的回调首个参数都是err\n\n## exec\nexec方法将会生成一个子shell，然后在该 shell 中执行命令\n\n子进程会并缓冲产生的数据，当子进程结束后，exec会从子进程中返回一个完整的buffer\n\nexec只适合获取小量数据，maxBuffer 默认值为1mb，超出会报错：Error：maxBuffer exceeded\n\n```js\nchild_process.exec(command, [options], callback)\nexec( \n  command: string, \n  options?: Object | undefined \n  callback?: ((\n      error: ExecException | null, \n      stdout: string, \n      stderr: string\n    ) => void\n  ) | undefined\n): ChildProcess\n```\n\noptions配置项：\n\n```\ncwd <string> 子进程的当前工作目录。\nenv <Object> 环境变量键值对。\nencoding <string> 默认为 'utf8'。\nshell <string> 用于执行命令的 shell。 在 UNIX 上默认为 '/bin/sh'，在 Windows 上默认为 process.env.ComSpec。\ntimeout <number> 超时，默认为 0。\nmaxBuffer <number> stdout 或 stderr 允许的最大字节数。默认为 1024 * 1024。如果超过限制，则子进程会被终止。查看警告：maxBuffer and Unicode。\nkillSignal <string> | <integer> 默认为 'SIGTERM'。\nuid <number> 设置该进程的用户标识。\ngid <number> 设置该进程的组标识。\nwindowsHide <boolean> 隐藏通常在 Windows 系统上创建的子进程控制台窗口。默认值：false。\n```\n\n举个栗子：\n\n```js\nexec('node -v && mkdir test',{\n  cwd: __dirname, // 设置工作目录为当前目录\n}, (err, stdout, stderr) => {\n  console.log(stdout) // v18.12.1\n})\n```\n\n通常用exec同步方法较多，因为处理的数据较少，速度快\n\n```js\nconst nodeVersion  = execSync('node -v && mkdir test',{\n  cwd: __dirname, // 设置工作目录为当前目录\n})\nconsole.log(nodeVersion.toString())\n```\n\n总之 shell 命令能做的，exec都能做\n\n## spawn\nspawn创建一个子进程，具有三个输入输出流：**stdin**、**stdout**、**stderr**，通过这三个流，可以实时获取子进程的输入输出和错误信息\n\n```js\nchild_process.spawn(command, [args], [options])\nspawn(\n  command: string, \n  args?: readonly string[] | undefined, \n  options?: SpawnOptionsWithoutStdio | undefined\n): ChildProcessWithoutNullStreams\n```\n\noptions配置项：\n\n```\ncwd <string> | <URL> 子进程的当前工作目录。\nenv <Object> 环境变量键值对。默认值：process.env。\nargv0 <string> 显式设置发送给子进程的 argv[0] 的值。如果未指定，这将设置为 command。\nstdio <Array> | <string> 子进程的标准输入输出配置。\ndetached <boolean> 准备子进程独立于其父进程运行。具体行为取决于平台。\nuid <number> 设置进程的用户标识。\ngid <number> 设置进程的群组标识。\nserialization <string> 指定用于在进程之间发送消息的序列化类型。可能的值为 'json' 和 'advanced'。默认值：'json'。\nshell <boolean> | <string> 如果是 true，则在 shell 内运行 command。在 Unix 上使用 '/bin/sh'，在 Windows 上使用 process.env.ComSpec。 可以将不同的 shell 指定为字符串。默认值： false（无外壳）。\nwindowsVerbatimArguments <boolean> 在 Windows 上不为参数加上引号或转义。 在 Unix 上被忽略。当指定了 shell 并且是 CMD 时，则自动设置为 true。 默认值：false。\nwindowsHide <boolean> 隐藏通常在 Windows 系统上创建的子进程控制台窗口。默认值：false。\nsignal <AbortSignal> 允许使用中止信号中止子进程。\ntimeout <number> 允许进程运行的最长时间（以毫秒为单位）。默认值：undefined。\nkillSignal <string> | <integer> 当衍生的进程将被超时或中止信号杀死时要使用的信号值。默认值：'SIGTERM'。\n```\n\n创建一个进程执行ping命令\n\n```js\nconst subprocess = spawn('ping', ['127.0.0.1'], {\n  shell: true,\n})\n```\n\n### 子进程流事件\n监听子进程上的stdout流的事件，可以获取命令行的实时的输出数据\n\n```js\n// 读取输出流\nsubprocess.stdout.on('data', (data) => {\n  console.log(iconv.decode(data, 'cp936'))\n})\n// 输出流结束\nsubprocess.stdout.on('end', () => {\n  console.log('end')\n})\n// 输出流关闭\nsubprocess.stdout.on('close', () => {\n  console.log('close')\n})\n// 正在 Ping 127.0.0.1 具有 32 字节的数据:\n// 来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128\n// 来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128\n// 来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128\n// 来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128\n// 127.0.0.1 的 Ping 统计信息:\n//     数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n// 往返行程的估计时间(以毫秒为单位):\n//     最短 = 0ms，最长 = 0ms，平均 = 0ms\n// end\n// close\n```\n\n### 子进程事件\nChildProcess类继承EventEmitters所以实例包括以下几种事件\n1. `spawn` 一旦子进程成功生成，就会触发spawn事件。如果子进程没有成功生成，则触发error事件。无论生成的进程是否发生错误(如shell命令出错)，spawn事件都会触发。\n2. `exit` 该事件在子进程结束后触发。回调接收code、signal两个参数。如果进程退出，则 code 为进程最终退出码，否则为 null。 如果进程因收到信号而终止，则 signal 是信号的字符串名称，否则为 null，二者必有一null。\n3. `close` 该事件在子进程结束并且其的标准输入输出流已关闭后触发。进程结束，流可能还未关闭。回调接收code、signal两个参数。\n4. `disconnect` 调用父或子进程的`disconnect()`断开连接后触发。断开连接后就不能再发送或接收消息，且 subprocess.connected 属性为 false。\n5. `error` 在无法衍生该进程，或进程无法终止，或向子进程发送消息失败，该事件就会被触发。发生错误后，exit事件可能会也可能不会触发。在监听 exit 和 error 事件时，应该注意防止多次意外调用回调函数。\n6. `message` 当子进程使用`send()`发送消息时触发 message 事件。这是父子进程相互通信的基础。\n\n通常child_process.spawn创建的子进程，只使用spawn、exit、close、error这四个事件，disconnect、message则在child_process.fork中使用\n\n```js\n// 子进程创建成功\nsubprocess.on('spawn', () => {\n  console.log('subprocess spawn', subprocess.pid) // spawn 39036\n})\nsetTimeout(() => {\n  // 关闭子进程的标准输出流\n  subprocess.stdout.end();\n  // 退出子进程\n  subprocess.kill();\n}, 2000)\n// 子进程结束并退出\nsubprocess.on('exit', (code, signal) => {\n  console.log('subprocess exit', code, signal) // subprocess exit null SIGTERM\n})\n// 子进程结束并且其的标准输入输出流已关闭\nsubprocess.on('close', (code, signal) => {\n  console.log('subprocess close', code, signal) // subprocess close null SIGTERM\n})\n// 子进程错误\nsubprocess.on('error', (err) => {\n  console.log('subprocess error', err)\n})\n// 断开连接\nsubprocess.on('disconnect', () => {\n  console.log('subprocess disconnect')\n})\n// 子进程消息\nsubprocess.on('subprocess message', (msg) => {\n  console.log(msg)\n})\n```\n\n## execFile\nexecFile用于执行可执行文件，通常使用异步版本。\n\n可执行文件：node脚本，shell文件，windows的cmd脚本，posix的sh脚本。\n\nexecFile默认不衍生shell，而是指定的可执行文件file直接作为新进程衍生，因此不支持 I/O 重定向和文件通配等行为，比exec()效率略高。\n\n```js\nchild_process.execFile(file[, args][, options][, callback])\nexecFile( \n  file: string, \n  args: readonly string[] | null | undefined, \n  options: Object | undefined\n  callback: (\n    error: ExecFileException | null, \n    stdout: string, stderr: string\n  ) => void\n): ChildProcess\n```\n\noptions配置项：\n\n```\ncwd <string> | <URL> 子进程的当前工作目录。\nenv <Object> 环境变量键值对。默认值：process.env。\nencoding <string> 默认值：'utf8'\ntimeout <number> 默认值：0\nmaxBuffer <number> 标准输出或标准错误上允许的最大数据量（以字节为单位）。如果超过，则子进程将终止并截断任何输出。默认值：1024 * 1024。\nkillSignal <string> | <integer> 默认值：'SIGTERM'\nuid <number> 设置进程的用户标识。\ngid <number> 设置进程的群组标识。\nwindowsHide <boolean> 隐藏通常在 Windows 系统上创建的子进程控制台窗口。默认值： false。\nwindowsVerbatimArguments <boolean> 在 Windows 上不为参数加上引号或转义。在 Unix 上被忽略。默认值：false。\nshell <boolean> | <string> 如果是 true，则在 shell 内运行 command。在 Unix 上使用 '/bin/sh'，在 Windows 上使用 process.env.ComSpec。 可以将不同的 shell 指定为字符串。默认值：false（无外壳）。\nsignal <AbortSignal> 允许使用中止信号中止子进程。\n```\n\n举个栗子：\n\n```js\nexecFile('node', ['-v'], (err, stdout, stderr) => {\n  console.log(stdout) // v21.2.0\n});\n```\n\n创建一个cmd文件\n\n```cmd\necho '开始'\nmkdir test \ncd ./test\necho console.log(\"test\") >test.js\necho '结束'\nnode test.js\n```\n\nexecFile调用执行\n\n```js\nexecFile(path.resolve(__dirname, './test.cmd'),{\n  cwd: __dirname, // 设置工作目录为当前目录\n}, (err, stdout, stderr) => {\n  console.log(stdout)\n});\n```\n\n输出：\n\n```\nc:\\chuckle\\qx\\NodeJS-new\\child_process>echo '开始'\n'开始'\nc:\\chuckle\\qx\\NodeJS-new\\child_process>mkdir test\nc:\\chuckle\\qx\\NodeJS-new\\child_process>cd ./test\nc:\\chuckle\\qx\\NodeJS-new\\child_process\\test>echo console.log(\"test\")  1>test.js\nc:\\chuckle\\qx\\NodeJS-new\\child_process\\test>echo '结束'\n'结束'\nc:\\chuckle\\qx\\NodeJS-new\\child_process\\test>node test.js\ntest\n```\n\n## fork\nfork 用于衍生新的 Node.js 进程，会产生一个新的 V8 实例，所以需要指定一个 JS 文件，底层也是调用 spawn 来创建子进程\n\n```js\nchild_process.fork(modulePath[, args][, options])\nfork(\n  modulePath: string, \n  options?: ForkOptions | undefined\n): ChildProcess\n```\n\noptions配置项：\n\n```\ncwd <string> | <URL> 子进程的当前工作目录。\ndetached <boolean> 准备子进程独立于其父进程运行。具体行为取决于平台。\nenv <Object> 环境变量键值对。默认值：process.env。\nexecPath <string> 用于创建子进程的可执行文件。\nexecArgv <string[]> 传给可执行文件的字符串参数列表。默认值：process.execArgv。\ngid <number> 设置进程的群组标识。\nserialization <string> 指定用于在进程之间发送消息的序列化类型。可能的值为 'json' 和 'advanced'。默认值：'json'。\nsignal <AbortSignal> 允许使用中止信号关闭子进程。\nkillSignal <string> | <integer> 当衍生的进程将被超时或中止信号杀死时要使用的信号值。 默认值：'SIGTERM'。\nsilent <boolean> 如果为 true，则子进程的标准输入、标准输出和标准错误将通过管道传输到父进程，否则它们将从父进程继承。参阅 child_process.spawn() 的 stdio 的 'pipe' 和 'inherit' 选项，默认值：false。\nstdio <Array> | <string> 参见 child_process.spawn() 的 stdio。提供此选项时，它会覆盖 silent。如果使用数组变体，则它必须恰好包含一个值为 'ipc' 的条目，否则将抛出错误。例如 [0, 1, 2, 'ipc']。\nuid <number> 设置进程的用户标识。\nwindowsVerbatimArguments <boolean> 在 Windows 上不为参数加上引号或转义。在 Unix 上被忽略。默认值：false。\ntimeout <number> 允许进程运行的最长时间（以毫秒为单位）。默认值：undefined。\n```\n\n举个栗子：\n\n```js parent.js 父进程（主进程）\n// 使用child.js创建Node子进程\nconst forked = fork(path.resolve(__dirname, './child.js'));\n\n// 监听子进程的消息\nforked.on(\"message\", msg => {\n  console.log(\"Message from child\", msg);\n});\n\n// 向子进程发送消息\nforked.send({ hello: \"world\" });\n```\n\n```js child.js 子进程\n// 监听父进程发送的消息\nprocess.on(\"message\", msg => {\n  console.log(\"Message from parent:\", msg);\n});\n\nlet counter = 0;\n\nsetInterval(() => {\n  // 向父进程发送消息\n  process.send({ counter: counter++ });\n}, 1000);\n```\n\n```shell 结果\nMessage from parent: { hello: 'world' }\nMessage from child { counter: 0 }\nMessage from child { counter: 1 }\nMessage from child { counter: 2 }\n# ......\n```\n\n父子进程的通信：\n1. 父进程指定一个JS文件作为Node子进程，并获取子进程对象\n2. 父进程通过子进程对象，调用on()方法监听子进程发来的消息（触发message事件），调用send()方法向子进程发送消息\n3. 子进程调用process.send()方法向父进程发送消息\n4. 子进程监听message事件获取父进程发来的消息\n\n通过 fork 创建子进程之后，父子进程之间会创建一个 **IPC**（进程间）通道，方便父子进程直接通信，在 JS 层使用 process.send(mes) 和 process.on('message', msg => {}) 。\n\n在底层，实现进程间通信的方式有很多，Node 的IPC基于 libuv 实现，不同操作系统实现方式不一致，在 posix 中采用 Unix Domain Socket(套接字)，Windows 中使用 name pipe(命名管道)。\n\n常见进程间通信方式：消息队列、共享内存、pipe、信号量、套接字\n\n### 更实际的案例\n多个请求同时到来，并且都需要做大量计算\n\n```js server.js http服务主进程\nconst server = (data) => {\n  // 开启一个子进程，完成计算任务\n  const compute = fork(path.resolve(__dirname, './compute.js'));\n  // 向子进程发送数据\n  compute.send(data);\n  // 监听子进程的消息，获取计算结果\n  compute.on('message', (msg) => {\n    console.log('计算结果：', msg);\n  })\n}\n// 模拟多个请求同时到来\nserver([1,2,3,4,5,6,7,8,9,10]);\nserver([100,200,300,400,500,600,700,800,900,1000]);\nserver([10,200,3000,4000,5000,6000,7000,8000,9000,10000]);\n```\n\n```js compute.js 计算任务子进程\nconst longComputation = async (data) => {\n  return await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const sum = data.reduce((a, b) => {\n        return a + b;\n      }, 0);\n      resolve(sum);\n    }, 3000); // 模拟3s的计算任务\n  });\n};\n// 监听父进程发送的消息，开启计算任务\nprocess.on(\"message\", async msg => {\n  try {\n    const result = await longComputation(msg);\n    // 等待计算任务完成后，向父进程发送结果\n    process.send(result);\n  } catch (error) {\n    process.send({ error: error.message });\n  } finally {\n    process.disconnect();\n    process.exit();\n  }\n});\n```\n\n3s后，3个计算任务同时完成，主进程输出结果\n\n```txt 结果\n计算结果： 55\n计算结果： 5500\n计算结果： 52210\n```\n\n上面的代码受 fork 的进程数量限制，但是当我们执行它并通过 http 请求耗时计算端点时，主服务器没有被阻塞并且可以接受进一步的请求\n\nNode的`cluster`模块就是基于这种思想。\n\n# ffmpeg\n[ffmpeg](https://ffmpeg.org/)([cn](https://ffmpeg.p2hp.com/))是一个开源的跨平台多媒体处理工具，它功能强大，用途广泛，大量用于视频网站和商业软件，也是许多音频和视频格式的标准编码/解码实现\n\n它提供了一组强大的命令行工具和库，可以进行格式转换、视频处理、音频处理、流媒体传输等操作\n\n先封装一个通过execFile调用ffmpeg的函数\n\n```js\nconst ffmpeg = (str) => {\n  const ffmpegProcess = childProcess.execFile('ffmpeg', str.split(\" \"), {\n    cwd: __dirname,\n  }, (err, stdout, stderr) => {\n    if (err) {\n      console.error(err)\n      return\n    }\n    console.log(\"ffmpeg执行成功\")\n  })\n  ffmpegProcess.stdin.write('y'); // 输入y，覆盖输出文件\n  ffmpegProcess.stdin.end();  // 结束输入流\n}\n```\n\n调用函数传入参数实现功能\n\n```js\n// 格式转换\nffmpeg('-i ./test.mp4 ./test.avi')\n\n// 音频提取，直接转为音频格式即可，-vn表示去掉视频\nffmpeg('-i ./test.mp4 -vn ./test.mp3')\n\n// 裁剪视频，内部的编码格式不变，所以使用-c copy指定直接拷贝，不经过转码，这样比较快\nffmpeg('-i ./test.mp4 -ss 00:00:00 -to 00:00:05 -c copy ./test2.mp4')\n\n// 加水印\nffmpeg('-i ./test.mp4 -vf drawtext=text=Chuckle:fontsize=30:fontcolor=white:x=10:y=10 ./test3.mp4')\n\n// 删除水印，指定水印宽高和起始点\nffmpeg('-i ./test3.mp4 -vf delogo=w=120:h=30:x=10:y=10 ./test4.mp4')\n```\n\n\n\n\n\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"Rollup","url":"/article/d9966eb3.html","content":"\n# 初识\n[Rollup](https://cn.rollupjs.org/)是一个小巧强大的ESM打包器，Vite在生产环境下的打包基于Rollup\n\nRollup并不与webpack竞争，初衷是提供一个充分利用ESM各项特性的高效打包器，并不支持如HMR等特性，不能像Webpack那样几乎可以完成开发过程中，前端工程化的绝大多数工作。\n\n所以Rollup偏向应用于JS库，webpack偏向应用于前端工程、UI库。\n\n安装：\n\n```shell\n# 全局安装\nnpm i -g rollup\n# 本地安装\nnpm i rollup -D\n```\n\n`npx rollup`不加任何参数，默认输出help信息\n\n命令行参数：\n\n```shell\n-c, --config <filename>     使用此配置文件（如果使用参数但未指定值，则默认为 rollup.config.js）\n-d, --dir <dirname>         用于块的目录（如果不存在，则打印到 stdout）\n-e, --external <ids>        排除模块 ID 的逗号分隔列表\n-f, --format <format>       输出类型（amd、cjs、es、iife、umd、system）\n-g, --globals <pairs>       `moduleID:Global` 对的逗号分隔列表\n-h, --help                  显示此帮助消息\n-i, --input <filename>      输入（替代 <entry file>）\n-m, --sourcemap             生成源映射（`-m inline` 为内联映射）\n-n, --name <name>           UMD 导出的名称\n-o, --file <output>         单个输出文件（如果不存在，则打印到 stdout）\n-p, --plugin <plugin>       使用指定的插件（可重复）\n-v, --version               显示版本号\n-w, --watch                 监视产物文件并在更改时重新构建\n--amd.autoId                基于块名称生成 AMD ID\n--amd.basePath <prefix>     要预先添加到自动生成的 AMD ID 的路径\n--amd.define <name>         在 `define` 位置使用的函数\n--amd.forceJsExtensionForImports 在 AMD 导入中使用 `.js` 扩展名\n--amd.id <id>               AMD 模块的 ID（默认为匿名）\n--assetFileNames <pattern>  发布资源的名称模式\n--banner <text>             在产物顶部插入的代码（位于包装器之外）\n--chunkFileNames <pattern>  发布次要块的名称模式\n--compact                   缩小包装器代码\n--context <variable>        指定顶级 `this` 值\n--no-dynamicImportInCjs     将外部动态 CommonJS 导入编写为 require\n--entryFileNames <pattern>  发布入口块的名称模式\n--environment <values>      传递给配置文件的设置（请参阅示例）\n--no-esModule               不添加 __esModule 属性\n--exports <mode>            指定导出模式（auto、default、named、none）\n--extend                    扩展由 --name 定义的全局变量\n--no-externalImportAssertions 在 \"es\" 输出中省略导入断言\n--no-externalLiveBindings   不生成支持实时绑定的代码\n--failAfterWarnings         如果生成的构建产生警告，则退出并显示错误\n--filterLogs <filter>       过滤日志信息\n--footer <text>             在产物底部插入的代码（位于包装器之外）\n--no-freeze                 不冻结命名空间对象\n--generatedCode <preset>    使用哪些代码特性（es5/es2015）\n--generatedCode.arrowFunctions 在生成的代码中使用箭头函数\n--generatedCode.constBindings 在生成的代码中使用 \"const\"\n--generatedCode.objectShorthand 在生成的代码中使用简写属性\n--no-generatedCode.reservedNamesAsProps 始终引用保留名称作为 props\n--generatedCode.symbols     在生成的代码中使用符号\n--no-hoistTransitiveImports 不将中转导入提升到入口块中\n--no-indent                 不缩进结果\n--inlineDynamicImports      使用动态导入时创建单次打包\n--no-interop                不包括交互操作块\n--intro <text>              在产物顶部插入的代码（位于包装器内部）\n--logLevel <level>          要显示哪种类型的日志\n--no-makeAbsoluteExternalsRelative 不规范化外部导入\n--maxParallelFileOps <value> 并行读取的文件数\n--minifyInternalExports     强制或禁用内部导出的缩小\n--noConflict                为 UMD 全局生成 noConflict 方法\n--outro <text>              在产物底部插入的代码（位于包装器内部）\n--perf                      显示性能计时\n--no-preserveEntrySignatures 避免入口点的门面块\n--preserveModules           保留模块结构\n--preserveModulesRoot       将保留的模块放置在根路径下的此路径下\n--preserveSymlinks          解析文件时不要跟随符号链接\n--no-sanitizeFileName       不要替换文件名中的无效字符\n--shimMissingExports        为丢失的导出创建卡扣变量\n--silent                    不打印警告\n--sourcemapBaseUrl <url>    使用给定的基本 URL 发出绝对源映射 URL\n--sourcemapExcludeSources   在源映射中不包括源代码\n--sourcemapFile <file>      指定源映射的包位置\n--sourcemapFileNames <pattern> 编译后 sourcemap 的命名模式\n--stdin=ext                 指定用于标准输入的文件扩展名\n--no-stdin                  不要从 stdin 读取 \"-\"\n--no-strict                 不在生成的模块中发出 `\"use strict\";`\n--strictDeprecations        抛出有关不推荐使用的功能的错误\n--no-systemNullSetters      不要将空的 SystemJS setter 替换为 `null`\n--no-treeshake              禁用除屑优化\n--no-treeshake.annotations 忽略纯调用注释\n--treeshake.correctVarValueBeforeDeclaration 在声明之前将变量取消优化\n--treeshake.manualPureFunctions <names> 手动将函数声明为纯函数\n--no-treeshake.moduleSideEffects 假设模块没有副作用\n--no-treeshake.propertyReadSideEffects 忽略属性访问副作用\n--no-treeshake.tryCatchDeoptimization 不要关闭 try-catch-tree-shaking\n--no-treeshake.unknownGlobalSideEffects 假设未知的全局变量不会抛出异常\n--validate                  验证输出\n--waitForBundleInput        等待打包输入文件\n--watch.buildDelay <number> 节流观察重建\n--no-watch.clearScreen      重建时不要清除屏幕\n--watch.exclude <files>     排除要观察的文件\n--watch.include <files>     限制观察到指定文件\n--watch.onBundleEnd <cmd>   在 \"BUNDLE_END\" 事件上运行的 Shell 命令\n--watch.onBundleStart <cmd> 在 \"BUNDLE_START\" 事件上运行的 Shell 命令\n--watch.onEnd <cmd>         在 \"END\" 事件上运行的 Shell 命令\n--watch.onError <cmd>       在 \"ERROR\" 事件上运行的 Shell 命令\n--watch.onStart <cmd>       在 \"START\" 事件上运行的 Shell 命令\n--watch.skipWrite           在监视时不要将文件写入磁盘\n```\n\n案例工程：\n\n```js\n// ./src/index.js\nimport { log, err } from \"./mod02\";\nimport info from \"./mod01\";\nlog(info.name)\n\n// ./src/mod01.js\nexport default {\n  name: 'chuckle',\n}\n\n// ./src/mod02.js\nexport const log =  msg => {\n  console.log(\"=======Info=======\")\n  console.log(msg)\n  console.log(\"==================\")\n}\nexport const err =  msg => {\n  console.log(\"=======Error=======\")\n  console.log(msg)\n  console.log(\"==================\")\n}\n```\n\n使用命令打包：\n\n```shell\nnpx rollup ./src/index.js\nnpx rollup ./src/index.js --format iife --file ./dist/bundle.js\n```\n\n打包结果：\n\nRollup的打包结果非常简洁，且默认开启Tree-shaking，它仅仅是将各个模块按依赖顺序拼接，没有Webpack那样存在大量的引导代码和模块函数，\n\n```js\n(function () {\n  'use strict';\n\n  const log =  msg => {\n    console.log(\"=======Info=======\");\n    console.log(msg);\n    console.log(\"==================\");\n  };\n\n  var info = {\n    name: 'chuckle',\n  };\n\n  log(info.name);\n\n})();\n```\n\n# 配置文件\n`rollup.config.mjs`是rollup的默认[配置文件](https://cn.rollupjs.org/command-line-interface/#configuration-files)，导出一个配置对象\n\n使用配置文件：`npx rollup --config <配置文件名>`，指定配置文件名以区分生产和打包环境\n\n```json\n\"scripts\": {\n  \"build\": \"rollup --config\"\n},\n```\n\n[智能提示](https://cn.rollupjs.org/command-line-interface/#config-intellisense)：由于 Rollup 随附了 TypeScript 类型定义，因此你可以使用 JSDoc 类型提示来利用你的 IDE 的智能感知功能\n\n```js\n/**\n * @type {import('rollup').RollupOptions}\n */\nconst config = { /* 你的配置 */ };\nexport default config;\n// or\nimport { defineConfig } from 'rollup';\nexport default defineConfig({ /* 你的配置 */ });\n```\n\n## 基本配置\n[所有配置](https://cn.rollupjs.org/configuration-options/)\n\n```js\nexport default {\n  input: './src/index.js', // 打包入口\n  output: {\n    file: './dist/bundle.js', // 打包出口\n    format: 'iife' // 格式\n  },\n  // 插件\n  plugins: [],\n};\n```\n\n[output.format](https://cn.rollupjs.org/configuration-options/#output-format)配置指定bundle输出格式：\n1. `amd` – 异步模块加载，适用于 RequireJS 等模块加载器\n2. `cjs` – CommonJS，适用于 Node 环境和其他打包工具（别名：commonjs）\n3. `es/esm` – 将 bundle 保留为 ES 模块文件，适用于其他打包工具，以及支持 `<script type=module>` 标签的浏览器。\n4. `iife` – 自执行函数，适用于 `<script>` 标签。\n5. `umd` – 通用模块定义规范，同时支持 amd，cjs 和 iife\n6. `system` – SystemJS 模块加载器的原生格式（别名：systemjs）\n\n# 插件\n插件是Rollup唯一的功能扩展途径。[使用插件](https://cn.rollupjs.org/tutorial/#using-plugins)，[插件列表](https://github.com/rollup/awesome)\n\n## plugin-json\n使用[plugin-json](https://github.com/rollup/plugins/tree/master/packages/json)从 JSON 文件中导入数据\n\n安装：`npm i @rollup/plugin-json -D`\n\n```js 使用插件\nexport default {\n  plugins: [\n    json(),\n  ],\n}\n```\n\n读取package.json测试插件\n\n```js\nimport { log, err } from \"./mod02\";\nimport { name, version } from \"../package.json\"\nlog(name + \" \" + version)\n```\n\n打包结果：\n\npackage.json中的name和version成功打包进来了\n\n```js\n(function () {\n  'use strict';\n\n  const log =  msg => {\n    console.log(\"=======Info=======\");\n    console.log(msg);\n    console.log(\"==================\");\n  };\n\n  var name = \"01\";\n  var version = \"1.0.0\";\n\n  log(name + \" \" + version);\n\n})();\n```\n\n## 加载npm模块\n为了保持Rollup的精简，node-resolve不是内置功能，[原因](https://cn.rollupjs.org/faqs/#why-isnt-node-resolve-a-built-in-feature)\n\n这意味着需要安装[node-resolve](https://www.npmjs.com/package/@rollup/plugin-node-resolve)才能在模块中导入第三方npm模块\n\n安装：`npm i @rollup/plugin-node-resolve -D`\n\n```js 配置\nimport nodeResolve from '@rollup/plugin-node-resolve';\nplugins: [nodeResolve()]\n```\n\n测试：\n\n```js\nimport { max } from \"lodash-es\"\nconst arr = [1, 2, 3, 4, 5]\nconsole.log(max(arr))\n```\n\n打包结果：\n\n```js\n(function () {\n  'use strict';\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  var freeGlobal$1 = freeGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal$1 || freeSelf || Function('return this')();\n\n  var root$1 = root;\n\n  /** Built-in value references. */\n  var Symbol = root$1.Symbol;\n\n  var Symbol$1 = Symbol;\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto$1.hasOwnProperty;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$1.toString;\n\n  /** Built-in value references. */\n  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n\n    try {\n      value[symToStringTag$1] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag;\n      } else {\n        delete value[symToStringTag$1];\n      }\n    }\n    return result;\n  }\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto.toString;\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n\n  /** Built-in value references. */\n  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return (symToStringTag && symToStringTag in Object(value))\n      ? getRawTag(value)\n      : objectToString(value);\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n\n  /** `Object#toString` result references. */\n  var symbolTag = '[object Symbol]';\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike(value) && baseGetTag(value) == symbolTag);\n  }\n\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value;\n  }\n\n  /**\n   * The base implementation of `_.gt` which doesn't coerce arguments.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if `value` is greater than `other`,\n   *  else `false`.\n   */\n  function baseGt(value, other) {\n    return value > other;\n  }\n\n  /**\n   * The base implementation of methods like `_.max` and `_.min` which accepts a\n   * `comparator` to determine the extremum value.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The iteratee invoked per iteration.\n   * @param {Function} comparator The comparator used to compare values.\n   * @returns {*} Returns the extremum value.\n   */\n  function baseExtremum(array, iteratee, comparator) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var value = array[index],\n          current = iteratee(value);\n\n      if (current != null && (computed === undefined\n            ? (current === current && !isSymbol(current))\n            : comparator(current, computed)\n          )) {\n        var computed = current,\n            result = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Computes the maximum value of `array`. If `array` is empty or falsey,\n   * `undefined` is returned.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Math\n   * @param {Array} array The array to iterate over.\n   * @returns {*} Returns the maximum value.\n   * @example\n   *\n   * _.max([4, 2, 8, 6]);\n   * // => 8\n   *\n   * _.max([]);\n   * // => undefined\n   */\n  function max(array) {\n    return (array && array.length)\n      ? baseExtremum(array, identity, baseGt)\n      : undefined;\n  }\n\n  // import { log, err } from \"./mod02\";\n  // import info from \"./mod01\";\n  // import { name, version } from \"../package.json\"\n\n  const arr = [1, 2, 3, 4, 5];\n  console.log(max(arr));\n\n})();\n```\n\n## 加载CommonJS模块\nRollup设计之初只处理ESM模块的打包，若需导入CommonJS模块，则需要安装[plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs)插件，[文档](https://cn.rollupjs.org/introduction/#importing-commonjs)\n\n安装：`npm i @rollup/plugin-commonjs -D`\n\n```js 配置\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport commonjs from '@rollup/plugin-commonjs';\nplugins: [\n  nodeResolve(),\n  commonjs(),\n],\n```\n\n注意，Tree-shaking不对CommonJS模块起作用\n\n## 压缩代码\n[plugin-terser](https://www.npmjs.com/package/@rollup/plugin-terser)是rollup的一种[输出插件](https://cn.rollupjs.org/tutorial/#using-output-plugins)，用来压缩rollup分析完的代码\n\n安装：`npm i @rollup/plugin-terser -D`\n\n```js 配置\nimport terser from '@rollup/plugin-terser';\nplugins: [terser()]\n```\n\n技巧：同时输出未压缩和压缩bundle\n\n```js\noutput: [\n  {\n    file: './dist/bundle.js',\n    format: 'cjs'\n  },\n  {\n    file: './dist/bundle.min.js',\n    format: 'iife',\n    plugins: [terser()]\n  }\n],\n```\n\n## 清空输出目录\n[rollup-plugin-clear](https://www.npmjs.com/package/rollup-plugin-clear)在每次打包前清空输出目录\n\n安装：`npm i rollup-plugin-clear -D`\n\n```js\nplugins: [\n  clear({\n    // 需要清空的文件夹\n    targets: ['dist'],\n    // 在监视模式下进行汇总重新编译时是否清除目录\n    watch: true, // default: false\n  }),\n],\n```\n\n## 生成html\n[plugin-html](https://www.npmjs.com/package/@rollup/plugin-html)生成html\n\n安装：`npm i @rollup/plugin-html -D`\n\n```js 配置\nimport html from '@rollup/plugin-html';\nplugins: [\n  html({\n    fileName: 'index.html',\n    title: 'Rollup Demo',\n    attributes: { lang: 'en' },\n    publicPath: '',\n    meta: [\n      { charset: 'utf8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1.0' },\n      { name: 'keywords', content: 'rollup, demo' },\n    ],\n    template({ attributes, bundle, files, publicPath, title, meta }) {\n      return `<!DOCTYPE html>\n      <html${Object.entries(attributes).reduce((prev, [key, value]) => prev + ` ${key}=\"${value}\"`, '')}>\n      <head>\n      ${meta.reduce((prev, item) => prev + `<meta${Object.entries(item).reduce((prev, [key, value]) => prev + ` ${key}=\"${value}\"`, '')}>`, '')}\n        <title>${title}</title>\n      </head>\n      <body>\n        <script src=\"https://requirejs.org/docs/release/2.3.6/minified/require.js\" data-main=\"${publicPath}index.min.js\"></script>\n      </body>\n      </html>`;\n    }\n  })\n],\n```\n\n## 处理css\n[plugin-postcss](https://www.npmjs.com/package/rollup-plugin-postcss)支持css文件的加载、css加前缀、css压缩、对scss/less的支持等等\n\n安装：`npm i rollup-plugin-postcss -D`\n\n```js 配置\nimport postcss from 'rollup-plugin-postcss';\nplugins: [\n  postcss({\n    extract: 'index.css', // 提取css为独立文件\n    minimize: true, // 最小化\n    plugins: [], // 支持其它处理css的插件\n  }),\n]\n```\n\n## 开发服务器\n[plugin-serve](https://www.npmjs.com/package/rollup-plugin-serve)搭建开发服务器\n\n安装：`npm i rollup-plugin-serve -D`\n\n```js 配置\nplugins: [\n  serve({\n    port: 3000, // 端口\n    contentBase: 'dist', // 输出目录\n    openPage: '/index.html', // 打开的是哪个文件\n    open: true, // 自动打开浏览器\n  })\n]\n```\n\n### 自动刷新\n[plugin-livereload](https://www.npmjs.com/package/rollup-plugin-livereload)自动刷新浏览器\n\n安装：`npm i rollup-plugin-livereload -D`\n\n`-w`启动监视模式`\"dev\": \"rollup -c -w -m\"`\n\n```js 配置\nimport livereload from \"rollup-plugin-livereload\";\nplugins: [\n  clear({\n    targets: ['dist'],\n    watch: false, // 需要设为false，否则和自动刷新冲突\n  }),\n  serve({\n    port: 3000, // 端口\n    contentBase: 'dist', // 输出目录\n    openPage: '/index.html', // 打开的是哪个文件\n    open: false, // 自动打开浏览器\n  }),\n  livereload(),\n]\n```\n\n## JS兼容\n[plugin-babel](https://www.npmjs.com/package/@rollup/plugin-babel)用于源代码转译，对低版本NODE或者浏览器环境进行兼容\n\n安装：\n1. `npm i -D @rollup/plugin-babel @babel/core @babel/plugin-external-helpers @babel/plugin-transform-runtime @babel/preset-env @babel/preset-typescript`\n2. `npm i --save @babel/runtime`\n\n```js 配置\nimport { babel } from '@rollup/plugin-babel';\nplugins: [\n  babel({\n    exclude: \"**/node_modules/**\",\n    babelHelpers: \"runtime\",\n    extensions: ['.js', '.ts'],\n  }),\n]\n```\n\n```json .babelrc\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false // Rollup要求Babel配置保持ES6模块语法不变\n      }\n    ],\n    \"@babel/preset-typescript\"\n  ],\n  \"plugins\": [\n    \"@babel/plugin-external-helpers\",\n    [\n      \"@babel/plugin-transform-runtime\",\n      {\n        \"useESModules\": false\n      }\n    ]\n  ]\n}\n```\n\n# 代码拆分\n动态加载或多个入口点，Rollup会自动将代码拆分成块，也可以通过[output.manualChunks](https://cn.rollupjs.org/configuration-options/#output-manualchunks)显式配置要拆分的块，[文档](https://cn.rollupjs.org/tutorial/#code-splitting)\n\n## 动态加载、多入口打包\n\n```js 配置\ninput: {\n  index: './src/index.js',\n  main: './src/main.js',\n},\noutput: {\n  dir: 'dist',\n  entryFileNames: '[name].js',\n  format: 'amd' // 为了实现动态导入，不能是UMD和IIFE，为了适应浏览器环境，使用amd模块格式\n  // [!] RollupError: Invalid value \"iife\" for option \"output.format\" - UMD and IIFE output formats are not supported for code-splitting builds.\n},\n```\n\n```js main.js\nimport(\"./mod01\").then(({ default: info }) => {\n  console.log(info.name);\n});\n```\n\n打包结果：\n\n```js\nPromise.resolve().then(function () { return require('./mod01-4ejDwqza.js'); }).then(({ default: info }) => {\n  console.log(info.name);\n});\n// mod01-4ejDwqza.js\nvar mod01 = {\n  name: 'chuckle',\n};\nexports.default = mod01;\n```\n\ntip：多入口打包时，会自动提取公共的模块\n\n页面还需引入amd模块的实现库，如[requirejs](https://requirejs.org/)\n\n通过`data-main`指定模块的入口文件\n\n```html\n<script\n  src=\"https://requirejs.org/docs/release/2.3.6/minified/require.js\" \n  data-main=\"/dist/index.min.js\" \n></script>\n```\n\n## output.manualChunks\n\n```js\noutput: {\n  dir: 'dist',\n  entryFileNames: '[name].js',\n  format: 'amd',\n  manualChunks: {\n    lodash: ['lodash-es'] // 拆分引入的lodash-es模块\n  }\n}\n```\n\n# 区分环境\n使用多配置文件区分开发和生产环境\n\n`rollup.config.common.mjs` 基础公共配置\n\n```js\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport commonjs from '@rollup/plugin-commonjs';\nimport clear from 'rollup-plugin-clear';\nimport typescript from '@rollup/plugin-typescript';\n\nexport default {\n  input: {\n    index: './src/index.ts',\n  }, // 打包入口\n  plugins: [\n    json(),\n    nodeResolve(),\n    commonjs({extensions: ['.js', '.ts']}),\n    clear({\n      // 需要清空的文件夹\n      targets: ['dist'],\n      // 在监视模式下进行汇总重新编译时是否清除目录\n      watch: false, // default: false\n    }),\n    typescript({\n      compilerOptions: {\n        lib: [\"es5\", \"es6\", \"dom\"],\n        target: \"es6\"\n      }\n    }),\n  ],\n};\n```\n\n`rollup.config.dev.mjs` 开发环境配置\n\n```js\nimport serve from 'rollup-plugin-serve';\nimport livereload from \"rollup-plugin-livereload\";\nimport html from '@rollup/plugin-html';\nimport postcss from 'rollup-plugin-postcss';\nimport common from './rollup.config.common.mjs';\nimport { htmlDevTemple } from './html-temple.mjs';\n\nexport default Object.assign({}, common, {\n  output: [\n    {\n      dir: 'dist',\n      entryFileNames: '[name].js',\n      format: 'es',\n      manualChunks: {\n        lodash: ['lodash-es']\n      }\n    }\n  ],\n  plugins: [\n    ...common.plugins,\n    serve({\n      port: 3000, // 端口\n      contentBase: 'dist', // 输出目录\n      openPage: '/index.html', // 打开的是哪个文件\n      open: false, // 自动打开浏览器\n    }),\n    livereload(),\n    html(htmlDevTemple),\n    postcss({\n      extract: 'index.css', // 提取css为独立文件\n      minimize: false, // 最小化\n      plugins: [], // 支持其它处理css的插件\n    }),\n  ],\n});\n```\n\n`rollup.config.prod.mjs` 生产环境配置\n\n```js\nimport html from '@rollup/plugin-html';\nimport postcss from 'rollup-plugin-postcss';\nimport terser from '@rollup/plugin-terser';\nimport { babel } from '@rollup/plugin-babel';\nimport common from './rollup.config.common.mjs';\nimport { htmlProdTemple } from './html-temple.mjs';\n\nexport default Object.assign({}, common, {\n  output: [\n    {\n      dir: 'dist',\n      entryFileNames: '[name].js',\n      format: 'amd',\n    },\n    {\n      dir: 'dist',\n      entryFileNames: '[name].min.js',\n      format: 'amd',\n      plugins: [terser()],\n      manualChunks: {\n        lodash: ['lodash-es']\n      }\n    }\n  ],\n  plugins: [\n    ...common.plugins,\n    html(htmlProdTemple),\n    postcss({\n      extract: 'index.css', // 提取css为独立文件\n      minimize: true, // 最小化\n      plugins: [], // 支持其它处理css的插件\n    }),\n    babel({\n      exclude: \"**/node_modules/**\",\n      babelHelpers: \"runtime\",\n      extensions: ['.js', '.ts'],\n    }),\n  ],\n});\n```\n\n`html-temple.mjs` HTML模板\n\n```js\nconst config = {\n  fileName: 'index.html',\n  title: 'Rollup Demo',\n  attributes: { lang: 'en' },\n  publicPath: '',\n  meta: [\n    { charset: 'utf8' },\n    { name: 'viewport', content: 'width=device-width, initial-scale=1.0' },\n    { name: 'keywords', content: 'rollup, demo' },\n  ]\n}\n\nexport const htmlDevTemple = {\n  ...config,\n  template({ attributes, bundle, files, publicPath, title, meta }) {\n    const link = `<link rel=\"stylesheet\" href=\"${publicPath}index.css\">`;\n    const script = `<script type=\"module\" src=\"${publicPath}index.js\"></script>`;\n    return renderHtml([link], [script], { attributes, bundle, files, publicPath, title, meta });\n  }\n}\n\nexport const htmlProdTemple = {\n  ...config,\n  template({ attributes, bundle, files, publicPath, title, meta }) {\n    const link = `<link rel=\"stylesheet\" href=\"${publicPath}index.css\">`;\n    const requirejs = \"https://requirejs.org/docs/release/2.3.6/minified/require.js\";\n    const script = `<script src=\"${requirejs}\" data-main=\"${publicPath}index.min.js\"></script>`;\n    return renderHtml([link], [script], { attributes, bundle, files, publicPath, title, meta });\n  }\n}\n\nfunction renderHtml(additionalHead, additionalBody, { attributes, bundle, files, publicPath, title, meta }) {\n  return `<!DOCTYPE html>\n    <html${renderAttributes(attributes)}>\n    <head>\n      ${renderMeta(meta)}\n      <title>${title}</title>\n      ${arrToString(additionalHead)}\n    </head>\n    <body>\n      ${arrToString(additionalBody)}\n    </body>\n    </html>`;\n}\n\nfunction arrToString(arr) {\n  return arr.reduce((prev, item) => prev + item, '')\n}\n\nfunction renderAttributes(attributes) {\n  return Object.entries(attributes).reduce((prev, [key, value]) => prev + ` ${key}=\"${value}\"`, '')\n}\n\nfunction renderMeta(meta) {\n  return meta.reduce((prev, item) => prev + `<meta${Object.entries(item).reduce((prev, [key, value]) => prev + ` ${key}=\"${value}\"`, '')}>`, '')\n}\n```\n\n修改package.json\n\n```json\n\"scripts\": {\n  \"build\": \"rollup --config rollup.config.prod.mjs\",\n  \"dev\": \"rollup --config rollup.config.dev.mjs -w -m \"\n},\n```\n\n# 总结\n**rollup优点：**\n1. 输出结果更加扁平\n2. 自动移除未引用代码\n3. 打包结果依然完全可读\n\n**rollup缺点：**\n1. 加载非ESM的第三方模块比较复杂\n2. 模块最终都被打包到一个函数中，无法实现HMR\n3. 浏览器环境中，代码拆分功能依赖AMD库\n\nrollup适用于开发框架和库，对于开发应用则不太合适\n\nWebpack大而全，Rollup小而美\n\n# 配置TS环境\n安装依赖：`npm i @rollup/plugin-typescript tslib -D`\n\n```js 配置\nimport typescript from '@rollup/plugin-typescript';\ninput: {\n  index: './src/index.ts',\n},\ntypescript({\n  compilerOptions: {\n    lib: [\"es5\", \"es6\", \"dom\"],\n    target: \"es5\"\n  }\n})\n```\n\n```json tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n    \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n    \"diagnostics\": true, // 打印诊断信息 \n    \"target\": \"esnext\", /* 指定 ECMAScript 目标版本：'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */\n    \"module\": \"esnext\", /* 输出的代码使用什么方式进行模块化： 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    \"lib\": [ /* 指定引用的标准库 */\n      \"esnext\",\n      \"dom\",\n      \"dom.iterable\",\n    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n    \"allowJs\": true, // 允许编译器编译JS，JSX文件\n    \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./src\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n    \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n    \"declarationDir\": \"./dist/typings\", // 指定生成声明文件存放目录\n    // \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n    \"sourceMap\": false, // 生成目标文件的sourceMap文件\n    // \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n    \"declarationMap\": false, // 为声明文件生成sourceMap\n    // \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n    \"types\": [], // 加载的声明文件包\n    \"removeComments\": true, // 删除注释 \n    \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n    \"noEmitOnError\": true, // 发送错误时不输出任何文件\n    \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n    \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n    \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n    \"strict\": true, // 开启所有严格的类型检查\n    \"alwaysStrict\": true, // 在代码中注入'use strict'\n    \"noImplicitAny\": true, // 不允许隐式的any类型\n    \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n    \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n    \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n    \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n    \"noImplicitThis\": true, // 不允许this有隐式的any类型\n    \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n    \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n    \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n    \"noImplicitReturns\": true, //每个分支都会有返回值\n    \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n    \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n    \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { // 路径映射，相对于baseUrl\n      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      // \"jquery\": [\n      //   \"node_modules/jquery/dist/jquery.min.js\"\n      // ],\n      \"@/*\": [\n        \"src/*\"\n      ]\n    },\n    \"rootDirs\": [\n      \"src\"\n    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n    \"listEmittedFiles\": true, // 打印输出文件\n    \"listFiles\": true, // 打印编译的文件(包括引用的声明文件)\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"resolveJsonModule\": true\n  },\n  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n  \"include\": [\n    \"src/**/*\",\n  ],\n  // 指定一个排除列表（include的反向操作）\n  // \"exclude\": [\n  //   \"demo.ts\"\n  // ],\n  // 指定哪些文件使用该配置（属于手动一个个指定文件）\n  // \"files\": [\n  //   \"demo.ts\"\n  // ]\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"Webpack","url":"/article/764f33bc.html","content":"\n# 前言\n从Webpack开始的前端工程化探索\n\n# 模块化\n随着前端应用的日益复杂，程序员需要更高效的代码组织形式，以便提高可维护性并提升开发效率。\n\n模块化将复杂的代码按功能的不同，分为不同的模块，单独维护，提高开发效率。\n\n**模块：**\n1. 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。\n2. 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。\n\n## 演变\n**1、文件划分**\n将不同的功能及其状态数据存放在单独的JS文件中。约定一个文件就是一个模块，以单独的script标签引入至HTML。\n\n虽然实现了功能的划分，但缺点也十分明显：\n1. 污染全局作用域\n2. 命名冲突\n3. 无法管理模块的依赖关系\n\n**2、命名空间**\n在文件划分的基础上，约定每个模块只暴露一个全局的对象，对象包裹着模块的方法和状态。\n\n虽然避免了命名冲突，但仍然没有私有空间，\n\n**3、IIFE**\n通过立即执行函数实现私有空间，使用window暴露模块的成员，通过参数声明依赖。\n\n```js\n(($)=>{\n  const name = 123;\n  const fun = () => {\n    $('body');\n    console.log(name); // 闭包\n  }\n  window.modelA = {\n    name\n  }\n})(JQuery) // 通过参数声明依赖\n\n```\n\n以上是在没有工具和相关规范的早期，以约定的形式，实践模块化思想的方式。\n\n仍然存在问题：\n1. 依赖管理混乱\n2. 不同开发者、不同项目，模块化的实现有差异\n3. 模块的导入不受代码控制\n\n### 现代化\n1. **模块化规范：**对模块代码书写格式和交互规则的详细描述\n2. **模块加载器：**使用代码的方式，自动控制模块的导入，管理模块的依赖。\n\n在ES6模块化出现之前，为了解决模块化的需求，出现了众多的模块化机制，CommonJS(NodeJS内置)、AMD(require.js)、CMD(Sea.js)\n\nES6模块化出现后的**最佳实践**：\n1. 浏览器环境：ES Module\n2. Node环境：CommonJS\n\n## ES Module\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJS 和 AMD 模块，都是运行时的\n\n```html\n<script type='module'>\n  import { name } from './modules/index.js';\n  export name;\n</script>\n```\n\n特性：\n1. 自动采用严格模式，忽略'use strict'\n2. 每个ESM模块都是单独的私有作用域\n3. ESM通过CORS请求外部JS模块\n4. ESM的script标签会延迟执行脚本(相当于defer)\n\n详见[ES6查缺补漏 #Module模块化](/article/383b041f.html#Module模块化)、[MDN-JavaScript模块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)\n\n### 兼容性问题\nES6仍然有兼容性问题，早期的浏览器，特别是国产和手机上的浏览器\n\n```shell 使用 caniuse-cmd 检查兼容性\nnpm install -g caniuse-cmd\ncaniuse import\n```\n\n可以引入 [Polyfill](https://polyfill.io/) 兼容\n\n使用 webpack、vite 后，有更多的兼容插件可以安装使用，如 `@vitejs/plugin-legacy`\n\nscript添加nomodule属性，仅在不支持ESM的浏览器上执行该脚本\n\n### ESM in Node\n文档：\n[Node.js 如何处理 ES6 模块-阮一峰](https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html)\n[Node.js文档-ECMAScript模块](https://nodejs.cn/api/esm.html)\n\nESM在Node.js的v8.5.0中作为实验性功能被引入，v12.17.0为所有Node.js应用程序提供了ESM支持\n\n使用 `.mjs`、`.cjs` 文件后缀区分 ESM 和 CommonJS 模块\n\n原生Node环境中的ESM与CommonJS：\n1. ES Module中可以导入CommonJS模块\n2. CommonJS中不能导入ES Module模块\n3. CommonJS始终只会导出一个默认成员\n\nESM得到CommonJS全局成员的值：\n\n```js index.mjs\n// console.log(__dirname)\n// ReferenceError: __dirname is not defined in ES module scope\nimport { fileURLToPath } from 'url'\nimport { dirname } from 'path'\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename)\nconsole.log(__filename)\nconsole.log(__dirname)\n// c:\\***\\esm-in-node\\index.mjs\n// c:\\***\\esm-in-node\n\n```\n\n## 前端打包工具\nESM仍然存在一些问题：\n1. 存在兼容性问题\n2. 模块文件过多，网络请求频繁\n3. 不仅是JS，前端所有的资源，包括CSS、HTML都需要模块化\n\n前端需要更好的工具和规范，让开发者继续享受模块化带来的便利，而不需要担心对**生产环境**产生的影响。\n\n**需求推动技术的进步**，打包工具顺势出现了。打包工具解决的是前端整体的模块化，不只是局限于JS的模块化。\n\n如今前端项目的代码组织，已经走上了**编辑代码**和**最终运行文件**完全两样的形式，一系列**工具链**和自动化的思想也融入进了打包工具中，打包也逐渐从一个技术问题，转变为了生态和管理问题。打包工具现在也可称为**构建工具**，支撑着前端工程化。\n\n常见的打包工具：[Webpack](https://webpack.docschina.org/)、[Vite](https://vitejs.dev/)、[Rollup](https://rollupjs.org/)、[esbuild](https://esbuild.github.io/)\n\n# Webpack\n[Webpack](https://webpack.docschina.org/)是一个用于现代 JavaScript 应用程序的静态模块打包工具。\n\n学习webpack大体上就是学习webpack.config.js的配置、各种loaders和plugins的使用，所以，多看文档，广泛了解，取所需使用[文档](https://webpack.docschina.org/concepts/)、[配置](https://webpack.docschina.org/configuration/)、[指南](https://webpack.docschina.org/guides/)、[loaders](https://webpack.docschina.org/loaders/)、[plugins](https://webpack.docschina.org/plugins/)\n\n## 快速上手\n\n```shell 安装\nnpm init -y\nnpm install webpack webpack-cli --save-dev\n```\n\n```json package.json\n{\n  \"private\": true, // 防止意外发布\n  \"scripts\": {\n    \"build\": \"webpack\" // 打包命令\n  },\n}\n```\n\n创建index.html和src目录，并写两个模块化文件：\n\n```html index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <script type=\"module\" src=\"src/index.js\"></script>\n</body>\n</html>\n```\n\n```js src/index.js\nimport { createTitle } from \"./module.js\";\ndocument.body.append(createTitle('Hello World'));\n```\n\n```js src/module.js\nexport const createTitle = (title) => {\n  const element = document.createElement('h2')\n  element.textContent = title\n  element.addEventListener('click', () => {\n    alert(title)\n  })\n  return element\n}\n```\n\n直接打开 index.html 可以看到页面上的 Hello World\n\n接着使用webpack进行打包\n\n```shell\nnpx webpack\n# 或\nnpm run build\n```\n\nwebpack自动创建了 dist 目录，存放了打包好的 main.js\n\n```js dist/main.js\n(()=>{\"use strict\";document.body.append((e=>{const t=document.createElement(\"h2\");return t.textContent=e,t.addEventListener(\"click\",(()=>{alert(e)})),t})(\"Hello World\"))})();\n```\n\n改为引入main.js\n\n```html\n<!-- <script type=\"module\" src=\"src/index.js\"></script> -->\n<!-- 打包好的main.js已经是ES5语法，可以去掉type=\"module\" -->\n<script src=\"dist/main.js\"></script>\n```\n\n打开 index.html 仍然可以看到 Hello World\n\nWebpack4以后，支持这样0配置的方式，快速打包项目，src是默认打包入口，dist是输出，index.js -> main.js\n\n# 配置\n根目录的 `webpack.config.js` 是webpack默认的配置文件\n\n可以手动创建配置文件，或在 VSCode 中下载[webpack插件](https://marketplace.visualstudio.com/items?itemName=jeremyrajan.webpack)，通过 `Webpack Create` 命令，初始化 webpack\n\n```js 插件默认创建的webpack.config.js\nconst path = require('path');\nmodule.exports = {\n  // 设置模式为开发模式\n  mode: 'development',\n  // 应用程序的入口点\n  entry: path.join(__dirname, 'src', 'index'),\n  // 启用监视模式，以在文件更改时进行自动重新编译\n  watch: true,\n  // 输出配置\n  output: {\n    // 存储输出文件的目录\n    path: path.join(__dirname, 'dist'),\n    // 打包文件的公共路径（由浏览器用于加载资源）\n    publicPath: '/dist/',\n    // 主要包的输出文件名\n    filename: \"bundle.js\",\n    // 动态加载的代码的输出文件名（代码分割）\n    chunkFilename: '[name].js'\n  },\n  // 用于处理不同文件类型的模块配置\n  module: {\n    // 使用Babel处理JavaScript和JSX文件的规则\n    rules: [{\n      // 用于匹配以.jsx或.js结尾的文件\n      test: /.jsx?$/,\n      // 只处理src目录下的文件\n      include: [\n        path.resolve(__dirname, 'src')\n      ],\n      // 排除node_modules目录下的文件\n      exclude: [\n        path.resolve(__dirname, 'node_modules')\n      ],\n      // 使用babel-loader进行转译\n      loader: 'babel-loader',\n      options: {\n        // 使用指定的Babel预设\n        presets: [\n          [\"@babel/env\", {\n            // 指定目标浏览器版本为最近的两个Chrome版本\n            \"targets\": {\n              \"browsers\": \"last 2 chrome versions\"\n            }\n          }]\n        ]\n      }\n    }]\n  },\n  // 配置模块解析的文件扩展名\n  resolve: {\n    extensions: ['.json', '.js', '.jsx']\n  },\n  // 生成源映射以方便调试\n  devtool: 'source-map',\n  // 配置开发服务器\n  devServer: {\n    // 提供内容的基本目录\n    contentBase: path.join(__dirname, '/dist/'),\n    // 启用内联模式，自动注入脚本以处理实时更新\n    inline: true,\n    // 服务器主机\n    host: 'localhost',\n    // 服务器端口\n    port: 8080,\n  }\n};\n\n```\n\nJS配置文件运行在node环境中，所以需要使用CommonJS写法\n\n插件还会自动安装这些插件：\n\n```json\n\"devDependencies\": {\n  \"webpack\": \"^5.74.0\",\n  \"webpack-cli\": \"^4.10.0\",\n  \"@babel/core\": \"^7.18.13\",\n  \"@babel/preset-env\": \"^7.18.10\",\n  \"babel-loader\": \"^8.2.5\",\n  \"webpack-dev-server\": \"^4.10.0\"\n}\n```\n\n## 基本概念\n1. `entry`: webpack打包的入口起点，从这里开始根据各个文件之间的依赖来对文件进行打包。单页面应用只有一个入口起点，多页面应用则存在多个入口起点\n2. `output`: 打包文件输出定义的地方，定义打包后输出文件的名字以及输出路径等\n3. `mode`: 模式，webpack打包的模式，分为三种 development、production、none\n4. `loader`: 对javascript等文件进行预处理的，可以通过loader来构建包含javascript在内的任何静态资源\n5. `plugin`: 插件是用来解决loader解决不了的问题，它可以在webpack构建过程中任何一个节点来调用\n\n[createapp.dev](https://createapp.dev/webpack/) 是一个创建自定义 webpack 配置的在线工具\n\n使用不同的配置文件：\n\n```json package.json\n\"scripts\": {\n  \"build\": \"webpack --config prod.config.js\"\n}\n```\n\n# 入口和上下文\n入口对象是用于 webpack 查找开始构建 bundle 的地方。上下文是入口文件所处的目录的绝对路径的字符串。[文档](https://webpack.docschina.org/configuration/entry-context/)\n\n## 基础目录context\n`context` 基础目录，**绝对路径**，解析入口点(entry point)和加载器(loader)\n\n```js\ncontext: path.resolve(__dirname, 'src'),\n```\n\n配置了context后，entry路径相对于context\n\n```js\nentry: './src/index.js',\n// 配置context后\ncontext: path.resolve(__dirname, 'src'),\nentry: './index.js',\n```\n\n## 入口entry\nentry指示webpack使用一个或多个模块，来作为构建应用的入口，webpack会找出哪些模块和是入口起点的直接或者间接的依赖，并将其打包到一起。默认值 `./src/index.js`\n\n**value类型：**string、array、object\n\n入口分为**单入口**(单页应用SPA)和**多入口**(多页面应用)\n\n**1、单入口**\n单入口主要使用string、array为值，应用于单页应用SPA\n\n```js\nentry: './index.js',\n// 将这两个文件以及其中所依赖的代码打包到同一个文件中\nentry: ['./index.js', './main.js'],\n```\n\n这种写法默认的chunkname是main，是object的简略写法\n\n```js object完整写法\nentry: {\n  main: './index.js',\n},\nentry: {\n  main: ['./index.js', './main.js'],\n},\n```\n\n**2、多入口**\n多入口即有多个html，分别需要不同的打包好的js\n\n```js\n{\n  entry: {\n    main: './src/main.js',\n    bundle: './src/index.js'\n  },\n  // 这里的[name]相当于是个占位符，值就是上面入口的key值，单入口时可以写死，不过不建议\n  output: {\n    // 多入口需要对应多出口，通常用[name]占位，不然打包会报错\n    filename: '[name].js'\n  }\n}\n```\n\n可以看到dist目录下打包好了 main.js 和 index.js 两个文件\n\n**3、更多配置**\n打包入口不仅仅是写一个入口文件地址就可以，它还有额外的配置：\n1. `dependOn`: 指当前入口文件所依赖的模块，这些模块必须在入口文件被加载前加载\n2. `filename`: 指定要输出的文件名称(优先级高于output中的filename和path)\n3. `import`: 启动时要加载的模块(入口文件地址)\n\n```js\n{\n  entry: {\n    index: './index.js',\n    main: './main.js',\n    catalog: {\n      import: './catalog.js',\n      filename: 'pages/log.js',\n      dependOn: 'main',\n    },\n  },\n  output: {\n    filename: '[name].js',\n  }\n}\n```\n\n## 出口output\noutput配置的作用是告知webpack如何向硬盘写入打包好的文件。\n\n**注意：**entry可以存在多个入口，但output只有一个出口配置\n\n**配置项：**\n1. filename 打包文件名，默认main.js\n2. path 打包文件输出路径，默认dist\n3. clean 输出包前清空输出目录，默认false\n\n**1、filename**\n\n```js\n// [name]对应entry的key\noutput: {\n  filename: '[name].js',\n}\n// 使用内部chunk id占位\noutput: {\n  filename: '[id].bundle.js',\n  // main-0.js\n},\n// 使用由生成的内容产生的 hash，通常和[name]组合使用\noutput: {\n  filename: '[name]-[contenthash].js',\n  // main-8bc05850732530fe321c.js\n},\n```\n\n**2、path 和 clean**\n\n```js\noutput: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name]-[contenthash].js',\n  clean: true,\n}\n```\n\n\n# 工作模式mode\n`mode` 用于设置webpack的工作模式，告知 webpack 使用相应模式的内置优化，[文档](https://webpack.docschina.org/configuration/mode/)\n\n```js webpack.config.js\nmodule.exports = {\n  mode: 'development',\n};\n```\n\n三种工作模式：\n1. **production** 默认，生产模式，启用自动压缩代码、去除业务无关代码等\n2. **development** 开发模式\n3. **none** 不使用任何默认优化选项\n\n# 打包结果分析\n将 mode 设为 none，查看输出文件\n\n整个打包好的模块是一个立即执行函数\n\n```js 折叠后\n/******/ (() => { // webpackBootstrap\n/******/ })()\n;\n```\n\n展开一层\n\n```js\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.\n(() => {\n})();\n\n// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.\n(() => {\n})();\n\n/******/ })()\n;\n```\n\n先看最末尾的两个IIFE，两个入口文件 index.js 和 main.js，分别被打包为了立即执行函数，以此实现私有作用域\n\n```js\n// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.\n(() => {\nvar __webpack_exports__ = {};\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\ndocument.body.append((0,_module_js__WEBPACK_IMPORTED_MODULE_0__.createTitle)('Hello World'));\n})();\n\n// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.\n(() => {\n})();\n```\n\n再看其它代码\n\n```js\n// 这个数组包含了Webpack构建过程中生成的模块信息。\n// 数组的每个元素对应一个模块，具体模块的内容在数组索引位置的函数中定义\nvar __webpack_modules__ = ([/******/]);\n// 缓存已经加载的模块，以避免重复加载\nvar __webpack_module_cache__ = {};\n// 模块加载函数，用于加载模块并执行其中的代码。\n// 它接受一个模块ID作为参数，检查是否已经缓存了该模块，如果没有，则执行模块代码，并将模块的导出结果缓存起来\nfunction __webpack_require__(moduleId) {/******/}\n// 三个立即执行函数，往__webpack_require__上挂载了一些数据和工具函数\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t})();\n// 用于存储模块的导出内容\nvar __webpack_exports__ = {};\n```\n\n# loader\n[loader](https://webpack.docschina.org/concepts/loaders/)是webpack实现前端模块化的核心，用于将指定格式的资源文件按一定格式进行转换输出\n\n例如，可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。\n\n官方[loaders](https://webpack.docschina.org/loaders/)\n\n**特点：**\n1. 单一职责：一个Loader只做一件事情，正因为职责越单一，所以Loaders的组合性强，可配置性好\n2. loader支持链式调用，上一个loader的处理结果可以传给下一个loader接着处理，上一个Loader的参数options可以传递给下一个loader，直到最后一个loader，返回Webpack所期望的JavaScript\n\nwebpack内部的default loader只能处理JavaScript，想要处理如css、ts等其它类型文件，就要安装对应的loader\n\nloader可以分为三类：\n1. 编译转换型：如css-loader\n2. 文件操作型：如file-loader\n3. 代码检查型：如eslint-loader\n\n**案例：**\n\n```js\n// 用于处理不同文件类型的模块配置\nmodule: {\n  // 使用Babel处理JavaScript和JSX文件的规则\n  rules: [{\n    // 用于匹配以.jsx或.js结尾的文件\n    test: /.jsx?$/,\n    // 只处理src目录下的文件\n    include: [\n      path.resolve(__dirname, 'src')\n    ],\n    // 排除node_modules目录下的文件\n    exclude: [\n      path.resolve(__dirname, 'node_modules')\n    ],\n    // 使用babel-loader进行转译\n    loader: 'babel-loader',\n    options: {\n      // 使用指定的Babel预设\n      presets: [\n        [\"@babel/env\", {\n          // 指定目标浏览器版本为最近的两个Chrome版本\n          \"targets\": {\n            \"browsers\": \"last 2 chrome versions\"\n          }\n        }]\n      ]\n    }\n  }]\n},\n```\n\nModule的文档：[module](https://webpack.docschina.org/configuration/module/)\n\n## 加载css\n查看官方文档[指南-管理资源-加载CSS](https://webpack.docschina.org/guides/asset-management/#loading-css)\n\n安装所需的loader\n\n```shell\nnpm install --save-dev style-loader css-loader\n```\n\n添加配置，[css-loader](https://webpack.docschina.org/loaders/css-loader/)将css文件打包为js模块，[style-loader](https://webpack.docschina.org/loaders/style-loader/)把 CSS 插入到 DOM 中（css-loader将css push到一个数组中，style-loader将数组中的css通过style标签追加到html-head中）\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // 正则匹配loader要处理的资源\n        test: /\\.css$/i,\n        // 逆序执行，从右往左\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n}\n```\n\nsrc目录下创建index.css\n\n```css src/index.css\nbody{\n  background-color: #ccc;\n}\n```\n\n打包入口中使用该css\n\n```js src/index.js\nimport './index.css'\n```\n\n现在样式已经生效\n\nwebpack推荐我们使用import根据JS代码的需要**动态**导入资源，就像刚刚import css一样，这样的代码与资源的关系，更符合模块化的依赖思想\n\n## 加载其它资源\nwebpack5使用[资源模块Asset Modules](https://webpack.docschina.org/guides/asset-modules/)来加载图片、字体等资源，webpack4则使用[file-loader](https://v4.webpack.docschina.org/loaders/file-loader/)和[url-loader](https://v4.webpack.docschina.org/loaders/url-loader/)等\n\n### file-loader\n安装[file-loader](https://v4.webpack.docschina.org/loaders/file-loader/)：\n\n```shell\nnpm i file-loader -D\n```\n\n在代码所需的地方导入图片并使用\n\n```js src/index.js\nimport avatar from './avatar.png' // 导入打包后资源的路径\nconst img = new Image();\nimg.src = avatar;\ndocument.body.append(img);\n```\n\n配置规则\n\n```js\nmodule: {\n  rules: [\n    /******/\n    {\n      test: /\\.png$/,\n      use: 'file-loader',\n    }\n  ],\n},\n```\n\n打包后，在dist目录下生成了871132b331c17257fcba75273b57f9fe.png，这是将文件的hash值作为了打包后的文件名，当然，这也是可以自定义的。\n\n```js\n{\n  test: /\\.png$/,\n  use: {\n    loader: 'file-loader',\n    options: {\n      // 默认[hash].[ext]\n      name: '[path][name].[ext]',\n    }\n  },\n}\n```\n\n这样就能保留图片的原始相对路径和名称。\n\n### url-loader\nfile-loader拷贝文件到输出目录，而[url-loader](https://v4.webpack.docschina.org/loaders/url-loader/)通过**durl**的形式表示文件\n\n```shell\nnpm i url-loader -D\n```\n\ndurl即Data URLs，可以通过url直接去表示文件的内容，不会产生任何请求\n\n```js\n// 一个html类型的文件内容，编码是utf-8\ndata:text/html;charset=UTF-8,<h1>html content</h1>\n// 如果是图片这种无法直接通过文本表示的文件，则可以将文件内容进行base64编码\ndata:image/png;base64,iDAHAidhbaIADHA...AHiDAd\n```\n\n**最佳实践：**配置小文件使用url-loader，大文件则使用file-loader\n\n```js\n{\n  test: /\\.(png|ico)$/,\n  use: {\n    loader: \"url-loader\",\n    options: {\n      name: \"[path][name]_[hash:6].[ext]\",\n      limit: 50 * 1024, //小于50kb的进行编码\n      // 超过这个大小，url-loader会自动调用file-loader\n    },\n  },\n}\n```\n\n```js\nimport { createImage } from \"./module.js\";\nimport avatar from './avatar.png'\nimport icon from './icon.ico'\ndocument.body.append(createImage(avatar));\ndocument.body.append(createImage(icon));\n```\n\n### Asset Modules\nwebpack5使用[资源模块Asset Modules](https://webpack.docschina.org/guides/asset-modules/)来加载图片、字体等资源。\n\n在webpack5之前，通常使用：raw-loader将文件导入为字符串，url-loader将文件作为durl内联到bundle中，file-loader将文件发送到输出目录\n\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：\n1. `asset/resource` 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\n2. `asset/inline` 导出一个资源的 data URI。之前通过使用 url-loader 实现。\n3. `asset/source` 导出资源的源代码。之前通过使用 raw-loader 实现。\n4. `asset` 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n\n**案例：**\n\n```js asset/resource\n{\n  test: /\\.(png|jpg|svg|gif|ico)$/,\n  // type选择类型\n  type: \"asset/resource\",\n  // 通过generator属性进行配置\n  generator: {\n    filename: \"img/[name]_[hash:6][ext]\",\n  },\n},\n```\n\n```js asset/inline\n{\n  test: /\\.(png|jpg|svg|gif|ico)$/,\n  type: \"asset/inline\",\n},\n```\n\n最佳实践：type设为asset，添加一个parser属性，并且制定dataUrl的条件，添加maxSize属性；\n\n```js \n{\n  test: /\\.(png|jpg|svg|gif|ico)$/,\n  type: \"asset\",\n  generator: {\n    filename: \"img/[name]_[hash:6][ext]\",\n  },\n  parser: {\n    dataUrlCondition: {\n      maxSize: 50 * 1024,//小于50kb进行编码，转为base64\n    },\n  },\n},\n```\n\n## babel-loader\nwebpack由于打包需要，会去处理import和export，但对于其它ES6新特性，则不会去做兼容处理\n\n如果需要将代码中的ES6进行转换，则需要[babel-loader](https://webpack.docschina.org/loaders/babel-loader/)\n\n```js\n// 安装babel-loader及其依赖的核心库和特性转换集合\nnpm install -D babel-loader @babel/core @babel/preset-env\n```\n\n**注意：**babel只是转换JS代码的一个平台，还需要用其它的插件，如@babel/preset-env，通过该平台来转换ES6特性\n\n进行配置：\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/i,\n      include: [\n        path.resolve(__dirname, 'src')\n      ],\n      exclude: [\n        path.resolve(__dirname, 'node_modules')\n      ],\n      loader: 'babel-loader',\n      options: {\n        presets: [\"@babel/preset-env\"]\n      }\n    },\n  ]\n}\n```\n\n开启ESM转CommonJS(会导致Tree Shaking失效，不推荐开启)\n\n```js\npresets: [\n  [\"@babel/preset-env\", {\n    modules: \"commonjs\", // 开启ESM转CommonJS，默认：\"auto\"\n  }]\n]\n```\n\n这样就完成了简单的ES6转换，更完善的使用core-js@3兼容，后面再说吧。\n\n## 资源加载方式\n除了在js文件中使用import加载资源，webpack还会自动处理其它加载资源的方式，如css文件中的url()、@import\n\n例如：当css-loader在处理css文件时遇到url()时，会找到符合的规则对所需的资源进行处理，如使用asset/resource对图片资源处理\n\n```css\n/* main.css */\nbody{\n  background-image: url(avatar.png);\n  background-size: auto;\n}\n\n/* index.css */\n@import './main.css';\nbody{\n  background-color: #ccc;\n}\n```\n\n## 开发loader\n尝试开发一个markdown-loader，深入了解loader的工作过程\n\n**文档：**[编写loader](https://www.webpackjs.com/contribute/writing-a-loader/)\n\n**功能：**将模块中所需的markdown资源转为html内容导入\n\n在根目录新建`markdown-loader.js`，一个最简单的loader是一个函数，接收传入的资源内容，若该loader是最后一个执行的，返回结果必须是JS代码\n\n```js\nmodule.exports = source => {\n  console.log(source)\n  return 'console.log(source)'\n}\n```\n\n使用该loader\n\n```js\n{\n  test: /\\.md$/i,\n  use: path.resolve(__dirname, 'markdown-loader.js'),\n}\n```\n\n在模块中导入markdown，webpack只会处理模块所依赖的资源\n\n```js src/main.js\nimport md from './01.md'\nconsole.log(md)\n```\n\n打包时控制台输出了markdown的内容。查看打包结果，loader返回的js也在其中，被一个IIFE包裹。\n\n下面继续完成功能：\n\n安装解析markdown内容的模块，使用[marked](https://www.npmjs.com/package/marked)\n\n```shell\nnpm i marked -D\n```\n\n修改 `markdown-loader.js`\n\n```js\nconst marked = require('marked');\n\nmodule.exports = source => {\n  console.log(source)\n  const html = marked.parse(source)\n  console.log(html)\n  return 'console.log(source)'\n}\n```\n\n输出如下，现在loader已经能解析markdown文件了\n\n```text\n# 简介\n这是一个**markdown**\n<h1>简介</h1>\n<p>这是一个<strong>markdown</strong></p>\n```\n\n完善loader，将html暴露给模块使用，会作为模块中import markdown文件的default值\n\n```js\nconst marked = require('marked');\n\nmodule.exports = source => {\n  const html = marked.parse(source)\n  // html中存在一些字符，使用JSON.stringify进行转译\n  return `export default ${JSON.stringify(html)}`\n}\n```\n\n现在，markdown-loader就完成了，模块导入的就是解析好的html内容\n\n```js src/main.js\nimport md from './01.md'\nconsole.log(md)\n// <h1>简介</h1>\n// <p>这是一个<strong>markdown</strong></p>\n```\n\n当然，markdown-loader也可以直接返回解析好的html内容，再交给loader管道中下一个loader进行处理，webpack只要求最后一个loader返回的需要是JS代码\n\n处理html就需要安装html-loader，`npm i html-loader -D`\n\n修改代码：\n\n```js\n{\n  test: /\\.md$/i,\n  use: [\n    'html-loader',\n    path.resolve(__dirname, 'markdown-loader.js'),\n  ]\n}\n```\n\n```js\nconst marked = require('marked');\n\nmodule.exports = source => {\n  const html = marked.parse(source)\n  return html\n}\n```\n\n实现的功能也是一样的\n\n# plugin\nloader用于处理资源的加载，而插件[plugin](https://webpack.docschina.org/concepts/plugins/)用于实现各种**自动化**操作，如压缩代码、替换内容、处理资源\n\n官方[plugins](https://webpack.docschina.org/plugins/)\n\n## 打包分析插件\n[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)是一个打包分析插件，使用交互式可缩放树形地图可视化，并输出文件的大小。可以方便开发人员检查打包后的文件拆分、分析文件大小。\n\n每次打包时，会自动打开浏览器，访问`127.0.0.1:8888`查看项目结构\n\n安装：`npm i webpack-bundle-analyzer -D`\n\nwebpack中，插件都需要导入后使用，且通常插件导出的都是一个class，需要new实例。配置项plugins是一个数组，保存插件的实例。\n\n```js\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\n/*****/\nplugins: [\n  new BundleAnalyzerPlugin(),\n],\n```\n\n## 自动生成HTML\n手动在根目录创建index.html，并配置打包好的JS等资源的路径，这样硬编码过于麻烦且易出错\n\n可以使用[html-webpack-plugin](https://webpack.docschina.org/plugins/html-webpack-plugin/)简化HTML文件的创建，自动引入打包好的JS模块，这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。\n\n安装：`npm i html-webpack-plugin --D`\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nplugins: [\n  new HtmlWebpackPlugin({\n    template: path.resolve(__dirname, './index.html'), // 自定义模板\n    inject: 'body', // 插入到body\n    filename: 'index.html', // 输出文件名，默认index.html\n    title: 'webpack测试', // 自定义title，通过<%= htmlWebpackPlugin.options.title %>在html中使用\n    minify: true, // 压缩\n  }),\n]\n```\n\n修改根目录下的index.html，使其作为一个模板\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title><%= htmlWebpackPlugin.options.title %></title>\n</head>\n<body>\n  <!-- 去掉js文件的引入，插件会自动引入 -->\n  <!-- <script src=\"dist/main.js\"></script> -->\n</body>\n</html>\n```\n\n查看打包后的index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>webpack测试</title>\n</head>\n<body>\n  <script defer src=\"main_0cc0be.js\"></script>\n</body>\n</html>\n```\n\nhtml-webpack-plugin还有其它的配置项，查看官方仓库文档：[配置项](https://github.com/jantimon/html-webpack-plugin#options)\n\n若是多页面、多个html文件，则创建多个插件实例加入到plugins数组中\n\n## 拷贝文件\n通常项目中还有一些无需打包的静态文件存放于public目录，这些资源同样需要输出到dist\n\n[copy-webpack-plugin](https://webpack.docschina.org/plugins/copy-webpack-plugin/)\n\n安装：`npm i copy-webpack-plugin -D`\n\n```js\nconst CopyPlugin = require(\"copy-webpack-plugin\");\nplugins: [\n  new CopyPlugin({\n    patterns: [\n      // 复制public文件夹内的文件到{output}中\n      { from: path.resolve(__dirname, 'public'), to: \"\" },\n    ],\n  }),\n]\n```\n\n## 开发plugin\n相较于loader只作用于模块加载，plugin的作用范围更广。plugin通过常见的**钩子机制**实现，就像Vue生命周期提供的钩子一样。\n\nwebpack提供了很多打包过程中的**钩子**，plugin向这些钩子上**挂载**任务，并获取**上下文**，来实现对资源的操作等功能。\n\n钩子相关文档：[compiler-hooks](https://webpack.docschina.org/api/compiler-hooks/)\n\nwebpack要求plugin必须是一个函数，或一个**包含apply方法**的对象，通常是定义一个包含apply方法的类\n\n新建`myPlugin.js`\n\n```js\nexport default class {\n  // apply接收一个compiler对象参数\n  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数\n  apply(compiler) {}\n}\n```\n\n现在开发一个用于清除webpack生成的`/******/`注释，以方便阅读打包后的JS代码\n\n明确了功能，考虑需要用到哪些钩子，显然，清除注释要在输出文件前执行，对要输出的内容进行处理。[emit](https://webpack.docschina.org/api/compiler-hooks/#emit)钩子符合需求，这个钩子在输出 asset 到 output 目录之前执行。\n\n```js\nexport default class {\n  // apply接收一个compiler对象参数\n  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数\n  apply(compiler) {\n    // 通过hooks属性访问钩子，tap方法注册钩子函数\n    // tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数\n    compiler.hooks.emit.tap('MyPlugin', compilation => {\n      // compilation是此次打包过程中的上下文，存放了打包过程的信息和结果\n      // compilation.assets获取即将输出的资源文件信息\n      for (const name in compilation.assets) {\n        console.log(name); // 输出文件名\n      }\n    })\n  }\n}\n```\n\n使用插件\n\n```js\nconst MyPlugin = require('./myPlugin.js');\nplugins: [\n  new MyPlugin(),\n]\n```\n\n输出：\n\n```shell\nmain_28990539038fea465479.js\nimg/avatar_871132b331c17257fcba.png\nimg/icon_36fa45932bf38a34e9af.ico\nfavicon.ico\nindex.html\n```\n\n插件已经能读取到打包后的文件名，接下来通过正则替换来处理JS文件\n\n```js\nmodule.exports = class {\n  #isJSFile(filename) {\n    // 使用正则表达式检查文件名是否以 .js 结尾\n    return /\\.js$/i.test(filename);\n  }\n\n  // apply接收一个compiler对象参数\n  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数\n  apply(compiler) {\n    // 通过hooks属性访问钩子，tap方法注册钩子函数\n    // tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数\n    compiler.hooks.emit.tap('MyPlugin', compilation => {\n      // compilation是此次打包过程中的上下文，存放了打包过程的信息和结果\n      // compilation.assets获取即将输出的资源文件信息\n      for (const name in compilation.assets) {\n        // console.log(name);\n        // 使用source方法获取文件内容\n        if(this.#isJSFile(name)){\n          let content = compilation.assets[name].source();\n          // 使用正则去除webpack生成的/******/\n          content = content.replace(/\\/\\*{3,}\\//g, '');\n          // 覆盖文件信息\n          compilation.assets[name] = {\n            // 覆盖内容\n            source: () => content,\n            // webpack要求指定大小\n            size: () => content.length\n          }\n        }\n      }\n    })\n  }\n}\n```\n\n现在，打包的JS文件内容已经去除了`/******/`\n\n但控制台有警告信息：\n\n```shell\n(node:76292) [DEP_WEBPACK_COMPILATION_ASSETS] DeprecationWarning: Compilation.assets will be frozen in future, all modifications are deprecated.\nBREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.\n        Do changes to assets earlier, e. g. in Compilation.hooks.processAssets.\n        Make sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.\n(Use `node --trace-deprecation ...` to show where the warning was created)\n```\n\n这是因为Webpack5将在未来版本冻结`compilation.assets`，需在`compiler.hooks.thisCompilation`钩子中使用 Compilation 中的 processAssets hook 来对资源进行再处理\n\n```js\nmodule.exports = class {\n  #isJSFile(filename) {\n    // 使用正则表达式检查文件名是否以 .js 结尾\n    return /\\.js$/i.test(filename);\n  }\n\n  // apply接收一个compiler对象参数\n  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数\n  apply(compiler) {\n    // 使用thisCompilation钩子，在 compilation 对象创建时执行一些自定义逻辑\n    compiler.hooks.thisCompilation.tap('MyPlugin', compilation => {\n      // processAssets钩子用于在 webpack 编译完成后，但在最终资源输出之前，处理资源文件的阶段执行插件代码\n      compilation.hooks.processAssets.tap(\n        {\n          name: 'MyPlugin',\n          // https://webpack.docschina.org/api/compilation-hooks/#list-of-asset-processing-stages\n          stage: compilation.PROCESS_ASSETS_STAGE_OPTIMIZE, // 以通用的方式优化已有asset\n        },\n        (assets) => {\n          for (const name in assets) {\n            if (this.#isJSFile(name)) {\n              // 使用正则表达式去除块注释\n              const content = assets[name].source().replace(/\\/\\*{3,}\\//g, '');\n              // 覆盖文件信息\n              assets[name] = {\n                source: () => content,\n                size: () => content.length,\n              };\n            }\n          }\n        }\n      );\n    })\n  }\n}\n```\n\n# 优化开发过程\n项目打包过程已经自动化了，但开发过程仍然在手动操作\n\n编写代码->命令打包->运行应用->刷新浏览器，这个繁琐的过程也需要自动化，以提高开发效率\n\n提出下面的需求：\n1. 以 HTTP Server 运行，而不是打开文件浏览\n2. 自动编译 + 自动刷新\n3. 提供 Source Map 支持，方便调试\n\n## watch工作模式\n处于watch工作模式时，webpack会监听文件变化，自动重新打包\n\n添加watch配置：\n\n```js\nmodule.exports = {\n  watch: true,\n}\n```\n\n## DevServer\n[webpack dev server](https://webpack.docschina.org/configuration/dev-server)提供了HTTP Server，集成了自动编译和自动刷新浏览器的功能。\n\n该插件会将将打包结果暂时存放于内存，而不输出于硬盘，以提高性能。\n\n安装：`npm i webpack-dev-server -D`\n\n```js 添加配置\nmodule.exports = {\n  // 配置开发服务器\n  devServer: {\n    // 服务器主机\n    host: 'localhost',\n    // 服务器端口\n    port: 8080,\n    // 启用Gzip\n    compress: true,\n    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能\n     // 使用static配置从目录提供静态文件的选项，默认public\n    static: {\n      // 告诉服务器从哪里提供内容\n      directory: path.join(__dirname, 'public'),\n    },\n  }\n}\n```\n\n添加命令脚本\n\n```json\n{\n  \"scripts\": {\n    \"serve\": \"webpack serve\"\n  }\n}\n```\n\n使用命令运行`npm run serve`\n\n## 代理API服务\n前后端同源部署时，本地开发在请求api时可能有cors问题，可以使用开发服务器代理api请求，服务器间通信就不存在cors了\n\nDevServer就支持`proxy`配置api代理，[文档](https://webpack.docschina.org/configuration/dev-server/#devserverproxy)\n\n```js\ndevServer: {\n  proxy: {\n    // 代理api路径\n    '/api': {\n      // localhost:8080/api/user -> api.github.com/api/user\n      target: 'https://api.github.com',\n      // 请求路径重写 /api/user -> /user\n      pathRewrite: { '^/api': '' },\n      // 将 host 请求头修改为 target 的 URL\n      changeOrigin: true,\n    },\n  },\n}\n```\n\n## Source Map\n前端工程化后，源代码和运行代码几乎完全不同，调试和报错都是基于运行代码，调试源代码就成了问题\n\nSource Map用于映射源代码和运行代码之间的关系\n\n一个Source Map的组成：\n\n```json\n{\n  \"version\": 3, // 当前Map使用的Source Map标准版本\n  \"sources\": [\"main.js\"], // 记录源文件的名称，可以是多个文件\n  \"names\": [\"global\",/****/], // 源代码使用的成员名称，如变量的原名\n  \"mappings\": \";/****/\" // 核心，记录源码和运行代码一些字符的映射关系\n}\n```\n\n通过一行特定格式的注释引入Source Map\n\n```js\n//# sourceMappingURL=main.map\n```\n\n如果Source Map不起作用，需在浏览器控制台-设置-偏好设置中启用JavaScript源代映射\n\n使用[Devtool](https://webpack.docschina.org/configuration/devtool/)在webpack中配置Source Map：\n\n```js\nmodule.exports = {\n  devtool: 'source-map', // 值为Source Map工作模式\n}\n```\n\n相关文章：[一文搞懂SourceMap以及webpack devtool](https://juejin.cn/post/6960941899616092167)\n\nSource Map工作模式：\n\n```text\n[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map\n```\n\n1. `inline-` 将SourceMap内联到原始文件中，而不是创建一个单独的文件。\n2. `hidden-` 仍然会生成.map文件，但是打包后的代码中没有sourceMappingURL，即浏览器不会加载.map文件，控制台中看不到源代码。Map生成后只供服务端分析使用，前端将出错的行列传给服务端。\n3. `eval-` 通过eval包裹每个模块打包后代码以及对应生成的SourceMap（不实际生成），因为eval中为字符串形式，进行字符串处理会提升rebuild的速度。\n4. `nosources-` 不包含 sourcesContent 内容，调试时只能看到文件信息和行信息，无法看到源码。\n5. `cheap-[module-]` 只定位到源码所在的行，不定位至具体的列，构建速度有所提升。如果只用 cheap ，显示的是 loader 编译之后的源代码，加上 module 后会显示编译之前的源代码。\n\n如何选择devtool：\n1. **production：**none，source-map，hidden-source-map，nosources-source-map\n2. **development：**eval，eval-source-map，eval-cheap-source-map，eval-cheap-module-source-map\n\n开发环境下，需要频繁的修改代码，更多地考虑的开发效率和调试效率，所以更多关注 performance 中 rebuild 的性能。生产环境下，不必过多关注打包性能，主要考虑 quality 代码的保护性、出错的定位速度已经安全性\n\n## 热替换HMR\n监视模块变动后重新打包、自动刷新会导致页面的一些状态丢失（输入的文本内容），如果能让页面不刷新，模块也能更新，这样的开发体验会好很多\n\n模块热替换[HMR](https://webpack.docschina.org/configuration/dev-server/#devserverhot)(Hot Module Replacement)可以实现无刷更新模块，[「webpack 核心特性」模块热替换(HMR)](https://juejin.cn/post/6870258201384714253)\n\nHMR作用：\n1. 保留在完全重新加载页面期间丢失的应用程序状态。\n2. 只更新变更内容，以节省宝贵的开发时间。\n3. 在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。\n\n```js 使用HMR\ndevServer: {\n  hot: true, // 开启HMR\n  // 在构建失败时不刷新页面作为回退\n  // hot: 'only',\n}\n```\n\n从webpack-dev-server v4开始，HMR已默认启用。会自动应用HotModuleReplacementPlugin插件\n\n**注意：**HMR并不是开箱即用，还需要使用[HMR-API](https://webpack.docschina.org/api/hot-module-replacement/)手动处理模块的热替换逻辑，否则还会自动刷新，部分loader和插件如style-loader已经处理好了css的热更新逻辑，在Vue等框架下开发，框架本身也处理好了HMR\n\n使用[HMR-API](https://webpack.docschina.org/api/hot-module-replacement/)手动处理JS模块热替换：\n\n```js 通常在入口模块统一做处理\nif (module.hot) {\n  module.hot.accept('./library.js', function() {\n    // 对更新过的 library 模块做些事情...\n  });\n}\n// or\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept('./library.js', function () {\n    // Do something with the updated library module…\n  });\n}\n\n// accept方法\nmodule.hot.accept(\n  dependencies, // 可以是一个字符串或字符串数组\n  callback // 用于在模块更新后触发的函数\n  errorHandler // (err, {moduleId, dependencyId}) => {}\n);\n```\n\n案例：\n\n```js src/index.js\nimport { appendMarkdown } from \"./module.js\";\nimport md from './01.md'\nlet mde = appendMarkdown(md);\n\nif (module.hot) {\n  // 处理01.md的更新\n  module.hot.accept('./01.md', () => {\n    // 热重载，先移除原来的\n    document.body.removeChild(mde);\n    // 再创建新的\n    mde = appendMarkdown(md);\n  });\n}\n```\n\n热重载的需要根据自己的业务逻辑去实现，没有通用的方法，这也是webpack没有提供JS模块HMR的原因。\n\n打包后，HMR相关代码会被自动去除\n\n# 不同环境的配置\n不同的环境需要不同的webpack配置，主要是区分生产和开发环境，[文档](https://webpack.docschina.org/configuration/)\n\n区分环境有两种方式\n1. 配置函数中判断env，返回不同的配置信息\n2. 创建多个配置文件对应不同的环境（推荐）\n\n## 判断env\nwebpack配置导出一个函数而非对象，[导出函数](https://webpack.docschina.org/configuration/configuration-types/#exporting-a-function)，[环境变量](https://webpack.docschina.org/guides/environment-variables/)\n\n```js\n/**\n * \n * @param {string} env 环境名参数\n * @param {array} argv cli传递的所有参数\n * @returns {object} webpack配置\n */\nmodule.exports = (env, argv) => {\n  console.log(env);\n  // 默认的通用配置\n  const config = {\n    mode: 'none',\n    // 生成源映射以方便调试\n    devtool: 'eval-source-map',\n    // watch: true,\n    context: path.resolve(__dirname, 'src'),\n    entry: {\n      main: ['./index.js', './main.js'],\n    },\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[name]_[contenthash].js',\n      clean: true,\n    },\n    module: {\n      rules: [\n        {\n          // 正则匹配loader要处理的资源\n          test: /\\.css$/i,\n          // 逆序执行，从右往左\n          use: ['style-loader', 'css-loader'],\n        },\n        {\n          test: /\\.(png|jpg|svg|gif|ico)$/,\n          type: \"asset\",\n          generator: {\n            filename: \"img/[name]_[contenthash][ext]\",\n          },\n          parser: {\n            dataUrlCondition: {\n              maxSize: 50 * 1024,//小于50kb进行编码，转为base64\n            },\n          },\n        },\n        {\n          test: /\\.js$/i,\n          include: [\n            path.resolve(__dirname, 'src')\n          ],\n          exclude: [\n            path.resolve(__dirname, 'node_modules')\n          ],\n          loader: 'babel-loader',\n          options: {\n            presets: [\"@babel/preset-env\"]\n          }\n        },\n        {\n          test: /\\.md$/i,\n          use: path.resolve(__dirname, 'markdown-loader.js'),\n        }\n      ],\n    },\n    plugins: [\n      new HtmlWebpackPlugin({\n        template: path.resolve(__dirname, './index.html'), // 自定义模板\n        inject: 'body', // 插入到body\n        filename: 'index.html', // 输出文件名，默认index.html\n        title: 'webpack测试', // 自定义title，通过<%= htmlWebpackPlugin.options.title %>在html中使用\n        minify: true, // 压缩\n      }),\n    ],\n    // 配置开发服务器\n    devServer: {\n      // 服务器主机\n      host: 'localhost',\n      // 服务器端口\n      port: 8080,\n      // 使用HMR\n      hot: true,\n      // 启用Gzip\n      compress: true,\n      // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能\n      // 使用static配置从目录提供静态文件的选项，默认public\n      static: {\n        // 告诉服务器从哪里提供内容\n        directory: path.join(__dirname, 'public'),\n      },\n      proxy: {\n        // 代理api路径\n        '/api': {\n          // localhost:8080/api/user -> api.github.com/api/user\n          target: 'https://api.github.com',\n          // 请求路径重写 /api/user -> /user\n          pathRewrite: { '^/api': '' },\n          // 将 host 请求头修改为 target 的 URL\n          changeOrigin: true,\n        },\n      },\n    }\n  }\n  // 判断环境，修改配置\n  if (env.production) { // 生产环境\n    config.mode = 'production';\n    config.devtool = false;\n    config.plugins = [\n      ...config.plugins,\n      new CopyPlugin({\n        patterns: [\n          // 复制public文件夹内的文件到{output}中\n          { from: path.resolve(__dirname, 'public'), to: \"\" },\n        ],\n      }),\n    ];\n  } else if (env.development) { // 开发环境\n    config.mode = 'development';\n  }\n\n  return config\n}\n```\n\n```shell\nnpx webpack --env production\nnpx webpack --env development\n```\n\n## 多配置文件\n若项目较大配置复杂，就不适合用判断env的方式，写多个配置文件更清晰明了，[文档](https://webpack.docschina.org/guides/production/)\n\n通常有三个配置文件：\n1. `webpack.common.js` 通用配置文件，写一些项目的通用基础配置\n2. `webpack.dev.js` 开发配置文件\n3. `webpack.prod.js` 生产配置文件\n\n安装[webpack-merge](https://www.npmjs.com/package/webpack-merge)合并配置对象：`npm i webpack-merge -D`\n\n```js webpack.common.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'none',\n  // 生成源映射以方便调试\n  devtool: 'source-map',\n  // watch: true,\n  context: path.resolve(__dirname, 'src'),\n  entry: {\n    main: ['./index.js', './main.js'],\n  },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name]_[contenthash].js',\n    clean: true,\n  },\n  //警告 webpack 的性能提示\n  performance: {\n    hints: 'warning',\n    //入口起点的最大体积\n    maxEntrypointSize: 1024 * 1024 * 10,\n    //生成文件的最大体积\n    maxAssetSize: 1024 * 1024,\n    //只给出 js 文件的性能提示\n    assetFilter: function (assetFilename) {\n      return /\\.js$/.test(assetFilename);\n    }\n  },\n  module: {\n    rules: [\n      {\n        // 正则匹配loader要处理的资源\n        test: /\\.css$/i,\n        // 逆序执行，从右往左\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.(png|jpg|svg|gif|ico)$/,\n        type: \"asset\",\n        generator: {\n          filename: \"img/[name]_[contenthash][ext]\",\n        },\n        parser: {\n          dataUrlCondition: {\n            maxSize: 50 * 1024,//小于50kb进行编码，转为base64\n          },\n        },\n      },\n      {\n        test: /\\.js$/i,\n        include: [\n          path.resolve(__dirname, 'src')\n        ],\n        exclude: [\n          path.resolve(__dirname, 'node_modules')\n        ],\n        loader: 'babel-loader',\n        options: {\n          presets: [\"@babel/preset-env\"]\n        }\n      },\n      {\n        test: /\\.md$/i,\n        use: path.resolve(__dirname, 'markdown-loader.js'),\n      }\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, './index.html'), // 自定义模板\n      inject: 'body', // 插入到body\n      filename: 'index.html', // 输出文件名，默认index.html\n      title: 'webpack测试', // 自定义title，通过<%= htmlWebpackPlugin.options.title %>在html中使用\n      minify: true, // 压缩\n    }),\n  ],\n  // 配置开发服务器\n  devServer: {\n    // 服务器主机\n    host: 'localhost',\n    // 服务器端口\n    port: 8080,\n    // 使用HMR\n    hot: true,\n    // 启用Gzip\n    compress: true,\n    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能\n    // 使用static配置从目录提供静态文件的选项，默认public\n    static: {\n      // 告诉服务器从哪里提供内容\n      directory: path.join(__dirname, 'public'),\n    },\n    proxy: {\n      // 代理api路径\n      '/api': {\n        // localhost:8080/api/user -> api.github.com/api/user\n        target: 'https://api.github.com',\n        // 请求路径重写 /api/user -> /user\n        pathRewrite: { '^/api': '' },\n        // 将 host 请求头修改为 target 的 URL\n        changeOrigin: true,\n      },\n    },\n  }\n}\n```\n\n```js webpack.dev.js\nconst common = require(\"./webpack.common\");\nconst { merge } = require(\"webpack-merge\");\n\nmodule.exports = merge(common, {\n  mode: 'development',\n  devtool: 'eval-source-map',\n});\n```\n\n```js webpack.prod.js\nconst common = require(\"./webpack.common\");\nconst path = require('path');\nconst CopyPlugin = require(\"copy-webpack-plugin\");\nconst { merge } = require(\"webpack-merge\");\n\nmodule.exports = merge(common, {\n  mode: 'production',\n  devtool: false,\n  plugins: [\n    new CopyPlugin({\n      patterns: [\n        // 复制public文件夹内的文件到{output}中\n        { from: path.resolve(__dirname, 'public'), to: \"\" },\n      ],\n    }),\n  ],\n});\n```\n\n通过 --config 标志使用不同的配置文件\n\n```json\n\"scripts\": {\n  \"build\": \"webpack --config webpack.prod.js\",\n  \"build-dev\": \"webpack --config webpack.dev.js\",\n  \"prod\": \"webpack serve --config webpack.prod.js\",\n  \"dev\": \"webpack serve --config webpack.dev.js\"\n},\n```\n\n# 内置插件\nwebpack本身内置了很多插件对bundle进行优化，且一些插件在`mode: production`时会自动开启，进行一些通用的优化操作，[优化(Optimization)](https://webpack.docschina.org/configuration/optimization/)\n\n## DefinePlugin\n[DefinePlugin](https://webpack.docschina.org/plugins/define-plugin/)用来注入全局成员，在**编译时**将代码中的变量替换为其他值或表达式\n\n在`mode: production`时，DefinePlugin默认启用，并注入了`process.env.NODE_ENV`，许多第三方的模块使用这个常量来判断当前环境\n\nDefinePlugin接收一个对象，对象中的值若为字符串，将被作为代码片段使用，\n\n```js 使用API_BASE_URL区分生产和开发环境API接口\nconst webpack = require('webpack');\n\nplugins: [\n  new webpack.DefinePlugin({\n    // 使用JSON.stringify作为表示字符串的代码片段\n    API_BASE_URL: JSON.stringify('http://api.github.com'),\n  }),\n],\n\nconsole.log(API_BASE_URL)\n```\n\n## Tree Shaking\n[Tree Shaking](https://webpack.docschina.org/guides/tree-shaking/)用于移除JS上下文中的**未引用**代码(dead-code)，**基于ESM**\n\n在`mode: production`时Tree Shaking功能自动开启，也可通过配置开启\n\n```js\nmodule.exports = {\n  optimization: {\n    // 只导出使用了的成员\n    usedExports: true,\n  },\n}\n```\n\n测试代码：\n\n```js src/utils.js\nconst info = {\n  name: 'chuckle',\n  age: '20',\n}\nexport function getName(){\n  return info.name\n}\nexport function getAge(){\n  return info.age\n}\nexport function logName(){\n  console.log(info.name);\n}\nexport function logAge(){\n  console.log(info.age);\n}\n```\n\n打包结果，仍然存在未使用的代码片段，这是因为usedExports只是标记了未引用代码，而`optimization.minimize`才是用于压缩bundle，并去除未引用代码，两者搭配才实现了Tree Shaking\n\n```js\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logName: () => (/* binding */ logName)\n/* harmony export */ });\n/* unused harmony exports getName, getAge, logAge */\nvar info = {\n  name: 'chuckle',\n  age: '20'\n};\nfunction getName() {\n  return info.name;\n}\nfunction getAge() {\n  return info.age;\n}\nfunction logName() {\n  var _console;\n  /* eslint-disable */(_console = console).log.apply(_console, _toConsumableArray(oo_oo(\"3634127370_12_2_12_24_4\", info.name)));\n}\nfunction logAge() {\n  var _console2;\n  /* eslint-disable */(_console2 = console).log.apply(_console2, _toConsumableArray(oo_oo(\"3634127370_15_2_15_23_4\", info.age)));\n}\n```\n\n### 压缩代码去除未引用\n`optimization.minimize`压缩bundle并去除未引用代码，`mode: production`默认开启\n\n```js\nmodule.exports = {\n  //...\n  optimization: {\n    minimize: true,\n  },\n};\n```\n\n打包后，未使用过的代码已经去除\n\n```js\ne.d(_,{logName:()=>d});var t={name:\"chuckle\",age:\"20\"};\n```\n\n### 副作用\n将文件标记为[side-effect-free](https://webpack.docschina.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)(无副作用)安全地删除未用到的export，目的是为了给Tree Shaking更大的优化空间\n\n副作用：模块执行时，除了导出成员之外所作的事情\n\n[optimization.sideEffects](https://webpack.docschina.org/configuration/optimization/#optimizationsideeffects)告知webpack去辨识package.json中的副作用标记或规则，以跳过那些当导出不被使用且被标记不包含副作用的模块。\n\n```js\noptimization: {\n  sideEffects: true, // 开启\n},\n```\n\n```json\n\"sideEffects\": false, // 项目所有模块都无副作用\n// or\n\"sideEffects\": [\"*.css\"], // 使用css-loader且在css文件中使用import时很有必要\n```\n\n常见副作用代码：\n\n```js src/pad.js\n// 数字前补全0\nNumber.prototype.pad = function (size) {\n  let result = String(this);\n  while (result.length < size) {\n    result += '0';\n  }\n  return result;\n}\n\n// 导入使用\nimport './pad'\n```\n\n若没有标记副作用，打包会排除该代码片段\n\n```text\nUncaught TypeError: 8.pad is not a function\n  at ./main.js (main.js:17:72)\n  at __webpack_require__ (bootstrap:24:1)\n  at startup:7:1\n  at startup:7:1\n```\n\n标记副作用\n\n```json\n\"sideEffects\": [\"*.css\", \"./src/pad.js\"],\n```\n\n## 模块分包\nwebpack会将所有小颗粒度的模块，从入口模块开始打包到一个JS模块，若项目较大，bundle也会很大，一些模块可以分包出来，减小bundle的体积，[文档](https://webpack.docschina.org/guides/code-splitting/)\n\n模块分包办法：\n1. 多入口打包\n2. 动态导入\n\n### 多入口打包\n多入口打包通常用于多页面应用，但也可以一个页面应用多个bundle，实现分包\n\n同事可以使用`dependOn`指定依赖的公共模块，并在html中引入公共模块\n\n```js\nentry: {\n  main: {\n    import: ['./index.js', './main.js'],\n    dependOn: 'shared',\n  },\n  about: {\n    import: ['./about.js'],\n    dependOn: 'shared',\n  },\n  shared: './module.js',\n},\noutput: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name]_[contenthash].js',\n  clean: true,\n},\nplugins: [\n  new HtmlWebpackPlugin({\n    template: path.resolve(__dirname, './index.html'), // 自定义模板\n    inject: 'body', // 插入到body\n    filename: 'index.html', // 输出文件名，默认index.html\n    title: 'webpack测试', // 自定义title，通过<%= htmlWebpackPlugin.options.title %>在html中使用\n    minify: true, // 压缩\n    chunks: ['main', 'shared'], // 公共模块也要引入\n  }),\n  new HtmlWebpackPlugin({\n    template: path.resolve(__dirname, './about.html'),\n    inject: 'body',\n    filename: 'about.html',\n    title: '关于页',\n    minify: true, // 压缩\n    chunks: ['about', 'shared'],\n  }),\n],\n```\n\n如果想要在一个 HTML 页面上使用多个入口，还需设置 [runtimeChunk](https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk)\n\n```js\noptimization: {\n  // 用于指定运行时(runtime)代码的拆分策略\n  runtimeChunk: 'single',\n},\n```\n\n### 自动提取\n当多个模块引入了同一个模块，可以使用[splitChunks](https://webpack.docschina.org/plugins/split-chunks-plugin/)将其自动提取为独立的chunk\n\n```js\nsplitChunks: {\n  chunks: 'all',\n  minSize: 20 * 1024, // 设置最小分包大小,默认20000\n  minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小\n},\n```\n\n`minSizeReduction`：设置需要分包的bundle最小大小，这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize\n\n这样就不用使用`dependOn`指定依赖的公共模块了\n\n### 动态导入\n[动态导入](https://webpack.docschina.org/guides/code-splitting/#dynamic-imports)实现按需加载，需要某个模块再加载该模块，所有动态导入的模块都会被自动分包\n\n使用ESM的`import()`实现动态导入\n\n下面是一个hash路由的小demo\n\n```html\n<body>\n  <header>\n    <a href=\"#Home\">首页</a>\n    <a href=\"#List\">列表</a>\n  </header>\n  <div id=\"main\"></div>\n</body>\n```\n\n```js src/blog.js\nimport home from './home';\nimport list from './list';\n\nconst render = ()=>{\n  const hash = window.location.hash || \"#Home\";\n  const mainEle = document.querySelector('#main');\n  mainEle.innerHTML = \"\";\n  if(hash === \"#List\"){\n    mainEle.appendChild(list());\n  }else if(hash === \"#Home\"){\n    mainEle.appendChild(home());\n  }\n}\nrender();\n\nwindow.addEventListener(\"hashchange\", render)\n```\n\n```js src/home/index.js\nimport { renderMarkdown } from \"../module\";\nimport './index.css'\nimport md from './index.md'\nexport default () => renderMarkdown(md, \"home\");\n```\n\n```js src/list/index.js\nimport { renderMarkdown } from \"../module\";\nimport './index.css'\nimport md from './index.md'\nexport default () => renderMarkdown(md, 'list');\n```\n\n若不使用动态导入，不同路由页引入的css都同时影响样式，导致样式冲突，下面使用`import()`改造\n\n```js src/blog.js\nconst render = () => {\n  const hash = window.location.hash || \"#Home\";\n  const mainEle = document.querySelector('#main');\n  mainEle.innerHTML = \"\";\n  if (hash === \"#List\") {\n    import('./list').then(({ default: list }) => {\n      mainEle.appendChild(list());\n    })\n  } else if (hash === \"#Home\") {\n    import('./home').then(({ default: home }) => {\n      mainEle.appendChild(home());\n    })\n  }\n}\nrender();\n\nwindow.addEventListener(\"hashchange\", render)\n```\n\n### 魔法注释\n在动态导入过程中可以加入魔法注释，控制分包命名、合并、开启[预加载](https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules)\n\n```js\n// 使用chunkName设置分包命名\nimport(/* webpackChunkName: \"home\" */'./home')\nimport(/* webpackChunkName: \"list\" */'./list')\n// 相同chunkName会被打包到一起\nimport(/* webpackChunkName: \"components\" */'./home')\nimport(/* webpackChunkName: \"components\" */'./list')\n// 开启预加载\nimport(/* webpackPrefetch: true */'./list');\n```\n\n# css处理进阶\ncss这东西吧，还得琢磨琢磨\n\n## css-loader模块化\n开启`options.modules`，css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。[文档](https://webpack.docschina.org/loaders/css-loader/#modules)\n\n**作用：**CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名\n\n```js\nrules: [\n  {\n    test: /\\.css$/i,\n    loader: \"css-loader\",\n    options: {\n      modules: true,\n    },\n  },\n],\n```\n\n通过导出对象访问类名来应用样式\n\n```css\n.list{\n  background-color: #2f59b4\n}\n```\n\n```js\nimport { renderMarkdown } from \"../module\";\nimport css from './index.css'\nimport md from './index.md'\nexport default () => renderMarkdown(md, css.list);\n```\n\n## 提取css\n之前css通过style-loader直接应用到style标签内，而css则保存在js模块中，若css体积较大，还是提取css为一个单独的文件好\n\n[MiniCssExtractPlugin](https://webpack.docschina.org/plugins/mini-css-extract-plugin/)将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载\n\n安装：`npm i mini-css-extract-plugin -D`\n\n```js 配置\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n\nmodule.exports = {\n  plugins: [new MiniCssExtractPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: [MiniCssExtractPlugin.loader, \"css-loader\"],\n      },\n    ],\n  },\n};\n```\n\n## 压缩css\nwebpack本身只能压缩JS模块,需要压缩CSS等其它类型文件需要安装对应的插件\n\n使用[CssMinimizerWebpackPlugin](https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/)优化和压缩独立的CSS模块\n\n安装：`npm i css-minimizer-webpack-plugin -D`\n\n```js 配置\nconst CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\");\n\noptimization: {\n  minimize: true,\n  // 压缩类的插件应配置在minimizer，受minimize控制\n  minimizer: [\n    // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）\n    `...`,\n    new CssMinimizerPlugin(),\n  ],\n},\n```\n\n# 文件hash\n开启静态资源的客户端缓存后，为了能及时更新资源，资源文件就需要带上hash，[文档](https://webpack.docschina.org/guides/caching/)\n\n绝大多数插件都支持使用`filename`配置输出的文件名\n\n三种hash：\n\n```js\n// [hash]项目级hash，项目中一个模块有变化，该hash就变化\nfilename: '[name]_[hash].js',\n// [chunkhash]chunk级hash，同一路的打包相同hash\nfilename: '[name]_[chunkhash].js',\n// [contenthash]文件级hash，根据输出文件内容的hash\nfilename: '[name]_[contenthash].js',\n```\n\n指定hash长度\n\n```js\nfilename: '[name]_[contenthash:8].js',\n```\n\n控制缓存最佳实践：8位contenthash\n\n# 总结\n\n```json package.json\n{\n  \"name\": \"webpack01\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"private\": true,\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.prod.js\",\n    \"build-dev\": \"webpack --config webpack.dev.js\",\n    \"prod\": \"webpack serve --config webpack.prod.js\",\n    \"dev\": \"webpack serve --config webpack.dev.js\"\n  },\n  \"sideEffects\": [\n    \"*.css\",\n    \"./src/pad.js\"\n  ],\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.23.3\",\n    \"@babel/preset-env\": \"^7.23.3\",\n    \"babel-loader\": \"^8.3.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"css-loader\": \"^6.8.1\",\n    \"css-minimizer-webpack-plugin\": \"^5.0.1\",\n    \"file-loader\": \"^6.2.0\",\n    \"html-loader\": \"^4.2.0\",\n    \"html-webpack-plugin\": \"^5.5.3\",\n    \"marked\": \"^9.1.6\",\n    \"mini-css-extract-plugin\": \"^2.7.6\",\n    \"style-loader\": \"^3.3.3\",\n    \"url-loader\": \"^4.1.1\",\n    \"webpack\": \"^5.74.0\",\n    \"webpack-bundle-analyzer\": \"^4.9.1\",\n    \"webpack-cli\": \"^4.10.0\",\n    \"webpack-dev-server\": \"^4.15.1\",\n    \"webpack-merge\": \"^5.10.0\"\n  }\n}\n```\n\n# 配置TS环境\n安装TS相关依赖：\n1. 编译TS `npm install ts-loader -D`\n2. TS环境 `npm install typescript -D`\n\n```js 配置webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst webpack = require('webpack');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\");\n\nmodule.exports = {\n  mode: 'none',\n  // 生成源映射以方便调试\n  devtool: 'source-map',\n  // watch: true,\n  context: path.resolve(__dirname, 'src'),\n  entry: {\n    main: {\n      import: ['./index.ts'],\n    }\n  },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name]_[contenthash].js',\n    clean: true,\n  },\n  optimization: {\n    usedExports: true,\n    // minimize: true,\n    // 用于指定运行时(runtime)代码的拆分策略\n    // runtimeChunk: 'single',\n    // splitChunks: {\n    //   chunks: 'all',\n    //   minSize: 10 * 1024, // 设置最小分包大小\n    //   // minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小\n    // },\n    minimizer: [\n      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）\n      `...`,\n      new CssMinimizerPlugin(),\n    ],\n  },\n  //警告 webpack 的性能提示\n  performance: {\n    hints: 'warning',\n    //入口起点的最大体积\n    maxEntrypointSize: 1024 * 1024 * 10,\n    //生成文件的最大体积\n    maxAssetSize: 1024 * 1024,\n    //只给出 js 文件的性能提示\n    assetFilter: function (assetFilename) {\n      return /\\.ts$/.test(assetFilename);\n    }\n  },\n  module: {\n    rules: [\n      {\n        // 正则匹配loader要处理的资源\n        test: /\\.css$/i,\n        // 逆序执行，从右往左\n        use: [\n          // {\n          //   loader: 'style-loader',\n          // },\n          {\n            loader: MiniCssExtractPlugin.loader\n          },\n          {\n            loader: 'css-loader',\n            // options: {\n            //   modules: true // css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。\n            // },\n          },\n        ],\n      },\n      {\n        test: /\\.(png|jpg|svg|gif|ico)$/,\n        type: \"asset\",\n        generator: {\n          filename: \"img/[name]_[contenthash][ext]\",\n        },\n        parser: {\n          dataUrlCondition: {\n            maxSize: 50 * 1024,//小于50kb进行编码，转为base64\n          },\n        },\n      },\n      {\n        test: /\\.js$/i,\n        include: [\n          path.resolve(__dirname, 'src')\n        ],\n        exclude: [\n          path.resolve(__dirname, 'node_modules')\n        ],\n        loader: 'babel-loader',\n        options: {\n          presets: [\"@babel/preset-env\"]\n          // presets: [\n          //   [\"@babel/preset-env\", {\n          //     modules: \"commonjs\", // 开启ESM转CommonJS\n          //   }]\n          // ]\n        }\n      },\n      {\n        test: /\\.ts$/i,\n        loader: \"ts-loader\",\n        include: [\n          path.resolve(__dirname, 'src')\n        ],\n        exclude: [\n          path.resolve(__dirname, 'node_modules')\n        ],\n      }\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, './index.html'), // 自定义模板\n      inject: 'body', // 插入到body\n      filename: 'index.html', // 输出文件名，默认index.html\n      title: 'webpack测试', // 自定义title，通过<%= htmlWebpackPlugin.options.title %>在html中使用\n      minify: true, // 压缩\n      chunks: ['main'],\n    }),\n    new webpack.DefinePlugin({\n      API_BASE_URL: JSON.stringify('http://api.github.com'),\n    }),\n    new MiniCssExtractPlugin(),\n  ],\n  resolve: {\n    extensions: ['.ts', '.js'],\n    alias: {\n      '@': path.resolve(__dirname, './src')\n    }\n  },\n  // 配置开发服务器\n  devServer: {\n    // 服务器主机\n    host: 'localhost',\n    // 服务器端口\n    port: 8080,\n    // 使用HMR\n    hot: true,\n    // 启用Gzip\n    compress: true,\n    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能\n    // 使用static配置从目录提供静态文件的选项，默认public\n    static: {\n      // 告诉服务器从哪里提供内容\n      directory: path.join(__dirname, 'public'),\n    },\n    proxy: {\n      // 代理api路径\n      '/api': {\n        // localhost:8080/api/user -> api.github.com/api/user\n        target: 'https://api.github.com',\n        // 请求路径重写 /api/user -> /user\n        pathRewrite: { '^/api': '' },\n        // 将 host 请求头修改为 target 的 URL\n        changeOrigin: true,\n      },\n    },\n  }\n}\n```\n\n```json tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": false, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n    // \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n    \"diagnostics\": true, // 打印诊断信息 \n    \"target\": \"esnext\", /* 指定 ECMAScript 目标版本：'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */\n    \"module\": \"esnext\", /* 输出的代码使用什么方式进行模块化： 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    \"lib\": [ /* 指定引用的标准库 */\n      \"esnext\",\n      \"dom\",\n      \"dom.iterable\",\n    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n    \"allowJs\": true, // 允许编译器编译JS，JSX文件\n    \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./src\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n    \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n    \"declarationDir\": \"./dist/typings\", // 指定生成声明文件存放目录\n    // \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n    \"sourceMap\": false, // 生成目标文件的sourceMap文件\n    // \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n    \"declarationMap\": false, // 为声明文件生成sourceMap\n    // \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n    \"types\": [], // 加载的声明文件包\n    \"removeComments\": true, // 删除注释 \n    \"noEmit\": false, // 不输出文件,即编译后不会生成任何js文件\n    \"noEmitOnError\": true, // 发送错误时不输出任何文件\n    \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n    \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n    \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n    \"strict\": true, // 开启所有严格的类型检查\n    \"alwaysStrict\": true, // 在代码中注入'use strict'\n    \"noImplicitAny\": true, // 不允许隐式的any类型\n    \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n    \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n    \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n    \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n    \"noImplicitThis\": true, // 不允许this有隐式的any类型\n    \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n    \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n    \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n    \"noImplicitReturns\": true, //每个分支都会有返回值\n    \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n    \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n    \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { // 路径映射，相对于baseUrl\n      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      // \"jquery\": [\n      //   \"node_modules/jquery/dist/jquery.min.js\"\n      // ],\n      \"@/*\": [\n        \"src/*\"\n      ]\n    },\n    \"rootDirs\": [\n      \"src\"\n    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n    \"listEmittedFiles\": true, // 打印输出文件\n    \"listFiles\": true, // 打印编译的文件(包括引用的声明文件)\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"resolveJsonModule\": true,\n    \"allowImportingTsExtensions\": true,\n  },\n  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n  \"include\": [\n    \"src/**/*\",\n  ],\n  // 指定一个排除列表（include的反向操作）\n  // \"exclude\": [\n  //   \"demo.ts\"\n  // ],\n  // 指定哪些文件使用该配置（属于手动一个个指定文件）\n  // \"files\": [\n  //   \"demo.ts\"\n  // ]\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"编码备忘录","url":"/article/f12f59c3.html","content":"\n# Ubuntu右上角网络图标消失\n\n```shell\nsudo service NetworkManager stop\nsudo rm /var/lib/NetworkManager/NetworkManager.state\nsudo service NetworkManager start\n```\n\n参考：[Ubuntu22.04右上角网络图标消失](https://zhuanlan.zhihu.com/p/518321547)\n\n# textarea增加tab缩进\n\n```html\n<n-input type=\"textarea\" @keydown.tab.prevent=\"addTab\"/>\n<script setup>\nfunction addTab(event) {\n  const { selectionStart, selectionEnd } = event.target;\n  const value = info.value.content;\n\n  info.value.content =\n    value.substring(0, selectionStart) +\n    '  ' +\n    value.substring(selectionEnd);\n\n  // 更新光标位置\n  nextTick(() => {\n    event.target.selectionStart = event.target.selectionEnd =\n      selectionStart + 2;\n  });\n}\n</script>\n\n```\n\n参考：[Js textarea 支持tab缩进](https://blog.csdn.net/ccmcu/article/details/105629236)\n\n# 固定大小vmdk、vdi扩容\n\n进入VirtualBox安装目录\n\n```shell\n# vmdk转换成vdi\nVBoxManage.exe clonehd source.vmdk target.vdi --format VDI\n# 创建新虚拟介质，大小为扩容后需要的大小\nVBoxManage.exe createhd -filename \"D:\\vx\\docker1\\server2008r2_810g\" -size 151920 -format VDI -variant Standard\n# 克隆命令\nVBoxManage.exe clonehd \"D:\\vx\\docker1\\docker1.vdi\" \"D:\\vx\\docker1\\server2008r2_810g.vdi\" --existing\n# vdi转换成vmdk\nVBoxManage.exe clonehd source.vdi target.vmdk --format VMDK\n```\n\n参考：\n1. [vdi转vmdk VirtualBox与VMware硬盘格式转换及使用方法](https://blog.csdn.net/qq_30054403/article/details/123451969)\n2. [virtualBox 常用命令行操作](https://blog.csdn.net/qq_42683011/article/details/111108472)\n3. [VirtualBox扩容失败-Progress state: VBOX_E_NOT_SUPPORTED Resizing to new size 16231956480 is not yet](https://blog.csdn.net/weixin_40542512/article/details/101105433)\n\n# VM虚拟机无法CV文件\n\n1、确认安装 open-vm-tools-desktop \n\n```shell\nsudo apt install open-vm-tools-desktop\n```\n\n2、登录系统时，右下角设置选择 **xorg** 显示服务\n\n参考：[解决无法往 VMware 虚拟机复制粘贴文件的问题](https://www.cnblogs.com/stou/p/17229604.html)\n\n# Vue3父子组件传值双向绑定\n\n父组件：\n\n```html\n<QRCode v-model:showModal=\"showModal\"></QRCode>\n<script setup>\nconst showModal = ref(false);\n</script>\n```\n\n子组件：\n\n```html\n<n-modal v-model:show=\"localShowModal\"></n-modal>\n<script setup>\nconst props = defineProps(['showModal']);\nconst emit = defineEmits(['update:showModal']);\nconst localShowModal = computed({\n  get(){\n    return props.showModal;\n  },\n  set(value){\n    emit('update:showModal', value);\n  }\n});\n</script>\n```\n\n# Vite配置@符路径\n\n```js vite.config.js\nimport {resolve} from \"path\"\nexport default defineConfig({\n  resolve: {\n    alias: [\n      {\n        find: '@',\n        replacement: resolve(__dirname, \"src\")\n      }\n    ]\n  },\n});\n```\n\n参考：[在vite项目配置src路径别名为 “@”](https://juejin.cn/post/7237540467427999799)\n\n# Vite低版本浏览器兼容\n\n```shell 安装 plugin-legacy 和 terser 压缩器\nnpm install @vitejs/plugin-legacy -D\nnpm add -D terser\n```\n\n```js vite.config.js\nimport legacy from '@vitejs/plugin-legacy'\nexport default defineConfig({\n  plugins: [\n    vue(),\n    legacy({\n      // 设置目标浏览器，browserslist 配置语法\n      targets: ['defaults', 'not IE 11'],\n      modernPolyfills: true\n      // 面向IE11时需要此插件\n      // additionalLegacyPolyfills: ['regenerator-runtime/runtime'],\n      // polyfills: ['es.object.values', 'es.array.flat-map']\n    }),\n  ]\n})\n```\n\n```js app.vue 中添加\n!(function (t) {\n  function e() {\n    var e = this || self;\n    (e.globalThis = e), delete t.prototype._T_;\n  }\n  \"object\" != typeof globalThis &&\n    (this\n      ? e()\n      : (t.defineProperty(t.prototype, \"_T_\", {\n        configurable: !0,\n        get: e,\n      }),\n        _T_));\n})(Object);\n```\n\n参考：[vite项目低版本浏览器兼容性问题](https://blog.csdn.net/a404352329/article/details/129921804)\n\n# Vite环境变量\n\n新建 .env 和 .env.local\n\n```\nVITE_API_BASE_URL=http://127.0.0.1:3000\n```\n\n`import.meta.env` 使用环境变量\n\n```js\nimport.meta.env.VITE_API_BASE_URL\n```\n\n参考：\n1. [环境变量和模式](https://cn.vitejs.dev/guide/env-and-mode.html)\n2. [vite中环境变量的使用与配置（非常详细）](https://juejin.cn/post/7172012247852515335)\n\n# node项目环境变量\n\n```json package.json\n\"scripts\": {\n  \"start\": \"node ./bin/www\",\n  \"dev\": \"set NODE_ENV=development&& nodemon ./bin/www\"\n},\n```\n\n安装 dotenv，区分开发和生产环境\n\n```shell\nnpm install dotenv -S\n```\n\n```js\nconst dotenv = require('dotenv')\nif(process.env.NODE_ENV === \"development\"){\n  dotenv.config({ path: \".env.local\" });\n}else{\n  dotenv.config();\n}\n```\n\n新建 .env 和 .env.local\n\n```\nMODB_URL=mongodb://127.0.0.1:27017/\n```\n\n使用环境变量\n\n```js\nprocess.env.MODB_URL\n```\n\n# 开启/关闭Hyper-v\n\n```shell 执行命令后重启电脑\n# 开启\nbcdedit /set hypervisorlaunchtype auto\n# 关闭\nbcdedit /set hypervisorlaunchtype off\n```\n\n# SSH相关\nSSH的小问题那可太多了，这里记录一下\n\n## no hostkey alg\n该错误表示 SSH 客户端在尝试连接远程主机时，没有找到匹配的主机密钥算法。这通常是由于远程主机和客户端之间的配置不匹配导致的。\n\n```shell 解决办法\nvim /etc/ssh/sshd_config\n# 添加一行：\nHostKeyAlgorithms +ssh-rsa,ssh-dss\n#重启sshd服务\nservice sshd restart\n```\n\n## 免密登陆配置\n将本地公钥添加到服务器的 `~/.ssh/authorized_keys` 文件中\n\n配置使用密钥登陆\n\n```\nHost qcqx\n  HostName 8.*******\n  Port 22\n  User root\n  ForwardAgent yes\n  PreferredAuthentications publickey\n  IdentityFile \"C:\\Users\\64507\\.ssh\\test.rsa\"\n  IdentitiesOnly yes\n```\n\n修改 `/etc/ssh/sshd_config` 文件\n\n```\nPubkeyAuthentication yes\nRSAAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\nStrictModes no\nPubkeyAcceptedAlgorithms +ssh-rsa\n```\n\n[ssh配置免密码登录至Linux—已配置密钥仍无法登陆等问题](https://xy94.gitee.io/2020/06/22/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/)\n\n## ssh-rsa not in PubkeyAcceptedAlgorithms\nssh-rsa已被弃用，事实上，出于安全原因默认禁用，应该避免。使用rsa-sha2-256或rsa-sha2-512代替\n\n修改 `/etc/ssh/sshd_config` 文件\n\n```\nPubkeyAcceptedAlgorithms +ssh-rsa\n```\n\n[SSH server gives \"userauth_pubkey: key type ssh-rsa not in PubkeyAcceptedAlgorithms [preauth]\" when connecting with Putty](https://unix.stackexchange.com/questions/721606/ssh-server-gives-userauth-pubkey-key-type-ssh-rsa-not-in-pubkeyacceptedalgorit)\n\n## win下ssh找不到config和密钥\nwindow下，ssh会去找 `HOME` 环境变量下的 .ssh 文件夹。需要确保该环境变量存在。\n\n# 为火狐单独写CSS\n任何以以 @-moz- 开头的规则都是 Gecko 引擎特定的规则，而不是标准规则\n\nurl-prefix(url) 规则将包含的样式规则应用于 URL 以其开头的任何页面。不带 URL 参数使用时，适用于所有页面。\n\n```css 用它来适配scrollbar滚动条\n@-moz-document url-prefix() {\n  * {\n    scrollbar-width: thin;\n    scrollbar-color: #43b4ffc0 transparent;\n  }\n}\n```\n\n参考：[只为 Firefox 编写 CSS 规则](https://blog.csdn.net/weixin_46267040/article/details/125369675)\n\n# wsl 相关\nwsl的小问题、小细节可太多了\n\n## wslhost\n给wsl的动态ip设置host，方便外部连接\n\n```shell\nvim /etc/profile\n# 添加下面内容\nipaddr=$(ifconfig eth0 | grep 'inet ' | awk '{print $2}')\nsed -i '/wslhost/d' /mnt/c/Windows/System32/drivers/etc/hosts\necho \"$ipaddr wslhost\" >> /mnt/c/Windows/System32/drivers/etc/hosts\n```\n\n## sudo免密\n\n```shell\nsudo visudo\n# 加上一行\n<用户名> ALL=(ALL) NOPASSWD:ALL\n```\n\n## wsl自动启动ssh服务\n\n```shell\nvim ~/.bashrc # 编辑.bashrc，添加ssh服务状态判断\nsudo service ssh status | grep -q 'not running' && sudo service ssh start\n```\n\n# vscode 插件发布\n\n```bash\n# 申请 token：https://dev.azure.com/qcqx/_usersSettings/tokens\nvsce login qcqx # 登陆，输入 token\nvsce package # 打包\nvsce publish # 发布\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["备忘录"],"categories":["学习笔记"]},{"title":"泡茶-年轻人的第一次养生","url":"/article/e60c11dd.html","content":"\n在每日高强度的~~玩耍~~、上课、学习后，精神愈发疲惫，是时候开始养生了。\n\n**茶**是好东西，但红黄白绿的各种茶，摸不着头脑，还是让GPT推荐下吧。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/67-1.webp width=\"100%\" style=\"max-width:600px\">\n\n看起来绿茶和红茶挺不错，但还得是红茶，主打的就是精神，当大学生哪有不困=_=的。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/67-2.webp width=\"100%\" style=\"max-width:600px\">\n\n在B站看了看红茶推荐，凤牌的貌似不错，果断下单。68块钱100克，够喝半学期了，好喝再买。当然茶几、保温壶也得安排上。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/67-3.webp width=\"100%\" style=\"max-width:400px\">\n\n这红茶也确实不错，叶片完整不碎，出汤干净色泽偏橙红，清香微甘，不苦不涩。比以前喝过的五虎正山小种，口感上好得多。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/67-4.webp width=\"100%\" style=\"max-width:400px\">\n\n喝完也确实感觉精神了不少，至少感觉上是这样。早上课前来一杯，回到宿舍就泡好当白开水喝，养生又享受。不用经常买饮料喝，对于本就不富裕的微信零钱也是保护。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/67-0.webp width=\"100%\" style=\"max-width:500px\">\n\n","tags":["茶","养生"],"categories":["Chuckle"]},{"title":"Banner随机文章展示","url":"/article/a1bf85bf.html","content":"\n# 前言\nBanner 处的文章推荐总是挂着那几个文章，静态博客要去经常换也麻烦，嗯，就是懒了\n\n改为随机展示文章就解放双手啦\n\n# 实现\n>首先当然得实现一个类似于我首页那样的Banner\n\n**1、**在`themes\\butterfly\\scripts\\helpers\\` 新建一个生成器 `home_random_post.js`\n\n该生成器会将 matter 中 **random** 配置不为 false 的文章的基本信息输出到 **random.json**\n\n```js home_random_post.js\nhexo.extend.generator.register('thePosts', function (locals) {\n  const jsonData = locals.posts\n    .filter(post => post.random !== false)\n    .map(post => {\n      return {\n        title: post.title || \"暂无标题\",\n        abbrlink: post.abbrlink,\n        cover: post.cover,\n        description: post.description || \"暂无简介\"\n      };\n    });\n\n  return {\n    path: 'random.json',\n    data: JSON.stringify(jsonData)\n  };\n});\n\n```\n\n**2、**js 请求该 json ，随机选取若干文章渲染展示到页面上\n\n```js\nfunction getRandomElementsFromArray(arr, num) {\n  const totalElements = arr.length;\n  const selectedElements = new Set();\n  while (selectedElements.size < num) {\n    const randomIndex = Math.floor(Math.random() * totalElements);\n    selectedElements.add(arr[randomIndex]);\n  }\n  return Array.from(selectedElements);\n}\nfunction renderingPosts(data){\n  const randomElements = getRandomElementsFromArray(data, 6);\n  const postsHtml = randomElements.map((i) => `\n    <div class=\"top_post_item\">\n      <div class=\"post_cover\">\n        <a href=\"/article/${i.abbrlink}.html\" title=\"${i.title}\">\n          <img class=\"post_bg entered loaded\" src=\"${i.cover}\" alt=\"${i.title}\" data-no-lazy>\n          <div class=\"post_cover_info\">\n            <p class=\"post_cover_text\">${i.description}</p>\n          </div>\n        </a>\n      </div>\n      <div class=\"post_info\" onclick=\"window.open('/article/${i.abbrlink}.html', '_self')\">\n        <a class=\"article-title\" href=\"/article/${i.abbrlink}.html\" title=\"${i.title}\">${i.title}</a>\n      </div>\n    </div>`).join('');\n  document.querySelector(\"#homeTopGroup>.top_post_group\").innerHTML = postsHtml\n}\nif(!sessionStorage.getItem(\"postsInfo\")){\n  fetch(\"/random.json\")\n  .then(res=>res.json())\n  .then(data=>{\n    console.log(1);\n    sessionStorage.setItem(\"postsInfo\", JSON.stringify(data));\n    renderingPosts(data);\n  })\n}else{\n  renderingPosts(JSON.parse(sessionStorage.getItem(\"postsInfo\")));\n}\n\n```\n\nBanner 的实现各不相同，但适配自己的并不难，postsHtml 内的 hmtl 模板需要修改一下\n\n这里放一下我的 pug 和 css\n\n```pug\n#home_top\n  .home_top_group\n    #homeTopGroup.homeTopGroup\n      .category_group\n          .category_item\n            a.category_button(href=\"/archives/\",style=\"background:linear-gradient(to right,#00868Bdb,#3fc1c9db)\")\n              span.category_button_text 归档\n              i.fas.fa-laptop-code\n          .category_item\n            a.category_button(href=\"/archives/2022/\",style=\"background:linear-gradient(to right, #0A5ABEdb, #2fcbffdb)\")\n              span.category_button_text 2022\n              i.fas.fa-lightbulb\n      .top_post_group\n        //- 这下面是原来固定的写法\n        //- if site.data.slider\n        //-   each i in site.data.slider\n        //-     .top_post_item\n        //-       .post_cover\n        //-         a(href=url_for(i.link) title=i.title)\n        //-           img.post_bg.entered.loaded(src=url_for(i.cover))\n        //-           .post_cover_info\n        //-             p.post_cover_text= i.description\n        //-       .post_info(onclick=`\"window.open(`+url_for(i.link)+`,\"_self\")\"`)\n        //-         a.article-title(href=url_for(i.link) title=i.title)= i.title\n\n```\n\n```css\n:root{\n    --mj-white: #fff;\n    --mj-card-bg: rgba(255,255,255,0.67);\n    --mj-theme: #128adadb;\n    --mj-secondbg: #ededed;\n    --mj-card-border: #e3e8f7;\n    --style-border: 2px solid rgba(0, 255, 255, 0.6);\n    --anchor-border: 1px solid rgba(21, 158, 208, 0.8);\n    --style-hover-border: 2px solid var(--mj-theme);\n}\n[data-theme=dark] {\n    --mj-card-bg: rgba(0,0,0,0.6);\n    --style-border: 2px solid rgba(56,211,203,0.8);\n}\n/* home top */\n#home_top {\n    width: 100%;\n}\n.home_top_group {\n    border-radius: 11px;\n    overflow: auto;\n    width: 100%;\n    margin-bottom: 0;\n}\n.homeTopGroup {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    width: 100%;\n    overflow: auto;\n    overflow-x: score;\n    border-radius: 11px;\n}\n.homeTopGroup::-webkit-scrollbar {\n    display: none;\n}\n\n.homeTopGroup .category_group{\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    min-width: 200px;\n    min-height: 166px;\n}\n.top_post_item>.post_cover>a{\n    display: block;\n}\n.homeTopGroup .category_item {\n    overflow: hidden;\n    transform: scale(1);\n    transition: .3s;\n    height: 48%;\n    border-radius: 12px;\n}\n.homeTopGroup .category_item a.category_button {\n    height: 100%;\n    width: 100%;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    display: inline-block;\n    text-align: left;\n    line-height: 4em;\n    font-weight: 800;\n    font-size: 16px;\n    color: var(--mj-white);\n    transition: all .4s cubic-bezier(.39,.575,.565,1);\n    transform: scale(1);\n    overflow: hidden;\n}\n.category_button_text {\n    padding-left: 25px;\n}\na.category_button i {\n    font-size: 3rem;\n    opacity: .3;\n    position: absolute;\n    right: 15px;\n    top: 10%;\n    transition: .3s;\n    transform: rotate(-10deg);\n    /*width: 100px;\n    text-align: center;*/\n}\na.category_button:hover i {\n    opacity: .8;\n    transition: .8s;\n    transition-delay: .15s;\n    transform: scale(1.1)\n}\na.category_button:hover:after{\n    width: 3rem;\n    transition: .8s;\n}\na.category_button:after {\n    top: 45px;\n    width: 1rem;\n    left: 25px;\n    height: 2.5px;\n    background: var(--mj-white);\n    content: \"\";\n    border-radius: 1px;\n    position: absolute;\n    transition: .8s;\n}\n@media screen and (max-width: 1245px){\n  .homeTopGroup,.home_top_group {\n      border-radius: 0px;\n  }\n}\n@media screen and (max-width: 768px){\n  .homeTopGroup .category_group {\n    min-width: 130px!important;\n  }\n  #home_top {\n    width: calc(100% + 17px);\n  }\n  .home_top_group {\n      overflow: visible;\n  }\n  .homeTopGroup {\n      width: calc(100% + 17px);\n      margin-left: -17px;\n  }\n  .homeTopGroup .category_group{\n      margin-left: 17px;\n  }\n}\n.top_post_group{\n    display: flex;\n    position: relative;\n}\n.top_post_group .top_post_item {\n    display: flex;\n    width: 200px;\n    height: 166px;\n    flex-direction: column;\n    align-items: flex-start;\n    margin-left: 8px;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    overflow: hidden;\n    border: var(--style-border);\n    color: var(--text-highlight-color);\n    transition: 0.3s;\n}\n/* .top_post_group .top_post_item:first-child{\n    right: 0px;\n} */\n.top_post_group .top_post_item:hover {\n    border: var(--style-hover-border);\n    background: #128adadb;\n}\n.top_post_group .top_post_item .post_cover {\n    width: 100%;\n    height: 110px;\n    position: relative;\n}\n.top_post_group .top_post_item .post_cover img {\n    object-fit: cover;\n    width: 100%;\n    height: 110px;\n    background: var(--mj-secondbg);\n}\n.top_post_group .top_post_item .post_cover .post_cover_info {\n    position: absolute;\n    top: 0;\n    width: 101%;\n    height: 100%;\n    opacity: 0;\n    background-color: rgba(0,0,0,0.7) !important;\n    transition: all 0.3s ease;\n    display: flex;\n} \n.top_post_group .top_post_item:hover .post_cover .post_cover_info{\n    opacity: 1;\n}\n.top_post_group .top_post_item .post_cover .post_cover_info .post_cover_text{\n    color: #fff;\n    padding: 13px 14px;\n    font-size: 15px;\n    font-weight: 400;\n    margin: 0;\n    -webkit-line-clamp: 3;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n}\n.top_post_group .top_post_item .post_info a{\n    color: var(--mj-fontcolor) !important;\n    transition: 0;\n}\n.top_post_group .top_post_item:hover .post_info a{\n    color: var(--mj-white) !important;\n}\n.top_post_group .top_post_item .post_info {\n    padding: 6px 9px!important;\n    transition: .3s;\n    width: 100%;\n    height: 100%;\n}\n.top_post_group .top_post_item .post_info .article-title {\n    -webkit-line-clamp: 2;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    line-height: 1.4;\n    justify-content: center;\n    align-items: flex-end;\n    align-content: center;\n    font-weight: 800;\n    font-size: 14px!important;\n    padding: 0!important;\n}\n\n```\n\n# 懒加载的修改\nbtf主题若开启了懒加载，可能会有些bug，文章图片不能正常被懒加载所加载，那干脆就不让懒加载去接管这些图片\n\n修改 `themes\\butterfly\\scripts\\filters\\post_lazyload.js`\n\n```js 对返回值进行了修改\nfunction lazyload (htmlContent) {\n  const bg = hexo.theme.config.lazyload.placeholder ? urlFor(hexo.theme.config.lazyload.placeholder) : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\n  // 修改下面的返回值\n  return htmlContent.replace(/(<img(?![^>]*\\bdata-no-lazy\\b)[^>]*? src=)/ig, `$1 \"${bg}\" data-lazy-src=`);\n}\n```\n\n现在，只要加上了 **data-no-lazy** 属性的 img 标签，都不会被懒加载所接管\n\n# 后记\n期待 [@Heo](https://blog.zhheo.com/) 对他 Banner 的大改\n\n\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"ES6查缺补漏","url":"/article/383b041f.html","content":"\n# 前言\n一直没有把ES6标准系统地进行学习，虽然很多新特性已经用上了，但也该系统地学习一下\n\n还是阮一峰讲得全面些：[ECMAScript 6 入门 | 阮一峰](https://es6.ruanyifeng.com/) 很多新特性，多用就记住了\n\n# ES6简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言\n\nES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准\n\n# let和const\nlet 声明变量，const声明常量（内存地址所保存的数据不得改动）\n\n**1、块级作用域**\n\n```js\nvar a = 2;\n{\n  let a = 1;\n  console.log(a); // 1\n}\nconsole.log(a); // 2\n```\n\n**2、同一个块内不允许覆盖、重复声明**\n\n```js\nvar a = 1;\nvar a = 2;\nconsole.log(a); // 2\nlet b = 1;\nlet b = 2; // 'b' has already been declared\n{\n  let b = 2;\n  console.log(b); // 2\n}\n```\n\n**3、没有变量提升**\n\n```js\nconsole.log(a); // undefined\nvar a = 1;\nconsole.log(b); // Cannot access 'b' before initialization\nlet b = 2;\n```\n\n**4、暂时性死区**\n只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部的影响\n\n只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n```js 变量一定要在声明之后使用\nconsole.log(typeof a); // undefined\nconsole.log(typeof b); // undefined\nvar b = 1;\nconsole.log(typeof x); // ReferenceError\nlet x = 2;\n```\n\n**Tip：**\n**1、**循环中的 var 与 let:\n\nvar 会提升进行声明，数组中所有函数访问的都是同一个 i\n\n```js\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n```\n\n变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 都是一个新的变量，但在循环中，JavaScript 引擎会记住每一次 let 的值，下一次创建的时候，直接在这个值上递进\n\n```js\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n\n**2、**const 声明的对象仍然是可写的，可以使用 `Object.freeze()` 冻结对象\n\n当对象嵌套时，需要递归冻结\n\n```js\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, i) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n```\n\n# 解构赋值\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值\n\n## 数组解构\n\n**1、**只要等号两边的模式相同，左边的变量就会被赋予对应的值\n\n```js\nlet [a, b, c, ...d] = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a); // 1\nconsole.log(d); // [ 4, 5, 6, 7, 8 ]\n```\n\n**2、**如果解构不成功，变量的值就等于undefined\n\n```js\nlet [a] = [];\nconsole.log(a); // undefined\nlet [b, c] = [1];\nconsole.log(c); // undefined\n```\n\n**3、**解构赋值允许指定默认值，只有当一个数组成员严格等于undefined，默认值才会生效\n\n```js\nlet [b, c = 2] = [1];\nconsole.log(c); // 2\n```\n\n如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined\n\n```js\nlet [x = 1] = [undefined];\nx // 1\nlet [x = 1] = [null];\nx // null\n```\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值\n\n```js\nfunction f() {\n  console.log('123'); \n}\nlet [a = f()] = [1]; // 不执行f()\nlet [b = f()] = []; // 123\n```\n\n## 对象解构\n**1、**解构提取对象中的属性\n\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n}\nlet { a, b } = obj // 变量名与属性名需相同\nconsole.log(a) // 1\n```\n\n变量名与属性名不一致，需写成下面这样\n\n```js\nconst obj = {\n  a: 1\n}\nlet { a : x } = obj\nconsole.log(x) // 1\n```\n\n**2、**嵌套结构的对象\n\n```js\nconst obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\nlet { p, p: [x, { y }] } = obj;\nconsole.log(x); // Hello\nconsole.log(y); // World\n```\n\n**3、**剩余运算符，将其它属性展开到一个对象中存储\n\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n}\nconst a = {\n  ...obj,\n  b: 3, // 可以覆盖\n  c: 4, // 默认值\n}\nconsole.log(a.a, a.b, a.c); // 1 3 4\n```\n\n**4、**可以取到继承的属性\n\n```js\nconst obj1 = {};\nconst obj2 = { a: 1 };\nObject.setPrototypeOf(obj1, obj2);\nconst { a } = obj1;\nconsole.log(a); // 1\n```\n\n## 函数参数解构\n函数的参数也可以使用解构赋值\n\n```js\nfunction add([x, y]){\n  return x + y;\n}\nadd([1, 2]); // 3\n[[1, 2], [3, 4]].map(([a, b]) => a + b); // [ 3, 7 ]\n```\n\n## 技巧\n**1、**交换变量的值\n\n```js\nlet x = 1;\nlet y = 2;\nlet [x,y] = [y,x];\n```\n\n**2、**函数返回多个值\n\n```js\n// 返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n\n// 返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n```\n\n# 函数的扩展\n**1、带参数默认值的函数**\n\n```js\nfunction f(a, b = 1) { }\nfunction f(a, b = fun()) { }\n```\n\n**2、rest 参数**\n获取函数的多余参数，不需要使用 arguments 对象，rest 参数之后不能再有其他参数\n\n```js\nfunction f(a, ...b) {\n  console.log(a, b); // 1 [2, 3]\n}\nf(1, 2, 3);\n```\n\n**3、name 属性**\n返回函数名\n\n```js\nfunction foo() {}\nfoo.name // \"foo\"\n```\n\n\n\n## 箭头函数\n使用“箭头”（=>）定义函数\n\n```js\nvar f = v => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n多种写法\n\n```js\nvar f = v => v;\nvar f = v => { return v };\nvar f = (a, b) => a + b;\n```\n\n简化回调函数\n\n```js\n[1,2,3].map(function (x) {\n  return x * x;\n});\n[1,2,3].map(x => x * x);\n```\n\n箭头函数的特性：\n1、没有自己的 this\n2、不可以当作构造函数\n3、不可以使用 arguments 对象\n4、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数\n\n# 对象的扩展\n**1、属性简洁表示**\n\n```js\nlet [a, b] = [1, 2];\nconst obj = {\n  a,\n  b,\n  fun(){ } // 简写对象方法\n}\n```\n\n**2、属性名表达式**\n属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串\n属性名表达式与简洁表示法，不能同时使用\n\n```js\nobj['a' + 'bc'] = 123; // obj.abc = 123\nlet propKey = 'foo';\nlet obj = {\n  [propKey]: true,\n  ['a' + 'bc']: 123\n};\n```\n\n## Object方法\n**1、**`is()`\n判断两个值是否相同，解决了 NaN 问题\n\n```js\nObject.is(null,undefined); // false\nObject.is(NaN,NaN); // true\nNaN === NaN // false\n```\n\n**2、**`assign()`\n合并多个对象，并返回第一个参数的引用，冲突属性后面覆盖前面\n\n```js\nlet obj1 = { a: 1 }\nlet obj2 = { a: 2, b: 3 }\nlet obj3 = Object.assign(obj1, obj2); // {a: 2, b: 3}\nconsole.log(obj3 === obj1); // true\n```\n\n**3、**`keys()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键名**\n\n**4、**`values()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键值**\n\n**5、**`entries()` 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的**键值对数组**\n\n**6、**`fromEntries()` entries() 的逆操作，用于将一个键值对数组转为对象\n\n**7、**`hasOwn()` 判断某个属性是否为自身的属性\n\n# 数组的扩展\n**1、扩展运算符** `...`\n扩展运算符将一个数组转为用逗号分隔的参数序列\n\n```js\nconsole.log(...[1, 2, 3]) // 1 2 3\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\nfunction add(x, y) { return x + y }\nadd(...[4, 38]) // 42\n```\n\n替代用到 apply() 和 push() 的某些操作\n\n```js\nMath.max.apply(null, [11, 33, 22]) // 33\nMath.max(...[11, 33, 22]) // 33\nlet arr1 = [0, 1, 2]\nlet arr2 = [3, 4, 5]\narr1.push.apply(arr1, arr2)\narr1.push(...arr2)\n```\n\n## Array方法\n**1、**`Array.from()` 将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的 Set 和 Map）\n\n```js\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\nconsole.log([].slice.call(arrayLike)) // [ 'a', 'b', 'c' ]\nconsole.log(Array.from(arrayLike)) // [ 'a', 'b', 'c' ]\n```\n\n接收第二个参数，回调函数，对每个元素进行处理\n\n```js\nlet arrayLike = {\n  '0': 1,\n  '1': 2,\n  length: 2\n};\nconsole.log(Array.from(arrayLike, item => item * 2)) // [ 2, 4 ]\n```\n\n**2、**`Array.of()` 将一组任意类型的值，转换为数组\n\n```js 弥补Array的不足\nArray.of(1, 2) // [1, 2]\nArray(3) // [, , ,]\nArray.of(3) // [3]\n```\n\n## 实例方法\n**1、**`copyWithin(target, start = 0, end = this.length)` 将指定位置的成员**复制**到其他位置（会覆盖），然后返回当前数组\ntarget（必需）：从该位置开始替换数据。如果为负值，表示倒数。\nstart（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\nend（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n```js\n[1,2,3,4,5].copyWithin(0,3) // [4, 5, 3, 4, 5]\n```\n\n**2、**`find()` 找出第一个符合条件的数组成员。传入一个回调函数，没有符合条件的则返回 undefined\n\n```js\n[1, -2, -5, 10].find(n => n < 0) // -2\n[1, -2, -5, 10].find(function(value, index, arr) {\n  return value < 0;\n})\n```\n\n`findIndex()` 返回第一个符合条件的数组成员的位置，没有符合条件的则返回 -1\n`findLast() findLastIndex()` 从数组的最后一个成员开始，依次向前检查\n\n可以接受第二个参数，用来绑定回调函数的this对象\n\n**3、**`fill()` 使用给定值，覆盖填充一个数组\n可以接受第二、三个参数，用于指定填充的起始位置和结束位置\n\n```js\n['a', 'b', 'c'].fill(7) // [7, 7, 7]\nnew Array(3).fill(7) // [7, 7, 7]\n```\n\n若填充对象，数组中填充的是该对象的引用\n\n**4、**`entries() keys() values()` 用于遍历数组，都返回一个**遍历器**对象\nkeys() 是键名的遍历，values() 是键值的遍历，entries() 是键值对的遍历\n\n```js\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index); // 0 // 1\n}\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem); // 'a' // 'b'\n}\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem); // 0 \"a\" // 1 \"b\"\n}\n```\n\n**5、**`includes()` 判断数组中是否包含某个值，可选第二个参数表示搜索的起始位置，默认为0\n\n```js\n[1, 2, 3].includes(2) // true\n[1, 2, NaN].includes(NaN) // true\n```\n\n**6、**`flat()` 将多维数组解构为一维，传入参数表示总共解构多少层，默认 1\n该方法返回一个新数组，对原数据没有影响\n\n如果不管有多少维，都要转成一维数组，可以用 Infinity 作为参数。\n如果原数组有空位，flat()方法会跳过空位\n\n```js\n[1, 2, [3, 4]].flat() // [1, 2, 3, 4]\n[1, 2, [3, 4, [5, 6]]].flat() // [1, 2, 3, 4, [5, 6]]\n[1, 2, [3, 4, [5, 6]]].flat(2) // [1, 2, 3, 4, 5, 6]\n[1, [2, [3]]].flat(Infinity) // [1, 2, 3]\n[1, 2, , 4, 5].flat() // [1, 2, 4, 5]\n```\n\n`flatMap()` 传入一个遍历函数，先执行 `map()` 再 `flat()` 只能展开一层数组。\n可选第二个参数，用来绑定遍历函数里面的this\n\n```js\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n**7、**`at()` 返回指定索引上的值，允许负索引\n该方法不仅可用于数组，也可用于字符串和类型数组\n\n```js\nlet arr = [1, 2, 3]\narr[arr.length - 1] // 3\narr.at(-1) // 3\n```\n\n**8、**`toReversed() toSorted() toSpliced() with()` \n含义和用法完全一样，但不改变原数组，而返回一个原数组的拷贝：\ntoReversed() 对应 reverse()，用来颠倒数组成员的位置。\ntoSorted() 对应 sort()，用来对数组成员排序。\ntoSpliced() 对应 splice()，用来在指定位置，删除指定数量的成员，并插入新成员。\nwith(index, value) 对应 splice(index, 1, value)，用来将指定位置的成员替换为新的值。\n\n**9、**`group((item, index, array) => {})` 数组成员分组\n根据分组函数的运行结果，将数组成员分组，分组函数的返回值应该是字符串（或者可以自动转为字符串），以作为分组后的组名\n\n还未实装的[提案](https://github.com/tc39/proposal-array-grouping)\n\n```js\nlet arr = [1,2,3,4,5];\nlet result = arr.group(item => {\n  return item % 2 === 0 ? 'even': 'odd';\n});\nconsole.log(result);\n```\n\n\n# 运算符的扩展\n**1、指数运算符**`**`\n多个指数运算符连用时，是从最右边开始计算的\n\n```js\n2 ** 2 // 4\n2 ** 3 ** 2 // 相当于 2 ** (3 ** 2)\nlet b = 4;\nb **= 3; // 等同于 b = b * b * b;\n```\n\n**2、链判断运算符**`?.`\n如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在\n\n```js\n// 错误的写法\nconst  firstName = message.body.user.firstName || 'default';\n// 正确的写法\nconst firstName = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n```\n\n使用 `?.` 运算符简化写法\n在链式调用的时候判断左侧的对象是否为 null 或 undefined。如果是，则不再往下运算，直接返回 undefined\n\n```js\nconst firstName = message?.body?.user?.firstName || 'default';\n```\n\n判断对象方法是否存在，如果存在就立即执行：\n\n```js\nobj.fun?.()\n```\n\n**3、NULL 判断运算符**`??`\n使用 `||` 运算符指定默认值时，只要属性的值为 null 或 undefined，默认值就会生效，但是属性的值如果为空字符串或 false 或 0，默认值也会生效\n\nNull 判断运算符 `??` 类似 `||`，但是只有运算符左侧的值为 null 或 undefined 时，才会返回右侧的值\n\n与链判断运算符 `?.` 配合使用，为 null 或 undefined 的值设置默认值。\n\n```js\nconst a = obj?.a ?? 10;\n```\n\n\n# Symbol类型\nSymbol 是新的**基本数据类型**，表示**独一无二**的值\n\n```js\nlet s = Symbol();\nconsole.log(typeof s) // symbol\nconsole.log(Symbol('sss') == Symbol('sss')) //false\n```\n\nSymbol 值通过 `Symbol()` 函数生成，允许接受一个**字符串**作为参数，表示对 Symbol 实例的**描述**。这主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n如果 Symbol 的参数是一个**对象**，就会调用该对象的 `toString()` 方法，将其转为**字符串**，然后再生成一个 Symbol 值\n\n```js\nlet s = Symbol('sss');\nconsole.log(s) // Symbol(sss)\nconsole.log(s.toString()) // Symbol(sss)\n\nconst obj = {\n  toString() {\n    return 'abc';\n  }\n}\ns = Symbol(obj);\nconsole.log(s) // Symbol(abc)\n```\n\nSymbol 值也可以转为**布尔值**(true)，但是不能转为数值\n\n```js\nlet s = Symbol();\nconsole.log(Boolean(s)) // true\nconsole.log(Number(s)) // TypeError\n```\n\n## 作为属性名\n现在，对象的**属性名**可以是字符串或 **Symbol** 值\n\n由于每一个 Symbol 值都是不相等的，这意味着只要 Symbol 值用于对象的属性名，就能保证不会出现同名的属性\n\n```js 两次Symbol('123')返回值并不相同\nlet s = Symbol('123');\nconst obj = { \n  a: 1,\n  [s]: 's'\n}\nobj[Symbol('123')] = 123\nconsole.log(obj) // { a: 1, [Symbol(123)]: 's', [Symbol(123)]: 123 }\nconsole.log(obj[s]) // s\n\n```\n\nSymbol 值作为对象属性名时，用点运算符无法获取该属性\n\n```js\nlet s = Symbol('s');\nconst obj = { \n  [s]: 's',\n  s: 123\n};\nconsole.log(obj.s) // 123\nconsole.log(obj[s]) // s\n```\n\nSymbol 值作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，所以通常可以当做**私有属性**来使用\n\n`Object.getOwnPropertySymbols()` 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值\n`Reflect.ownKeys()` 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名\n\n```js\nconst obj = {\n  a: 1,\n  [Symbol('s')]: 's',\n};\nfor (let key in obj) {\n  console.log(key); // a\n}\nconsole.log(Object.keys(obj)); // [ 'a' ]\n\nconsole.log(Object.getOwnPropertySymbols(obj)); // [ Symbol(s) ]\nconsole.log(Reflect.ownKeys(obj)); // [ 'a', Symbol(s) ]\n\n```\n\n## Symbol方法\n**1、**`Symbol.for()` 将生成的 Symbol 值登记在全局环境中供搜索，若有相同描述的 Symbol 值则复用返回\n\nSymbol() 写法没有登记机制\n\n其登记机制可以用在不同的 iframe 或 service worker 中取到同一个值\n\n```js\nlet s1 = Symbol('s');\nlet s2 = Symbol.for('s');\nlet s3 = Symbol.for('s');\nconsole.log(s1 === s2); // false\nconsole.log(s2 === s3); // true\n```\n\n**2、**`Symbol.keyFor()` 返回一个**已登记**的 Symbol 类型值的参数 key\n\n```js\nlet s1 = Symbol('s');\nlet s2 = Symbol.for('s');\nconsole.log(Symbol.keyFor(s1)) // undefined\nconsole.log(Symbol.keyFor(s2)) // s\n```\n\n\n# Map对象\nMap对象保存键值对，元素会保持其插入时的顺序。\n\nMap的键可以是任意数据类型，包括函数、对象或任意基本类型。\n\n在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效\n\n```js 创建一个Map\nvar m = new Map();\n//或传入一个嵌套数组\nm = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n```\n\nObject与Map增删改查基本操作。\n\n```js\nvar o = {};\nvar m = new Map();\n//添加\no.x = 1;\nm.set('x', 1);\n//修改\no.x = 2;\nm.set('x', 2);\n//递增\no.x++;\nm.set('x', m.get('x')+1);\n//获取\no.x;\nm.get('x');\n//删除\ndelete o.x;\nmap.delete('x');\n\n```\n\nMap的键值对个数可以通过size属性获取\n\n```js\nvar m = new Map();\nm.set('x', 1);\nm.set('y', 2);\nconsole.log(m);//Map(2) {'x' => 1, 'y' => 2}\nconsole.log(m.size);//2\n```\n\n## Map的方法\n**基本方法：**\n1. **`get()`：**获取元素\n2. **`set()`：**设置元素\n3. **`has()`：**检查是否有指定key\n4. **`clear()`：**清空map\n5. **`delete()`：**删除指定元素\n\n**遍历方法：**\n1. **`keys()`：**提取键并返回**键**的迭代器MapIterator对象\n2. **`values()`：**提取值并返回**值**的迭代器MapIterator对象\n3. **`entries()`：**提取键值对并返回取**键值对**的迭代器MapIterator对象\n4. **`forEach()`：**传入回调函数(value, key)=>{}\n\n```js\nvar m = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n\nconsole.log(m.keys());//MapIterator {'x', 'y'}\nconsole.log(m.values());// MapIterator {1, 2}\nconsole.log(m.entries());// MapIterator {'x' => 1, 'y' => 2}\n\n//迭代器可以用for-of遍历\nfor (let [key, value] of m.entries()) {\n    console.log(key, value);//x 1, y 2\n}\n\nm.forEach((value, key) => {\n    console.log(key, value);//x 1, y 2\n})\n\n```\n\n# Set对象\n**Set**是**唯一值**的集合，与map类似，map存放的是键值对，而set只存放唯一值。\n\n**创建set对象：**\n\n```js\nvar s = new Set();\nvar s = new Set([1,2,3]);\n```\n\nset对象与数组也很像，可以互相转换\n\n```js\nvar arr1 = [1, 2, 3];\nvar s = new Set(arr1);//数组转为set对象，会去重\nvar arr2 = [...s];//set对象转为数组\n```\n\n可利用set值唯一的特性做**数组去重、并集、交集、差集**操作\n\n```js\n//1、去重\nvar s = new Set([1,2,3,3,2,1]);\nvar arr = [...s];//[1,2,3]\n\n//2、并集\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s = new Set([...arr1, ...arr2]); // {1, 2, 3, 4}\nvar arr = [...s];// [1,2,3,4]\n\n//3、交集，arr1和arr2共有的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => s2.has(x));//[2, 3]\n\n//4、差集,arr1去除arr2中的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => !s2.has(x));//[1]\n\n```\n\nSet值个数可以通过size属性获取\n\n```js\nvar s = new Set([1,2,3]);\nconsole.log(s);//Set(3) {1, 2, 3}\nconsole.log(s.size);//3\n```\n\n## Set的方法\n1. **`add()`：**添加新元素\n2. **`delete()`：**删除指定元素\n3. **`clear()`：**清空所有元素\n4. **`has()`：**判断是否存在某值\n5. **`forEach()`：**遍历每个元素，传入回调函数\n6. **`keys()`：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n7. **`values()`：**同keys()\n8. **`entries()`：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n**add()、delete()、clear()、has() ：**\n\n```js\nvar s = new Set([1,2,3]);\ns.add(4);\nconsole.log(s);//Set(4) {1, 2, 3, 4}\ns.delete(2);\ns.has(2);//false\ns.clear();\nconsole.log(s.size);// 0\n\n```\n\n**keys()、values() ：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.values();\nconsole.log(setIter);//SetIterator {1, 2, 3}\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // 2\nconsole.log(setIter.next().value); // 3\n```\n\n**entries() ：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.entries();\nconsole.log(setIter);//SetIterator {1 => 1, 2 => 2, 3 => 3}\nconsole.log(setIter.next().value); // [1, 1]\nconsole.log(setIter.next().value); // [2, 2]\nconsole.log(setIter.next().value); // [3, 3]\n```\n\n**forEach() ：**遍历每个元素，传入回调函数，参数：回调函数、thisArg执行回调函数时可以当作this来使用。\n回调函数参数：值（key）、值（value）、set对象\n\n```js\nvar s = new Set([1,2,3]);\ns.forEach((key,value,set)=>{\n    console.log(key,value);//1 1, 2 2, 3 3\n});\n```\n\n# 迭代/遍历器Iterator\nES6之后，表示“集合”的数据结构，在原先 Array 和 Object 基础上，又增加了 Map 和 Set\n\n遍历器 Iterator 用于规范统一地对集合进行遍历操作，是一个能访问数据的接口\n\n**Iterator 的遍历过程：**\n（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构的当前成员的信息（一个包含 value、done 属性的对象）\nvalue：当前成员的值\ndone：布尔值，表示遍历是否结束\n\n总之，遍历器使得不同的数据结构都可以被 for-of 遍历，只要实现了 Symbol.iterator\n\n## Symbol.iterator\nSymbol.iterator 是一个预定义好的、类型为 Symbol 的特殊值，是 Iterator 接口\n\n一个数据结构只要具有 Symbol.iterator 属性，就是可遍历的，也就是可以用 for-of 进行遍历\n\nSymbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器\n\n```js\nconst obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n```\n\n原生具备 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象\n\n```js 获取数组的迭代器\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n// for-of 遍历\nlet arr = ['a', 'b', 'c'];\nfor(let item in arr) {\n  console.log(item);\n}\n```\n\n\n# 生成器Generator\n生成器是一种函数，function关键字与函数名之间有一个星号 *，函数体内部使用yield表达式\n\n调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是一个遍历器对象\n\nyield 关键字会暂停函数的执行，调用遍历器对象的 next 方法，能让函数执行到下一个 yield 暂停处（或是return）\n\n总之 Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\n```js\nfunction* fun() {\n  console.log(1);\n  yield 'qx';\n  console.log(2);\n  yield 'chuckle';\n  console.log(3);\n}\nconst f = fun();\nconsole.log(f.next())\nconsole.log(f.next())\nconsole.log(f.next())\n// 1\n// { value: 'qx', done: false }\n// 2\n// { value: 'chuckle', done: false }\n// 3\n// { value: undefined, done: true }\n```\n\nnext() 会返回一个包含 value、done 属性的对象，其中 value 值是 yield 后面表达式的值\n\nnext() 可以传入参数，yield 是将其返回后，函数再继续执行到下一个 yield\n\n```js\nfunction* fun() {\n  let x = yield;\n  console.log(x);\n  let y = yield;\n  console.log(x+y);\n}\nconst f = fun();\nconsole.log(f.next(1))\nconsole.log(f.next(2))\nconsole.log(f.next(3))\n// { value: undefined, done: false }\n// 2\n// { value: undefined, done: false }\n// 5\n// { value: undefined, done: true }\n```\n\n使用 Generator 函数能够很方便地实现 Symbol.iterator，其目的也正是如此\n\n```js\nfunction* objectEntries(obj){\n    // 获取对象的所有 key 保存到数组 [name, age]\n    const propKeys = Object.keys(obj);\n    for(const propkey of propKeys){\n        yield [propkey, obj[propkey]]\n    }\n}\nconst obj = {\n    name: 'chuckle',\n    age: 19\n}\n// 把 Generator 生成器函数赋值给对象的Symbol.iterator属性, 为该对象加上遍历器接口\nobj[Symbol.iterator] = objectEntries;\n// objectEntries(obj) 等价于 obj[Symbol.iterator](obj) \nfor(let [key, value] of objectEntries(obj)){ \n    console.log(`${key}: ${value}`);\n}\n// name: chuckle\n// age: 19\n```\n\n## Generator的应用\n**1、异步代码同步化**\n\n```js\nfunction* main(){\n  let res = yield request('https://v1.hitokoto.cn/');\n  console.log('1:'+res);\n  res = yield request('https://v1.hitokoto.cn/');\n  console.log('2:'+res);\n  res = yield request('https://v1.hitokoto.cn/');\n  console.log('3:'+res);\n}\nconst ite = main();\nite.next();\n\nfunction request(url){\n  fetch(url)\n  .then(res=>res.json())\n  .then(data=>{\n    ite.next(data.hitokoto)\n  })\n}\n// 1:自己永远是孤单的，但你可以让其他人变得不孤单。\n// 2:我就是小偷，专门来偷走哥哥的心\n// 3:电脑的处理器总比执行单元小。\n```\n\n**2、正确的执行顺序**\n\n```js\nfunction* main(){\n  fun1();\n  yield fun2();\n  fun3();\n}\nlet ite = main();\nite.next();\n// 1 2 3\n\nfunction fun1(){\n  console.log('1');\n}\nfunction fun2(){\n  setTimeout(()=>{\n    console.log('2');\n    ite.next();\n  },1000)\n}\nfunction fun3(){\n  console.log('3');\n}\n```\n\n# for-in 和 for-of\n**for-in**(ES5) 和 **for-of**(ES6) 都是遍历数据的语法。\n\n**for-in** 用于遍历对象的**可枚举**的**属性**（名称），**会顺着原型链查找**可枚举属性。\n\n```js\nlet obj = {\n  name: '张三',\n  age: 18\n}\nObject.prototype.sex = \"男\"\n\nfor(let item in obj) {\n  console.log(item) // name、age、sex\n}\n```\n\n而 **for-of** 用于遍历**可迭代对象**，即实现了 Symbol.iterator 接口的对象，会顺着原型链查找 Symbol.iterator 属性。\n\nArray，Map，Set，String 等都实现了该接口，可以直接遍历其值。\n\n```js\nlet arr = ['a', 'b', 'c']\nfor(let item of arr) {\n  console.log(item) // a、b、c\n}\n```\n\n\n\n# Promise\n**之前已经记过笔记了：**[Promise异步编程](/article/7a1fbbc5.html)\n\n# Class类\n在 ES5 中生成实例对象的传统方法是通过构造函数\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.sayName = function () {\n  console.log(this.name);\n}\nlet p = new Person('chuckle', 18);\np.sayName() // chuckle\n```\n\nES6新增了class语法糖，类本质上是函数，类本身指向其构造函数 `constructor()`，所以类的构造函数也就是类本身\n\n```js\nclass A { }\nconsole.log(typeof A === 'function'); // true\n```\n\n构造函数和普通函数容易混淆，现在，可以通过 Class 关键字来声明一个类了，其内置的 `constructor()` 在实例化对象时会立即被调用\n\n用法还是大差不差，并且和之前一样，**类方法都在原型上**\n\n```js\nclass Person {\n  // 实例化的时候会立即被调用\n  constructor(name, age){\n      this.name = name;\n      this.age = age;\n  }\n  //等同于Person.prototype.sayName = function sayName(){}\n  sayName(){\n    console.log(this.name);\n  }\n}\nlet p = new Person('chuckle', 18);\np.sayName() // chuckle\n```\n\n由于类中定义的方法都在其构造函数的原型上，所以可以用 Object.assign() 向类添加多个方法\n\n```js\nclass Person {\n  constructor(){}\n}\nObject.assign(Person.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n\n## constructor函数\n`constructor()` 方法是类的默认方法，在创建实例对象时，自动调用\n\n默认返回实例对象（即this），也可以指定返回（return）另外一个对象\n\n```js\nconstructor() {\n  return Object.create(null);\n}\n```\n\n如果一个实例属性不需要接受外部的传参赋值，可以不在 constructor 方法中定义\n\n```js\nclass Person {\n  constructor(name, age){\n      this.name = name;\n      this.age = age;\n  }\n  country = 'china';\n}\nlet p = new Person('chuckle', 18);\nconsole.log(p)\n// Person { country: 'china', name: 'chuckle', age: 18 }\n```\n\n## Class表达式\n可以写成表达式的形式\n\n```js\nconst MyClass = class { \n  name = 'chuckle';\n  SayName() {\n    console.log(this.name);\n  }\n};\nconst myClass = new MyClass();\nmyClass.SayName() // chuckle\n```\n\n可以写出立即执行的 Class\n\n```js\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\nperson.sayName(); // 张三\n```\n\n## Static\n在类成员前，加上static关键字，就表示静态属性或方法\n\n**静态**即不会被实例继承，而是直接通过类来调用\n\n静态方法可以与非静态方法重名\n\n```js\nclass Class{ \n  name = 'chuckle';\n  static name = 'qx';\n  static SayName() {\n    console.log(this.name); // 静态方法的this指类本身，只能访问静态属性\n  }\n};\nClass.SayName() // qx\nnew Class().SayName(); // TypeError: myClass.SayName is not a function\n```\n\n父类的静态成员，可以被子类继承\n\n```js\nclass Foo {\n  static num = 123;\n  static classMethod() {\n    return 'hello';\n  }\n}\nclass Bar extends Foo {\n}\nBar.classMethod() // 'hello'\nBar.num // 123\n```\n\n## 私有方法和属性\n私有，即只能在类的内部访问的方法和属性，外部不能访问，有利于代码的封装\n\n早期并没有途径实现真正的私有，只能通过特殊的命名规则加以区别\n\n```js\nclass Class {\n  foo () {} // 公有\n  _fun() {} // 加上_表示私有\n}\n```\n\n或者借助 Symbol 来让成员不易被获取，但仍然可以被 Reflect.ownKeys() 等方法获取到\n\n```js\nlet s1 = Symbol('name');\nlet s2 = Symbol('fun')\nclass Class {\n  name = 'qx';\n  [s1] = 'chuckle';\n  [s2](){\n    console.log(this.name);\n  };\n}\nconst myClass = new Class()\nconsole.log(myClass) // Class { name: 'qx', [Symbol(name)]: 'chuckle' }\nmyClass[s2]() // qx\nconsole.log(Object.getOwnPropertySymbols(myClass)) // [ Symbol(name) ]\n```\n\nES2022 正式为 class 添加了私有成员，方法是在属性或方法名之前使用 `#` 表示\n\n```js\nclass Class {\n  #count = 0;\n  get value(){\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\nconst myClass = new Class();\nmyClass.increment();\nconsole.log(myClass.value) // 1\nconsole.log(myClass.#count) // SyntaxError: Private field '#count' must be declared in an enclosing class\nconsole.log(myClass.count) // undefined\n```\n\n不管在类的内部或外部，如果读取一个不存在的私有成员，会报错\n\n私有成员前面，也可以加上 static 关键字，表示这是一个静态的私有成员\n\n## 类的继承\nClass 通过 `extends` 关键字实现继承，写法比 ES5 的原型链继承，要清晰和方便很多\n\n```js\nclass Animal {\n    constructor(name, age){\n        this.name = name;\n        this.age = age;\n    }\n    sayName(){\n        return this.name;\n    }\n    sayAge(){\n        return this.age;\n    }\n}\n \nclass Dog extends Animal{\n    constructor(name, age, color){\n        // 子类的构造函数必须执行一次 super() 函数\n        super(name, age);  // 等同于 Animal.call(this,name,age); 继承父类的属性\n        this.color = color;\n    }\n    // 子类自己的方法\n    sayColor(){\n        return `${this.name}是${this.age}岁了，它的颜色是${this.color}`;\n    }\n    // 重写父类的方法\n    sayName(){\n        // super 相同于 Animal\n        return this.name + super.sayAge + this.color;\n    }\n}\n \nlet d1 = new Dog('小黄', 28, 'red');\nconsole.log(d1.sayAge());     // 调用继承父类的方法\nconsole.log(d1.sayColor());   // 调用子类自己的方法\nconsole.log(d1.sayName());    // 调用重写父类的方法\n```\n\n### 继承的原型链\n类的继承是原型链继承，子类的原型的__proto__指向父类的原型，详见：[原型与原型链](/article/7d8b8b34.html#原型与原型链)\n\n同时为了静态方法能够继承，子类的构造函数的__proto__指向父类的构造函数\n\n```js\nclass A {\n  name = 'a'\n  getName() {\n    console.log(this.name)\n  }\n}\nclass B extends A {\n  name = 'b'\n}\n// 继承实例方法\nconsole.log(Object.getPrototypeOf(B.prototype) === A.prototype) // true\n// 继承静态的类方法\nconsole.log(Object.getPrototypeOf(B) === A) // true\n```\n\n**两条原型链：**\n\n```js\nB.__proto__ === A\nB.prototype.__proto__ === A.prototype\n```\n\n## super\nsuper 关键字，既可以当作函数使用，也可以当作对象使用\n\nsuper 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super() 函数\n调用super()的作用是形成子类的this对象，任何对子类 this 的操作都要放在 super() 的后面\n\nsuper() 相当于 A.prototype.constructor.call(this)（在子类的this上运行父类的构造函数）\n\n```js\nclass A {}\nclass B extends A {\n  constructor() {\n    super();\n    this.name = 'qx';\n  }\n}\n```\n\nsuper 作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类\n\n定义在父类实例上的方法或属性，无法通过 super 调用\n\n```js\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n```\n\n# Module模块化\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJS 和 AMD 模块，都是运行时的\n\n```js\n// CommonJS模块\nlet { stat, exists, readfile } = require('fs');\n// ES6模块\nimport { stat, exists, readFile } from 'fs';c\n```\n\nES6 模块主要有两个命令构成：`export` 和 `import`\n\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量\n\n```js\nconst name = '张三';\nconst age = 18;\nconst sayName = function() { console.log(fristName); }\nexport {name, age, sayName}\n\nimport {name, age, sayName} from './modules/index.js';\n```\n\n默认暴露 `export default` 为模块指定默认输出，import命令可以为该匿名函数指定任意名字\n\n```js\nexport default function(){\n  console.log('chuckle');\n}\n\nimport sayName from './modules/index.js'\nimport { default as sayName } from './modules/index.js'\nimport sayName, { name } from './modules/index.js'\nsayName(); // chuckle\n```\n\n整体加载：模块暴露的内容都会作为该对象的成员\n\n```js\nimport * as obj from './modules/index.js';\n```\n\n在浏览器环境中，需要给 script 标签加上 `type='module'` 属性\n\n```html\n<script type='module'>\n  import { name } from './modules/index.js';\n</script>\n```\n\n## 动态import()\n使用 `import()` 函数动态引入模块\n\n```js\nif(true){\n  import('./modules').then(mod=>{\n    console.log(mod) // mod对象中包含模块暴露的成员\n  })\n}\n```\n\n\n\n\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"文本、代码粘贴分享平台项目","url":"/article/544ba770.html","content":"\n# 前言\n网上居然没有个轻量方便的代码粘贴分享的网站，那就自己动手丰衣足食。\n\n**目的：**跨设备、远程进行文本、代码的传输、分享与展示（起初只是为了在qq群里发代码不刷屏）\n\n作为大学牲，之前忙着预习期末，6月份都没写博文，也少写代码，都快忘了Vue3咋写了，这个项目就当康复训练了（康复效果显著）\n\n# 简介\n一个轻量快捷的文本、代码粘贴分享网站\n\n**演示：**[粘贴分享](https://s.qcqx.cn/)，使用Cloud Mongodb + Vercel部署\n\n**前端：**[paste-share](https://github.com/qxchuckle/paste-share)\n\nVue3 + Vite + Vue Router + Pinia + Naive UI + Echarts + axios + sass + highlight.js + vue-clipboard3 + qrcode.vue\n\n**后端：**[paste-share-server](https://github.com/qxchuckle/paste-share-server)\n\nNodeJS + Express + MongoDB + Mongoose + shortid + jsonwebtoken\n\n# 功能\n1. 注册、登录、自动登录，区分多用户和游客，Token控制会话\n2. 游客也能粘贴分享内容，注册登录后能查看自己所分享的所有内容\n3. 分享内容可选加密\n4. 删除、修改分享内容\n5. 搜索及分页展示\n6. 多种语言可选，代码高亮展示\n7. 分享链接、分享内容快速复制及二维码分享\n8. 权限管理，分为超级管理员、普通管理员、普通用户\n9. Echarts可视化展示后台数据\n10. 完整的后台管理系统\n11. 可选深、浅主题色，支持按时间自动切换\n12. 必要的加载动画、进度条及消息小弹窗提示\n13. 移动端窄屏适配\n\n# 截图\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-2.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-3.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-4.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-5.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-6.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-7.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-8.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/62-9.webp loading=\"lazy\">","tags":["NodeJS","Vue"],"categories":["项目"]},{"title":"Express+Vue3前后端分离博客","url":"/article/ebf9360.html","content":"\n# 前言\n花了三天时间搞定，属于是边写边学\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/61-2.webp loading=\"lazy\">\n\nBug嘛，肯定没有（没发现就是没有！）\n这不是 Bug ，这是一个特性，它在我的机器上可以很好地运行。\n\n# 简介\n一个简单的前后端分离的博客，拥有完整的接口与后台\n\n**演示：**[轻笑Chuckle|博客](https://blog.qcqx.cn/)，部署使用的cloud Mongodb + Vercel，可能会有亿点慢\n\n后台账号：qx 密码：123456\n\n**前端：**[仓库 blog-vue](https://github.com/qxchuckle/blog-vue)\n\nVue3 + Vite + Vue Router + Pinia + Naive UI + wangEditor + axios + sass\n\n**后端：**[仓库 blog-server](https://github.com/qxchuckle/blog-server)\n\nNodeJS + Express + MongoDB + Mongoose + jsonwebtoken\n\n# 后端\n**接口文档：**[API文档](https://console-docs.apipost.cn/preview/c671abaeb3ac6f29/c22da7ca55753064)\n\n1. 登陆、注册、自动登陆校验\n2. 分类的增删改查\n3. 文章的增删改查\n4. 敏感操作（增删改）校验token\n5. API视情况返回不同的json信息\n\n获取文章时通过携带的query参数不同，可以实现分页查询、查询指定分类的文章、标题和内容关键词搜索等\n\n# 前端\n1. 路由拦截，自动登陆\n2. 完整的管理后台，文章管理、富文本编辑、分类管理\n3. 人性化的交互，加载提示、信息提示\n4. 适配移动端\n5. 表单输入内容的校验\n6. 管理员登陆状态的管理\n7. 对分类等数据进行暂存，除非进行了修改，否则不去请求后端接口\n8. 使用pinia管理状态以及对状态的操作，两个store：UserStore、PostStore\n9. 代码上，对文章列表、富文本编辑等组件的封装，方便复用\n\n# Tip\n因为是个人博客，所以后端没有设计区分多用户的文章、分类管理，注册好管理员就改后端代码把注册接口堵死吧\n\n后端config.js保存了token加密字符串、数据库连接url等配置\n\n输入内容的限制只在前端做了，后端只管关键参数有没有传过来，至于内容的限制，懒了，能跑就行，咕咕咕\n\n是否展示业务逻辑已经写完，但是没有实装（加个判断的事），感觉个人博客没必要是否展示（那我写来干嘛？以后实装），所以现在就算选不展示，也还是会展示滴\n\n# 截图\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/61-3.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/61-4.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/61-5.webp loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/61-6.webp loading=\"lazy\">\n","tags":["NodeJS","Vue"],"categories":["项目"]},{"title":"Vite、Pinia、Router","url":"/article/31e8cb77.html","content":"\n# Vite\n[Vite](https://cn.vitejs.dev/) 是一种新型的前端构建工具，它可以在开发过程中提供快速的反应速度。相对于其他传统的打包工具，Vite利用浏览器原生ES模块导入功能代替传统的打包方式，实现了更快的构建和启动速度，在生产环境下打包使用 Rollup\n\n**开始：** `npm create vite@latest`\n\n根据提示完成项目创建\n\n```js\n√ Project name: ... vite-test\n√ Select a framework: » Vue\n√ Select a variant: » JavaScript\n```\n\n**安装依赖：**`npm i`\n\n**运行：**`npm run dev`\n\n项目结构与 vue-cli 差不多\n\n**差别：**\n(1) index.html 现在位于项目根目录\n(2) [vite.config.js](https://cn.vitejs.dev/config/) 是Vite项目的配置文件，用于配置Vite本身和插件的选项\n\n# 路由router\n在 vue2 中学的是 [vue-router](https://router.vuejs.org/zh/)@3，现在该跟上最新版本了\n\n**安装：**`npm i vue-router`\n\n虽然大版本变了，但很多功能和写法也只是稍微变了点样子\n\n**配置路由：**\n\n```js /router/index.js\n// 导入创建路由必要的方法\nimport { createRouter, createWebHashHistory } from \"vue-router\";\n// 路由懒加载\nconst Login = () => import('../components/Login/index.vue')\n\n// 路由配置\nconst routes = [\n  {\n    // 都是熟悉的配置项\n    path: '/login',\n    name: 'Login',\n    component: Login,\n    children:[]\n  }\n];\n\n// 创建路由并暴露其返回值\nexport default createRouter({\n  // 配置路由模式hash和history\n  history: createWebHashHistory(),\n  // 使用路由配置\n  routes\n})\n\n```\n\n在 main.js 导入并使用路由\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n// 导入路由\nimport router from './router'\n// 使用路由\ncreateApp(App).use(router).mount('#app')\n```\n\n## 路由模式\nhash 模式 `createWebHashHistory()` \n\nHTML5 模式 `createWebHistory()`\n\n```js\nimport { createWebHashHistory, createWebHistory } from \"vue-router\";\nexport default createRouter({\n  // history: createWebHashHistory(),\n  history: createWebHistory(),\n  routes\n})\n```\n\n## 路由守卫\n[路由守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)使用也和之前差不多\n\n现在每个路由守卫都接收两个参数，不再有 next()\n(1) **to:** 即将要进入的目标\n(2) **from:** 当前导航正要离开的路由\n\n通过返回值来控制路由：\n(1) **false:** 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n(2) **一个路由地址:** 通过一个路由地址跳转到一个不同的地址，就像调用 router.push() 一样，可以设置诸如 replace: true 或 name: 'home' 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 from 一样。\n(3) **无返回值**或**true:** 继续当前路由\n\n**全局路由守卫：**\n\n```js\nconst router = createRouter({ /* ... */ }）\nlet isAuthenticated = true;\n// 全局前置守卫\nrouter.beforeEach(async (to, from) => {\n  console.log(to,from);\n  if (\n    // 检查用户是否已登录\n    !isAuthenticated &&\n    // ❗️ 避免无限重定向\n    to.name !== 'Login'\n  ) {\n    // 将用户重定向到登录页面\n    return { name: 'Login' }\n  }\n})\n\n```\n\n## 编程式路由\n在 vue3  组合式 API 中不再有 this\n\n使用 `useRouter()`, `useRoute()` 的返回值获取路由器和当前路由对象，route 对象是一个响应式对象\n\n```js\nimport { useRouter, useRoute } from 'vue-router'\nconst router = useRouter()\nconst route = useRoute()\nconsole.log(route);\nfunction pushLogin() {\n  router.push({\n    name: 'Login'\n  })\n}\n\n```\n\n**注意：**在模板中仍然可以访问 $router 和 $route，不需要在 setup 中返回 router 或 route\n\n## 导航流程\n\n1. 导航被触发。\n2. 在失活的组件里调用 beforeRouteLeave 守卫。\n3. 调用全局的 beforeEach 守卫。\n4. 在重用的组件里调用 beforeRouteUpdate 守卫。\n5. 在路由配置里调用 beforeEnter。\n6. 解析异步路由组件。\n7. 在被激活的组件里调用 beforeRouteEnter。\n8. 调用全局的 beforeResolve 守卫。\n9. 导航被确认。\n10. 调用全局的 afterEach 钩子。\n11. 触发 DOM 更新。\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n> 路由这块，多看[文档](https://router.vuejs.org/zh/guide/)吧\n\n# pinia\n[Pinia](https://pinia.web3doc.top/) 是类似 Vuex 的**状态管理**库，具有更好的类型安全性和更简单的API\n\npinia 中只有 state、getter、action，抛弃了 Vuex 中的 Mutation，但和 vuex 一样，有一个 store\n\n**安装：**`npm i pinia`\n\n`createPinia` 创建并使用pinia：\n\n```js\n// 导入并使用pinia\nimport { createPinia } from 'pinia'\napp.use(createPinia())\n```\n\n## 创建store\n使用 `defineStore()` 创建一个 store，并且需要一个唯一名称，作为第一个参数传递。pinia中允许创建多个store\n\n```js /store/mainStore.js\nimport { defineStore } from 'pinia'\n// 创建并暴露一个store\nexport default defineStore('mainStore', {\n  // 类似data，存储状态\n  // 在 Pinia 中，状态被定义为返回初始状态的函数\n  state: () => {\n    return {\n      num: 1,\n      name: 'chuckle'\n    }\n  },\n  // 对状态的操作\n  actions: {\n    add(){\n      this.num++\n    }\n  },\n  // 相当于计算属性，传入一个store的state作为参数\n  getters: {\n    bigNum(state){\n      return state.num*10\n    }\n  }\n});\n\n```\n\n## 使用store操作状态\n在需要使用该 store 的组件中引入\n\n为了从 Store 中提取属性同时保持其响应式，需要使用 `storeToRefs()`\n\n```html\n<script setup>\nimport { storeToRefs } from 'pinia'\nimport { useStore } from './stores/mainStore'\n// store 是一个用reactive 包裹的对象，不能对其进行解构\nconst store = useStore()\n// 为了从 Store 中提取属性同时保持其响应式，需要使用storeToRefs()\nconst { num, name, bigNum } = storeToRefs(store)\n</script>\n<template>\n  <!-- store中的 -->\n  <h3>{{ store.name }}</h3>\n  <h3>{{ store.num }}</h3>\n  <h3>{{ store.bigNum }}</h3>\n  <!-- 提取出来的 -->\n  <h3>{{ name }}</h3>\n  <h3>{{ num }}</h3>\n  <h3>{{ bigNum }}</h3>\n  <button @click=\"store.add()\">增加</button>\n</template>\n\n```\n\n**其它操作：**\n1. `$reset()` 重置 state\n```html\n<button @click=\"store.$reset()\">重置</button>\n```\n2. `$patch()` 批量写入或修改 state\n```js\nfunction bulkChange(){\n  store.$patch((state)=>{\n    state.name = \"qx\";\n    state.num = state.num *10\n  })\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"TypeScript笔记","url":"/article/9d362be7.html","content":"\n# 初识\n[TypeScript](https://www.tslang.cn/index.html) 是由巨硬开发的 **JS 的超集**，通过添加可选的静态类型和基于类的面向对象编程思想，使得代码更易于理解、维护和重构。此外，**TS** 还支持其他高级语言功能，如接口、泛型、命名空间和装饰器等\n\n**规范：**TS 提供了更好的类型检查和代码提示工具，并且可以使用第三方库中的类型声明文件进行代码补全和类型检查\n\n**开发：**TS 为现代Web应用程序和大型项目提供了一个强大的编程环境，可以帮助开发人员减少错误、提高开发效率和代码质量\n\n**运行：**TS 可以转换成 JS 并在任何支持 JS 的环境中运行，包括浏览器、Node.js和移动应用程序等\n\n**安装：**`npm install typescript -g` 会在全局暴露一个 **tsc** 命令\n\n`tsc -init` 初始化，创建 **tsconfig.json**\n\n`tsc -w` 监视所有 TS 文件变化，实时编译成 JS\n\n`npm install ts-node -g` 安装 **ts-node** 更方便地运行 TS\n\n# 配置文件\n**tsconfig.json** 是 TS 的配置文件\n\n可以定义哪些文件需要包含在编译过程中、使用哪个ECMAScript目标版本、生成哪种模块系统、是否开启严格模式等等\n\n**常用配置项：**\n1. **target** 设置编译后的 JavaScript 代码使用的 ECMAScript 版本，默认为 ES3，可设置为 ES5、ES6/ES2015、ES7 等。\n2. **strict** 开启所有严格类型检查选项，包括noImplicitAny，noImplicitThis，alwaysStrict等等。如果希望 TypeScript 给出尽可能多的类型检查错误提示，可以将此选项设置为 true。\n3. **module** 指定生成的模块规范类型，可选值有 commonjs、amd、system 和 es2015。\n4. **lib** 指定编译过程中需要引入的库文件，默认情况下只包含 DOM 和 ES 标准库，可以通过指定其他库来获得更好的类型检查支持。\n5. **moduleResolution** 指定模块解析策略，可选值有 classic、node、和 yarn pnp。\n6. **esModuleInterop** 简化导入cjs模块功能\n7. **outDir** 输出目录，指定编译后的 JavaScript 代码所在的目录。\n8. **rootDir** 项目根目录\n9. **allowJs** 允许编译器编译 .js 文件（通常是为了容易迁移现有的 JavaScript 项目到 TypeScript 项目）\n10. **sourceMap** 生成 sourcemap 文件，方便调试 TypeScript 代码时能够正确地映射回原始的 TypeScript 代码。\n11. **noImplicitAny** 当 TypeScript 无法推导出变量的类型时，给出一个错误提醒\n12. **noImplicitThis** 禁止 this 关键字的隐式 any 类型\n13. **strictNullChecks** 严格模式下对 null 和 undefined 的检查。\n\n# TS检查相关注释\n(1) `// @ts-nocheck` 加到文件首行，当前文件不需要 ts 校验\n(2) `// @ts-check` 加到文件首行，对当前文件进行 ts 校验\n(3) `// @ts-ignore` 忽略下一行代码的 ts 校验\n(4) `// eslint-disable-next-line` 忽略下一行代码的 eslint 校验\n(5) `/* eslint-disable */` eslint忽略\n\n# 类型标注\n通过 `<数据>:<类型>` 对变量、函数返回值、函数参数等数据进行类型的标注、限制\n\n**思想：**定义任何东西的时候要注明类型，调用任何东西的时候要检查类型。\n\n可以标注的类型：\n(1) **基础类型：**Boolean、Number、String、null、undefined 以及 ES6 的 Symbol 和 ES10 的 BigInt。\n(2) **空值**：Void\n(3) **顶级类型：**任意类型 Any 和 不知道的类型 Unknown\n(4) Object、object 和 {} \n(5) **接口和对象类型：**interface定义\n(6) **数组类型**\n(7) **函数类型**\n\n## 基本类型\n**1、字符串类型：string**\n\n```ts\nlet str: string = \"chuckle\";\nstr = `1+1=${1+1}`; // 可以使用模板字符串\nstr = \"1+1=\" + \"2\"; // 可以拼接\n```\n\n**2、数字类型：number**\n\n```ts\nlet num: number = 1\nnum = NaN\nnum = Infinity\nnum = 0xf00d // 十六进制\nnum = 0b1010 // 二进制\n```\n\n**3、布尔类型：boolean**\n\n**注意：**new Boolean() 返回的是一个 Boolean 对象，而不是布尔值\n\n```ts\nlet bool: boolean = true\nbool = Boolean(0) // false\n```\n\n**4、Null 和 undefined 类型**\n\nundefined 和 null 是所有类型的**子类型**，在**非严格模式**下可以赋给其它**任何类型**的变量\n\n**严格模式下：**\n(1) undefined 和 null 不能赋给其它类型的变量，但 undefined 可以赋给 void 类型（一般也用不到）\n(2) null 和 undefined 类型也不能相互赋值\n\n```ts\nlet a: null = null\nlet b: undefined =  undefined\na = b // 严格模式下不允许\nlet str: string = a // 严格模式下不允许\nlet c: void = null // 严格模式下不允许\nc = undefined // 始终允许\n```\n\n## 空值void\nJS 中没有空值的概念，TS 中可以使用 void 表示函数无返回值\n\n**注意：**\n(1) 不能将 void 赋给除 any 外其它类型的变量。\n(2) 使用 any 类型的变量接收函数返回的空值，打印 undefined\n(3) Boolean(void) 值是 false\n\n```ts\nfunction fun(): void{}\nlet a: any = fun();\nconsole.log(a); // undefined\na = Boolean(fun());\nconsole.log(a); // false\nlet b: string = fun() // 不允许\n```\n\n## any和unknown\nany 和 unknown 是 TS 中的顶级类型，可以包含所有类型的数据\n\n如果所有变量都是 any 类型，那就是 AnyScript，写起来和 JS 没什么区别，最好不要这么做\n\n```ts\nlet a: any = 1;\na = \"qx\"\na = true\na = null\n```\n\n**any 与 unknown 的区别：**\nany 可以赋给其它类型，而 unknown 不能赋值给除 any 和 unknown 以外的其它类型\n\n```ts\nlet a: any = 1\nlet b: unknown = 2\nlet num: number = a // any可以赋给其它类型\na = b // unknown可以赋给any\nnum = b // unknown不能赋给其它类型\n```\n\nunknown 类型不能读任何元素、属性，也不能调用任何方法，所以 unknown 比 any 安全\n\n```ts\nlet u: unknown = { a: 1 }\nconsole.log(u); // 可以\nconsole.log(u.a); // 错误\nu =  ()=>{ console.log('@@') }\nu() // 错误\n```\n\n## Object、object和{}\nObject、object 和 {} 虽然能保存的数据类型不同，但都和 **unknown** 类型一样，不能读任何元素、属性，也不能调用任何方法\n\n**1、**Object 类型是所有 Object 类的实例的类型，字面量 {} 代表的也是 Object\n\n由于原型链顶层就是 Object，所有基本数据类型和引用类型最终都指向 Object，所以他也包含所有类型\n\n```ts\nlet obj: Object = 1;\nobj = \"chuckle\"\nconsole.log(obj); // chuckle\nobj = { a: 1 }\nconsole.log(obj.a); // 报错：类型Object上不存在属性a\n```\n\n**2、**object 代表所有**非值类型**的类型（数组、对象、函数）等，常用于泛型约束\n\n```ts\nlet o: object = ()=>{ console.log('@@') }\no() // 此表达式不可调用。类型{}没有调用签名\no = ['1','2']\nconsole.log(o[1]) // 错误\no = { a: 1 }\nconsole.log(o) // 报错：类型object上不存在属性a\n```\n\n## 接口和对象类型\n在 TypeScript 中，使用接口（Interfaces）来定义对象的类型。\n\n即使用 **interface** 来定义一种对对象的约束\n\n接口是一个非常灵活的概念，除了可用于对类的一部分**行为**进行抽象外，也常用于**对象的形状**的描述。\n\n```ts\n// 定义一个对象\ninterface Person{\n  name: String,\n  age: number,\n}\n// 必须按照定义的形状来声明\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20\n}\n\n```\n\n1、重名的接口会合并，共同起作用\n\n```ts\ninterface Person{\n  name: String,\n}\ninterface Person{\n  age: number,\n}\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20\n}\n\n```\n\n2、任意属性 [propName: string] (索引签名)\n\n声明的对象中可以有任意个数所定义的类型（或其子类型）的属性\n\n```ts\ninterface Person{\n  name: String,\n  age: number,\n  [propName: string]: any\n}\nlet person: Person = {\n  name: \"chuckle\",\n  age: 20,\n  // 接下来可以有任意个数any类型的属性\n  a: 1,\n  b: \"qx\",\n  c(){\n    console.log(this.a)\n  }\n}\n\n```\n\n3、readonly 让属性只读\n\n```ts\ninterface Person{\n  readonly name: String,\n  age: number,\n}\n```\n\n4、定义对象中的函数\n\n```ts\ninterface Person{\n  fun: (value:number)=>number\n}\n```\n\n6、接口继承 extends\n\n```ts\ninterface A{\n  name: String,\n}\ninterface B extends A{\n  age: number,\n}\nlet b: B = {\n  name: \"chuckle\",\n  age: 20,\n}\n\n```\n\n## 数组类型\n使用 `:<元素类型>[]` 来定义一个数组\n\n```ts\nlet arr: number[] // 定义数值类型的数组\n```\n\n使用泛型的方式定义\n\n```ts\nlet arr: Array<number>\n```\n\n定义二维数组\n\n```ts\nlet arr: number[][]\nlet arr: Array<Array<number>>\n```\n\n定义包含多种类型的数组\n\n```ts\nlet arr: (number|string)[] = [1, 2, '3', 4]\n```\n\n### 元组\n元组：赋值时，元素的类型、位置、个数必须一一对应\n\n```ts\nlet arr: [number,string] = [1,'qx']\n```\n\n允许起名加上可选修饰符，对于越界的元素他的类型被限制为联合类型，也就是可以push已有的元素类型\n\n```ts\nconst arr: [x: number, y?: boolean] = [1, true]\narr.push(1) // 允许push已有的元素类型\narr.push(\"1\") // 类型“\"1\"”的参数不能赋给类型“number | boolean | undefined”的参数。\nconsole.log(arr)\n```\n\n可以用于表格数据的约束\n\n```js\nlet excel: [name: string, sex: string, age: number][] = [\n  ['张三', '男', 18],\n  ['张三', '男', 18],\n  ['张三', '男', 18]\n]\n```\n\n## 函数类型与定义\n定义一个函数类型变量\n\n```ts\nlet fun: Function\nfun = ()=>{}\n```\n\n定义函数的参数和返回值\n\n```ts\nfunction fun(a:number, b:number):number{\n  return a+b;\n}\nconsole.log(fun(1,1))\n```\n\n使用 interface 定义函数类型（函数也是一种对象）\n\n```ts\ninterface Fn {\n  // 只有一个string类型的参数，返回值是数值类型\n  (name: string): number\n}\nlet fun: Fn = (name)=>{\n  console.log(name)\n  return 1\n}\nfun(\"chuckle\")\n\n```\n\nTS 可以定义函数中的 this 类型，用于增强补全，必须写在函数的第一个参数上，不作为真正的参数定义\n\n```ts\ninterface Obj{\n  name: string\n  // TS可以定义this的类型（一般用于增强补全），必须在第一个参数上定义\n  add: (this:Obj, num:number)=>void\n}\nlet obj:Obj = {\n  name: \"chuckle\",\n  add(num:number){\n    console.log(num);\n    console.log(this.name);\n    // 此时this.就会有补全\n  }\n}\nobj.add(1);\n\n```\n\n# ?可选符\n使用 `?:` 定义函数参数或对象属性作为可选项\n\n```ts\ninterface Person{\n  name: String,\n  age?: number, // 年龄可选\n}\n// 第二个b参数可选\nfunction fun(a:number, b?:number):number{\n  return b ? a+b : a;\n}\n\n```\n\n# 联合类型\n使用 `<类型1>|<类型2>` 标注多个类型\n\n```ts\n// 函数可传入两种参数\nfunction fun(a: number | string) { }\n// 可保存两种类型的变量\nlet a: number | string\n```\n\n# 交叉类型\n`<类型1>&<类型2>` 需同时满足两种类型，通常配合接口使用\n\n```ts\ninterface Student {\n  name: string\n  id: number\n}\ninterface Person {\n  name: string\n  age: number\n}\nlet p: Student & Person = {\n  name: \"chuckle\",\n  id: 1,\n  age: 20\n}\n\n```\n\n# 类型断言\n`值 as 类型`或`<类型>值` 欺骗 TypeScript 编译器，但无法避免运行时的错误\n\n```ts\nfunction fun(a: number | string){\n  // console.log(a.length); // 数值类型没.length方法，会报错\n  console.log((<string>a).length); // 断言a一定是string类型\n}\nfun(123) // undefined\nfun('123') // 3\n```\n\nTS 直接在 window 上添加属性是不允许的，但可以将 window 断言为 any 类型，就可以添加属性了\n\n```ts\nwindow.a = 1; // 不可以\n(<any>window).a = 1; // 断言成any就可以了\nconsole.log((<any>window).a);\n```\n\n# 内置对象\nJS 中有很多内置对象，它们可以直接在 TS 中当做定义好了的类型来使用\n\n**1、ECMAScript 的内置对象：**内置对象名就是类型名\n\n```ts\nlet b: Boolean = new Boolean(1)\nconsole.log(b)\nlet n: Number = new Number(true)\nconsole.log(n)\nlet s: String = new String('chuckle')\nconsole.log(s)\nlet d: Date = new Date()\nconsole.log(d)\nlet r: RegExp = /^123/\nconsole.log(r)\nlet e: Error = new Error(\"error\")\nconsole.log(e)\n\n```\n\n**2、DOM 和 BOM 的内置对象：** \n`HTML<标签名>Element` 某个内置标签的类型，input、span 等\n`HTMLElement` 语义化的标签名，footer、header，以及自定义标签名\n`Element` 任何标签元素的类型\n`NodeList` 任何元素集合的类型\n`NodeListOf<其它类型>` 指定元素集合的类型\n\n由于元素可能获取不到，要加上 null 组成联合类型\n\n```ts\nlet div1: HTMLInputElement | null = document.querySelector('input');\nlet div2: HTMLDivElement | null = document.querySelector('div');\nlet div3: NodeListOf<HTMLElement> | null = document.querySelectorAll('.content');\nlet local: string | null = localStorage.getItem('token')\nlet lct: Location  = location\nlet pms: Promise<number> = new Promise((r)=>r(1))\n```\n\n```ts\n//dom元素的映射表\ninterface HTMLElementTagNameMap {\n  \"a\": HTMLAnchorElement;\n  \"abbr\": HTMLElement;\n  \"address\": HTMLElement;\n  \"applet\": HTMLAppletElement;\n  \"area\": HTMLAreaElement;\n  \"article\": HTMLElement;\n  \"aside\": HTMLElement;\n  \"audio\": HTMLAudioElement;\n  \"b\": HTMLElement;\n  \"base\": HTMLBaseElement;\n  \"bdi\": HTMLElement;\n  \"bdo\": HTMLElement;\n  \"blockquote\": HTMLQuoteElement;\n  \"body\": HTMLBodyElement;\n  \"br\": HTMLBRElement;\n  \"button\": HTMLButtonElement;\n  \"canvas\": HTMLCanvasElement;\n  \"caption\": HTMLTableCaptionElement;\n  \"cite\": HTMLElement;\n  \"code\": HTMLElement;\n  \"col\": HTMLTableColElement;\n  \"colgroup\": HTMLTableColElement;\n  \"data\": HTMLDataElement;\n  \"datalist\": HTMLDataListElement;\n  \"dd\": HTMLElement;\n  \"del\": HTMLModElement;\n  \"details\": HTMLDetailsElement;\n  \"dfn\": HTMLElement;\n  \"dialog\": HTMLDialogElement;\n  \"dir\": HTMLDirectoryElement;\n  \"div\": HTMLDivElement;\n  \"dl\": HTMLDListElement;\n  \"dt\": HTMLElement;\n  \"em\": HTMLElement;\n  \"embed\": HTMLEmbedElement;\n  \"fieldset\": HTMLFieldSetElement;\n  \"figcaption\": HTMLElement;\n  \"figure\": HTMLElement;\n  \"font\": HTMLFontElement;\n  \"footer\": HTMLElement;\n  \"form\": HTMLFormElement;\n  \"frame\": HTMLFrameElement;\n  \"frameset\": HTMLFrameSetElement;\n  \"h1\": HTMLHeadingElement;\n  \"h2\": HTMLHeadingElement;\n  \"h3\": HTMLHeadingElement;\n  \"h4\": HTMLHeadingElement;\n  \"h5\": HTMLHeadingElement;\n  \"h6\": HTMLHeadingElement;\n  \"head\": HTMLHeadElement;\n  \"header\": HTMLElement;\n  \"hgroup\": HTMLElement;\n  \"hr\": HTMLHRElement;\n  \"html\": HTMLHtmlElement;\n  \"i\": HTMLElement;\n  \"iframe\": HTMLIFrameElement;\n  \"img\": HTMLImageElement;\n  \"input\": HTMLInputElement;\n  \"ins\": HTMLModElement;\n  \"kbd\": HTMLElement;\n  \"label\": HTMLLabelElement;\n  \"legend\": HTMLLegendElement;\n  \"li\": HTMLLIElement;\n  \"link\": HTMLLinkElement;\n  \"main\": HTMLElement;\n  \"map\": HTMLMapElement;\n  \"mark\": HTMLElement;\n  \"marquee\": HTMLMarqueeElement;\n  \"menu\": HTMLMenuElement;\n  \"meta\": HTMLMetaElement;\n  \"meter\": HTMLMeterElement;\n  \"nav\": HTMLElement;\n  \"noscript\": HTMLElement;\n  \"object\": HTMLObjectElement;\n  \"ol\": HTMLOListElement;\n  \"optgroup\": HTMLOptGroupElement;\n  \"option\": HTMLOptionElement;\n  \"output\": HTMLOutputElement;\n  \"p\": HTMLParagraphElement;\n  \"param\": HTMLParamElement;\n  \"picture\": HTMLPictureElement;\n  \"pre\": HTMLPreElement;\n  \"progress\": HTMLProgressElement;\n  \"q\": HTMLQuoteElement;\n  \"rp\": HTMLElement;\n  \"rt\": HTMLElement;\n  \"ruby\": HTMLElement;\n  \"s\": HTMLElement;\n  \"samp\": HTMLElement;\n  \"script\": HTMLScriptElement;\n  \"section\": HTMLElement;\n  \"select\": HTMLSelectElement;\n  \"slot\": HTMLSlotElement;\n  \"small\": HTMLElement;\n  \"source\": HTMLSourceElement;\n  \"span\": HTMLSpanElement;\n  \"strong\": HTMLElement;\n  \"style\": HTMLStyleElement;\n  \"sub\": HTMLElement;\n  \"summary\": HTMLElement;\n  \"sup\": HTMLElement;\n  \"table\": HTMLTableElement;\n  \"tbody\": HTMLTableSectionElement;\n  \"td\": HTMLTableDataCellElement;\n  \"template\": HTMLTemplateElement;\n  \"textarea\": HTMLTextAreaElement;\n  \"tfoot\": HTMLTableSectionElement;\n  \"th\": HTMLTableHeaderCellElement;\n  \"thead\": HTMLTableSectionElement;\n  \"time\": HTMLTimeElement;\n  \"title\": HTMLTitleElement;\n  \"tr\": HTMLTableRowElement;\n  \"track\": HTMLTrackElement;\n  \"u\": HTMLElement;\n  \"ul\": HTMLUListElement;\n  \"var\": HTMLElement;\n  \"video\": HTMLVideoElement;\n  \"wbr\": HTMLElement;\n}\n\n```\n\n## 代码雨\n\n```css\n*{\n  padding: 0;\n  margin: 0;\n  overflow: hidden;\n}\nbody{\n  background-color: #000;\n}\n```\n\n```ts\nimport './index.css'\n\nlet canvas: HTMLCanvasElement = document.querySelector('#canvas');\nlet ctx = canvas.getContext('2d');\ncanvas.width = screen.availWidth;\ncanvas.height = screen.availHeight;\n\nlet str: string[] = 'qcqxchuckle0101010101'.split('');\nlet arr = Array(Math.ceil(canvas.width / 10)).fill(0);\n\nconst rain = () => {\n  // 不断的在绘制矩形，没有清除上一次画布，矩形是叠加起来的半透明的，所以背景越来越黑，文字越来越谈，感觉像渐变\n  ctx.fillStyle = 'rgba(0,0,0,0.05)';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  ctx.fillStyle = '#0f0';\n  arr.forEach((item, index) => {\n    if (Math.random() > 0.2) { // 控制字符显示的概率\n      const text = str[Math.floor(Math.random() * str.length)]; // 随机获取一个文字\n      ctx.fillText(text, index * 10, item); // 间隔10px绘制文字\n    }\n    // 文字到底部或者大于一个随机数则重置到顶部\n    arr[index] = item > canvas.height || item > Math.random() * canvas.height * (canvas.height > 1000 ? 20 : 10) ? 0 : item + 10\n  });\n};\n\nlet stv = setInterval(rain, 40);\nwindow.addEventListener('resize', () => {\n  clearInterval(stv);\n  canvas.width = screen.availWidth;\n  canvas.height = screen.availHeight;\n  stv = setInterval(rain, 40);\n});\n```\n\n# Class\nClass类是ES6新特性，详见：[ES6-Class类](/article/383b041f.html#Class%E7%B1%BB)\n\n在TS中使用**interface**定义类，当然interface还能定义对象，因为对象是类的实例，类是对象的模板\n\n```ts\n// 用来定义对象的类型\ninterface Options {\n  el: string | HTMLElement\n}\n// 用来约束Class\ninterface VueCls {\n  options: Options\n  init(): void\n}\n// implements关键字定义类\nclass Vue implements VueCls {\n  options: Options\n  constructor(options: Options) {\n    this.options = options\n    this.init()\n  }\n  init(): void {\n    console.log(this.options) // { el: '#app' }\n  }\n}\nconst vue = new Vue({\n  el: '#app'\n});\n```\n\n一个类可以由多个interface进行约束\n\n```ts\ninterface VueCls1 {\n  options: Options\n}\ninterface VueCls2 {\n  init(): void\n}\n// implements关键字定义类\nclass Vue implements VueCls1, VueCls2 {\n  options: Options\n  constructor(options: Options) {\n    this.options = options\n    this.init()\n  }\n  init(): void {\n    console.log(this.options) // { el: '#app' }\n  }\n}\n```\n\n## 继承\nClass 通过 `extends` 关键字实现继承，详见：[ES6-类的继承](/article/383b041f.html#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF)\n\n一个简化版的虚拟DOM案例：\n\n```ts\n// 用来定义对象的类型\ninterface Options {\n  el: string | HTMLElement\n}\n\n// 用来约束Class\ninterface VueCls {\n  options: Options\n  init(): void\n}\n\n// 定义节点的数据结构\ninterface Vnode {\n  tag: string // 标签名\n  text?: string // 文本内容\n  children?: Vnode[] // 子节点\n}\n\n// 简化版虚拟Dom\nclass Dom {\n  // 创建节点\n  createElement(tag: string) {\n    return document.createElement(tag);\n  }\n  // 填充文本\n  setText(el: HTMLElement, value: string) {\n    el.textContent = value;\n  }\n  // 渲染\n  render(data: Vnode) {\n    // 创建当前节点\n    const root = this.createElement(data.tag);\n    // 如果有文本则填充\n    if (data.text) {\n      this.setText(root, data.text)\n    }\n    // 如果该有子节点，则递归渲染\n    if (data.children && Array.isArray(data.children)) {\n      data.children.forEach(child => {\n        // 渲染并获取子节点\n        const e = this.render(child)\n        // 将子节点添加给父节点\n        root.appendChild(e);\n      })\n    }\n    // 返回当前节点\n    return root;\n  }\n}\n\n// 虚拟dom数据\nconst data: Vnode = {\n  tag: 'div',\n  text: \"这是一个div标签\",\n  children: [\n    {\n      tag: 'p',\n      text: \"这是一个p标签\"\n    },\n    {\n      tag: 'div',\n      children: [\n        {\n          tag: 'p',\n          text: \"这是一个p标签\"\n        },\n        {\n          tag: 'span',\n          text: \"这是一个span标签\"\n        },\n      ]\n    },\n  ],\n}\n\n// extends实现继承，需要写在implements之前\nclass Vue extends Dom implements VueCls {\n  options: Options\n  constructor(options: Options) {\n    super();\n    this.options = options\n    this.init()\n  }\n  init(): void {\n    // 调用父类的方法\n    const dom = this.render(data)\n    const app = typeof this.options.el === \"string\" ? document.querySelector(this.options.el) : this.options.el\n    // app存在则将Dom挂载到页面上\n    app?.appendChild(dom)\n  }\n}\n\n// 创建实例\nconst vue = new Vue({\n  el: '#app'\n});\n```\n\n渲染结果：\n\n```html\n<div id=\"app\">\n  <div>这是一个div标签\n    <p>这是一个p标签</p>\n    <div>\n      <p>这是一个p标签</p>\n      <span>这是一个span标签</span>\n    </div>\n  </div>\n</div>\n```\n\n## 访问修饰符\n访问修饰符是TS提供的特性，总共有三个：**public** **private** **protected**，用于控制对类内部成员的访问权限\n1. `public` 默认，实例和子类都能访问\n2. `private` 私有的，只能在类内部访问，实例和子类都不能访问\n3. `protected` 类和子类能访问，实例不能访问\n\n一个特殊的：`readonly` 只能访问，不能修改(可以在constructor中初始化)\n\n对上面的虚拟dom案例进行修饰：\n\n```ts\n// 用来定义对象的类型\ninterface Options {\n  el: string | HTMLElement\n}\n\n// 用来约束Class\ninterface VueCls {\n  options: Options\n  init(): void\n}\n\n// 定义节点的数据结构\ninterface Vnode {\n  tag: string // 标签名\n  text?: string // 文本内容\n  children?: Vnode[] // 子节点\n}\n\n// 简化版虚拟Dom\nclass Dom {\n  // 创建节点\n  private createElement(tag: string) {\n    /*****/\n  }\n  // 填充文本\n  private setText(el: HTMLElement, value: string) {\n    /*****/\n  }\n  // 渲染\n  protected render(data: Vnode) {\n    /*****/\n  }\n}\n\n// implements关键字定义类\nclass Vue extends Dom implements VueCls {\n  readonly options: Options\n  constructor(options: Options) {\n    super();\n    /*****/\n  }\n  init(): void {\n    /*****/\n  }\n}\n```\n\n**注意：**接口中不能出现 public, protected, private 修饰符，因为默认只能规定类中的 public 属性和方法，也就是说接口中定义的成员都是 public 的\n\n```ts\ninterface VueCls {\n  /*****/\n  init(): void\n}\nclass Vue extends Dom implements VueCls {\n  /*****/\n  // 报错：属性“init”在类型“Vue”中是私有属性，但在类型“VueCls”中不是。\n  private init(): void {\n    /*****/\n  }\n}\n```\n\n## 抽象类\n`abstract` 关键字定义抽象类和抽象方法，抽象类无法实例化，抽象方法只能描述\n\n作用：用于顶层设计，派生类实现功能\n\n```ts\nabstract class Person {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  abstract setName(name: string): void\n}\n\nclass Student extends Person {\n  // 子类必须实现抽象父类的抽象方法\n  setName(name: string): void {\n    this.name = name\n  }\n}\n\nconst stu = new Student(\"chuckle\")\nconsole.log(stu.name) // chuckle\nstu.setName(\"qcqx\")\nconsole.log(stu.name) // qcqx\n```\n\n# 枚举类型\n`enum` 定义枚举类型，枚举成员只能是数字或字符串，且readonly\n\n枚举成员也可以被当做一个类型，可以指定某些变量的值必须是枚举成员的值\n\n[聊聊TypeScript中枚举对象(Enum)](https://segmentfault.com/a/1190000040817957)\n\n**1、数字枚举**\n默认从0开始枚举，可以**反向映射**\n\n```ts\nenum Color {\n  red,\n  green,\n  blue\n}\nconsole.log(Color)\n// { '0': 'red', '1': 'green', '2': 'blue', red: 0, green: 1, blue: 2 }\nconsole.log(Color[0]) // red\nconsole.log(Color.red) // 0\n```\n\n可以指定初值\n\n```ts\nenum Color {\n  red = 1,\n  green,\n  blue\n}\nconsole.log(Color)\n// { '1': 'red', '2': 'green', '3': 'blue', red: 1, green: 2, blue: 3 }\nconsole.log(Color[0]) // undefined\nconsole.log(Color.red) // 1\n```\n\n**2、字符串枚举**\n每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化\n\n```ts\nenum Color {\n  red = 'red',\n  green = 'green',\n  blue = 'blue'\n}\nconsole.log(Color)\n// { red: 'red', green: 'green', blue: 'blue' }\nconsole.log(Color.red) // red\n```\n\n**3、异构枚举**\n枚举可以混合字符串和数字成员\n\n```ts\nenum Color {\n  red = 'red',\n  green = 'green',\n  blue = 3\n}\nconsole.log(Color)\n// { '3': 'blue', red: 'red', green: 'green', blue: 3 }\n```\n\n**4、接口枚举**\n用于约束成员值的范围\n\n```ts\nenum Color {\n  red = 'red',\n  green = 'green',\n  blue = 3\n}\ninterface A {\n  red: Color.red;\n  blue: Color.blue;\n}\nlet obj: A = {\n  // red: 'red', // 不能将类型“\"red\"”分配给类型“Color.red”。\n  red: Color.red,\n  // blue: 2 // 不能将类型“2”分配给类型“Color.blue”。\n  blue: 3\n}\n```\n\n**4、const枚举**\n直接将枚举编译为常量，而普通声明的枚举编译完后是个对象，可以避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问\n\n注意：const枚举不能反向映射\n\n```ts\nconst enum Types{\n  No = \"No\",\n  Yes = 1,\n}\nconsole.log(Types.No)\nconsole.log(Types.Yes)\n// 编译后\nconsole.log(\"No\" /* Types.No */);\nconsole.log(1 /* Types.Yes */);\n// 非const编译后\nvar Types;\n(function (Types) {\n    Types[\"No\"] = \"No\";\n    Types[Types[\"Yes\"] = 1] = \"Yes\";\n})(Types || (Types = {}));\nconsole.log(Types.No);\nconsole.log(Types.Yes);\n```\n\n# 类型推论\nTS会在没有明确的指定类型的时候推断出一个类型\n\n```ts\n// 推论为string类型\nlet str = \"chuckle\"\n// 不能再赋予其它类型\nstr = 123 // 不能将类型“number”分配给类型“string”。\n```\n\n若变量没有初始化，会在首次赋值时推断类型\n\n```ts\nlet str\nstr = \"qx\"\nstr = 123 // 不能将类型“number”分配给类型“string”。\n```\n\n# 类型别名\n`type` 定义类型别名，多用于复合类型\n\n```ts\n// 复合类型\ntype t1 = number | string\nlet s: t1\n// 函数类型\ntype t2 = (name: string) => string\nconst fn1: t2 = (name) => {\n  return name\n}\n// 值别名，只能是value定义的值\ntype value = boolean | 0 | '123'\nlet a: value = 0\n```\n\ntype 和 interface 区别：\n1. interface可以继承  type 只能通过 & 交叉类型合并\n2. type 可以定义联合类型、可以使用一些操作符 interface 不行\n3. interface 遇到重名的会合并 type 不行\n\ntype 中的 extends 表示包含，判断左值是否为右类型的子类型\n\n```ts\ntype num1 = 1 extends number ? 1 : 0 // 1\ntype num2 = 1 extends string ? 1 : 0 // 0\ntype num3 = {} extends number ? 1 : 0 // 1\ntype num5 = 1 extends Object ? 1 : 0 // 1\ntype num6 = (()=>{}) extends object ? 1 : 0 // 1\ntype num7 = Number extends object ? 1 : 0 // 1\ntype num8 = number extends object ? 1 : 0 // 0\ntype num9 = Object extends object ? 1 : 0 // 1\ntype num10 = any extends object ? 1 : 0 // 1\ntype num11 = void extends Object | string | object ? 1 : 0 // 0\ntype num12 = void extends null | undefined ? 1 : 0 // 0\ntype num13 = null | undefined extends object ? 1 : 0 // 0\ntype num14 = null extends undefined ? 1 : 0 // 0\ntype num15 = undefined extends null ? 1 : 0 // 0\ntype num16 = undefined | null extends never ? 1 : 0 // 0\ntype num17 = never extends undefined & null ? 1 : 0 // 1\n```\n\n类型的层级：\n\n```text\nobject 包含所有非值类型(undefined,null除外)\nany unknown\nObject\nNumber String Boolean \nnumber string boolean\nnever\n```\n\n# never类型\nnever 类型来表示不应该存在的状态\n\n```ts\ntype A = void | number | never // void | number\ntype B = number & string // never\n// 因为必定抛出异常，所以 error 将不会有返回值\nfunction error(message: string): never {\n    throw new Error(message);\n}\n// 因为存在死循环，所以 loop 将不会有返回值\nfunction loop(): never {\n  while (true) {}\n}\n```\n\n作用：便于TS检查一些可能存在的运行时的期望错误\n\n```ts\ntype Value = 1 | 2 | 3 // 限制值\n// type Value = 1 | 2 | 3 | 4 // 增加值而没有相对应的匹配\nfunction choice(value: Value) {\n  switch (value) {\n    case 1:\n      break\n    case 2:\n      break\n    case 3:\n      break\n    // 进入default肯定有问题\n    default:\n       // 若增加了一个4，则编辑器报错：不能将类型“number”分配给类型“never”。\n      const error: never = value;\n      return error\n  }\n}\n```\n\n# 泛型\n泛型是动态类型，即在使用时确定类型，相比于暴力使用any，泛型即保留了方便的类型检查又增加了灵活性\n\n```ts\nfunction toArray<T>(a: T, b: T): Array<T> {\n  return [a, b]\n}\ntoArray<number>(1, 2) // 完整写法，将类型传入<>\ntoArray(1, 2) // 自动推断\n```\n\n泛型有些类似类型的函数，先用个T作为形式类型占位，再由外部传入实际类型，或者让TS自动推断，所以<>中可以用多个形式类型占位\n\n```ts\nfunction toArray<T, K>(a: T, b: K): Array<T | K> {\n  return [a, b]\n}\ntoArray<number, string>(1, \"a\") // 完整写法，将类型传入<>\ntoArray(1, \"a\") // 自动推断\n```\n\n除了在函数中，interface、type、class 等都可以使用泛型\n\n```ts\n// type\ntype AA<T> = number | string | T\nlet aa: AA<boolean> // 声明变量时确定第三个类型\naa = false\naa = 1\naa = \"aa\"\n// interface\ninterface Data<T> {\n  msg: T\n}\nlet d: Data<string> = { msg: \"hello\" }\n// class\nclass Sub<T>{\n  attr: T[] = [];\n  add(a: T): T[] {\n    this.attr.push(a)\n    return this.attr\n  }\n}\nlet ss = new Sub<number>()\nss.attr = [1, 2, 3]\nss.add(123)\nlet sss = new Sub<string>()\nsss.attr = ['1', '2', '3']\nsss.add('123')\n```\n\n一个常用的技巧：\n因为 js 中的 number/string/boolean 这些基本量是传值的，而 object/array 这些对象传引用地址，当我们想在函数内部通过参数修改传进来的数据时，就得使用引用数据类型，所以我们把基本量包装成一个对象传进去，就可以实现在函数内部修改参数了\n\n```ts\ntype ref<T> = {\n  value: T\n}\n```\n\n泛型在封装请求方法时也经常使用：\n\n```json data.json\n{\n  \"code\": \"0000\",\n  \"msg\": \"成功\",\n  \"data\": {\n    \"name\": \"qx\",\n    \"age\": 20\n  }\n}\n```\n\n```ts\nconst axios = {\n  get<T>(url: string): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      let xhr = new XMLHttpRequest()\n      xhr.open('get', url)\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n          resolve(JSON.parse(xhr.responseText))\n        }\n      }\n      xhr.send(null)\n    })\n  }\n}\n\n// 定义返回的数据类型\ninterface ResData {\n  code: string\n  msg: string\n  data: any\n}\n\naxios.get<ResData>('./data.json').then(res => {\n  console.log(res.data) // {name: 'qx', age: 20}\n})\n```\n\n## 泛型约束keyof\n在<>中使用extends约束泛型的类型范围\n\n```ts\n// function getLegnth<T>(arg:T) {\n//   return arg.length // 类型“T”上不存在属性“length”。\n// }\ninterface Len {\n  length: number\n}\nfunction getLegnth<T extends Len>(arg: T) {\n  return arg.length\n}\n```\n\n`keyof` 可以获取一个对象类型的所有键，作为联合类型\n\n```ts\n// function prop<T>(obj: T, key: string) {\n//   return obj[key] // 元素隐式具有 \"any\" 类型，因为类型为 \"string\" 的表达式不能用于索引类型 \"unknown\"。\n// }\nfunction prop<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key]\n}\nlet o = { a: 1, b: 2, c: 3 }\nprop(o, 'a') \n// prop(o, 'd') // 类型“\"d\"”的参数不能赋给类型“\"a\" | \"b\" | \"c\"”的参数\n```\n\n更灵活的用法：\n\n```ts\ninterface Info {\n  name: string\n  age: number\n}\ntype InfoOptions<T extends object> = {\n  [Key in keyof T]?: T[Key]\n}\ntype BB = InfoOptions<Info>\n// type BB = {\n//   name?: string | undefined;\n//   age?: number | undefined;\n// }\n```\n\n# tsconfig.json\n`tsconfig.json` 是TS的配置文件，通过 `tsc --init` 生成\n\n配置详解：\n\n```json\n{\n  \"compilerOptions\": {\n    \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n    \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n    \"diagnostics\": true, // 打印诊断信息 \n    \"target\": \"ES5\", // 目标语言的版本\n    \"module\": \"CommonJS\", // 生成代码的模板标准\n    // \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n    \"lib\": [\n      \"DOM\",\n      \"ES5\",\n      \"ES6\",\n    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n    \"allowJs\": true, // 允许编译器编译JS，JSX文件\n    \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n    \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n    \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n    // \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n    \"sourceMap\": true, // 生成目标文件的sourceMap文件\n    // \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n    \"declarationMap\": true, // 为声明文件生成sourceMap\n    \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n    \"types\": [], // 加载的声明文件包\n    \"removeComments\": true, // 删除注释 \n    \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n    \"noEmitOnError\": true, // 发送错误时不输出任何文件\n    \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n    \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n    \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n    \"strict\": true, // 开启所有严格的类型检查\n    \"alwaysStrict\": true, // 在代码中注入'use strict'\n    \"noImplicitAny\": true, // 不允许隐式的any类型\n    \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n    \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n    \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n    \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n    \"noImplicitThis\": true, // 不允许this有隐式的any类型\n    \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n    \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n    \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n    \"noImplicitReturns\": true, //每个分支都会有返回值\n    \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n    \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n    \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { // 路径映射，相对于baseUrl\n      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      // \"jquery\": [\n      //   \"node_modules/jquery/dist/jquery.min.js\"\n      // ],\n      \"@/*\":[\n        \"./\"\n      ]\n    },\n    \"rootDirs\": [\n      \"src\",\n      \"out\"\n    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n    \"listEmittedFiles\": true, // 打印输出文件\n    \"listFiles\": true // 打印编译的文件(包括引用的声明文件)\n  },\n  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n  // \"include\": [\n  //   \"src/**/*\"\n  // ],\n  // 指定一个排除列表（include的反向操作）\n  // \"exclude\": [\n  //   \"demo.ts\"\n  // ],\n  // 指定哪些文件使用该配置（属于手动一个个指定文件）\n  // \"files\": [\n  //   \"demo.ts\"\n  // ]\n}\n```\n\n# 命名空间\n`namespace` 定义命名空间，内部成员默认私有，通过 `export` 暴露\n\n**作用：**组织代码，避免命名冲突\n\n```ts\nnamespace A {\n  // export暴露命名空间内部成员\n  export const B = 123;\n  // 默认是命名空间私有成员\n  const C = 456;\n  // 可以嵌套使用\n  export namespace AA {\n    export const BB = B + C;\n  }\n}\nconsole.log(A.B); // 123\nconsole.log(A.AA.BB); // 579\n// 同名命名空间自动合并成员\nnamespace A {\n  export const D = 678;\n}\nconsole.log(A.D); // 678\n// 简化命名空间\nimport X = A.AA;\nconsole.log(X.BB); // 579\n```\n\n# 三斜线指令\n[三斜线指令](https://www.tslang.cn/docs/handbook/triple-slash-directives.html)是包含单个XML标签的单行注释。注释的内容会做为编译器指令使用。\n\nTS3.0后建议用import\n\n`<reference path=\"...\" />` 类似import，导入依赖，但无需export先暴露\n\n```ts\n///<reference path=\"./1.ts\" />\n///<reference path=\"./2.ts\" />\nconsole.log(X1.A, X2.A);\n```\n\n`<reference types=\"node\" />` 声明文件引入，表明这个文件使用了 `@types/node/index.d.ts` 里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。\n\n# 声明文件d.ts\n`.d.ts` (declare)，TS的声明文件。对于第三方纯js库，通过d.ts可以获得完整的TS静态类型检查、提示、补全等功能\n\n```ts\ndeclare var // 声明全局变量\ndeclare function // 声明全局方法\ndeclare class // 声明全局类\ndeclare enum // 声明全局枚举类型\ndeclare namespace // 声明（含有子属性的）全局对象\ninterface 和 type // 声明全局类型\n/// <reference /> 三斜线指令\n```\n\nTS会解析项目中所有的 *.ts 文件，当然也包含 .d.ts，注意 files、include 和 exclude 配置\n\nTS2.0后，还会默认的查看 `node_modules/@types` 文件夹，用于为 TypeScript 提供有关用 JavaScript 编写的 API(第三方库) 的类型信息\n\n热门的JS第三方库通常社区已经维护了其声明文件，安装：`npm i @types/<包名> -D`\n\n部分库如axios，已经在package.json中指定了声明文件\n\n```json\n{\n  \"types\": \"index.d.ts\",\n}\n```\n\n对于社区没有维护声明文件的第三方库，就需要通过`declare module`语法自己写了，[declare关键字](https://wangdoc.com/typescript/declare)\n\n以express为例：\n\n```ts\nimport express from 'express'\nconst app = express()\nconst router = express.Router()\napp.use('/api', router)\nrouter.get('/list', (req, res) => {\n  res.json({\n      code: 200\n  })\n})\napp.listen(9001,()=>{\n  console.log(9001)\n})\n\n// express.d.ts\ndeclare module 'express' {\n  interface Router {\n    get(path: string, cb: (req: any, res: any) => void): void\n  }\n  interface App {\n    use(path: string, router: any): void\n    listen(port: number, cb?: () => void): void\n  }\n  interface Express {\n    (): App\n    Router(): Router\n  }\n  const express: Express\n  export default express\n}\n```\n\n也可以为项目中常用的类型编写一个声明文件，声明语句中只能定义类型，不能在声明语句中定义具体的实现\n\n```ts\nconst num: ref<number> = {\n  value: 0,\n}\nx = 1;\n```\n\n```ts index.d.ts\ndeclare type ref<T> = {\n  value: T\n}\ndeclare let x:number;\n```\n\n# Mixins混入\n对象的混入：`Object.assign` 合并多个对象\n\n```ts\ninterface Name {\n  name: string\n}\ninterface Age {\n  age: number\n}\ninterface Sex {\n  sex: number\n}\n \nlet people1: Name = { name: \"chuckle\" }\nlet people2: Age = { age: 20 }\nlet people3: Sex = { sex: 1 }\n \n// 推断为交叉类型const people: Name & Age & Sex\nconst people = Object.assign(people1,people2,people3)\n```\n\n类方法的混入：\n\nTS并没有Mixins关键字，实现类的混入需要用赋值断言、写混入函数\n\n```ts\nclass O1 {\n  name!: string;\n  getName(): void {\n    console.log(this.name);\n  }\n}\n\nclass O2 {\n  age!: number;\n  getAge(): void {\n    console.log(this.age);\n  }\n}\n\nclass O3 implements O1, O2 {\n  // O1\n  name: string = 'chuckle';\n  getName!: () => void // 待混入的方法\n  // O2\n  age: number = 20;\n  getAge!: () => void // 待混入的方法\n}\n\napplyMixins(O3, [O1, O2]);\nlet smartObj = new O3();\nsmartObj.getName();\nsmartObj.getAge();\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    console.log(baseCtor.prototype);\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      // 挂载到原型上\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\n    });\n  });\n}\n```\n\n相较于继承，这样混入使得只有类方法被“继承”\n\n# 装饰器\n装饰器就是一个函数，可以注入到类、方法、属性、参数，对象上，扩展其功能，增加了代码的可读性，清晰地表达了意图。\n\n这是一个实验性的功能，虽然[TS5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)后已经正式推出\n\n```json tsconfig.json\n// 允许普通装饰器\n\"experimentalDecorators\": true,\n```\n\n## 类装饰器\n类装饰器`ClassDecorator`应用于类构造函数，可以用来监视，修改或替换类定义\n\n```ts\ntype ClassDecorator = <TFunction extends Function>(\n  target: TFunction // 类的构造函数(也就是类本身)作为其唯一的参数\n) => TFunction | void;\n```\n\n通过装饰器给类添加属性和方法：\n\n```ts\nconst Base: ClassDecorator = (target: Function) => {\n  console.log(target); // [class CLS]\n  target.prototype.fn = () => {\n    console.log(\"chuckle\");\n  }\n}\n\n@Base\nclass CLS { }\n\nconst cls = new CLS() as any;\ncls.fn() // chuckle\n```\n\n### 返回值\n如果类装饰器返回一个值，它会使用提供的构造函数(类)来替换类的声明。并且必须保证能覆盖原来类的属性和方法，所以通常继承原来的类。\n\n```ts\nfunction classDecorator<T extends { new(...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    newProperty = \"new property\";\n    hello = \"override\";\n  }\n}\n\n@classDecorator\nclass Greeter {\n  property = \"property\";\n  hello: string;\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\nconst greeter = new Greeter(\"world\");\nconsole.log(greeter);\n// Greeter {\n//   property: 'property',\n//   hello: 'override',\n//   newProperty: 'new property'\n// }\n```\n\n注意，应该返回一个匿名类，否则实例前面的类型提示是返回的类名，而不是原来的类名，这容易造成误解\n\n```js\nlet a: any = null;\nfunction classDecorator<T extends { new(...args: any[]): {} }>(constructor: T) {\n  class A extends constructor {\n    newProperty = \"new property\";\n    hello = \"override\";\n  }\n  a =\tA;\n  return  A\n}\n\n@classDecorator\nclass Greeter {\n  property = \"property\";\n  hello: string;\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\nconst greeter = new Greeter(\"world\");\nconsole.log(greeter);\n// A {\n//   property: 'property',\n//   hello: 'override',\n//   newProperty: 'new property'\n// }\n// 实际上并没有发生继承，装饰器返回的类直接覆盖了原来的类的声明，现在的 Greeter 和 A 指的都是同一个类\nconsole.log(a === Greeter); // true\n```\n\n## 装饰器工厂\n装饰器工厂是一个高阶函数（函数柯里化），外层的函数接受值，里层的函数最终接受类的构造函数\n\n```ts\nconst Base = (name: string) => {\n  const fn: ClassDecorator = (target: Function) => {\n    console.log(target); // [class CLS]\n    target.prototype.name = name;\n    target.prototype.fn = () => {\n      console.log(name);\n    }\n  }\n  return fn;\n}\n\n@Base(\"chuckle\")\nclass CLS {\n  constructor() {\n\n  }\n}\nconst cls = new CLS() as any;\ncls.fn() // chuckle\n```\n\n## 方法装饰器\n方法装饰器`MethodDecorator`应用到方法的属性描述符上，用来监视，修改或者替换方法定义\n\n```ts\ntype MethodDecorator = <T>(\n  target: Object, // 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n  propertyKey: string | symbol, // 成员的名字(函数名)\n  descriptor: TypedPropertyDescriptor<T> // 成员的属性描述符\n) => TypedPropertyDescriptor<T> | void; // 如果返回一个值，会被用作方法的属性描述符。\n```\n\n```ts\nconst met:MethodDecorator = (...args) => {\n  console.log(args);\n  // [\n  //   {},\n  //   'getName',\n  //   {\n  //     value: [Function: getName], // 原方法\n  //     writable: true, // 可写\n  //     enumerable: false, // 不可枚举\n  //     configurable: true // 可配置\n  //   }\n  // ]\n}\nclass A {\n  @met\n  getName ():string {\n      return 'chuckle'\n  }\n}\nconst a = new A();\n```\n\n实现对原方法的拦截加工：\n\n```ts\nfunction MethodInterceptor(params?: string): MethodDecorator {\n  return (target: Object, name: string | symbol, decr: PropertyDescriptor) => {\n    let temp = decr.value; // 保存原方法\n    // 拦截加工原方法，不能是箭头函数, 否则 this 指向不是类的实例\n    decr.value = function (...args: any) {\n      console.log('前置拦截');\n      console.log(this); // CLS { name: 'chuckle' }\n      temp.call(this, ...args) // 调用原方法\n      console.log('后置拦截');\n    }\n  }\n}\nclass CLS {\n  name = 'chuckle'\n\n  @MethodInterceptor(\"chuckle\")\n  fn(...args: any) {\n    console.log(args); // [ 1, 2, 3 ]\n  }\n}\nlet cls = new CLS()\ncls.fn(1, 2, 3)\n// 前置拦截\n// CLS {}\n// [ 1, 2, 3 ]\n// 后置拦截\n```\n\n### 实现GET装饰器\n请求通过装饰器工厂传入的url，将返回的数据传给原方法\n\n```ts\nfunction GET(url: string): MethodDecorator {\n  return (target: Object, name: string | symbol, decr: PropertyDescriptor) => {\n    const fnc = decr.value; // 保存原方法\n    fetch(url).then(res => res.json())\n      .then(data => {\n        fnc({\n          code: 200,\n          msg: 'success',\n          data\n        }) // 调用原方法\n      }).catch(err => {\n        fnc({\n          code: 500,\n          msg: err,\n          data: null\n        })\n      })\n  }\n}\nclass CLS {\n  @GET('https://api.github.com/')\n  fn(result: any) {\n    console.log(result.code); // 200\n    console.log(result.msg); // success\n    console.log(result.data); // { current_user_url: ..... }\n  }\n}\nconst cls = new CLS();\n```\n\n## 参数装饰器\n参数装饰器应用于类构造函数或方法声明，没有返回值。用来监视一个方法的参数是否被传入。\n\n```ts\ntype ParameterDecorator = (\n  target: Object, // 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n  propertyKey: string | symbol | undefined, // 成员的名字（函数名） \n  parameterIndex: number // 参数在函数参数列表中的索引\n) => void;\n```\n\n```ts\nconst currency: ParameterDecorator = (\n  target: Object,\n  key: string | symbol | undefined,\n  index: number\n) => {\n  console.log(target === CLS.prototype) // true\n  console.log(target, key, index)\n  // {} setName 0\n}\n\nclass CLS {\n  name = 'chuckle'\n  setName(@currency name: string) {\n    this.name = name\n  }\n}\n```\n\n## 属性装饰器\n属性装饰器应用较少，用来监视类中是否声明了某个名字的属性。\n\n```ts\ntype PropertyDecorator = (\n  target: Object, // 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n  propertyKey: string | symbol // 成员的名字(属性名)\n) => void;\n```\n\n```ts\nconst met: PropertyDecorator = (target: Object, key: string | symbol) => {\n  console.log(target, key); // {} name\n}\n\nclass CLS {\n  @met\n  name = 'chuckle'\n}\n```\n\n## 顺序\n多个同类型装饰器可以同时应用到一个声明上\n\n```ts\n// 书写在同一行上：\n@f @g x\n// 书写在多行上：\n@f\n@g\nx\n```\n\n求值方式与复合函数相似。复合的结果(f ∘ g)(x)等同于f(g(x))。\n\n当多个装饰器应用在一个声明上时会进行如下步骤的操作：\n1. 由上至下依次对装饰器表达式求值。\n2. 求值的结果会被当作函数，由下至上依次调用（应用）。\n\n### 装饰器求值\n类中不同声明上的装饰器将按以下规定的顺序应用：\n1. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。\n2. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。\n3. 参数装饰器应用到构造函数。\n4. 类装饰器应用到类。\n\n方法参数装饰器执行的优先级最高，而方法和属性装饰器受到定义顺序的影响。类与构造器参数装饰器优先级最低。\n\n# 元数据\n对象、类等都是数据，它们描述了某种数据，而**描述这些数据的数据就是元数据**\n\n[reflect-metadata](https://www.npmjs.com/package/reflect-metadata) 库通过添加对元数据的支持，使得装饰器能够更方便地访问和修改类和方法的元数据，也许还会提示安装tslib\n\n安装：`npm i reflect-metadata tslib`\n\n```ts 引入，扩展了全局API Reflect\nimport 'reflect-metadata'\n```\n\n在装饰器中可以拿到类、方法、访问符、属性、参数的基本信息，如名称，描述符等。获取更多信息就需要元数据。\n\n在编译过程中产生的元数据是非常重要的信息，在 nestjs 框架中 DI 和 IOC 的实现就依赖了他们。\n\n参考：\n[深入浅出Typescript装饰器](https://zhuanlan.zhihu.com/p/617505961)\n[TS 装饰器(2): 元数据](https://zhuanlan.zhihu.com/p/480376523)\n\n## 定义/获取元数据\n`Reflect.defineMetadata()`定义元数据：给对象、类等数据附加额外的描述信息，但又不会影响到数据本身。\n`Reflect.getMetadata()` 获取元数据。\n\n```ts\n// 为类或对象定义元数据\nReflect.defineMetadata(key, value, classObject)\n// 为classPrototype[methodName]方法定义元数据\nReflect.defineMetadata(key, value, classPrototype, methodName)\n// 为classPrototype[propKey]属性定义元数据\nReflect.defineMetadata(key, value, classPrototype, propKey)\n// 获取元数据\nReflect.getMetadata(metadataKey, target, propertyKey?)\n```\n\n前两个参数分别是元数据的key和value，**都是any类型**，后面的参数设定了要将元数据定义给谁。\n\n```ts\nconst obj = { \n  name: 'chuckle',\n  fn(){\n    console.log(this.name);\n  }\n}\n// 定义在obj对象上\nReflect.defineMetadata('testKey1', 'testValue1', obj)\n// 定义在obj对象的name属性上\nReflect.defineMetadata('testKey2', 'testValue2', obj, 'name')\n// 定义在obj对象的fn方法上\nReflect.defineMetadata('testKey3', 'testValue3', obj, 'fn')\n\n// 获取obj对象上的元数据\nconsole.log(Reflect.getMetadata('testKey1', obj)) // testValue2\n// 获取obj对象的name属性上的元数据\nconsole.log(Reflect.getMetadata('testKey2', obj, 'name')) // testValue2\n// 获取obj对象的fn方法上的元数据\nconsole.log(Reflect.getMetadata('testKey3', obj, 'fn')) // testValue3\n\n// 不存在的元数据，返回undefined\nconsole.log(Reflect.getMetadata('test', obj)) // undefined\n```\n\n元数据可以定义在不存在的对象成员上，并且能正常获取\n\n```ts\nconst obj = {}\nReflect.defineMetadata('testKey', 'testValue', obj, 'name')\nconsole.log(Reflect.getMetadata('testKey', obj, 'name')) // testValue\n```\n\n### 在类中定义\n`Reflect.defineMetadata`多给普通对象定义元数据\n\n类使用 `@Reflect.metadata` 元数据装饰器，更方便地定义元数据，参数只有key和value\n\n类元数据直接定义在类的构造函数上，而类成员的元数据定义在原型对象对应的属性上（无论实际上是否存在该属性），实例也会被赋予类成员元数据的副本\n\n```ts\n@Reflect.metadata('testKey1', 'testValue1')\nclass CLS {\n\n  @Reflect.metadata('testKey2', 'testValue2')\n  name = 'chuckle'\n\n  @Reflect.metadata('testKey3', 'testValue3')\n  fn() {\n    console.log(this.name);\n  }\n}\nconst cls = new CLS();\nconsole.log(Reflect.getMetadata('testKey1', CLS)) // testValue1\nconsole.log(Reflect.getMetadata('testKey2', CLS.prototype, 'name')) // testValue2\nconsole.log(Reflect.getMetadata('testKey3', CLS.prototype, 'fn')) // testValue3\n// 实例也会被赋予类成员的元数据的副本\nconsole.log(Reflect.getMetadata('testKey2', cls, 'name')) // testValue2\n```\n\n## 其它方法\n**Reflect**还有一些方法\n1. `hasMetadata` 判断指定目标是否存在指定key的元数据\n2. `hasOwnMetadata` 判断指定目标是否存在指定key的元数据\n3. `getMetadataKeys` 获取指定目标的所有的元数据key组成的数组，包括其父类的元数据key\n4. `getOwnMetadataKeys` 获取指定目标自身的所有的元数据key组成的数组，不包括其父类的元数据key\n\n```ts\n@Reflect.metadata('key1', 'value1')\nclass Parent{ }\n@Reflect.metadata('key2', 'value2')\nclass Child extends Parent{ }\n\nconsole.log(Reflect.getMetadataKeys(Child)) // [ 'key2', 'key1' ]\nconsole.log(Reflect.getOwnMetadataKeys(Child)) // [ 'key2' ]\n\nconsole.log(Reflect.hasMetadata('key1', Child)) // true\nconsole.log(Reflect.hasOwnMetadata('key1', Child)) // false\n```\n\n## 内置元数据\n开启`emitDecoratorMetadata`配置，TS 会在编译后自动给类和类成员添加如下元数据:\n1. `design:type`：被装饰目标的类型\n  - 成员属性：属性的标注类型\n  - 成员方法：Function 类型\n2. `design:paramtypes`: 被装饰目标的参数类型\n  - 成员方法：方法形参列表的标注类型\n  - 类：构造函数形参列表的标注类型\n3. `design:returntype`\n  - 成员方法：函数返回值的标注类型\n\n```json tsconfig.json\n// 允许自动添加内置元数据\n\"emitDecoratorMetadata\": true,  \n```\n\n**注意：**\n1. 只有你已经给目标添加了元数据，TS才会自动为这些目标添加内置元数据。\n2. 标注类型，即在代码中显式标注参数、返回值、属性等的类型，而不能靠自动推断。\n\n通过 `design:paramtypes` 可以获取到方法中有多少个参数，每个参数的类型等信息\n\n```ts\n@Reflect.metadata('key', 'value')\nclass People {\n  @Reflect.metadata('key', 'value')\n  name: string\n\n  constructor(name: string, age: number) {\n    this.name = name\n  }\n\n  @Reflect.metadata('key', 'value')\n  setName(name: string): string{\n    this.name = name\n    return this.name\n  }\n}\n// 获取标注的参数信息\nconsole.log(Reflect.getMetadata('design:paramtypes', People))\n// [ [Function: String], [Function: Number] ]\nconsole.log(Reflect.getMetadata('design:paramtypes', People.prototype, 'setName'))\n// [ [Function: String] ]\n\n// 获取标注的返回值信息\nconsole.log(Reflect.getMetadata('design:returntype', People.prototype, 'setName'))\n// [Function: String]\n\n// 获取标注的属性类型\nconsole.log(Reflect.getMetadata('design:type', People.prototype, 'name'))\n// [Function: String]\n```\n\n总之就是将你在代码中显式标注的类型信息，转为对应元数据定义在对应的类或类成员上\n\n## 元数据的继承\n元数据可以很好的适配于类之间的继承关系，父类会将其元数据的副本赋予子类，包括类本身和类成员的元数据\n\n```ts\nclass Parent {\n  @Reflect.metadata('aa', 'aa')\n  aa = 1\n}\nclass Child extends Parent { }\nconsole.log(Reflect.getMetadataKeys(Child.prototype, 'aa'))\n// [ 'design:type', 'aa' ]\n```\n\n# 搭建TS环境\n使用Rollup、Webpack等打包构建工具开发TS项目\n\n## Rollup\n详见：[Rollup#配置TS环境](/article/d9966eb3.html#配置TS环境)\n\n```json 我的tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n    \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n    \"diagnostics\": true, // 打印诊断信息 \n    \"target\": \"esnext\", /* 指定 ECMAScript 目标版本：'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */\n    \"module\": \"esnext\", /* 输出的代码使用什么方式进行模块化： 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    \"lib\": [ /* 指定引用的标准库 */\n      \"esnext\",\n      \"dom\",\n      \"dom.iterable\",\n    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n    \"allowJs\": true, // 允许编译器编译JS，JSX文件\n    \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n    \"outDir\": \"./dist\", // 指定输出目录\n    \"rootDir\": \"./src\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n    \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n    \"declarationDir\": \"./dist/typings\", // 指定生成声明文件存放目录\n    // \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n    \"sourceMap\": false, // 生成目标文件的sourceMap文件\n    // \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n    \"declarationMap\": false, // 为声明文件生成sourceMap\n    // \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n    \"types\": [], // 加载的声明文件包\n    \"removeComments\": true, // 删除注释 \n    \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n    \"noEmitOnError\": true, // 发送错误时不输出任何文件\n    \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n    \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n    \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n    \"strict\": true, // 开启所有严格的类型检查\n    \"alwaysStrict\": true, // 在代码中注入'use strict'\n    \"noImplicitAny\": true, // 不允许隐式的any类型\n    \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n    \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n    \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n    \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n    \"noImplicitThis\": true, // 不允许this有隐式的any类型\n    \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n    \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n    \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n    \"noImplicitReturns\": true, //每个分支都会有返回值\n    \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n    \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n    \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { // 路径映射，相对于baseUrl\n      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      // \"jquery\": [\n      //   \"node_modules/jquery/dist/jquery.min.js\"\n      // ],\n      \"@/*\": [\n        \"src/*\"\n      ]\n    },\n    \"rootDirs\": [\n      \"src\"\n    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n    \"listEmittedFiles\": true, // 打印输出文件\n    \"listFiles\": true, // 打印编译的文件(包括引用的声明文件)\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"resolveJsonModule\": true\n  },\n  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\n  \"include\": [\n    \"src/**/*\",\n  ],\n  // 指定一个排除列表（include的反向操作）\n  // \"exclude\": [\n  //   \"demo.ts\"\n  // ],\n  // 指定哪些文件使用该配置（属于手动一个个指定文件）\n  // \"files\": [\n  //   \"demo.ts\"\n  // ]\n}\n```\n\n## Webpack \n详见：[Webpack#配置TS环境](/article/764f33bc.html#配置TS环境)\n\n## esbuild+swc\n\n安装：`npm i @swc/core esbuild @swc/helpers -D`\n\n**@swc/core** 是 swc 的核心包，用于编译 JavaScript 和 TypeScript 代码；**esbuild** 是一个快速的 JavaScript 和 TypeScript 构建工具；**@swc/helpers** 是 swc 的辅助包，用于转换 JSX 代码\n\n运行：node ./config.mjs\n\n```js config.mjs\nimport esbuild from 'esbuild'//打包工具\nimport swc from '@swc/core'//类似于babel es6 转 es5\nimport fs from 'node:fs'\nesbuild.build({\n  entryPoints: ['./src/index.ts'], //入口文件\n  bundle: true, //模块单独打包\n  loader: {\n    '.js': 'js',\n    '.ts': 'ts',\n    '.jsx': 'jsx',\n    '.tsx': 'tsx',\n  },\n  treeShaking:true,\n  define: {\n    'process.env.NODE_ENV': '\"production\"',\n  },\n  plugins: [\n    {\n      //实现自定义loader\n      name: \"swc-loader\",\n      setup(build) {\n        build.onLoad({ filter: /\\.(js|ts|tsx|jsx)$/ }, (args) => {\n          // console.log(args);\n          const content = fs.readFileSync(args.path, \"utf-8\")\n          const { code } = swc.transformSync(content, {\n            filename: args.path\n          })\n          return {\n            contents: code\n          }\n        })\n      },\n    }\n  ],\n  outdir: \"dist\"\n})\n```\n\n# 实战\n写一些小玩意练练手\n\n## 封装LocalStorage\n实验 Rollup + TS 封装一个支持过期时间的LocalStorage\n\n```ts src/enum/index.ts\n// 字典\nexport enum Dictionaries {\n  // 过期时间key\n  expire = '__expire__',\n  // 永不过期\n  permanent = 'permanent'\n}\n```\n\n```ts src/types/index.ts\nimport { Dictionaries } from \"../enum\";\nexport type Key = string // key类型\n// 永不过期 | 过期时间的时间戳\nexport type expire = Dictionaries.permanent | number\n// LocalStorage数据结构\nexport interface Data<T> {\n  value: T,\n  [Dictionaries.expire]: expire\n}\n// 获取LocalStorage结果\nexport interface Result<T> {\n  message: string,\n  value: T | null\n}\n// 定义封装LocalStorage类\nexport interface StorageCls {\n  set: <T>(key: Key, value: T, expire: expire) => void\n  get: <T>(key: Key) => Result<T | null>\n  remove: (key: Key) => void\n  clear: () => void\n}\n```\n\n```ts src/index.ts\nimport { Dictionaries } from \"./enum\";\nimport { Key, Result, StorageCls, expire, Data } from \"./types\";\n\nclass LLS implements StorageCls {\n  set<T = any>(key: Key, value: T, expire: expire): void {\n    const data: Data<T> = {\n      value,\n      [Dictionaries.expire]: expire\n    }\n    localStorage.setItem(key, JSON.stringify(data))\n  }\n\n  get<T = any>(key: Key): Result<T | null> {\n    const data: Data<T> | null = JSON.parse(localStorage.getItem(key) || 'null')\n    const result: Result<T | null> = {\n      message: \"\",\n      value: null\n    }\n    if (data === null) {\n      result.message = `找不到${key}`\n    } else if (this.isOverdue(data[Dictionaries.expire])) {\n      result.message = `${key}已过期`\n      this.remove(key)\n    } else {\n      result.message = `获取${key}成功`\n      result.value = data.value\n    }\n    return result\n  }\n\n  remove(key: string): void {\n    localStorage.removeItem(key)\n  }\n\n  clear(): void {\n    localStorage.clear()\n  }\n\n  private isOverdue(expire: expire): boolean {\n    const now = new Date().getTime()\n    if (expire === Dictionaries.permanent) {\n      return false\n    } else if (typeof expire === 'number') {\n      return expire < now ? true : false\n    }\n    return false\n  }\n}\n\n// 测试代码\nconst sl = new LLS()\n// 5s后过期\nsl.set<number>('a', 123, new Date().getTime() + 5000)\nsetInterval(() => {\n  const a = sl.get<number>('a')\n  console.log(a)\n}, 500)\n```\n\n## 发布订阅模式\n实现个类似addEventListener、Vue evnetBus的发布订阅模式Demo\n\n一个消息可以挂载多个订阅方法\n\n```ts\n// 订阅方法\ninterface EventFun {\n  (...args: any[]): any\n}\ninterface EventCls {\n  // 订阅消息\n  on(name: string, callback: EventFun): void\n  // 发布消息\n  emit(name: string, ...args: any[]): void\n  // 取消订阅\n  off(name: string, fn: EventFun): void\n  // 只订阅一次\n  once(name: string, fn: EventFun): void\n}\ntype CallbackArr = Array<EventFun>\n// 保存所有消息\ninterface EventList {\n  // 消息名:订阅的方法集合\n  [key: string]: CallbackArr,\n}\nclass SubPub implements EventCls {\n  list: EventList\n  constructor() {\n    this.list = {}\n  }\n  on(name: string, callback: EventFun) {\n    const callbackList: CallbackArr = this.list[name] || [];\n    callbackList.push(callback)\n    this.list[name] = callbackList\n  }\n  emit(name: string, ...args: any[]) {\n    const callbackList: CallbackArr = this.list[name]\n    if (callbackList) {\n      if (callbackList.length <= 0) {\n        console.warn(\"该消息没有订阅者\")\n        return;\n      }\n      callbackList.forEach(callback => {\n        callback.apply(this, args)\n      })\n    } else {\n      console.warn(\"没有该消息\")\n    }\n  }\n  off(name: string, fn: EventFun) {\n    const callbackList: CallbackArr = this.list[name]\n    if (callbackList) {\n      if (callbackList.length <= 0) {\n        console.warn(\"该消息没有订阅者\")\n        return;\n      }\n      const index = callbackList.findIndex(fns => fns === fn)\n      index > -1 ? callbackList.splice(index, 1) : null\n    } else {\n      console.warn(\"没有该消息\")\n    }\n  }\n  once(name: string, fn: EventFun) {\n    const decor: EventFun = (...args) => {\n      fn.apply(this, args)\n      this.off(name, decor)\n    }\n    this.on(name, decor)\n  }\n}\n```\n\n测试：\n\n```ts\nconst subPub = new SubPub()\n// 测试on和off\nsubPub.emit('abc', 678) // 没有该消息\nconst fn: EventFun = (...arg) => {\n  console.log(arg);\n}\nsubPub.on('abc', fn)\nsubPub.emit('abc', 131, true) // [ 131, true ]\nsubPub.emit('abc', 678, false, 'qx') // [ 678, false, 'qx' ]\nsubPub.off('abc', fn)\nsubPub.emit('abc', 321, 'qx') // 该消息没有订阅者\nconsole.log(\"=======================\");\n// 测试once\nsubPub.emit('a', 678) // 没有该消息\nsubPub.once('a', (...arg) => {\n  console.log(arg);\n})\nsubPub.emit('a', 678, 'abc') // [ 678, 'abc' ]\nsubPub.emit('a', 123, 'qx') // 该消息没有订阅者\nsubPub.on('a', (...arg) => {\n  console.log(arg);\n})\nsubPub.emit('a', 123, 'qx') // [ 123, 'qx' ]\n```\n\n# Proxy、Reflect\nProxy(代理)和Reflect(反射)是ES6为了操作对象而提供的新API，它们为开发者提供了对对象行为进行拦截和自定义的能力\n\nProxy和Reflect都有13个名字和参数一模一样的方法，因为对象的操作无非就get、set等\n\nES6推荐用Proxy去代理对对象的操作，用Reflect实现对对象的实际操作\n\n## 基本操作\n**Proxy基本操作：**\n\n```ts\n/**\n * @interface ProxyHandler\n * @template T - 泛型，代表被代理对象的类型\n */\ninterface ProxyHandler<T extends object> {\n  /**\n   * 1、用于拦截函数调用操作。\n   *\n   * @param {T} target - 被代理的原始可调用对象。\n   * @param {*} thisArg - 函数调用时的原始 this 上下文。\n   * @param {Array} argArray - 传递给函数调用的参数数组。\n   * @returns {*} 函数调用的结果。\n   */\n  apply?(target: T, thisArg: any, argArray: any[]): any;\n\n  /**\n   * 2、用于拦截 `new` 操作符，即构造函数的调用。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {Array} argArray - 传递给构造函数的参数数组。\n   * @param {Function} newTarget - 最初调用的构造函数。\n   * @returns {object} 构造函数调用的结果。\n   */\n  construct?(target: T, argArray: any[], newTarget: Function): object;\n\n  /**\n   * 3、用于拦截 `Object.defineProperty()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} property - 要定义或修改的属性的名称或 `Symbol`。\n   * @param {PropertyDescriptor} attributes - 属性的描述符。\n   * @returns {boolean} 一个布尔值，指示属性是否成功定义或修改。\n   */\n  defineProperty?(target: T, property: string | symbol, attributes: PropertyDescriptor): boolean;\n\n  /**\n   * 4、用于拦截 `delete` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} p - 要删除的属性的名称或 `Symbol`。\n   * @returns {boolean} 一个布尔值，指示属性是否成功删除。\n   */\n  deleteProperty?(target: T, p: string | symbol): boolean;\n\n  /**\n   * 5、用于拦截属性值的获取操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} p - 要获取的属性的名称或 `Symbol`。\n   * @param {*} receiver - 代理或从代理继承的对象。\n   * @returns {*} 属性的值。\n   */\n  get?(target: T, p: string | symbol, receiver: any): any;\n\n  /**\n   * 6、用于拦截 `Object.getOwnPropertyDescriptor()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} p - 要获取属性描述符的属性的名称或 `Symbol`。\n   * @returns {PropertyDescriptor | undefined} 属性的描述符或 `undefined`。\n   */\n  getOwnPropertyDescriptor?(target: T, p: string | symbol): PropertyDescriptor | undefined;\n\n  /**\n   * 7、用于拦截 `[[GetPrototypeOf]]` 内部方法。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @returns {object | null} 对象的原型或 `null`。\n   */\n  getPrototypeOf?(target: T): object | null;\n\n  /**\n   * 8、用于拦截 `in` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} p - 要检查存在性的属性的名称或 `Symbol`。\n   * @returns {boolean} 一个布尔值，指示属性是否存在。\n   */\n  has?(target: T, p: string | symbol): boolean;\n\n  /**\n   * 9、用于拦截 `Object.isExtensible()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @returns {boolean} 一个布尔值，指示对象是否可扩展。\n   */\n  isExtensible?(target: T): boolean;\n\n  /**\n   * 10、用于拦截 `Reflect.ownKeys()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @returns {ArrayLike<string | symbol>} 一个可迭代对象，包含对象自身的所有属性键。\n   */\n  ownKeys?(target: T): ArrayLike<string | symbol>;\n\n  /**\n   * 11、用于拦截 `Object.preventExtensions()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @returns {boolean} 一个布尔值，指示对象是否成功变为不可扩展。\n   */\n  preventExtensions?(target: T): boolean;\n\n  /**\n   * 12、用于拦截属性值的设置操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {string | symbol} p - 要设置的属性的名称或 `Symbol`。\n   * @param {*} newValue - 要设置的新值。\n   * @param {*} receiver - 最初分配操作的对象。\n   * @returns {boolean} 一个布尔值，指示属性是否成功设置。\n   */\n  set?(target: T, p: string | symbol, newValue: any, receiver: any): boolean;\n\n  /**\n   * 13、用于拦截 `Object.setPrototypeOf()` 操作。\n   *\n   * @param {T} target - 被代理的原始对象。\n   * @param {object | null} v - 对象的新原型或 `null`。\n   * @returns {boolean} 一个布尔值，指示是否成功设置对象的原型。\n   */\n  setPrototypeOf?(target: T, v: object | null): boolean;\n}\n```\n\n**Reflect基本操作：**\n\n```ts\ndeclare namespace Reflect {\n  /**\n   * 1、调用具有指定对象作为 this 值和指定数组的元素作为参数的函数。\n   *\n   * @param {Function} target - 要调用的函数。\n   * @param {*} thisArgument - 用作 this 对象的对象。\n   * @param {Array} argumentsList - 传递给函数的参数值的数组。\n   * @returns {*} 函数调用的结果。\n   */\n  function apply<T, A extends readonly any[], R>(\n      target: (this: T, ...args: A) => R,\n      thisArgument: T,\n      argumentsList: Readonly<A>,\n  ): R;\n  function apply(target: Function, thisArgument: any, argumentsList: ArrayLike<any>): any;\n\n  /**\n   * 2、使用指定数组的元素作为参数以及指定的构造函数作为 `new.target` 值构造目标。\n   *\n   * @param {Function} target - 要调用的构造函数。\n   * @param {Array} argumentsList - 传递给构造函数的参数值的数组。\n   * @param {Function} newTarget - 用作 `new.target` 对象的构造函数。\n   * @returns {object} 构造函数调用的结果。\n   */\n  function construct<A extends readonly any[], R>(\n      target: new (...args: A) => R,\n      argumentsList: Readonly<A>,\n      newTarget?: new (...args: any) => any,\n  ): R;\n  function construct(target: Function, argumentsList: ArrayLike<any>, newTarget?: Function): any;\n\n  /**\n   * 3、向对象添加属性或修改现有属性的属性。\n   *\n   * @param {object} target - 要添加或修改属性的对象。这可以是原生 JavaScript 对象\n   *         （即用户定义的对象或内置对象）或 DOM 对象。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @param {PropertyDescriptor & ThisType<any>} attributes - 属性的描述符。可以是数据属性或访问器属性。\n   * @returns {boolean} 一个布尔值，指示属性是否成功定义或修改。\n   */\n  function defineProperty(target: object, propertyKey: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): boolean;\n\n  /**\n   * 4、从对象中删除属性，相当于 `delete target[propertyKey]`，除非 `target[propertyKey]` 是不可配置的，否则不会抛出异常。\n   *\n   * @param {object} target - 从中删除自有属性的对象。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @returns {boolean} 一个布尔值，指示属性是否成功删除。\n   */\n  function deleteProperty(target: object, propertyKey: PropertyKey): boolean;\n\n  /**\n   * 5、获取目标的属性，相当于 `target[propertyKey]` 当 `receiver === target` 时。\n   *\n   * @param {object} target - 包含属性的对象，可以是直接在对象上定义的属性，也可以是原型链中继承的属性。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @param {unknown} receiver - 作为 getter 函数中的 `this` 值使用的引用，\n   *         如果 `target[propertyKey]` 是访问器属性。\n   * @returns {*} 属性的值。\n   */\n  function get<T extends object, P extends PropertyKey>(\n      target: T,\n      propertyKey: P,\n      receiver?: unknown,\n  ): P extends keyof T ? T[P] : any;\n\n  /**\n   * 6、获取指定对象的自有属性描述符。\n   * 自有属性描述符是直接在对象上定义的，而不是从对象的原型继承的描述符。\n   *\n   * @param {object} target - 包含属性的对象。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @returns {TypedPropertyDescriptor<P extends keyof T ? T[P] : any> | undefined}\n   *         属性的描述符或 `undefined`。\n   */\n  function getOwnPropertyDescriptor<T extends object, P extends PropertyKey>(\n      target: T,\n      propertyKey: P,\n  ): TypedPropertyDescriptor<P extends keyof T ? T[P] : any> | undefined;\n\n  /**\n   * 7、返回对象的原型。\n   *\n   * @param {object} target - 引用原型的对象。\n   * @returns {object | null} 对象的原型或 `null`。\n   */\n  function getPrototypeOf(target: object): object | null;\n\n  /**\n   * 8、等效于 `propertyKey in target`。\n   *\n   * @param {object} target - 包含属性的对象，可以是直接在对象上定义的属性，也可以是原型链中继承的属性。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @returns {boolean} 一个布尔值，指示属性是否存在。\n   */\n  function has(target: object, propertyKey: PropertyKey): boolean;\n\n  /**\n   * 9、返回一个值，指示是否可以向对象添加新属性。\n   *\n   * @param {object} target - 要测试的对象。\n   * @returns {boolean} 一个布尔值，指示对象是否可扩展。\n   */\n  function isExtensible(target: object): boolean;\n\n  /**\n   * 10、返回对象的自有字符串和符号键。对象的自有属性是直接在该对象上定义的属性，\n   * 不是从对象的原型继承的属性。\n   *\n   * @param {object} target - 包含自有属性的对象。\n   * @returns {(string | symbol)[]} 包含对象自有的所有属性键的数组。\n   */\n  function ownKeys(target: object): (string | symbol)[];\n\n  /**\n   * 11、防止向对象添加新属性。\n   *\n   * @param {object} target - 要使其不可扩展的对象。\n   * @returns {boolean} 一个布尔值，指示对象是否已成功变为不可扩展。\n   */\n  function preventExtensions(target: object): boolean;\n\n  /**\n   * 12、设置目标的属性，相当于 `target[propertyKey] = value` 当 `receiver === target` 时。\n   *\n   * @param {object} target - 包含属性的对象，可以是直接在对象上定义的属性，也可以是原型链中继承的属性。\n   * @param {PropertyKey} propertyKey - 属性名称。\n   * @param {any} value - 要设置的新值。\n   * @param {any} receiver - 作为 setter 函数中的 `this` 值使用的对象，\n   *        如果 `target[propertyKey]` 是访问器属性。\n   * @returns {boolean} 一个布尔值，指示属性是否成功设置。\n   */\n  function set<T extends object, P extends PropertyKey>(\n      target: T,\n      propertyKey: P,\n      value: P extends keyof T ? T[P] : any,\n      receiver?: any,\n  ): boolean;\n  function set(target: object, propertyKey: PropertyKey, value: any, receiver?: any): boolean;\n\n  /**\n   * 13、设置指定对象的原型为对象 proto 或 null。\n   *\n   * @param {object} target - 要更改其原型的对象。\n   * @param {object | null} proto - 新原型的值，或 `null`。\n   * @returns {boolean} 一个布尔值，指示是否成功设置对象的原型。\n   */\n  function setPrototypeOf(target: object, proto: object | null): boolean;\n}\n```\n\n## 案例\n**判断成年的案例：**\n\n```ts\nlet person = {\n  name: 'chuckle',\n  age: 20,\n}\nlet personProxy = new Proxy(person, {\n  get(target, p, receiver) {\n    if (target.age < 18) {\n      return Reflect.get(target, p, receiver)\n    } else {\n      return '已成年'\n    }\n  }\n})\nconsole.log(personProxy.age) // 已成年\nReflect.set(person, 'age', 16)\nconsole.log(personProxy.age) // 16\n```\n\n**实现简单的响应式Demo：**\n\n```ts\nconst ref = <T extends object>(params: T): T => {\n  return new Proxy(params, {\n    get(target, key, receiver): any {\n      return Reflect.get(target, key, receiver)\n    },\n    set(target, key, value, receiver): boolean {\n      // 获取原来的值\n      const oldValue = Reflect.get(target, key, receiver);\n      // 输出变化，或做一些响应式操作\n      console.log(`set [${String(key)}] from \"${oldValue}\" to \"${value}\"`);\n      // 映射实际操作\n      const result = Reflect.set(target, key, value, receiver);\n      return result;\n    }\n  })\n};\nconst person = ref({\n  name: 'chuckle',\n  age: 20,\n});\nconsole.log(person); // { name: 'chuckle', age: 20 }\nperson.age = 16; // set [age] from \"20\" to \"16\"\n```\n\n# 类型兼容性\n\n\n\n## 协变(鸭子类型)\n**协变:鸭子类型**在程序设计中是动态类型的一种风格。\n在这种风格中，一个物件有效的语义，不是由继承自特定的类或实现特定的接口决定，而是由**当前方法和属性的集合**决定\n\n一只鸟走路像鸭子，游泳也像，做什么都像，那么这只鸟就可以成为鸭子类型。\n\n当子类型中的属性满足父类型就可以进行赋值，即协变不能少可以多\n\n```ts\ninterface Bird {\n  name: string;\n}\ninterface Duck {\n  name: string;\n  say(): void\n}\nlet bird: Bird = {\n  name: '鸟',\n}\nlet duck: Duck = {\n  name: '鸭子',\n  say() {\n    console.log(this.name);\n  }\n}\nbird = duck\n```\n\nDuck类型包含了Bird类型，且比Bird类型更具体，属性更多，从继承角度讲，Duck就是Bird的子类型，而子类型当然可以赋值给父类型，但会抛弃子类型中不属于父类型的多余属性\n\n## 逆变\n逆变同样是子类型赋给父类型，多发生在函数参数上\n\n接收子类型的函数变量不能赋给接收父类型的函数变量\n\n```ts\ninterface Bird {\n  name: string;\n}\ninterface Duck {\n  name: string;\n  say(): void\n}\nlet fnBird = (params: Bird) => {\n  console.log(params.name);\n}\nlet fnDuck = (params: Duck) => {\n  console.log(params.name);\n  params.say();\n}\nfnBird = fnDuck // 错误\n// 不能将类型“(params: Duck) => void”分配给类型“(params: Bird) => void”。\n// 参数“params”和“params” 的类型不兼容。\n// 类型 \"Bird\" 中缺少属性 \"say\"，但类型 \"Duck\" 中需要该属性。\nfnDuck = fnBird // 允许\n```\n\n函数变量发生赋值后，调用`fnBird()`，实际上仍然调用的是`(params: Duck)=>{}`，若是传入`params: Bird`，其成员不足以覆盖`params: Duck`，`params.say()`会报错，所以是不安全的，仍然要符合**不能少可以多**\n\n## 双向协变\n这是一种不安全的类型兼容操作，在TS2.0后需要关闭严格的函数类型检查，来允许函数参数双向协变\n\n```json\n\"compilerOptions\": {\n  \"strictFunctionTypes\": false,\n}\n```\n\n现在函数变量可以自由赋值\n\n```ts\nlet fnBird = (params: Bird) => {\n  console.log(params.name);\n}\nlet fnDuck = (params: Duck) => {\n  console.log(params.name);\n  params.say();\n}\nfnBird = fnDuck // 允许\nfnDuck = fnBird // 允许\n```\n\n因为保存函数的仅仅是一个变量，赋值后到另一个函数变量后调用，再调用的仍然同一个函数，看起来没问题，但若是在赋值后再调用原本的变量调用函数，就会存在问题\n\n```ts\ninterface Bird {\n  name: string;\n}\ninterface Duck {\n  name: string;\n  say(): void\n}\nlet bird: Bird = {\n  name: '鸟',\n}\nlet duck: Duck = {\n  name: '鸭子',\n  say() {\n    console.log(this.name);\n  }\n}\nlet fnBird = (params: Bird) => {\n  console.log(params.name);\n}\nlet fnDuck = (params: Duck) => {\n  console.log(params.name);\n  params.say();\n}\nfnBird = fnDuck\nfnBird(bird) // 运行时报错：params.say is not a function\nfnDuck(duck)\n```\n\nfnBird在经过赋值后，实际的函数是fnDuck，需要的是Duck类型参数，但仍然传入的是Bird类型参数，父类型赋给子类型当然会出错\n\n所以，**不要使用双向协变**，这可能导致运行时的意外错误\n\n# Set,Map\nset和map是ES6新增的引用数据类型，详见：[ES6查缺补漏](/article/383b041f.html#Map对象)\n\nSet类似于数组，但自动去重\n\n```ts\nconst arr: number[] = [1, 2, 3, 3, 2, 1];\nconst set: Set<number> = new Set(arr);\nset.add(4);\nconsole.log(set); // Set(4) { 1, 2, 3, 4 } 自动去重\nset.delete(4);\nconsole.log(set); // Set(3) { 1, 2, 3 }\nconsole.log(set.has(4)); // false\n```\n\nMap类似对象，但键可以是任意类型\n\n```ts\nconst arr: [any, any][] = [\n  ['x', 1],\n  ['y', 2],\n]\nconst map: Map<any, any> = new Map(arr);\nconsole.log(map); // Map(2) { 'x' => 1, 'y' => 2 }\nmap.set('z', 3);\nconsole.log(map.get('z')); // 3\nconsole.log(map.keys()); // [Map Iterator] { 'x', 'y', 'z' }\nconsole.log(map.values()); // [Map Iterator] { 1, 2, 3 }\n```\n\n## weakSet,weakMap\nWeak在英语的意思是**弱**，表示[weakSet](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)的值、[weakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)的键必须是引用类型，且引用是弱引用，不计入垃圾回收策略，如果没有其他的对Weak中对象的引用存在，那么这些对象会被垃圾回收\n\n**垃圾回收：**JavaScript引擎在值“可达”和可能被使用时会将其保持在内存中，否则会自动进行垃圾回收\n\n```ts\nlet john = { name: \"John\" };\n// 该对象能被访问，john 是它的引用\n// 覆盖引用\njohn = null;\n// 该对象将会被从内存中清除\n```\n\n通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的。\n\n例如，如果把一个对象放入到Map中作为键，那么只要这个Map存在，那么这个对象也就存在，即使没有其他对该对象的引用。\n\n```ts\nlet map = new Map();\nmap.set(john, \"...\");\njohn = null; // 覆盖引用\n// john 被存储在了 map 中，\n// 我们可以使用 map.keys() 来获取它\nconsole.log(map.keys()) // [Map Iterator] { { name: 'John' } }\n```\n\nWeakMap在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收\n\n```ts\nlet john: any = { name: \"John\" };\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\njohn = null; // 覆盖引用\n// john 被从内存中删除了！没有任何办法获取原来的对象\n// weakMap没有keys()方法\n// WeakMap 只有以下的方法：\n// 1. weakMap.get(key)\n// 2. weakMap.set(key, value)\n// 3. weakMap.delete(key)\n// 4. weakMap.has(key)\n```\n\nWeakMap和WeakSet在第三方库处理外部数据、或用作缓存时非常有用，可以防止垃圾数据堆积在内存中\n\n```ts\nlet visitsCountMap = new WeakMap(); // weakmap: user => visits count\n// 递增用户来访次数\nfunction countUser(user: object) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\nlet john: any = { name: \"John\" };\ncountUser(john); // count his visits\n// john 离开了，WeakMap自动释放该键值对\njohn = null;\n```\n\n# 内置高级类型\nTS内置了许多高级类型（常用的工具类型），可以看作是类型的函数，接收一个类型，返回加工后的类型\n\n例如：\n\n```ts\n/**\n * 将 T 中的所有属性变为可选的\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n/**\n * 将 T 中的所有属性变为必需的\n */\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n/**\n * 将 T 中的所有属性变为只读的\n */\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\n/**\n * 从 T 中挑选出键在联合类型 K 中的一组属性\n */\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\n/**\n * 构造一个具有一组属性 K，属性类型为 T 的类型\n */\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n/**\n * 从 T 中排除那些可分配给 U 的类型\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n/**\n * 去掉某些属性\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\n## Partial\n`Partial<T>`可以将原来的类型变为**可选**的\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype p1 = Partial<Person>\n// type p1 = {\n//   name?: string | undefined;\n//   age?: number | undefined;\n//   gender?: \"male\" | \"female\" | undefined;\n// }\n```\n\n**keyof**获取一个对象类型的所有键，作为联合类型，**in**是映射类型语法，用于遍历**keyof T**让联合类型的每一项作为属性，**?** 将每一个属性变成可选项，**T\\[P\\]**索引访问操作符，与访问属性值的操作类似\n\n```ts\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n## Pick\n**筛选类型的属性**。从类型的属性中，选取指定一组属性，返回一个新的类型定义。\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype p2 = Pick<Person, 'name' | 'age'>\n// type p2 = {\n//   name: string;\n//   age: number;\n// }\n```\n\n**K extends keyof T**限制key必须是传入类型的属性，**in**遍历**K**让联合类型的每一项作为属性，**T\\[P\\]**索引访问操作符\n\n```ts\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n```\n\n## Readonly\n将类型中所有属性变为**只读**\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype p3 = Readonly<Person>\n// type p3 = {\n//   readonly name: string;\n//   readonly age: number;\n//   readonly gender: 'male' | 'female';\n// }\n```\n\n源码上和Partial很像，只是把 **?** 换为了**readonly**\n\n```ts\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n// type Partial<T> = {\n//   [P in keyof T]?: T[P];\n// };\n```\n\n## Record\n构造一个具有一组属性 K，属性类型为 T 的类型，做到同时对 key 和 value 进行类型定义\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype persons = Record<string, Person>\n// type persons = {\n//   [x: string]: Person;\n// }\n```\n\n`keyof any`: any 可以代表任何类型。那么任何类型的 key 都可能为 string 、 number 或者 symbol 。所以自然 keyof any 为 string | number | symbol 的联合类型。\n`K extends keyof any`: 类型约束，表示类型参数 K 必须是类型 string | number | symbol 的子集或相同类型。\n`[P in K]` 表示对类型 K 中的每个属性键 P 进行映射（遍历）。其中 K 是一个联合类型或是一个具有多个属性的类型\n\n```ts\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\ntype keys = keyof any\n// type keys = string | number | symbol\n```\n\n## Omit\n去掉某些属性\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype p4 = Omit<Person, 'gender'>\n// type p4 = {\n//   name: string;\n//   age: number;\n// }\n```\n\n```ts\n// 从 T 中排除那些可分配给 U 的类型 \ntype Exclude<T, U> = T extends U ? never : T;\n// 去掉某些属性\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\n## ReturnType\n`ReturnType<T>` 获取函数返回值的类型\n\n```ts\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\nconst fn = () => 'hello'\ntype T = ReturnType<typeof fn>;  // string\n```\n\n# 类型工具\n内置高级类型就是类型工具，但还有一些常用的类型工具并没有内置，需要自己实现\n\n1、将部分属性变为可选\n\n```ts\ninterface Person {\n  name: string\n  age: number,\n  gender: 'male' | 'female'\n}\ntype Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\ntype newPerson = Optional<Person, 'gender'>\n// type newPerson = {\n//   name: string\n//   age: number,\n//   gender?: 'male' | 'female'\n// }\n```\n\n# 占位符infer\n**infer**关键字定义一个占位符，可以自动推断类型，简化代码\n\n案例：传入一个类型，若是数组类型，则返回数组元素的类型组成的联合类型，否则原样返回\n\n```ts\ntype TypeDeconstruct<T> = T extends Array<any> ? T[number] : T\n// 在 TypeScript 中，对于任何具有数字索引签名的对象（比如数组），使用 [number] 可以获取其元素类型。\n// 这是 TypeScript 的索引访问类型的一部分，用于表示通过索引访问数组、元组或对象属性的类型。\nconst arr = [1, 'a', 2, 'b'];\ntype A = TypeDeconstruct<typeof arr> // type A = string | number\ntype B = TypeDeconstruct<boolean> // type B = boolean\n```\n\n使用**infer**自动推断数组中元素的类型\n\n```ts\ntype TypeDeconstruct<T> = T extends Array<infer U> ? U : T\n// 使用infer定义的占位符U，自动推断数组中元素的类型作为联合类型\nconst arr = [1, 'a', 2, 'b'];\ntype A = TypeDeconstruct<typeof arr> // type A = string | number\ntype B = TypeDeconstruct<boolean> // type B = boolean\n```\n\n## 提取/删除元素\n1、提取头部元素\n\n```ts\ntype Arr = ['a','b','c']\ntype First<T extends any[]> =  T extends [infer First,...any[]] ? First : []\ntype a = First<Arr> // type a = \"a\"\n```\n\n2、提取尾部元素\n\n```ts\ntype Arr = ['a', 'b', 'c']\ntype Last<T extends any[]> = T extends [...any[], infer Last,] ? Last : []\ntype a = Last<Arr> // type a = \"c\"\n```\n\n3、剔除第一个元素 Shift\n\n```ts\ntype Arr = ['a','b','c']\ntype Shift<T extends any[]> =  T extends [unknown,...infer Rest] ? Rest : []\ntype a = Shift<Arr> // type a = [\"b\", \"c\"]\n```\n\n4、剔除尾部元素 Pop\n\n```ts\ntype Arr = ['a','b','c']\ntype Pop<T extends any[]> =  T extends [...infer Rest,unknown] ? Rest : []\ntype a = Pop<Arr> // type a = [\"a\", \"b\"]\n```\n\n## 递归\n通过递归将类型数组逆序：\n\n```ts\ntype Arr = ['a','b','c']\ntype ReveArr<T extends any[]> = T extends [infer First, ...infer rest] ? [...ReveArr<rest>, First] : T\ntype Res = ReveArr<Arr> // type Res = [\"c\", \"b\", \"a\"]\n```\n\n提取指定位置上的元素：\n\n```ts\ntype Arr = ['a', 'b', 'c'];\n// 简单写法，不用递归\n// type Index<T extends any[], K extends number> = T[K];\n// type aa = Index<Arr, 1>; // type aa = \"b\"\n\n// 递归写法\n// 获取类型数组指定位置上的元素，索引从1开始\ntype IndexOf<T extends any[], K extends number, Acc extends any[] = []> = {\n  // 如果 K 等于 0，说明已经达到了目标索引位置，返回 Acc 中的第一个元素\n  0: Acc[0];\n  // 否则，继续递归，Acc 中添加数组的第一个元素，同时 K 减 1\n  1: K extends 0 ? Acc[0] : IndexOf<Tail<T>, K, [Head<T>, ...Acc]>;\n}[K extends Acc['length'] ? 0 : 1];\n// 辅助类型：获取数组的第一个元素\ntype Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never;\n// 辅助类型：获取数组的剩余部分\ntype Tail<T extends any[]> = T extends [infer _H, ...infer R] ? R : [];\n\ntype a = IndexOf<Arr, 1>; // type a = \"a\"\ntype b = IndexOf<Arr, 2>; // type b = \"b\"\ntype c = IndexOf<Arr, 3>; // type b = \"c\"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","TypeScript"],"categories":["学习笔记"]},{"title":"Vue笔记[六]-Vue3","url":"/article/63b3ee69.html","content":"\n# Vue3\n[Vue3](https://cn.vuejs.org/) 是由**尤雨溪**等[99位贡献者](https://github.com/vuejs/vue-next/graphs/contributors)开发的一款前端框架。于 2020/09/18 正式发布，耗时2年多、[2600+次提交](https://github.com/vuejs/vue-next/graphs/commit-activity)、[30+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)，在这里，框架将授予你「**声明式**」、「**组件化**」的编程模型，导引「**响应式**」之力。你将扮演一位名为「**CV工程师**」的神秘角色在自由的编码中邂逅样式各异、功能独特的组件库们，和他们一起解决问题，完成多样的需求——同时，逐步发掘「**组合式API**」的真相。\n\n**注意：**尽管 Vue3 兼容大部分 Vue2 写法，但组合式 API 写法下，最好不要混用\n\n# Vue-cli创建工程\nVue3 推荐使用 [Vite]() 来创建工程，但刚学完 vue2 还是接着用 Vue-cli 把 Vue3 新的语法学完，再去学习 Vite 和 [pinia](https://pinia.web3doc.top/) 的使用吧\n\n工程结构和 vue2 中的一样，但文件内有些变化：\n\n```js main.js\n// 引入的不再是Vue构造函数\n// 而是createApp工厂函数，无需通过new去调用\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n// 创建应用实例，类似vm，但比vm更轻\nconst app = createApp(App)\n// 挂载\napp.mount('#app')\n\n```\n\n单文件组件模板可以没有根元素\n\n```html\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <HelloWorld msg=\"Welcome to Your Vue.js App\"/>\n</template>\n```\n\n# 初识setup\n**setup** 是 Vue3 中一个新的**配置项**，值为一个**函数**。\n\n组件中所有的数据、方法都要配置在 **setup** 中\n\nsetup函数有两种返回值\n(1) 返回一个**对象**，对象中的所有属性都可以在组件模板中使用\n(2) 返回一个**渲染函数**，会替换掉组件模板（基本用不到）\n\nsetup 执行是在创建实例之前，也就是 **beforeCreate** （之前）执行，所以 setup 函数中的 this 不是组件的实例，而是undefined，setup是**同步**的\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"showName\">点击</button>\n</template>\n<script>\nexport default {\n  name: 'App',\n  // setup配置项\n  setup(){\n    // 定义一些数据和方法\n    let name = 'chuckle';\n    let age = 20;\n    function showName(){\n      alert(name);\n    }\n    // 返回一个对象\n    return {\n      name,\n      age,\n      showName,\n    }\n  }\n}\n</script>\n\n```\n\n# < script setup >\n在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。可以通过构建工具来简化该操作。\n\n给 `<script>` 标签加上 **setup** 属性，里面的代码会被编译成 `setup()` 函数的内容\n\n与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，`<script setup>` 中的代码会在每次组件实例被创建的时候执行\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"showName\">点击</button>\n</template>\n<script setup>\n// 定义一些数据和方法\nlet name = 'chuckle';\nlet age = 20;\nfunction showName() {\n  alert(name);\n}\n</script>\n\n```\n\n**setup带来的改变：**\n1. 解决了vue2的data和methods方法相距太远，无法组件之间复用\n2. 提供了script标签引入共同业务逻辑的代码块，顺序执行\n3. script变成setup函数，默认暴露给模版\n4. 组件直接挂载，无需注册\n5. 自定义的指令也可以在模版中自动获得\n6. this不再是这个活跃实例的引用\n7. 带来的大量全新api，比如defineProps，defineEmits，withDefault，toRef，toRefs\n\n# 响应式\n对比探究 Vue3 中的响应式使用与实现\n\n## ref函数\n`setup()` 返回的数据并没有自带**响应式**的效果，在 Vue3 中要实现响应式，需要使用 `ref()` 对数据进行处理\n\n**作用：**用 `ref()` 定义**响应式**变量，将**传入的值**包装为一个带 **value** 属性的 ref 对象（**引用实现对象**），允许我们创建可以使用**任何值类型**的**响应式**数据\n\nJS 中需要 **.value** 才能获取或修改数据，模板中直接写 ref 对象名\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"change\">改变</button>\n</template>\n<script setup>\n// Vue3 遵循按需引入的理念，所以许多 vue 中的东西需要引入后才能使用\nimport { ref } from 'vue';\n// 定义一些数据和方法\nlet name = ref('chuckle');\nlet age = ref(20);\n// 修改数据，响应式\nfunction change() {\n  name.value = 'qx';\n  age.value = 19;\n}\n</script>\n\n```\n\n`ref()` 传入值为**基本数据类型**时，其响应式本质和 vue2 一样，是通过 `Object.defineProperty()` 的 **getter** 和 **setter** 进行**数据劫持**和**数据代理** 实现的\n\n```js\nRefImpl {__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: 'chuckle', _value: 'chuckle'}\ndep: Set(1) {ReactiveEffect}\n__v_isRef: true\n__v_isShallow: false\n_rawValue: \"chuckle\"\n_value: \"chuckle\"\n// 熟悉的(...)数据代理\nvalue: (...) // \"chuckle\"\n[[Prototype]]: Object\n  constructor: class RefImpl\n  // 熟悉的(...)数据劫持，添加get和set\n  value: (...) //\"chuckle\"\n  // 熟悉的 getter 和 setter\n  get value: ƒ value()\n  set value: ƒ value(newVal)\n  [[Prototype]]: Object\n\n```\n\n`ref()` 传入值为**对象类型**时，会去调用 `reactive()` 处理 **value**，而 `reactive()` 返回一个 **Proxy** 类型的对象\n\n暂时看不懂的东西：\n\n```js\nRefImpl {__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: {…}, _value: Proxy(Object)}\ndep: undefined\n__v_isRef: true\n__v_isShallow: false\n_rawValue: {a: 1, b: 2}\n_value: Proxy(Object)\n  [[Handler]]: Object\n  [[Target]]: Object\n  [[IsRevoked]]: false\nvalue: Proxy(Object)\n  [[Handler]]: Object\n  [[Target]]: Object\n    a: 1\n    b: 2\n  [[Prototype]]: Object\n  [[IsRevoked]]: false\n[[Prototype]]: Object\n\n```\n\n## reactive函数\n`reactive()` 传入一个**对象类型**，返回该对象类型的代理对象（**Proxy**的实例对象，简称**proxy**对象）\n\n`reactive()` 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的**原始类型**无效\n\n**proxy** 对象直接用变量名访问数据，无需 .value\n\n可以直接通过下标**响应式**地修改数组数据，这是通过 **defineProperty** 实现的响应式所做不到的\n\n```html\n<template>\n  <h2>{{ name }}</h2>\n  <h2>{{ age }}</h2>\n  <button @click=\"change\">改变</button>\n  <h3>{{ obj.a }}</h3>\n  <h3>{{ obj.b }}</h3>\n  <h3>{{ arr.toString() }}</h3>\n</template>\n\n<script setup>\nimport { ref, reactive } from 'vue';\n// 定义一些数据和方法\nlet name = ref('chuckle');\nlet age = ref(20);\nlet obj = reactive({\n  a: 1,\n  b: 2,\n});\nlet arr = [1,2,3];\n// 修改数据，响应式\nfunction change() {\n  name.value = 'qx';\n  age.value++;\n  // proxy对象无需.value，可以直接访问\n  obj.a = 10;\n  obj.b++;\n  // 可以直接通过下标响应式地修改数组\n  arr[0] = 10;\n}\n</script>\n\n```\n\n在**定义响应式数据**时，通常基本数据类型用 `ref()`，引用数据类型用 `reactive()`\n\n但由于 `ref()` 定义的响应式数据需要 **.value** 才能获取和修改数据值，所以也通常将基本数据类型扔进一个对象中，然后用 `reactive()`，可以省去 **.value**\n\n## Vue2的响应式原理\n依靠 `Object.defineProperty()`\n\n**实现原理：**\n1. **基本数据类型：**通过 **defineProperty** 进行数据劫持与代理\n2. **对象类型：**深度遍历对象，通过 **defineProperty** 进行数据劫持与代理\n3. **数组类型：**通过重写更新数组的一系列方法（push等）\n\n**存在问题：**\n1. 深度遍历对象存在性能与效率问题\n2. 对象新增、删除属性，无法响应式，需用 $set 和 $delete\n3. 直接通过下标修改数组，无法响应式\n\n## Vue3的响应式原理\n依靠 ES6 中新的 API `window.Proxy()` 构造函数，解决了 Vue2 响应式中的问题\n\n`Proxy()` 返回 **proxy** 对象，它可以代理对**源数据**中**任何属性**的**任何操作**\n\n`Proxy()` 传入两个参数，第一个：要代理的源数据，第二个：一个配置对象，其中有 get、set 等方法，用于设置拦截\n如果Proxy的第二个参数（配置对象）没有设置任何拦截，就等同于直接访问原对象\n\n尝试使用 `Proxy()` 实现代理数据操作：\n\n```js\n// 源数据\nlet obj = {\n  name: 'chuckle',\n  age: 20\n}\n// 通过Proxy实例代理对源数据的增删改查操作\nconst agent = new Proxy(obj, {\n  // 对操作的拦截配置\n  // 获取属性值\n  get(target, propName){\n    console.log(`读取了${propName}属性`);\n    // 返回源数据的值\n    return target[propName]\n  },\n  // 修改属性值、新增属性\n  set(target, propName, value){\n    console.log(`修改或新增了${propName}属性，去响应式地更新视图`);\n    // 实际地修改源数据的值\n    target[propName] = value\n  },\n  // 删除属性\n  deleteProperty(target, propName){\n    console.log(`删除了${propName}属性，去响应式地更新视图`);\n    // 实际地删除源数据地属性，返回删除成功与失败地布尔值\n    return delete target[propName]\n  }\n});\n\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/58-3.webp\" width=\"260px\" loading=\"lazy\">\n\n**注意：**后续在 proxy 对象上添加新属性也是响应式的\n\n虽然上面已经模仿实现了\"响应式\"，但 Vue3 中还用到了 `window.Reflect` 对象\n\n`Proxy()` 用于**代理**（代理对数据的操作），`Reflect` 用于**反射**（实际对数据的操作）\n\n**Reflect 用法：**\n1. `Reflect.get(target, prop)` **获取**某个对象（target）中某个属性（prop）的值\n2. `Reflect.set(target, prop, value)` **修改**某个对象中某个属性的值为value\n3. `Reflect.deleteProperty(target, prop)` **删除**某个对象中的某个属性\n\nReflect 身上还有很多方法，ECMA 也在将原本 Object 中的方法移植到 Reflect 中\n\n```js\n// 源数据\nlet obj = {\n  name: 'chuckle',\n  age: 20\n}\n// 通过Proxy代理对源数据的增删改查操作\nconst agent = new Proxy(obj, {\n  // 对操作的拦截配置\n  // 获取属性值\n  get(target, propName){\n    console.log(`读取了${propName}属性`);\n    // 返回源数据的值\n    return Reflect.get(target, propName)\n  },\n  // 修改属性值、新增属性\n  set(target, propName, value){\n    console.log(`修改或新增了${propName}属性，去响应式地更新视图`);\n    // 实际地修改源数据的值\n    return Reflect.set(target, propName, value)\n  },\n  // 删除属性\n  deleteProperty(target, propName){\n    console.log(`删除了${propName}属性，去响应式地更新视图`);\n    // 实际地删除源数据地属性，返回删除成功与失败地布尔值\n    return Reflect.deleteProperty(target, propName)\n  }\n});\n\n```\n\n**MDN 文档：**[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 与 [Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)\n\n**总结 Vue3 响应式的实现原理:**\n1. **通过Proxy（代理）：**拦截对象中任意属性的变化, 包括增删改查等。\n2. **通过Reflect（反射）：**对源对象的属性进行实际操作。\n\n# props声明\n和 Vue2 一样，一个组件需要显式声明它所接受的 props\n\n`<script setup>` 的单文件组件中，props 可以使用 `defineProps()` 宏来声明\n\n```html\n<script setup>\nimport { defineProps } from 'vue';\nconst props = defineProps(['foo'])\nconsole.log(props.foo)\n</script>\n```\n\n没有使用 `<script setup>` 的组件中，prop 可以使用 props 选项来声明：\n\n```js\nexport default {\n  props: ['foo'], // 声明props\n  setup(props) {\n    // setup() 接收 props 作为第一个参数\n    console.log(props.foo)\n  }\n}\n```\n\nprops 也是一个 proxy 对象，也能实现响应式\n\n**注意：**所有的 props 都遵循着**单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而**不会逆向传递**，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，不应该在子组件中去更改一个 prop。\n\n# context上下文\n**context** 是 `setup(props, context)` 的第二个参数，代表上下文\n\ncontext 中有一些属性和方法\n1. **attrs** 没有接收的 prop 都会出现在里面\n2. `emit()` 触发父组件绑定来的自定义事件\n3. **slots** 没有接收的 slot 都会出现在里面\n\n`<script setup>` 中 useContext() 已经废弃\n\n需要使用独立的 API 获取原本 context 中的属性和方法：\n1. `useAttrs()` 没有接收的 prop 都会出现在里面\n2. `defineEmits()` 接收父组件绑定的自定义事件\n3. `useSlots()`  获取父组件中插槽传递的所有虚拟Dom对象，按插槽名字区分\n\n需要引入后使用：\n\n```js\nimport { useAttrs,defineEmits, useSlots } from 'vue';\n```\n\n**1、**`useAttrs()`\n\n```html\n<!-- 父组件 -->\n<student :a=\"1\" b=\"giggles\"></student>\n\n<!-- 子组件 -->\n<script setup>\n// 接收a\nconst props = defineProps(['a'])\nconsole.log(props)\n// 没接收的b会在里面\nconst attrs = useAttrs();\nconsole.log(attrs) // 一个proxy对象\n</script>\n\n```\n\n**2、**`defineEmits()`\n\n```html\n<!-- 父组件 -->\n<student @emitTest=\"emitTest\"></student>\n<script setup>\nfunction emitTest(value) {\n  console.log(value);\n}\n</script>\n\n<!-- 子组件 -->\n<script setup>\n// 接收自定义事件\nconst emit = defineEmits(['emitTest']);\n// 触发自定义事件\nemit('emitTest', name)\n</script>\n\n```\n\n**3、**`useSlots()`\n\n```html\n<!-- 父组件 -->\n<student>\n  <template #slotTest>\n    <h2>插槽</h2>\n  </template>\n</student>\n\n<!-- 子组件 -->\n<slot name=\"slotTest\"></slot>\n<script setup>\nconst slots = useSlots();\nconsole.log(slots)\n</script>\n\n```\n\n# defineExpose函数\n子组件通过 `defineExpose()` 向父组件暴露数据\n\n当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 { a: number, b: number } (ref 会和在普通实例中一样被自动解包)\n\n```html\n<!-- 父组件 -->\n<student ref=\"stu\"></student>\n<script setup>\n// 接收子组件\nlet stu = ref(null);\nonMounted(() => {\n  console.log(stu.value.name); // chuckle\n  console.log(stu.value.city); // 北京\n})\n</script>\n\n<!-- 子组件 -->\n<script setup>\nlet name = ref(\"chuckle\");\nlet city = ref(\"北京\");\n// 暴露数据\ndefineExpose({\n  name,\n  city\n})\n</script>\n\n```\n\n# computed计算属性\n`computed()` 接受一个 getter 函数，返回一个只读的响应式 **ref** 对象。该 ref 通过 .value 暴露 getter 函数的返回值。也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\n\n```js\nimport { computed } from 'vue';\nlet person = reactive({\n  firstName: '张',\n  lastName: '三'\n})\nlet name = computed(()=>{\n  return person.firstName + person.lastName;\n})\n\n// 可读写的：\nlet refObj = computed({\n  get(){},\n  set(value){}\n})\n\n```\n\n# watch函数\n`watch()` 监视一个或多个**响应式数据源**，并在数据源变化时调用所给的**回调函数**。\n\n返回值是一个用来停止监听的的函数\n\n**基本使用：**\n\n```js\nwatch(refObj, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n}, {\n  // 配置对象\n  deep: true,\n})\n```\n\n1、可以同时监视多个响应式数据，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\n\n```js\nwatch([name, age], ([newName, newAge], [oldName, oldAge]) => {})\n```\n\n2、当监听一个 **reactive** 定义的 **proxy** 响应式对象时，侦听器会强制启用**深层模式**，但回调函数收到的**新值**和**旧值**参数将是同一个对象\n\n```js\nlet person = reactive({\n  firstName: '张',\n  lastName: '三'\n})\nwatch(person, (newValue, oldValue)=>{\n  console.log(newValue,oldValue);\n  // Proxy(Object){firstName: '张一', lastName: '三'} \n  //Proxy(Object){firstName: '张一', lastName: '三'}\n  console.log(newValue===oldValue); // true\n})\n\n```\n\n3、监听 **proxy** 对象中某一个**基本数据类型**的属性，**新值**和**旧值**可以正常获取，但监听对象需写成**函数返回值形式**\n\n```js\nlet person = reactive({\n  a: { b: 1, c: 2 }\n})\nwatch(()=>person.a.b, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n```\n\n4、监听 **proxy** 对象中某一个**对象类型**的属性，**新值**和**旧值**是同一个对象\n\n```js\nlet person = reactive({\n  a: { b: 1, c: 2 }\n})\nwatch(person.a, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n```\n\n5、若监视一个使用 `ref()` 定义的**对象类型**的**响应式数据**，则需要 **deep: true** 开启深度监视，或去监视其 **.value**（此时value是一个proxy对象，会自动开启深度监视）\n\n```js\nlet person = ref({\n  a: { b: 1, c: 2 }\n})\nwatch(person, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n},{\n  deep: true, // 直接监视ref对象需要手动开启深度监视\n})\n// 也可以去监视其.value\nwatch(person.value, (newValue, oldValue)=>{\n  console.log(newValue, oldValue);\n})\n\n```\n\n# watchEffect函数\n`watchEffect()` **立即运行**一个回调函数，同时响应式地追踪其**依赖**，并在**依赖更改**时**重新执行**回调\n\n返回值是一个用来停止监听的的函数\n\n```js\nconst count = ref(0)\nwatchEffect(() => console.log(count.value)) // 立即执行回调，输出 0\ncount.value++ // 重新执行回调，输出 1\n```\n\n和计算属性有些像，计算属性重在最后的返回值，而watchEffect重在逻辑过程，而返回值确定\n\n# Vue3生命周期\nVue3 [生命周期钩子](https://cn.vuejs.org/api/composition-api-lifecycle.html)名称改为了 on 开头，但作用和 Vue2 中的差不多，但也添加了一些新钩子，有需要在文档中查看用法\n\n**Vue3 生命周期图：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/58-2.webp\" width=\"80%\" loading=\"lazy\">\n\n# 自定义hook\n**hook** 本质是一个函数。\n**自定义hook**，就是将 setup 中使用过的**组合式API**进行封装，写在一个单独的 JS 文件中并暴露出去，实现**代码复用**，命名通常以 use 开头，集中放在 hooks 文件夹中\n\n**作用：**在 Vue3 中通过**组合式函数**实现 JS 代码复用，而**避免**使用 mixin 混入\n\n**组合式函数：**是一个利用 Vue 的组合式 API 来封装和复用**有状态**和**相关逻辑**的**函数**。\n\n**案例：**写一个实时返回鼠标坐标的 hook，让任何组件引入即可使用\n\n```js /hooks/useMouse.js\nimport { reactive, onMounted, onBeforeUnmount } from \"vue\"\n// 暴露出该hook函数\nexport default function (){\n  // 状态\n  let coordinate = reactive({\n    x: 0,\n    y: 0,\n  })\n  // 修改状态\n  function monitorMouse(event){\n    coordinate.x = event.pageX;\n    coordinate.y = event.pageY;\n  }\n  // 组件挂载完开始监听\n  onMounted(()=>{\n    window.addEventListener('mousemove', monitorMouse)\n  })\n  // 组件卸载前结束监听\n  onBeforeUnmount(()=>{\n    window.removeEventListener('mousemove', monitorMouse)\n  })\n  // 将状态返回出去给组件使用\n  return coordinate\n}\n\n```\n\n组件中展示鼠标坐标，非常方便，引入hook并执行，获取状态，然后使用状态\n\n```html\n<template>\n  <!-- 使用hook函数返回的状态 -->\n  <span>X：{{ coordinate.x }} Y：{{ coordinate.y }}</span>\n</template>\n<script setup>\n// 引入hook\nimport useMouse from '@/hooks/useMouse';\n// 执行hook函数获取数据\nlet coordinate = useMouse();\n</script>\n\n```\n\n# toRef与toRefs\n`toRef()` 可以将值、refs 或 getters 规范化为 refs\n也可以基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性**保持同步**：改变源属性的值将更新 ref 的值，反之亦然\n\n```js\nlet refObj = toRef(proxyObj, 'propName');\n```\n\n为什么要用 `toRef()`：\n当直接解构 proxy 响应式对象时，对于属性值是**基本数据类型**的属性，传的是值，而非引用地址，解构后的变量会失去响应式的功能\n\n```html\n<template>\n  <h3>{{ a }}</h3>\n  <h3>{{ b }}</h3>\n</template>\n<script setup>\nlet obj = reactive({\n  a: {\n    b: 1,\n    c: 2,\n  }\n})\n// 解构obj\nlet a = obj.a; // 传的地址，响应式仍在\nconsole.log(a); // Proxy(Object) {b: 1, c: 2}\nlet b = obj.a.b; // 传的数值，响应式丢失\nconsole.log(b); // 1\n</script>\n\n```\n\n使用 `toRef()` 可以不用重新将解构的值通过 `ref()` 创建一个**独立**的 **ref** 对象，而是直接用源对象中的属性，通过引用关系，创建一个对应的 **ref** 对象，与其源属性**保持同步**\n\n```js\nlet obj = reactive({\n  a: { b: 1, c: 2 }\n})\n// 创建一个对应的 ref\nlet b = toRef(person.a, 'b');\nconsole.log(b);\n// ObjectRefImpl {_object: Proxy(Object), _key: 'b', _defaultValue: undefined, __v_isRef: true}\n```\n\n`toRefs()` 功能与 `toRef()` 差不多，但可以批量处理某个 proxy 对象中的所有属性(浅层)，返回一个对象，对象中存着源对象属性对应的 ref 对象\n\n```js\nlet refArr = toRefs(proxyObj);\n```\n\n**总结：**`toRef()`创健一个 ref 对像，其 value 值指向另一个对象中的某个属性\n\n# 其它组合式API\n介绍较不常用的组合式API\n\n## 响应式数据的判断\n1、`isRef()` 检查某个值是否为 ref 对象\n2、`unref()` 如果参数是 ref，则返回其 value 值，否则返回参数本身\n2、`isProxy()` 检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理\n3、`isReactive()` 检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理\n\n## 浅层响应式\n`shallowReactive()` reactive() 的浅层作用形式，只对**浅层属性**进行响应式处理\n\n`shallowRef()` ref() 的浅层作用形式，只有浅层的 value 是响应式的\n\n## 只读API\n`readonly()​` 深层的只读，接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理\n\n`shallowReadonly()` 浅层的只读\n\n## toRaw、markRaw\n`toRaw()` 根据一个 Vue 创建的 **proxy** 代理对象返回其**原始对象**的引用地址\n\n`markRaw()` 将一个对象标记为不可被转为 **proxy** 代理。返回该对象本身。可以让某些数据追加到 proxy 对象上后没有响应式功能。\n\n## 自定义ref\n`customRef()` 创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。\n\n接收一个工厂函数作为参数，这个工厂函数接受 **track** 和 **trigger** 两个函数作为参数，并返回一个带有 get 和 set 方法的对象\n\n`track()` 追踪数据变化，`trigger()` 重新解析模板\n\n**作用：**用于防抖、延迟更新视图等需求\n\n```js\nimport { customRef } from 'vue'\nfunction myRef(value){\n  return customRef((track, trigger)=>{\n    return {\n      get() {\n        track() // 追踪数据变化\n        return value\n      },\n      set(newValue) {\n        value = newValue\n        trigger() // 重新解析模板\n      }\n    }\n  })\n}\n\n```\n\n## 依赖注入\n`provide()` 祖先组件提供一个值，可以被后代组件注入。接受两个参数：第一个参数是要注入的 key（名字），第二个参数是要注入的值\n\n`inject()` 注入一个由祖先组件或整个应用 (app.provide()) 提供的值。\n\n通过这两个 API 可以实现祖先与后代组件的通信，非常方便\n\n```js\n// 祖先组件\nimport { provide } from 'vue';\nlet person = reactive({\n  firstName: '张',\n  lastName: '三',\n})\nprovide('person',person)\n\n// 后代组件\nimport { inject } from 'vue';\nlet person = inject('person');\nconsole.log(person); // 获取成功\n\n```\n\n**注意：**`provide()`、`inject()` 必须在组件的 setup() 阶段同步调用\n\nVue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，inject() 将返回 undefined，除非提供了一个默认值。\n\n# Fragment组件\n在 Vue2 中，组件模板必须有一个根标签\n\n在 Vue3 中，若模板中没有根标签，会将模板包含在一个 fragment 虚拟元素中，不会被实际渲染出来\n\n# Teleport组件\n`<teleport to=\"\">` 可以将组件模板、插槽移动到指定的任意元素中（尾插），to 中写 css 选择器\n\n一个简单的弹窗组件：\n\n```html\n<template>\n  <div>\n    <button @click=\"showPopUp\">点击显示弹窗</button>\n    <teleport to='body'>\n      <div class=\"popup-mask\" v-show=\"popup.isShow\">\n        <div class=\"popup\">\n          <h3>弹窗内容</h3>\n          <button @click=\"showPopUp\">关闭弹窗</button>\n        </div>\n      </div>\n    </teleport>\n  </div>\n</template>\n\n<script setup>\nimport { reactive } from 'vue';\nlet popup = reactive({\n  isShow: false,\n})\nfunction showPopUp() {\n  popup.isShow = !popup.isShow;\n}\n</script>\n\n<style lang=\"less\" scoped>\n.popup-mask {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.popup {\n  position: relative;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 200px;\n  height: 300px;\n  background: rgb(60, 60, 60);\n  text-align: center;\n}\n</style>\n\n```\n\n# Suspense组件(实验)\n**作用：**异步地动态加载子组件，父组件加载完就直接显示，不等待异步的子组件\n\n将要异步加载的子组件使用 `<Suspense>` 包裹\n\n`<Suspense>` 提供两个有名插槽，default 最终要加载的子组件，fallback 子组件还未加载出来时展示的模板\n\n```html\n<template>\n  <div class=\"app\">\n    <h3>我是App组件</h3>\n    <Suspense>\n      <!-- default插槽 -->\n      <template v-slot:default>\n        <Child/>\n      </template>\n      <!-- fallback插槽 -->\n      <template v-slot:fallback>\n        <h3>加载中.....</h3>\n      </template>\n    </Suspense>\n  </div>\n</template>\n\n```\n\n除了 `<Suspense>` 还可以使用 `defineAsyncComponent()` 异步引入组件\n\n```js\nimport { defineAsyncComponent } from 'vue'\nconst Child = defineAsyncComponent(()=>import('./components/Child.vue'))\n```\n\n异步引入组件后：\n(1) 该组件的 setup() 就可以是 async 函数，可以用 await，可以返回 promise 对象。\n(2) `<script setup>` 中也可以使用顶层 await。结果代码会被编译成 async setup()\n\n# Vue3的其它变化\n**1、全局 API 的转移：**`Vue.xxx` 调整到应用实例 `app` 上\n\n| 2.x 全局 API（`Vue`） | 3.x 实例 API (`app`)                        |\n| ------------------------- | ------------------------------------------- |\n| Vue.config.xxxx           | app.config.xxxx                             |\n| Vue.config.productionTip  | <strong style=\"color:#DD5145\">移除</strong>，因为不再有生产提示 |\n| Vue.component             | app.component                               |\n| Vue.directive             | app.directive                               |\n| Vue.mixin                 | app.mixin                                   |\n| Vue.use                   | app.use                                     |\n| Vue.prototype             | app.config.globalProperties                 |\n\n**2、Vue动画中过度类名的更改：**\n\n```css Vue2 写法\n.v-enter,\n.v-leave-to {\n  opacity: 0;\n}\n.v-leave,\n.v-enter-to {\n  opacity: 1;\n}\n```\n\n```css Vue3 写法\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n.v-leave-from,\n.v-enter-to {\n  opacity: 1;\n}\n```\n\n**3、**keyCode 不再作为 v-on 的修饰符，同时也不再支持 `config.keyCodes`\n\n**4、**移除 `v-on.native` 修饰符\n\n**5、**移除过滤器 **filter**\n\n**6、**父组件给子组件绑定自定义事件，子组件中需要接收才能使用，\n(1) `defineEmits()` 接收父组件绑定的自定义事件\n(2) 或者选项式中的 emits 配置项\n\n> THE END\n\n\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[五]-路由","url":"/article/ade78509.html","content":"\n# 路由route\n前端路由用于实现 **SPA应用**（单页Web应用）\n\n**SPA应用：**\n(1) 整个应用只有一个完整的页面\n(2) 点击导航区不刷新页面，只做页面的局部更新\n(3) 数据需要通过 ajax 请求获取\n\n每个路由都是**路径**与**组件**的**映射关系**，当浏览器的路径改变时，对应的组件就会显示\n\n# 路由基本使用\n在 Vue 中使用路由需安装 [vue-router](https://router.vuejs.org/) 插件\n\n**安装：** `npm install vue-router` ，最新版本仅支持 Vue3，Vue2 需使用 vue-router@3\n\n**使用步骤：**\n(1) 创建路由器\n(2) 注册路由\n(3) 使用路由\n(4) 编写路由组件\n\n**注意：**\n(1) 不断切换路由时，路由组件在重复地销毁和挂载，即**重复地**经过完整的**生命周期**\n(2) **vue-router** 插件会向 vm 和 vc 身上添加 `$route`（当前路由） 和 `$router`（全局路由器） 两个属性\n\n**1、创建路由器：**\n通常在 src 目录下新建 router/index.js\n\n使用 `new VueRouter()` 创建路由器实例\n\n```js /router/index.js\n// 该文件用于创建路由器\nimport VueRouter from 'vue-router';\nimport About from '@/pages/About.vue';\nimport Home from '@/pages/Home.vue';\n\n// 创建路由器\nexport default new VueRouter({\n  routes: [\n    // 一级路由\n    {\n      // 路由的路径\n      path: '/about',\n      // 路由对应展示的组件\n      component: About\n    },\n    {\n      path: '/home',\n      component: Home,\n    },\n  ]\n});\n\n```\n\n**2、注册路由：**\n在 `new Vue()` 时传入刚刚创建好的路由器实例\n\n因为 **vue-router** 是插件，还要 `Vue.use()` 安装插件\n\n```js main.js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport VueRouter from \"vue-router\";\n// 引入路由器\nimport router from \"@/router\"\n\nVue.config.productionTip = false;\n\nVue.use(VueRouter)\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n    // 使用路由器\n    router,\n})\n\n```\n\n**3、使用路由：**\n**vue-router** 提供了几个特殊标签来使用路由\n\n`<router-link>` 会被解析为 A 标签，点击后切换路由\n`<router-view>` 指定路由组件的呈现位置\n\n```html App.vue\n<template>\n  <div>\n    <!-- 使用router-link标签进行route切换 -->\n    <router-link to=\"/home\" active-class=\"active\">Home</router-link>\n    <router-link to=\"/about\" active-class=\"active\">About</router-link>\n    <!-- 路由组件呈现位置 -->\n    <router-view></router-view>\n  </div>\n</template>\n\n<!-- ....... -->\n\n```\n\n**4、编写路由组件：**\n**一般组件：**直接在另一个组件模板中写组件标签，一般放在 **components** 文件夹\n**路由组件：**配置在路由器中，通过切换路由动态展示和销毁，一般放在 **pages** 文件夹\n\n```html /pages/Home.vue\n<template>\n  <div>\n    <h2>我是Home组件</h2>\n  </div>\n</template>\n<!-- .... -->\n```\n\n```html /pages/About.vue\n<template>\n  <div>\n    <h2>我是About组件</h2>\n  </div>\n</template>\n<!-- .... -->\n```\n\n# 嵌套、多级路由\n**效果：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/57-2.webp\" loading=\"lazy\">\n\n使用 **children** 属性配置子路由\n\n```js /router/index.js\n// 该文件用于创建路由器\nimport VueRouter from 'vue-router';\nimport About from '@/pages/About.vue';\nimport Home from '@/pages/Home.vue';\nimport Message from '@/pages/HomePages/Message.vue';\nimport News from '@/pages/HomePages/News.vue';\n\n// 创建路由器\nexport default new VueRouter({\n  routes: [\n    // 一级路由\n    {\n      path: '/about',\n      component: About\n    },\n    {\n      path: '/home',\n      component: Home,\n      children: [\n        // 二级路由\n        {\n          // 多级路由不用再写斜杠\n          path: 'news',\n          component: News\n        },\n        {\n          path: 'message',\n          component: Message\n        }\n      ],\n    },\n  ]\n});\n\n```\n\n修改 Home.vue 组件加上二级路由切换\n\n```html /pages/Home.vue\n<template>\n  <div>\n    <h2>我是Home组件</h2>\n    <router-link to=\"/home/message\" active-class=\"active\">Message</router-link>\n    <router-link to=\"/home/news\" active-class=\"active\">News</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n<!-- .... -->\n\n```\n\n新建二级路由组件 Message.vue 和 News.vue\n\n```html Message.vue 和 News.vue\n<!-- Message.vue -->\n<template>\n  <div>\n    <h2>Home的二级路由Message</h2>\n  </div>\n</template>\n<!-- .... -->\n\n<!-- News.vue -->\n<template>\n  <div>\n    <h2>Home的二级路由News</h2>\n  </div>\n</template>\n<!-- .... -->\n\n```\n\n# route的属性\n**获取route：**组件中 `this.$route`，路由守卫中的 **to**、**from** 参数\n\n**route上常用属性：**\n1. **fullPath** 该路由的完整路径，带参数\n2. **meta** 一个对象，允许程序员自由地往里面加内容，可以在配置路由时就设置\n3. **name** 路由的名字\n4. **params** params参数\n5. **path** 路由路径\n6. **query** 查询字符串参数\n\n# 路由query传参\n通过 url 的 **query**（查询字符串）参数给子路由组件传参\n\n**使用：**\n\n```html /pages/HomePages/Message.vue\n<!-- 模板字符串写法 -->\n<router-link :to=\"`/home/message/detail?id=${item.id}&title=${item.title}`\">{{ item.title }}</router-link>\n<!-- 对象写法，推荐 -->\n<router-link :to=\"{\n  path: '/home/message/detail',\n  query: {\n    id: item.id,\n    title: item.title\n  }\n}\">\n{{ item.title }}</router-link>\n\n```\n\n子路由组件中通过 `$route.query.<key>` 获取 query 参数\n\n```html /pages/HomePages/MessageDetail.vue\n<h3>{{ $route.query.id }}</h3>\n<h3>{{ $route.query.title }}</h3>\n```\n\n# 命名路由\n给路由起名字，可以简化一些编码工作\n\n```js /router/index.js\n{\n  // 命名路由\n  name: 'Message',\n  path: 'message',\n  component: Message,\n  children: [\n    {\n      name: 'MessageDetail',\n      path: 'detail',\n      component: MessageDetail\n    }\n  ]\n}\n\n```\n\n使用 name 替代 path 配置，也能跳转路径\n\n```html /pages/HomePages/Message.vue\n<router-link :to=\"{\n  name: 'MessageDetail',\n  // path: '/home/message/detail',\n  query: {\n    id: item.id,\n    title: item.title\n  }\n}\">{{ item.title }}</router-link>\n\n```\n\n# 路由params传参\n使用 params 传参需要在路由 path 配置中写上 url 参数（占位符）\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  // 写上占位符\n  path: 'detail/:id/:title',\n  component: MessageDetail\n}\n```\n\n**传参：**使用 params 传参，路径只能用 name 写法，不能写 path\n\n```html /pages/HomePages/Message.vue\n<router-link :to=\"{\n  name: 'MessageDetail',\n  params: { //传params参数\n    id: item.id,\n    title: item.title\n  }\n}\">{{ item.title }}</router-link>\n```\n\n**获取参数：** `$route.params`\n\n```html /pages/HomePages/MessageDetail.vue\n<h3>{{ $route.params.id }}</h3>\n<h3>{{ $route.params.title }}</h3>\n```\n\n# 路由props配置\n在路由配置中加上 `props: true`，该路由组件收到的所有 **params 参数**都会以 **props** 形式呈现\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  path: 'detail/:id/:title',\n  component: MessageDetail,\n  // 写死数据，一般用不到\n  // props: {a:'1', b:'2'}\n  // 设置true，该路由组件收到的所有params参数都会以props形式呈现\n  props: true\n}\n\n```\n\n接收 props\n\n```js /pages/HomePages/MessageDetail.vue\nexport default {\n  name: 'MessageDetail',\n  // 接收props\n  props: ['id', 'title'],\n}\n```\n\n将 `props()` 写成**函数式**，参数是该路由 **$route** ，可以自定义返回值，不再局限于之前只能传 params 参数\n\n```js /router/index.js\n{\n  name: 'MessageDetail',\n  path: 'detail/:id/:title',\n  component: MessageDetail,\n  // 解构赋值从$route中拿出params和query\n  props({params,query}){\n    return {\n      id: params.id,\n      title: query.title\n    }\n  }\n}\n```\n\n# replace属性\n`<router-link>` 的 **replace** 属性\n\n**作用：**控制路由跳转时，操作浏览器**历史记录**的模式为 **replace**\n\n操作浏览器历史记录有 **push**(默认) 和 **replace** 两种模式\n(1) push 追加历史记录\n(2) replace 替换当前记录，使浏览器不能通过后退返回之前的路径\n\n```html\n<router-link to=\"/home\" active-class=\"active\" replace>Home</router-link>\n<router-link to=\"/about\" active-class=\"active\" replace>About</router-link>\n```\n\n# 编程式路由\n不使用 `<router-link>` 标签，通过调用 `$router` 上的方法，来控制路由的跳转\n\n`$router` 原型上的 `push()` 和 `replace()` 方法分别以**push** 和 **replace** 两种模式跳转路由，都接收一个配置对象，内容和 **to** 属性中的一样\n\n```html /pages/HomePages/Message.vue\n<button @click=\"pushShow(item)\">push跳转</button>\n<button @click=\"replaceShow(item)\">replace跳转</button>\n<!-- ...... -->\n<script>\n// ......\nmethods: {\n  pushShow(item){\n    this.$router.push({\n      name: 'MessageDetail',\n      params: {\n        id: item.id,\n        title: item.title\n      }\n    })\n  },\n  replaceShow(item){\n    this.$router.replace({\n      name: 'MessageDetail',\n      params: {\n        id: item.id,\n        title: item.title\n      }\n    })\n  }\n}\n// ......\n</script>\n\n```\n\n`$router` 的原型上还有其它方法\n(1) `back()` 后退\n(2) `forward()` 前进\n(3) `go()` 前进或后退几个历史记录\n\n在 vue-router 插件的某些版本，使用编程式路由时，相同路径跳转会报错，在路由配置文件中加上这段代码即可\n\n```js /router/index.js\n// 解决相同路径跳转报错的问题\n//先保存一份VueRouter\nlet originPush = VueRouter.prototype.push;\nlet originReplace = VueRouter.prototype.replace;\n//重写push|replace\n//第一个参数：往哪里跳（传递哪些参数）\nVueRouter.prototype.push = function(location,resolve,reject) {\n    if(resolve && reject) {\n        originPush.call(this,location,resolve,reject);\n    } else {\n        originPush.call(this,location,()=>{},()=>{});\n    }\n}\nVueRouter.prototype.replace = function(location,resolve,reject) {\n    if(resolve && reject) {\n        originReplace.call(this,location,resolve,reject);\n    } else {\n        originReplace.call(this,location,()=>{},()=>{});\n    }\n}\n\n```\n\n# 缓存路由组件\n切换路由，旧的路由组件会被销毁，在该组件中的用户输入等操作都会丢失\n\n要想切换路由不销毁旧的组件，可以将 `<router-view>` 放入 `<keep-alive>` 标签中，**include** 属性指定要缓存的组件名（默认全缓存）\n\n**作用：**让不展示的路由组件保持挂载，不被销毁\n\n```html /pages/Home.vue\n<router-link to=\"/home/message\" active-class=\"active\">Message</router-link>\n<router-link to=\"/home/news\" active-class=\"active\">News</router-link>\n<keep-alive include=\"News-\">\n  <router-view></router-view>\n</keep-alive>\n```\n\n# 两个新钩子\n`<keep-alive>` 给**能被其缓存**的**路由组件**添加了两个新的**生命周期钩子**\n\n(1) `activated()` 路由组件被**激活**时\n(2) `deactivated()` 路由组件**失活**时\n\n**作用：**在 `activated()` 中开启定时器、发AJAX请求等，在 `deactivated()` 中关闭定时器等\n\n# 路由守卫\n**作用：**对路由进行权限控制\n\n**分类：**全局守卫，独享守卫，组件内守卫\n\n在前端业务中，经常有需要配合后端校验权限后才能打开的页面，如个人中心、订单记录等等，通过路由守卫就能在切换路由前，对权限进行校验，然后控制切不切换页面（放行），或跳转到某一页面（登陆页）\n\n所有守卫本质都是**函数**，除了**全局后置守卫**没有第三个参数（next）之外，都有三个参数：\n(1) **to** 要切换的路由对象\n(2) **from** 切换前的路由对象\n(3) **next** 一个函数，无参时切换to的路由，有参时切换到指定路由\n\n三种守卫相互配合实现业务\n\n## 全局守卫\n**全局路由守卫：**监测所有路由的切换，只要切换路由，就会经过全局守卫的业务逻辑\n\n**分类：**\n(1) 全局**前置**守卫：在**切换路由前**触发的守卫\n(2) 全局**后置**守卫：在成功**切换路由后**触发的守卫\n\n**配置全局守卫：**在路由配置文件中，通过路由器上的两个方法配置全局守卫\n(1) `beforeEach(() => {})` 全局**前置**守卫\n(2) `afterEach(() => {})` 全局**前置**守卫\n\n```js\n/* ...... */\n// 全局前置守卫\nrouter.beforeEach((to, from, next) => {\n  console.log('切换路由前');\n  console.log(to);\n  console.log(from);\n  next();\n})\n// 全局后置守卫\nrouter.afterEach((to, from) => {\n  console.log('切换路由后');\n  console.log(to);\n  console.log(from);\n  // 动态地切换网页标题\n  if (to.meta.title) {\n    document.title = to.meta.title;\n  }\n})\n\n```\n\n## 独享守卫\n**独享路由守卫：** `beforeEnter()` 只监测某个路由，要切换到该路由，才触发该守卫\n\n**注意：**独享路由守卫没有后置，只在切换到该路由前触发\n\n```js\n// 创建路由器\nconst router = new VueRouter({\n  routes: [\n    {\n      name: 'About',\n      path: '/about',\n      component: About,\n      meta: {\n        title: '关于'\n      },\n      // 独享路由守卫\n      beforeEnter(to, from, next) {\n        console.log('切换到关于路由前');\n        console.log(to);\n        console.log(from);\n        // 做一些业务，这里让一秒后再切换\n        setTimeout(() => {\n          next();\n        }, 1000);\n      },\n    },\n\n    /* ...... */\n\n  ]\n});\n\n```\n\n## 组件内守卫\n**组件内路由守卫：**只在某一路由组件实例中生效的守卫，控制进入和离开该组件\n\n**分类：**\n(1) `beforeRouteEnter()` 通过路由规则 **要进入该组件前** 触发\n(2) `beforeRouteLeave()` 通过路由规则 **要离开该组件前** 触发\n\n```js\nexport default {\n  name: 'Home-',\n  // 通过路由规则 要进入该组件前 触发\n  beforeRouteEnter(to, from, next){\n    console.log('要进入该组件');\n    console.log(to);\n    console.log(from);\n    next();\n  },\n  // 通过路由规则 要离开该组件前 触发\n  beforeRouteLeave(to, from, next){\n    console.log('要进入该组件');\n    console.log(to);\n    console.log(from);\n    next();\n  }\n}\n\n```\n\n# 路由器两种工作模式\n**路由器有两种工作模式：**\n(1) **hash** 模式：url中带 **#** 号，如 localhost:8080/#/home\n(2) **history** 模式：url中不带 **#** 号 如 localhost:8080/home\n\n**1、hash 模式：**\n1. 对于 url 来说，# 号后面的内容都是 **hash 值**，**不会包含在 HTTP 请求的路径中**，# 号后面的路径只是 vue 路由器工作所需\n2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n3. 兼容性较好，无需后端特地去处理路径问题\n\n**2、history 模式：**\n1. url 样子较符合常理，也美观\n2. 项目上线后，需要后端去分辨前端路由和后端路由，返回不同的资源，解决 vue 这种单页应用程序切换路由后，刷新页面服务端404的问题，\n\n**mode** 配置，指定路由器工作模式\n\n```js\nconst router = new VueRouter({\n  // mode: 'hash',\n  mode: 'history',\n  /* ...... */\n})\n```\n\n**NodeJS-Express** 通过中间件 [connect-history-api-fallback](https://www.npmjs.com/package/connect-history-api-fallback) 自动处理路径问题\n\n# Element-UI\n组件化编码催生出了许多优秀的UI组件库，导入即可使用\n\n以 **Element-UI** 为例，vue2 使用 [Element](https://element.eleme.cn/)，vue3 用 [Element Plus](https://element-plus.gitee.io/)\n\n使用组件库更多的是去看其提供的文档\n\n**安装：** `npm i element-ui -S`\n\n**全部引入：**\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 全部引入\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\n\nVue.config.productionTip = false;\n\n// 使用ElementUI插件\nVue.use(ElementUI);\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n})\n\n```\n\n**按需引入：**\n\n安装 [babel-plugin-component](https://github.com/ElementUI/babel-plugin-component)\n\n修改 **babel.config.js**\n\n```js\nmodule.exports = {\n  presets: [\n    '@vue/cli-plugin-babel/preset',\n    [\"@babel/preset-env\", { \"modules\": false }]\n  ],\n  plugins: [\n    [\n      \"component\",\n      {\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      }\n    ]\n  ]\n}\n\n```\n\n然后就可以按需引入了\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 按需引入\nimport { Button,Row,DatePicker } from 'element-ui';\n\nVue.config.productionTip = false;\n\n// 按需使用\nVue.use(Button);\nVue.use(Row);\nVue.use(DatePicker);\n\nnew Vue({\n    el: \"#app\",\n    render: h => h(App),\n})\n\n```\n\n**使用组件：**看文档，cv使用组件标签\n\n```html\n<el-button type=\"primary\">主要按钮</el-button>\n<el-date-picker\n  type=\"date\"\n  placeholder=\"选择日期\">\n</el-date-picker>\n```\n\n# 项目上线\n**打包：**`npm run build` 生成 **dist** 文件夹\n\n将打包出的文件部署到服务端，交给后端去搞\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[四]-动画、Vuex","url":"/article/4c286eee.html","content":"\n# 过渡与动画\nVue 封装了过渡与动画效果\n\n**作用：**在**插入**、**更新**、**移除** Dom 元素时，自动在合适的时刻在**过渡标签**上**添加**或**移除不同的类名**，只需写动画和过渡效果并应用到**对应时刻的类名**上，而无需手动操作 Dom \n\n**过渡标签：**\n(1) `<transition>` 包裹需要动画效果的**单个**元素\n(2) `<transition-group>` 包裹需要动画效果的**多个**元素，每个元素都需要配置 **Key** 属性\n\n**不同时刻样式类名：**\n(1) 控制元素**进入**的样式\n1. **v-enter** 进入的起点\n2. **v-enter-active** 进入过程中\n3. **v-enter-to** 进入的终点\n\n(2) 控制元素**离开**的样式\n1. **v-leave** 离开的起点\n2. **v-leave-active** 离开过程中\n3. **v-leave-to** 离开的终点\n\n过渡标签添加 **name** 属性来配置**类名的前缀**，默认是 **v**，如进入起点的类名是 **.v-enter** 或 **<前缀>-enter**\n\n**离开和进入：**即元素的**插入**、**更新**、**移除**，通常配合 **v-show**、**v-if** 来控制\n\n添加 `appear` 属性让动画在网页首次加载时、元素首次插入时也触发\n\n## 元素飞入飞出案例\n\n分别用**动画属性** `animate` 和**过渡属性** `transition` 配合不同的类名实现**相同的**动画效果\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-2.gif width=\"200px\" loading=\"lazy\">\n\n**模板结构：**\n\n```html\n<template>\n  <div>\n    <button @click=\"isShow=!isShow\">显示隐藏</button>\n    <transition name=\"hello\" appear>\n      <h1 v-show=\"isShow\" class=\"title\">你好</h1>\n    </transition>\n  </div>\n</template>\n```\n\n**交互：**\n\n```js\nexport default {\n  name: 'Test-',\n  data(){\n    return{\n      isShow: true,\n    }\n  }\n}\n```\n\n使用**动画属性** `animate` 配合 **.v-enter-active** 和 **.v-leave-active**\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n/* 进入过程的动画 */\n.hello-enter-active{\n  animation: titleShow 1s;\n}\n/* 离开过程的动画 */\n.hello-leave-active{\n  animation: titleShow 1s reverse;\n}\n/* 动画 */\n@keyframes titleShow{\n  from {\n    transform: translateX(-100%);\n  }\n  to{\n    transform: translateX(0px);\n  }\n}\n\n```\n\n**过渡属性** `transition` 配合进入和离开的起点、终点的样式实现动画\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n/* 设置进入起点的样式 */\n.hello-enter {\n  transform: translateX(-100%);\n}\n/* 设置进入终点的样式 */\n.hello-enter-to {\n  transform: translateX(0);\n}\n/* 设置离开起点的样式 */\n.hello-leave {\n  transform: translateX(0);\n}\n/* 设置离开终点的样式 */\n.hello-leave-to {\n  transform: translateX(-100%);\n}\n/* 设置 transition 属性 */\n.hello-enter-active, .hello-leave-active {\n  transition: 0.5s linear;\n}\n\n```\n\n## 第三方动画库\n有许多优秀的动画库，引入即可使用，以 [animate.css](https://www.npmjs.com/package/animate.css) 为例\n\n**安装：**`npm install animate.css --save`\n\n使用第三方库时，通常要在**过渡标签**上通过几个属性来自定义**样式类名的后缀**，name属性设置前缀\n(1) **enter-active-class** 属性：设置**进入过程中**的样式类名\n(2) **leave-active-class** 属性：设置**离开过程中**的样式类名\n\n**使用：**引入动画库后，在**过渡标签**上设置name前缀以使用该动画库，然后在[animate.css文档](https://animate.style/)中挑选动画效果，将进入动画的类名设置到 **enter-active-class** 属性中，离开动画的类名设置到 **leave-active-class** 属性中，通过**设置样式类名**后缀来使用具体的动画效果\n\n**案例：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-3.gif\" loading=\"lazy\">\n\n```js\n// 引入动画库\nimport 'animate.css'\nexport default {\n  name: 'Test-',\n  data() {\n    return {\n      isShow: true,\n    }\n  }\n}\n```\n\n**模板结构：**\n\n```html\n<template>\n  <div>\n    <button @click=\"isShow = !isShow\">显示隐藏</button>\n    <!-- 设置动画 -->\n    <!-- name设置前缀表示使用animate.css动画库 -->\n    <!-- 通过设置样式类名后缀来使用具体的动画效果 -->\n    <transition \n      name=\"animate__animated animate__bounce\" \n      enter-active-class=\"animate__swing\"\n      leave-active-class=\"animate__backOutUp\" \n      appear\n    >\n      <h1 v-show=\"isShow\" class=\"title\" key=\"1\">你好</h1>\n    </transition>\n  </div>\n</template>\n```\n\nCSS 样式，因为使用了动画库，就无需自己写动画了\n\n```css\n.title {\n  background: rgb(114, 196, 219);\n}\n```\n\n# ToDoList添加动画\n给 ToDoList 案例中每个todo  的新增和删除添加动画\n\n**效果：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-4.gif\" width=\"70%\" loading=\"lazy\">\n\n修改 **ToDoList.vue** 组件\n\n```html\n<template>\n  <div class=\"todo-list\">\n    <ul>\n      <transition-group name=\"todo\">\n        <ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\"></ListItem>\n      </transition-group>\n    </ul>\n  </div>\n</template>\n\n<!-- ...... -->\n\n<style>\n/* ........ */\n/* 动画 */\n.todo-enter,\n.todo-leave-to {\n  opacity: 0;\n  transform: translateX(-50%);\n}\n\n.todo-enter-to,\n.todo-leave {\n  opacity: 1;\n  transform: translateX(0);\n}\n.todo-enter-active, .todo-leave-active {\n    transition: all 0.3s;\n}\n</style>\n\n```\n\n# Vue中发请求\n在 Vue 中发请求通常用 [Axios](https://github.com/axios/axios)\n\n**安装：** `npm i axios`\n\nAxios 笔记: [AJAX请求相关-Axios](/article/f3334fd0.html#Axios)\n\n## Vue-cli配置代理\n当后端没有配置 **cors** 时，本地开发环境请求后端API就会产生**跨域**问题\n\n服务器之间通信没有跨域问题，可以在本地配置一个代理服务器去请求API\n\n在 **vue.config.js** 中添加 **devServer** 配置项，以在开发环境下将 API 请求代理到 API 服务器\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n    proxy: '<转发的url>' \n  }\n})\n```\n\n配置代理后，将请求的 baseURL 改为本地ip+端口，如 120.0.0.1:8080，代理服务会将请求转发，自己去请求实际的API地址，然后返回数据\n\n有些时候并不想所有发往自身获取资源的请求都被代理转发，实际想获取的是本地public文件夹下的资源，而不是远程API的\n\n可以写完整版 devServer 配置，匹配路径去选择性代理\n\n**作用：**可以配置多个代理，且可以灵活的控制发往本地的请求是否走代理转发\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n    proxy: {\n      // 匹配路径代理\n      '/api': {\n        target: '<url>', // 代理目标的baseURL\n        ws: true, // 用于支持websocket\n        changeOrigin: true, // 伪造Host为代理目标baseURL\n        pathRewrite: {'<正则匹配路径>', '<替换内容>'} // 重写路径\n      },\n      '/foo': {\n        target: '<other_url>'\n      }\n    }\n  }\n})\n\n```\n\n~~还是让后端配cors好~~\n\n## 获取所有账单\n在 NodeJS 中写过一个记账本案例，里面写了一套完整的 API，刚好拿来用\n\n[KeepingBook-API文档](https://console-docs.apipost.cn/preview/3d8ecc659c1e192b/da97e0b2ec13fd71)\n\n**功能：**点击登陆提示登陆中，登陆成功提示成功登陆，点击获取账单，提示加载中，请求成功后展示所有账单的列表\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-5.gif\" loading=\"lazy\">\n\n```html App.vue\n<template>\n  <div>\n    <button @click=\"login\">登录获取token</button>\n    <button @click=\"getData\">获取所有账单</button>\n    <!-- 提示 -->\n    <div v-show=\"tip !== ''\" class=\"tip\">{{ tip }}</div>\n    <ul>\n      <li v-for=\"(item, index) in kpb\" :key=\"item.id\">\n        {{ index + 1 }}： {{ item.matter }} | {{ item.date }} | {{ item.type }} | {{ item.account }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport axios from \"axios\";\naxios.defaults.baseURL = 'https://kpb.qcqx.cn';\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      // 登陆返回的token\n      token: \"\",\n      // 账单数据\n      kpb: \"\",\n      // 提示\n      tip: \"欢迎，请登陆\",\n    }\n  },\n  methods: {\n    // 登陆\n    login() {\n      this.kpb = \"\";\n      this.tip = \"登陆中....\";\n      axios({\n        url: '/api/login',\n        method: 'post',\n        data: {\n          username: 'qx',\n          password: '123'\n        },\n        // 请求超时\n        timeout: 5000\n      }).then(res => {\n        // 响应体对象\n        console.log(res.data);\n        this.token = res.data.data.token;\n        this.tip = \"登陆成功\";\n      }).catch(err => {\n        console.log(err);\n        this.tip = \"登陆失败\";\n      });\n    },\n    // 获取账单\n    getData() {\n      this.kpb = \"\";\n      this.tip = \"账单加载中....\";\n      axios({\n        url: '/api',\n        method: 'get',\n        headers: {\n          token: this.token\n        },\n        // 请求超时\n        timeout: 5000\n      }).then(res => {\n        // 响应体对象\n        console.log(res.data);\n        if (res.data.data === null) {\n          this.tip = res.data.msg;\n          return;\n        }\n        this.kpb = res.data.data;\n        this.tip = \"\";\n      }).catch(err => {\n        console.log(err);\n        this.tip = \"获取账单失败\";\n      });\n    }\n  }\n};\n</script>\n\n```\n\n# 插槽\n**插槽**是由**子组件**在模板的合适位置通过 `<slot>` 定义的\n\n**作用：**让父组件可以向子组件定义的**插槽**处插入 html 结构\n\n**插槽的种类：**\n(1) **默认插槽：**简单地将组件标签中所有html结构放到插槽处\n(2) **具名插槽：**通过 `<slot>` 上的 **name** 属性区分插槽，通过 `v-slot:<插槽名>` 将html插入到指定插槽\n(3) **作用域插槽：**用于**数据在子组件**中，且不将数据外传，根据数据生成的结构由父组件决定的情况\n\n**注意：**\n(1) 父组件中要插入插槽的html结构也是在父组件中完成模板解析的，可以访问父组件中的数据，而不能直接访问到自组件的数据\n(2) 三种插槽可以混合使用\n\n## 默认插槽\n简单地将组件标签中所有html结构放到插槽处\n\n```html 父组件\n<ListBox>\n  <ul>\n    <li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li>\n  </ul>\n</ListBox>\n```\n\n```html 子组件\n<!-- 定义插槽 -->\n<slot></slot>\n```\n\n## 具名插槽\n通过 `<slot>` 上的 **name** 属性区分插槽，通过 `v-slot:<插槽名>` 将html插入到指定插槽\n\n`v-slot:` 可以简写为 `#`\n\n```html 父组件\n<ListBox>\n  <template v-slot:list>\n    <ul><li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li></ul>\n  </template>\n  <!-- v-slot: 简写为 # -->\n  <template #other>\n    <h2>chuckle</h2>\n  </template>\n</ListBox>\n\n```\n\n```html 子组件\n<slot name=\"list\"></slot>\n<slot name=\"other\"></slot>\n```\n\n## 作用域插槽\n用于**数据在子组件**中，且不将数据外传，根据数据生成的结构由父组件决定的情况\n\n子组件通过 `<slot>` 的标签属性传数据给父组件（只能在组件标签中使用）\n父组件通过 `#<插槽名>=\"obj\"` 的 obj 接收一个**对象**，对象中有传过来的属性名和属性值（数据）\n\n```html 父组件\n<ListBox>\n  <!-- default代表无名插槽 -->\n  <template #default=\"{arr}\">\n    <ul><li v-for=\"(item, index) in arr\" :key=\"index\">{{ item }}</li></ul>\n  </template>\n  <!-- v-slot接收到的是一个对象 -->\n  <template #other=\"obj\">\n    <div>{{ obj.x }} | {{ obj.y }}</div>\n  </template>\n</ListBox>\n\n```\n\n```html 子组件\n<!-- 将子组件的数据传给父组件内的组件标签中使用 -->\n<slot :arr=\"arr\"></slot>\n<!-- 传给父组件多个数据 -->\n<slot name=\"other\" :x=\"x\" :y=\"y\"></slot>\n```\n\n# Vuex\n在实现**组件间通信**时，无论是**全局事件总线**还是**消息订阅与发布**，大量的声明事件或消息名，会让代码变得臃肿、难以维护\n\n[Vuex](https://github.com/vuejs/vuex) 是实现**集中式状态（数据）管理**的一个 Vue 插件，对 Vue 应用中多个组件的**共享状态**进行集中式的管理（读/写）\n\n**安装：** `npm install vuex --save` Vue2 只能使用 Vuex3\n\n**功能：**将原本某一组件管理的数据拿出来给 Vuex 管理，所有组件都能看到 Vuex 中管理数据的仓库 **Store**，以及使用仓库所提供的，对数据读和写的方法\n\n**何时用 Vuex 管理状态（数据）：**\n(1) 多个组件依赖于同一状态\n(2) 来自不同组件的行为需要变更同一状态\n\n## Vuex工作原理\n**Vuex 工作原理图：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-7.webp\" loading=\"lazy\">\n\nVuex 有**三个重要组成部分**，这三个部分都在 **Store** 实例上，本质都是**对象**\n1. **Actions：**进行一些业务逻辑（异步）的操作，如发送 AJAX 请求，不直接对数据进行操作\n2. **Mutations：**对数据进行直接的维护，有许多对数据进行操作的自定义方法\n3. **State：**状态（数据），存放着多个组件共享的数据\n\n**Vuex的工作循环：**\n1. 组件通过 `dispatch()` 调用 **Actions** 中的方法，触发一些业务逻辑\n2. **Actions** 中业务逻辑处理完后，在合适时机调用 `commit()` 触发 **Mutations** 中对数据进行直接操作的方法\n3. 然后 **State** 中数据**响应式**地变化，触发对应**视图更新**\n\n**注意：**如果对数据的操作不带有更多的业务逻辑，组件也可以直接调用 `commit()` 方法\n\n**Store：**由 `Vuex.Store()` 构造函数创建，提供了三个重要组成部分以及 `dispatch()` 、`commit()` 等各种API\n\n## 搭建Vuex环境\n新建一个JS文件，用于配置和创建 Store 实例，通常是 `src/store/index.js`\n\n```js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 创建三个重要组成部分\nconst actions = {}\nconst mutations = {}\nconst state = {}\n\n// 创建store实例，并暴露出去\nexport default new Vuex.Store({\n  // 将三个重要部分都交给store管理\n  actions,\n  mutations,\n  state\n});\n\n```\n\n然后在 `new Vue()` 时将 **Store** 实例作为配置项传入\n\n**目的：**让 vm 和 vc 身上新增一个 **$store** 属性，让所有组件都能访问到数据仓库 **store**\n\n```js main.js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 引入store实例\nimport store from \"./store\";\n\nVue.config.productionTip = false;\n\nnew Vue({\n    el: \"#app\",\n    // 使用store\n    store,\n    render: h => h(App),\n})\n\n```\n\n## 纯Vue求和案例\n\n<img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/56-6.webp\" loading=\"lazy\">\n\n```html App.vue\n<template>\n  <div>\n    <CountNum></CountNum>\n  </div>\n</template>\n\n<script>\nimport CountNum from \"./components/CountNum.vue\";\nexport default {\n  name: \"App\",\n  components: {\n    CountNum,\n  }\n};\n</script>\n\n```\n\n```html\n<template>\n  <div>\n    <h3>{{ sum }}</h3>\n    <select v-model.number=\"num\">\n      <option value=\"1\">1</option>\n      <option value=\"2\">2</option>\n      <option value=\"3\">3</option>\n    </select>\n    <button @click=\"add\">+</button>\n    <button @click=\"reduce\">-</button>\n    <button @click=\"addOdd\">当前总和是奇数再加</button>\n    <button @click=\"addWait\">延迟1s再加</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"CountNum\",\n  data() {\n    return {\n      // 总和\n      sum: 0,\n      // 选择的数字\n      num: 0,\n    }\n  },\n  methods: {\n    // 加\n    add() {\n      this.sum += this.num;\n    },\n    // 减\n    reduce(){\n      this.sum -= this.num;\n    },\n    // 当前总和是奇数再加\n    addOdd(){\n      if(this.sum%2){\n        this.sum += this.num;\n      }\n    },\n    // 延迟1s再加\n    addWait(){\n      setTimeout(()=>{\n        this.sum += this.num;\n      }, 1000)\n    }\n  },\n}\n</script>\n\n```\n\n## Vuex版求和案例\n对纯 Vue 版进行修改，将 sum 交给 vuex 的 store 管理，将直接对数据的操作放到 Mutations 中，将带有业务逻辑的操作放到 Actions 中\n\n**一些总结与注意：**\n1. 虽然 `$store.state.xxx = xxx` 直接修改数据，也能响应式更新视图，但这样做无法被 vuex-tools 所监视，所以**不要直接修改数据** \n2. `commit()` 和 `dispatch()` 都只能传入两个参数，第一个是要触发的**函数名**，第二个是传入的数据\n3. **actions** 中的函数收到两个参数，第一个 **context** 指上下文，是一个 mini 的 store，有部分 store 上的属性和方法，第二个 **value** 是 `dispatch()` 传来的数据\n4. **mutations** 中的函数也收到两个参数，第一个 **state** 是 store 中的数据，第二个 **value** 是 `commit()` 传来的数据\n\n```html CountNum.vue\n<template>\n  <div>\n    <!-- 通过vc身上的$store.state获取数据 -->\n    <h3>{{ $store.state.sum }}</h3>\n    <select v-model.number=\"num\">\n      <option value=\"1\">1</option>\n      <option value=\"2\">2</option>\n      <option value=\"3\">3</option>\n    </select>\n    <button @click=\"add\">+</button>\n    <button @click=\"reduce\">-</button>\n    <button @click=\"addOdd\">当前总和是奇数再加</button>\n    <button @click=\"addWait\">延迟1s再加</button>\n    <button @click=\"$store.state.sum = 1\">测试直接修改数据</button>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"CountNum\",\n  data() {\n    return {\n      // 选择的数字\n      num: 0,\n    }\n  },\n  methods: {\n    // 加\n    add() {\n      // 传入函数名去匹配对数据的操作和选择的数字\n      this.$store.commit('add', this.num)\n    },\n    // 减\n    reduce(){\n      this.$store.commit('reduce', this.num)\n    },\n    // 当前总和是奇数再加\n    addOdd(){\n      this.$store.dispatch('addOdd', this.num)\n    },\n    // 延迟1s再加\n    addWait(){\n      this.$store.dispatch('addWait', this.num)\n    }\n  },\n}\n</script>\n\n```\n\n```js /store/index.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 有业务逻辑的操作放在actions中\nconst actions = {\n  // context：上下文，一个mini都store，有store中的部分属性和方法\n  // value，组件中dispatch()传过来的值\n  addOdd(context, value) {\n    if (context.state.sum % 2) {\n      // 业务逻辑处理完后调用上下文中的commit()\n      context.commit('add', value);\n    }\n  },\n  addWait(context, value) {\n    setTimeout(() => {\n      context.commit('add', value);\n    }, 1000)\n  }\n}\n\n// 没有业务逻辑的操作放在mutations中\nconst mutations = {\n  // mutations中的函数收到两个参数\n  // state：store中的数据，value：commit()传过来的值\n  add(state, value) {\n    state.sum += value;\n  },\n  reduce(state, value) {\n    state.sum -= value;\n  },\n}\n\nconst state = {\n  // 数据\n  sum: 0,\n}\n\n// 创建store实例\nexport default new Vuex.Store({\n  actions,\n  mutations,\n  state\n});\n\n```\n\n## getters配置项\n除了三个重要组成部分必须作为 Store 的配置项之外，还有其它配置项\n\ngetters 和计算属性差不多，对数据进行加工后再返回，其中的函数收到一个参数 state\n\n```js\n// 准备getters\nconst getters = {\n  // 对sum进行放大10倍\n  bigSum(state){\n    return state.sum * 10;\n  }\n}\nexport default new Vuex.Store({\n  actions,\n  mutations,\n  state,\n  // 配置getters\n  getters\n});\n\n```\n\n通过 `$store.getters` 获取加工后的数据\n\n```html\n<h3>{{ $store.state.sum }}</h3>\n<h3>{{ $store.getters.bigSum }}</h3>\n```\n\n## mapState和mapGetters\n当一个组件需要获取**多个状态**时，总在模板中用 `$store.state.xxx` 获取状态，代码重复且冗余\n\n即使是手动写成**计算属性**，也要重复去 `return $store.state.xxx`\n\n`mapState()` 和 `mapGetters()` 可以帮我们**生成状态的计算属性**，以此简洁地使用状态\n\n需要引入后才能使用：\n\n```js\nimport { mapState, mapGetters} from 'vuex'\n```\n\n**使用注意：**\n1. 传入一个对象，key-value 是 `<生成的计算属性名>:<状态名或getter名>`\n2. 返回值是包含多个计算属性的对象，需要用 `...` 对象展开运算符，将其与组件的计算属性对象合并\n\n```js\n// \nimport { mapState, mapGetters} from 'vuex'\nexport default {\n  /* .... */\n  computed: {\n    test(){\n      return 'test'\n    },\n    // 对象展开运算符\n    ...mapState({\n      sum: 'sum'\n    }),\n    ...mapGetters({\n      bigSum: 'bigSum'\n    })\n  },\n  /* .... */\n}\n\n```\n\n当要**生成的计算属性名**和**状态名或getter名**一样时，可以使用数组简写形式，传入数组，元素是**状态名或getter名**\n\n```js\nmapState(['sum'])\n```\n\n## mapActions和mapMutations\n在 methods 中也写了很多看起来重复的代码\n\n```js\n// 加\nadd() {\n  // 传入函数名去匹配对数据的操作和选择的数字\n  this.$store.commit('add', this.num)\n},\n// 减\nreduce(){\n  this.$store.commit('reduce', this.num)\n},\n// 当前总和是奇数再加\naddOdd(){\n  this.$store.dispatch('addOdd', this.num)\n},\n// 延迟1s再加\naddWait(){\n  this.$store.dispatch('addWait', this.num)\n}\n```\n\n`mapActions()` 和 `mapMutations()` 能够生成调用 commit 和 dispatch 方法的方法\n\n用法和 mapState 和 mapGetters 差不多\n\n```js\nmethods: {\n  ...mapMutations(['add', 'reduce']),\n  ...mapActions({\n    addOdd: 'addOdd',\n    addWait: 'addWait'\n  }),\n},\n```\n\n生成的方法长这样，需要传入一个value\n\n```js\nadd(value){\n  this.$store.commit('add', value)\n}\n```\n\n所以调用时就需要手动传入 value\n\n```html\n<!-- 手动传入加数num -->\n<button @click=\"add(num)\">+</button>\n<button @click=\"reduce(num)\">-</button>\n<button @click=\"addOdd(num)\">当前总和是奇数再加</button>\n<button @click=\"addWait(num)\">延迟1s再加</button>\n```\n\n## Vuex模块化\n不同的功能会用到不同的数据，当很多实现不同功能的数据都写在一个 index.js 中或一个配置项中时，会导致命名冲突且代码不易维护\n\n**作用：**让代码更好维护，让多种数据分类更加明确\n\n将不同数据的 store 配置项单独拿出，每个模块的函数获取的数据或上下文都是模块自己的，无需再指定，即**模块的局部状态**\n\n```js /store/count.js\nexport default {\n  // 开启命名空间\n  namespaced: true,\n\n  actions: {\n    // context：上下文，一个mini都store，有store中的部分属性和方法\n    // value，组件中dispatch()传过来的值\n    addOdd(context, value) {\n      if (context.state.sum % 2) {\n        context.commit('add', value);\n      }\n    },\n    addWait(context, value) {\n      setTimeout(() => {\n        context.commit('add', value);\n      }, 1000)\n    }\n  },\n\n  mutations: {\n    // mutations中的函数收到两个参数\n    // state：store中的数据，value：commit()传过来的值\n    add(state, value) {\n      state.sum += value;\n    },\n    reduce(state, value) {\n      state.sum -= value;\n    },\n  },\n\n  state: {\n    sum: 0,\n  },\n\n  getters: {\n    bigSum(state) {\n      return state.sum * 10;\n    }\n  }\n}\n\n```\n\n通过 `Store()` 的 **modules** 配置项使用模块\n\n```js /store/index.js\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n// 使用vuex插件\nVue.use(Vuex);\n\n// 导入求和案例配置\nimport count from \"./count.js\";\n\n// 创建store实例\nexport default new Vuex.Store({\n  modules: {\n    // 使用模块\n    count,\n  }\n});\n\n```\n\n调整 `mapState()`、`mapGetters()` 等的参数，指定是触发哪个模块的 **actions** 或 **mutations**\n\n```js\ncomputed: {\n  ...mapState('count',['sum']),\n  ...mapGetters('count',['bigSum'])\n},\nmethods: {\n  ...mapMutations('count',['add', 'reduce']),\n  ...mapActions('count',['addOdd', 'addWait']),\n},\n```\n\n**总结：**\n**(1)** **命名空间：**默认情况下，模块内部的 action、mutation 和 getter 注册在**全局命名空间**，这样使得多个模块能够对同一个 mutation 或 action 作出响应。如果希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。\n\n**(2)** **开启命名空间后：**\n1. 组件中读取 state 数据\n```js\n// 方式一：直接读取\nthis.$store.count.sum\n// 方式二：借助mapState\n...mapState('count',['sum'])\n```\n2. 组件中读取 getters 数据\n```js\n// 方式一：直接读取\nthis.$store.getters['count/bigSum']\n// 方式二：借助mapGetters\n...mapGetters('count',['bigSum'])\n```\n3. 组件中调用 dispatch\n```js\n// 方式一：直接读取\nthis.$store.dispatch('count/addOdd', value)\n// 方式二：借助mapActions\n...mapActions('count',['addOdd', 'addWait']),\n```\n4. 组件中调用 commit\n```js\n// 方式一：直接读取\nthis.$store.commit('count/add', value)\n// 方式二：借助mapActions\n...mapMutations('count',['add', 'reduce']),\n```\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[三]-ToDoList","url":"/article/f82307c5.html","content":"\n# 查看和运行\n[github仓库](https://github.com/qxchuckle/ToDoList-Vue)\n\n在1024code上在线查看和运行[ToDoList-Vue](https://1024code.com/codecubes/0vj8mqd)\n\n# 组件化编码流程\n**组件化编码流程:**\n1. **实现静态组件：**设计页面，根据**功能**或**区域**分割页面板块设计组件，使用组件实现静态页面效果\n2. **展示动态数据：**设计每个组件应有的数据，以及数据之间的联系，将数据样例应用到组件中\n3. **交互**从绑定事件监听开始\n\n# ToDoList\n**页面设计与组件：**\n\n将页面整体分为三大块，header（头部）、list（内容）、footer（尾部）\n\nlist 中重复的部分提取为 item 组件\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/55-2.webp width=\"80%\" loading=\"lazy\">\n\n# 实现静态组件\n写好静态页面和样式\n\n```html App.vue\n<template>\n  <div id=\"app\">\n    <div id=\"todo-container\">\n      <div id=\"todo-wrap\">\n        <ToDoHeader></ToDoHeader>\n        <ToDoList></ToDoList>\n        <ToDoFooter></ToDoFooter>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport ToDoHeader from \"./components/ToDoHeader.vue\";\nimport ToDoList from \"./components/ToDoList.vue\";\nimport ToDoFooter from \"./components/ToDoFooter.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    ToDoHeader,\n    ToDoList,\n    ToDoFooter,\n  },\n};\n</script>\n\n<style lang=\"less\">\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nul {\n  list-style: none;\n}\n\n#app {\n  margin: 20px 10px;\n  font-size: 16px;\n}\n\n#todo-container {\n  max-width: 600px;\n  min-width: 300px;\n  height: auto;\n  margin: 0 auto;\n  padding: 10px;\n  border: @todo-border;\n  border-radius: @todo-border-radius;\n\n  #todo-wrap {\n    width: 100%;\n  }\n\n}\n</style>\n\n```\n\n```html ToDoHeader.vue\n<template>\n    <div class=\"todo-header\">\n        <input type=\"text\" placeholder=\"回车新增ToDo\" />\n        <button>新增</button>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: \"ToDoHeader\",\n};\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n.input-focus {\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),\n        0 0 8px rgba(82, 168, 236, 0.6);\n    border-color: rgba(82, 168, 236, 0.8);\n    outline: none;\n}\n\n.todo-header {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    margin-bottom: 15px;\n\n    input {\n        width: 100%;\n        font-size: 16px;\n        padding: 8px 10px;\n        border: @todo-border;\n        border-radius: @todo-border-radius;\n\n        &:focus {\n            .input-focus();\n        }\n    }\n\n    button {\n        margin-left: 10px;\n        width: 65px;\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        background: rgb(52, 201, 238);\n        font-size: 16px;\n        color: #fff;\n    }\n\n}\n</style>\n\n```\n\n```html ToDoList.vue\n<template>\n  <div class=\"todo-list\">\n    <ul>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n      <ListItem></ListItem>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport ListItem from \"./ListItem.vue\";\nexport default {\n  name: \"ToDoList\",\n  components: {\n    ListItem,\n  },\n};\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n.todo-list {\n  margin-bottom: 15px;\n  border-radius: @todo-border-radius;\n  border: @todo-border;\n}\n</style>\n\n```\n\n```html ListItem.vue\n<template>\n    <li>\n        <label>\n            <input type=\"checkbox\">\n            <span>这是一个ToDo</span>\n        </label>\n        <button class=\"list-item-btn\">删除</button>\n    </li>\n</template>\n\n<script>\nexport default {\n    name: 'ListItem',\n}\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\nli {\n    border-bottom: @todo-border;\n    display: flex;\n    height: 38px;\n    line-height: 37px;\n    justify-content: space-between;\n\n    &:last-child{\n        border-bottom: none;\n    }\n\n    label {\n        margin-left: 10px;\n\n        input {\n            top: -1px;\n            position: relative;\n            vertical-align: middle;\n            margin-right: 10px;\n        }\n    }\n\n    button {\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        font-size: 14px;\n        margin: 5px;\n        padding: 0 5px;\n        background: #dc7878;\n        color: #fff;\n    }\n}\n</style>\n\n```\n\n```html ToDoFooter.vue\n<template>\n    <div id=\"todo-footer\">\n        <input type=\"checkbox\">\n        <div class=\"statistics\">已完成0 / 全部4</div>\n        <button>清除已完成</button>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'ToDoFooter',\n}\n</script>\n\n<style lang=\"less\" scoped>\n@todo-border: 1px solid #ccc;\n@todo-border-radius: 6px;\n\n#todo-footer {\n    width: 100%;\n    height: 40px;\n    line-height: 40px;\n    padding-left: 10px;\n\n    input {\n        top: 1px;\n        position: relative;\n    }\n\n    .statistics {\n        width: fit-content;\n        display: inline-block;\n        margin-left: 20px;\n    }\n\n    button {\n        float: right;\n        padding: 5px 10px;\n        margin: 5px 0;\n        border-radius: @todo-border-radius;\n        border: @todo-border;\n        color: #fff;\n        background: rgb(220, 120, 120);\n        font-size: 15px;\n    }\n}\n</style>\n\n```\n\n# 设计数据\n数据在 List 中展示，所以下面操作 **ToDoList.vue** 组件\n\n有许多todo，而每个todo都有许多属性，如内容、是否完成、以及唯一标识该 todo 的id\n\n所以数据的结构应该是这样：\n\n```\ntodos: [\n    {\n      id: \"001\",\n      title: \"第一件事\",\n      complete: false\n    },\n    {\n      id: \"002\",\n      title: \"第二件事\",\n      complete: true\n    },\n    {\n      id: \"003\",\n      title: \"第三件事\",\n      complete: false\n    }\n  ],\n}\n\n```\n\n有了动态的数据，使用 **v-for** 遍历数据，将原来写死的模板替换掉，\n\n并且将遍历的每个 todo 通过**组件标签**传给子组件 **ToDoItem.vue**\n\n```html ToDoList.vue\n<ul>\n  <ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\"></ListItem>\n</ul>\n```\n\n子组件使用 **props** 接收父组件传来的 **todo** 进行内容展示\n\n```html ToDoItem.vue\n<template>\n    <li>\n        <label>\n            <input type=\"checkbox\" :checked=\"todo.complete\">\n            <span>{{ todo.title }}</span>\n        </label>\n        <button class=\"list-item-btn\">删除</button>\n    </li>\n</template>\n\n<script>\nexport default {\n    name: 'ListItem',\n    props: ['todo'],\n}\n</script>\n\n```\n\n# 完善添加功能\nvue 是以**数据驱动**的，所以不应该直接操控dom，而是让数据发生变化，触发视图的更新\n\n添加一个todo分为两步：\n1. 按下回车或按钮时获取输入框的内容\n2. 将获取到的内容添加到 **ToDoList.vue** 组件 data 中的 **todos** 数组中\n\n## 获取输入框内容\n这里还是要写点原生js代码的，但不多\n\n```html ToDoHeader.vue\n<template>\n    <div class=\"todo-header\">\n        <input type=\"text\" placeholder=\"回车新增ToDo\" @keyup.enter=\"addToDo\"/>\n        <button @click=\"addToDo\">新增</button>\n    </div>\n</template>\n\n<script>\nimport {nanoid} from \"nanoid\";\nexport default {\n    name: \"ToDoHeader\",\n    methods: {\n        addToDo(e){\n            // 获取input框元素\n            let input = e.target.tagName === \"INPUT\" ? e.target : e.target.parentNode.firstElementChild\n            // 输入框为空返回\n            if(input.value === \"\"){\n                return\n            }\n            // 生成数据对象\n            let todo = {\n                // 正常来说数据由后端返回，id由数据库维护，这里使用nanoid生成唯一id\n                id: nanoid(),\n                title: input.value,\n                complete: false\n            }\n            // 清空input\n            input.value = \"\";\n            console.log(todo);\n        }\n    }\n};\n</script>\n\n```\n\n## 修改todos数组\n通过 **props** 子组件能接收父组件传来的数据，但现在 **ToDoHeader.vue** 与 **ToDoList.vue** 是兄弟组件\n\n实现兄弟组件之间的通信有很多种办法：全局事件总线、消息对外发布、vuex等\n\n这些高级的办法后面再学，现在先用一种老办法：让兄弟组件共同的父组件（App.vue）去管理数据（todos），通过 **props** 传数据给子组件使用，父组件通过传一个函数来接收子组件的数据（让子组件在合适时候调用该接口函数，并传入父组件所需的数据）\n\n修改 App.vue：\n\n```html App.vue\n<template>\n  <div id=\"app\">\n    <div id=\"todo-container\">\n      <div id=\"todo-wrap\">\n        <!-- 将接口函数传给子组件 -->\n        <ToDoHeader :receive=\"receive\"></ToDoHeader>\n        <!-- 将todo数据传给list组件使用 -->\n        <ToDoList :todos=\"todos\"></ToDoList>\n        <ToDoFooter></ToDoFooter>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport ToDoHeader from \"./components/ToDoHeader.vue\";\nimport ToDoList from \"./components/ToDoList.vue\";\nimport ToDoFooter from \"./components/ToDoFooter.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    ToDoHeader,\n    ToDoList,\n    ToDoFooter,\n  },\n  data(){\n    return {\n      todos: [\n        {\n          id: \"001\",\n          title: \"第一件事\",\n          complete: false\n        },\n        {\n          id: \"002\",\n          title: \"第二件事\",\n          complete: true\n        },\n        {\n          id: \"003\",\n          title: \"第三件事\",\n          complete: false\n        }\n      ],\n    }\n  },\n  methods: {\n    // 接口函数，让子组件在合适时候调用，并传入父组件所需的数据\n    receive(value){\n      // 操控数组数据\n      this.todos.unshift(value);\n    }\n  }\n};\n</script>\n\n```\n\n## 自定义事件与$emit()\n子组件调用父组件的函数，以**向父组件传数据**，更规范的做法是用**组件的自定义事件**\n\n**用法：**父组件给子组件实例绑定一个**自定义事件**，并且**指定回调**（父组件中的函数），子组件在合适的时候 使用 `$emit()` 触发该自定义事件，并且给该事件的回调函数传入所需的参数，以此实现**子组件向父组件传数据**\n\n```html\n<!-- 父组件绑定一个事件 -->\n<ToDoHeader @receive=\"receive\" ></ToDoHeader>\n<script>\nexport default {\n  methods: {\n    // 事件回调函数\n     receive(value){\n       // 操控数组数据\n       this.todos.unshift(value);\n     }\n  }\n}\n</script>\n\n<!-- 子组件也有一个自己的事件 -->\n<button @click=\"addToDo\">新增</button>\n<script>\nexport default {\n  methods: {\n    addToDo(e){\n      let todo = {}\n      // 去触发父组件的receive事件，并向receive事件的回调函数传入todo对象作为参数\n      this.$emit('receive',todo)\n    }\n  }\n}\n</script>\n\n```\n\n当一个子组件要绑定**多个**事件时，在组件标签上写太多绑定就过于臃肿了，可以使用 `$refs` 获取子组件实例对象，再在父组件生命周期 `mounted()` 上用 `$on()` **绑定自定义事件**\n\n并且这样**动态绑定**事件**更加灵活**\n\n**注意：**绑定在组件标签上的事件都会被当做自定义事件，所以若要绑定**原生事件**（如click），需加上 **native** 修饰符\n\n```html\n<ToDoHeader ref=\"ToDoHeader\" @click.native=\"alter('原生事件')\"></ToDoHeader>\n<script>\nexport default {\n  methods: {\n    // 事件回调函数\n     receive(value){\n       // 操控数组数据\n       this.todos.unshift(value);\n     }\n  },\n  mounted(){\n    // 等效于<ToDoHeader @receive=\"receive\" ></ToDoHeader>\n    this.$refs.ToDoHeader.$on('receive',this.receive);\n  }\n}\n</script>\n\n```\n\n**注意：**看起来是子组件触发父组件的回调，但 **$emit** 底层并**不是触发**，而是**冒泡**\n\n有时要在合适时刻用**vc**上的 `$off(<事件名>)` 解绑事件，解绑多个事件则传入**事件名数组**，若不传入参数则**解绑所有事件**\n\n# 完善勾选功能\n**功能：**页面中勾选 todo 后，修改对应数据的 complete 属性，以表示 todo 是否已完成\n\n**实现方式：**点击勾选后，拿到该 todo 的 id 值，传给管数据的 App.vue，找到对应的 todo，让其 complete 取反\n\n由于ListItem是App的孙子，所以要先通过 `$emit()` 将数据传给父组件（ToDoList），再由父组件传给爷爷组件（App）\n\n```html\n<!-- App.vue中，updateComplete接收id并对complete取反 -->\n<ToDoList :todos=\"todos\" @updateComplete=\"updateComplete\"></ToDoList>\n<script>\n updateComplete(id){\n   // 遍历找到对应的todo\n   this.todos.forEach((item)=>{\n     if(item.id === id){\n       // complete取反\n       item.complete = !item.complete;\n     }\n   });\n}\n</script>\n\n<!-- ToDoList.vue中receiveId将子组件传过来的id再传给App，起中转效果 -->\n<ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\" @receiveId=\"receiveId\"></ListItem>\n<script>\nreceiveId(id){\n  this.$emit('updateComplete', id)\n}\n</script>\n\n<!-- ListItem.vue中 -->\n<input type=\"checkbox\" :checked=\"todo.complete\" @change=\"changeComplete(todo.id)\">\n<script>\nchangeComplete(id){\n   // 由于ListItem是App的孙子，所以要先通过$emit()将数据传给父组件，再由父组件传给爷爷组件\n   this.$emit('receiveId', id)\n}\n</script>\n\n```\n\n# 完善删除功能\n**功能：**点击每个todo对应的删除按钮就在数据中删除该todo\n\n实现起来和勾选功能差不多，也是逐层传id给App，再遍历查找删除\n\n```html\n<!-- App.vue中 -->\n<ToDoList :todos=\"todos\" @updateComplete=\"updateComplete\" @deleteToDo=\"deleteToDo\"></ToDoList>\n<script>\ndeleteToDo(id) {\n   this.todos.forEach((item, index, arr) => {\n     if (item.id === id) {\n       arr.splice(index, 1)\n     }\n   });\n }\n</script>\n\n<!-- ToDoList.vue中 -->\n<ListItem v-for=\"item in todos\" :key=\"item.id\" :todo=\"item\" @receiveId=\"receiveId\" @deleteToDo=\"deleteToDo\"></ListItem>\n<script>\ndeleteToDo(id){\n   this.$emit('deleteToDo', id)\n }\n</script>\n\n<!-- ListItem.vue中 -->\n<button class=\"list-item-btn\" @click=\"deleteToDo(todo.id)\">删除</button>\n<script>\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   this.$emit('deleteToDo', id)\n}\n</script>\n\n```\n\n# 完善底部\n**功能：**全选按钮、已完成统计、清除所有已完成按钮\n\n**实现：**使用计算属性并遵循数据驱动，结合之前的父子组件通信方法很容易实现\n\n```html ToDoFooter.vue\n<template>\n    <div id=\"todo-footer\">\n        <div v-show=\"this.todos.length\">\n            <input type=\"checkbox\" v-model=\"checkValue\">\n            <div class=\"statistics\">已完成{{ doneToDo }} / 全部{{ todos.length }}</div>\n            <button @click=\"deleteComplete\">清除已完成</button>\n        </div>\n        <div class=\"tip\" v-show=\"!this.todos.length\">没有ToDo</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'ToDoFooter',\n    props: ['todos'],\n    computed: {\n        // 计算已完成数量\n        doneToDo() {\n            // 通过reduce统计已完成\n            return this.todos.reduce((pre, item) => {\n                return pre + (item.complete ? 1 : 0)\n            }, 0)\n        },\n        // 全选按钮的状态\n        checkValue: {\n            // checkValue无论是设置还是确定值，都要通过数据驱动，遍历所有数据来确定todo是否全部完成\n            get() {\n                // 比较已完成数量和全部todo数量，且todo至少要有一个才打勾\n                return this.doneToDo === this.todos.length && this.todos.length > 0;\n            },\n            // 将changeAll()移到此处，点击checkbox后通过changeAll()修改数据后，自动触发计算属性的getter并更新视图\n            set() {\n                this.changeAll()\n                return\n            }\n        }\n    },\n    methods: {\n        // 全选或全不选，即全都变为目前全选按钮状态的反状态\n        changeAll() {\n            // 因为现在checkValue是计算属性，checkbox点击变化后的未来值要通过“非”体现\n            // 数据变化，checkValue计算属性也自动触发getter更新视图，v-model更新checked\n            this.$emit('changeAll', !this.checkValue)\n        },\n        // 删除所有已完成项\n        deleteComplete() {\n            this.$emit('deleteComplete')\n        }\n    }\n}\n</script>\n\n```\n\n```html App.vue\n<ToDoFooter :todos=\"todos\" @changeAll=\"changeAll\" @deleteComplete=\"deleteComplete\"></ToDoFooter>\n<script>\n// 全选或全不选，即全都变为目前全选按钮状态的反状态\n changeAll(checkValue){\n   this.todos.forEach((item) => {\n     if(item.complete !== checkValue) {\n       item.complete = checkValue;\n     }\n   });\n },\n // 删除所有已完成项\n deleteComplete(){\n   this.todos = this.todos.filter((item) => {\n     return !item.complete;\n   });\n }\n</script>\n\n```\n\n# ToDo本地存储\n使用 localStorage 保存todos，初始化todos，本地存储有则拿，没有则赋值空数组\n\nwatch 监视 todos 的变化，数据多层开启深度监视，只要数据**发生改变就更新**本地存储的数据\n\n```js App.vue\nexport default {\n  data() {\n    return {\n      // 初始化todos，本地存储有则拿，没有则赋值空数组\n      todos: JSON.parse(localStorage.getItem(\"todos\")) || [],\n    }\n  },\n  watch: {\n    // 监视todos的变化\n    todos: {\n      // 数据多层开启深度监视\n      deep: true,\n      handler(value) {\n        // 只要数据发生改变就更新本地存储的数据\n        localStorage.setItem(\"todos\", JSON.stringify(value));\n      }\n    }\n  }\n};\n\n```\n\n# 全局事件总线\n在之前，使用 **props**、自定义事件、`$emit()` 来实现**父组件**与**子组件**的通信（数据传输）\n\n现在可以通过**全局事件总线**实现**任意组件**之间的通信\n\n实现全局事件总线并不需要学习新的API，本质还是通过自定义事件来实现的，是一种经验\n\n**实现：**\n**1、总线：**vm 和所有 vc 都能获取的东西，所以要将其放在 **Vue 的原型**上\n**2、事件总线：**这个总线应用要能够调用 `$on()` 绑定各种事件，能够调用 `$emit()` 触发事件，因为 `$on()` 和 `$emit()` 两个方法都在 Vue **原型**上，所以使用现成的 vm 作为总线即可，在生命周期 `beforeCreate()` 将 vm 放到 Vue.prototype 上，`Vue.prototype.$bus = this`\n\n```js\nnew Vue({\n  render: h => h(App),\n  beforeCreate(){\n    Vue.prototype.$bus = this;// 安装全局事件总线，this指的就是vm\n  }\n}).$mount('#app')\n```\n\n**使用全局事件总线`$bus`：**A 组件需要 B 组件传来某些数据，则 A 组件调用 `$bus` 的 `$on()` 方法绑定一个**自定义事件**，事件的回调函数写在 A组件中，然后在 B 组件中调用 `$bus` 的 `$emit()` 方法，触发**对应的事件**，并传入 A 组件所需的数据，于是 A 组件就能通过回调函数收到 B 组件传来数据\n\n```js\n// A组件\nexport default {\n  name: 'A'\n  methods: {\n    // 接收数据的方法\n    receive(data){\n      console.log(`收到了数据：${data}`);\n    }\n  },\n  mounted(){\n    // 在全局事件总线上发布一个事件\n    this.$bus.$on('receive', this.receive)\n  }\n}\n// B组件\nexport default {\n  name: 'B'\n  methods: {\n    // 在合适时刻调用该方法，通过$bus发送数据给A组件\n    sendOut(){\n      let data = 'chuckle'\n      // 触发receive事件，将data传给该事件的回调函数\n      this.$bus.$emit('receive', data)\n    }\n  }\n}\n\n```\n\n简单得说，就是在 Vue 原型上的 $bus 绑定了一堆自定义事件，通过自定义事件的回调接收与触发，就实现了任意组件间的通信\n\n当然，若事件较多，可以不使用vm作为全局事件总线，不同类型组件的通信，单独 new 一个 vc 出来当事件总线\n\n**注意：**规范起见，每个组件应该在生命周期 `beforeDestroy()` 时解绑事件\n\n```js\nbeforeDestroy(){\n  this.$bus.$off('<要解绑的事件名>')\n}\n```\n\n> Vue3中没有Vue()，而是createApp()，且$on $off $once都已废弃，所以Vue3中使用全局事件总线要安装第三方库：[mitt](https://www.npmjs.com/package/mitt)\n\n## TodoList使用$bus\n让 **ListItem** 组件通过全局事件总线，直接和管理 todos 数据的 **App** 组件通信，不再经过 **ToDoList** 组件\n\n修改 App.vue\n\n```html\n<!-- 不再给ToDoList绑定事件 -->\n<ToDoList :todos=\"todos\"></ToDoList>\n<script>\nexport default {\n  name: \"App\",\n  /* ······ */\n  mounted(){\n    // 在全局事件总线上发布事件\n    this.$bus.$on('updateComplete', this.updateComplete)\n    this.$bus.$on('deleteToDo', this.deleteToDo)\n  }\n}\n</script>\n\n```\n\n修改 ListItem.vue 的相关函数\n\n```js\nchangeComplete(id) {\n   // 触发事件传入id\n   this.$bus.$emit('updateComplete', id)\n},\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   // 触发事件传入id\n   this.$bus.$emit('deleteToDo', id)\n}\n\n```\n\n# 消息发布与订阅\n**消息发布与订阅**可以实现**任意组件**间的通信\n\n**提供**数据的组件**发布消息**，**接收**数据的组件**订阅该消息**\n\nvue并不自带消息库，原生js实现起来也麻烦，所以一般调用第三方库，这里使用 [pubsub-js](https://www.npmjs.com/package/pubsub-js)\n\n**安装：** `npm i pubsub-js`\n\n**使用：**`subscribe()` 订阅消息、`publish()` 发布消息、`unsubscribe()` 根据id取消订阅\n\n```js\n// 引入pubsub-js库\nimport pubsub from 'pubsub-js';\n\n// 订阅消息，返回一个唯一的订阅的id\nconst subID = pubsub.subscribe('<消息名>', (msgName, data)=>{\n  // 消息回调函数传入两个参数\n  // 第一个是消息名，第二个是发布消息时传入的数据\n  console.log(data);\n})\n\n// 发布消息\npubsub.publish('<消息名>', '<数据>')\n\n// 根据id取消订阅\npubsub.unsubscribe(subID)\n\n```\n\n对比全局事件总线，两者非常相似\n\n## TodoList使用pubsub\n在**ListItem** 与 **App** 组件通信，将每个todo的删除功能改为**消息发布与订阅**实现，勾选功能仍然保留全局事件总线的实现，方便对比学习\n \n修改 App.vue 的相关函数\n\n```js\nexport default {\n  name: \"App\",\n  /* ······ */\n  mounted(){\n    this.$bus.$on('updateComplete', this.updateComplete)\n    // this.$bus.$on('deleteToDo', this.deleteToDo)\n    \n    // 订阅消息\n    pubsub.subscribe('deleteToDo', (magName, data)=>{\n      magName; // eslint不允许不使用参数，这里使用一下\n      // 将接收到的数据（要删除的id）传给删除函数\n      this.deleteToDo(data)\n    })\n  }\n}\n\n```\n\n修改 ListItem.vue 的相关函数\n\n```js\ndeleteToDo(id) {\n   if (!confirm('确认删除吗?')) {\n       return\n   }\n   // 触发事件传入id\n   // this.$bus.$emit('deleteToDo', id)\n\n   // 发布消息\n   pubsub.publish('deleteToDo', id);\n}\n\n```\n\n# 添加编辑功能\n这个功能较为综合\n\n**功能：**点击编辑按钮，title变成可编辑的input框并获取焦点，编辑按钮变取消按钮，并显示保存按钮，输入框失去焦点后也能保存修改\n\n修改 App.vue 相关函数\n\n```js\nmethods: {\n// 修改todo的title\n editToDo(id,value){\n   this.todos.forEach((item, index, arr) => {\n     if (item.id === id) {\n       arr[index].title = value;\n     }\n   });\n }\n}\n\nmounted(){\n  // 订阅修改todo的消息\n  pubsub.subscribe('editToDo', (magName,arr)=>{\n    magName;\n    this.editToDo(arr[0],arr[1])\n  })\n}\n```\n\n大改 ListItem.vue\n\n```html\n<template>\n    <li>\n        <label>\n            <input v-show=\"!isEdit\" type=\"checkbox\" :checked=\"todo.complete\" @change=\"changeComplete(todo.id)\">\n            <span v-show=\"!isEdit\" ref=\"titleToDo\">{{ todo.title }}</span>\n            <input v-show=\"isEdit\" class=\"todo-title-input\" type=\"text\" :value=\"todo.title\" ref=\"titleInput\"\n                @blur=\"editToDo(todo.id)\" contenteditable=\"true\">\n        </label>\n        <div class=\"btn-box\">\n            <button v-show=\"isEdit\" class=\"list-item-btn\" @click=\"editToDo(todo.id)\">保存</button>\n            <button v-show=\"isEdit\" class=\"list-item-btn\" @click=\"completeEdit()\">取消</button>\n            <button v-show=\"!isEdit\" class=\"list-item-btn\" @click=\"edit()\">编辑</button>\n            <button class=\"btn-delete\" @click=\"deleteToDo(todo.id)\">删除</button>\n        </div>\n    </li>\n</template>\n\n<script>\nimport pubsub from \"pubsub-js\";\nexport default {\n    name: 'ListItem',\n    props: ['todo'],\n    data() {\n        return {\n            // 是否在修改，控制输入框显隐\n            isEdit: false,\n        }\n    },\n    methods: {\n        changeComplete(id) {\n            // 触发事件传入id\n            this.$bus.$emit('updateComplete', id)\n        },\n        deleteToDo(id) {\n            if (!confirm('确认删除吗?')) {\n                return\n            }\n            // 触发事件传入id\n            // this.$bus.$emit('deleteToDo', id)\n            // 发布消息\n            pubsub.publish('deleteToDo', id);\n        },\n        // 进行修改\n        edit() {\n            this.isEdit = true;\n            // $nextTick的回调函数会在dom节点更新之后再执行\n            this.$nextTick(()=>{\n                // 让输入框获取焦点\n                this.$refs.titleInput.focus();\n            });\n        },\n        // 完成修改（取消也是完成）\n        completeEdit() {\n            this.isEdit = false;\n            this.ifEdit = false;\n        },\n        // 修改todo并发生消息\n        editToDo(id) {\n            this.completeEdit()\n            // 获取input框元素\n            let input = this.$refs.titleInput;\n            // 如果输入框内容没有变则返回\n            if (input.value === this.todo.title) return;\n            // 如果输入框内容为空提示为空并返回\n            if (input.value.trim() === \"\") {\n                alert('ToDo内容为空！请重新修改')\n                return;\n            }\n            pubsub.publish('editToDo', [id, input.value]);\n        }\n    }\n}\n</script>\n\n```\n\n## $nextTick\n在编辑功能中，通过 `$nextTick()` 方法实现了input框出现时自动获取焦点\n\n**作用：**在下一次DOM更新结束后执行其指定的回调\n\n**何时使用：**当改变数据后，要基于更新后的新DOM进行某些操作时，要在 `$nextTick()` 的回调函数中进行操作\n\n```js\nedit() {\n   this.isEdit = true;\n   // $nextTick的回调函数会在dom节点更新之后再执行\n   this.$nextTick(()=>{\n       // 让输入框获取焦点\n       this.$refs.titleInput.focus();\n   });\n}\n\n```\n\n也可以不使用这个 API，直接包裹一个没设定时间的定时器，由于**事件循环**的机制，也能成功对更新后的新DOM进行某些操作\n\n\n\n\n\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[二]-组件化","url":"/article/331af2cc.html","content":"\n# 生命周期\nVue会在一些特殊时刻去调用一些特殊的函数\n\n这些要经过的特殊时刻就是**生命周期**，要调用的特殊函数就是**生命周期函数**（生命周期钩子，生命周期回调函数）\n\n**为什么叫钩子：**vm在某个步骤上已经写了执行该名称的函数，但函数内容未定义，得程序员来定义。即生命周期函数的名字不可更改，但函数的具体内容需要程序员根据业务需求编写\n\n**Vue实例的生命周期：**\n**1、初始化显示**\n1. `beforeCreate()` => 初始化：生命周期、事件，但数据代理还未开始\n2. `create()` => 初始化：数据监测、数据代理\n3. `beforeMount()` => 模板解析完毕，虚拟DOM建立，但还未挂载\n4. `mounted()` => 挂载完毕，虚拟DOM转为真实DOM\n\n**2、更新状态: this.xxx = value**\n1. `beforeUpdate()` => 数据已更新，但页面还未更新，新旧虚拟dom还未对比\n2. `updated()` => 数据和页面都是新的\n\n**3、销毁 vue 实例:** `vm.$destroy()` 触发下面两个钩子\n1. `beforeDestroy()` => 此时vm上所有东西都是可用的，但不再解析模板更新页面\n2.  `destroyed()` => vm彻底被销毁\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/53-3.webp width=\"100%\" loading=\"lazy\">\n\n还有三个钩子不在图中，和路由相关\n\n**常用钩子：**\n1. **mounted:** 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】\n2. **beforeDestroy:** 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】\n\n**关于销毁Vue实例：**\n1. 在大多数场景中不应该调用 vm.$destroy() 。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。\n2. 销毁后借助Vue开发者工具看不到任何信息\n3. 销毁后自定义事件会失效，但原生D0M事件依然有效\n4. 在beforeDestroy中做好善后工作\n\n# 组件\n**组件：**应用中**局部**功能**代码**和**资源**的**集合**\n\n在 Vue 中，组件是**可复用**的 **Vue实例**\n\n组件体现了**封装**的思想，组件也可以嵌套封装\n\n**组件化：**编写一套组件，在所需的页面**引入**组件，当应用中的功能都是多组件的方式来编写的, 这个应用就是一个组件化的应用\n\n**为什么要组件化：**传统的三件套可以只能做到拆分css、js模块化，而html结构不复用，且文件依赖关系（N-1-N）复杂，组件化后，页面的每个部分都对应一个组件，组件中的小功能部分也能对应更多组件，组件逐层嵌套，最终由一个Vue实例管理，依赖关系清晰，通过引入组件构建页面，代码复用率高，后续维护也能针对性找到组件进行操作\n\n## 非单文件组件\n**非单文件组件：**一个文件中包含n个组件，**实际开发几乎不用**这种写法\n\n**使用组件流程：**\n1. **定义组件：** `Vue.extend()`\n**-** 配置项中**不能写el属性**，因为最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器\n**-** 组件中的data必须用**函数式**，避免组件被复用时，数据存在引用关系。\n**-** 使用 **template** 配置组件模板结构，必须有一个根元素包裹\n```js\nconst school = Vue.extend({\n   // 模板，template中的模板必须有一个根元素包裹\n   template: `\n       <div>\n           <h3>{{name}}</h3>\n           <h3>{{city}}</h3>\n       </div>\n   `,\n   // 组件中的data必须用函数式\n   // 因为对象是引用类型数据，函数式返回一个新对象才能保证多次引用组件的data互不影响\n   data() { \n       return {\n           name: '五道口',\n           city: '京海'\n       }\n   }\n})\n\n```\n2. **注册组件：**\n**-** `Vue.component()` 全局注册\n**-** 局部注册，在vm配置项的 **components** 属性中\n```js\n// 全局注册组件，多个vue实例都能使用该组件\nVue.component('school', school)\n// 组件由vm管理\nnew Vue({\n   el: '#root',\n   data: {\n       msg: '信息'\n   },\n   // 局部注册组件\n   components: {\n       // 组件名\n       student\n   }\n})\n\n```\n3. **使用组件：**在容器中写**组件标签**\n\n**案例：**\n\n```html 非单文件组件案例\n<div id=\"root\">\n  <h2>{{msg}}</h2>\n  <!-- 引用组件，组件标签 -->\n  <school></school>\n  <hr />\n  <!-- 多次引用组件，且数据独立互不影响 -->\n  <student></student>\n  <student></student>\n</div>\n<script>\n  // 使用Vue.extend定义一个组件，传入一个配置项\n  const school = Vue.extend({\n      // 模板，template中的模板必须有一个根元素包裹\n      template: `\n          <div>\n              <h3>{{name}}</h3>\n              <h3>{{city}}</h3>\n          </div>\n      `,\n      // 组件中的data必须用函数式\n      // 因为对象是引用类型数据，函数式返回一个新对象才能保证多次引用组件的data互不影响\n      data() { \n          return {\n              name: '五道口',\n              city: '京海'\n          }\n      }\n  })\n  const student = Vue.extend({\n      template: `\n          <div>\n              <h3>{{name}}</h3>\n              <h3>{{age}}</h3>\n              <button @click=\"age++\">年龄加一</button>\n          </div>\n      `,\n      data() { \n          return {\n              name: 'chuckle',\n              age: '19'\n          }\n      }\n  })\n  // 全局注册组件，多个vue实例都能使用该组件\n  Vue.component('school', school)\n  // 组件由vm管理\n  new Vue({\n      el: '#root',\n      data: {\n          msg: '信息'\n      },\n      // 局部注册组件\n      components: {\n          // 组件名\n          student\n      }\n  })\n</script>\n\n```\n\n## 注意事项\n**关于组件名：**\n1. 组件名只有**一个单词**时，引用组建时写**小写** `<student>` 或**大写** `<Student>` Vue只会去找小写的组件名，即组件名**只有一个单词时**需使用**小写**\n2. 组件名由**多个单词**组成时，有两种写法：**横杠写法**、**双驼峰写法**（只能在脚手架环境中使用）\n```html\n<!-- 横杠写法 -->\n<my-school></my-school>\n<script>\n  Vue.component('my-school', MySchool)\n</script>\n<!-- 双驼峰写法（只能在脚手架环境中使用） -->\n<MySchool></MySchool>\n<script>\n  Vue.component('MySchool', MySchool)o[]\n</script>\n\n```\n3. 不能使用html已有标签名作为组件名\n4. 在定义组件时添加 **name** 配置，无论注册使用时是什么名，在开发者工具中显示的都是该 name（首字母同样会自动显示大写）\n```js\nconst school = Vue.extend({\n  // 设置 name\n  name: 'MySchool',\n  template: ``,\n  data() { \n    return {}\n  }\n})\n\n```\n\n在**脚手架环境**下，可以使用组件时可以写**双标签** `<school></school>` 或**自闭合标签** `<school/>`，不用使用脚手架时，`<school/>` 会导致后续组件不能渲染。\n\n定义组件可以**简写:**\n注册组件时底层有判断，若是一个对象，Vue会帮我们调用Vue.extend，并将对象作为配置项传入\n\n```js\n// 简写，实际上也调用了Vue.extend\nconst school = {\n   template: ``,\n   data() { \n       return {}\n   }\n}\n// 写上 Vue.extend 不简写\nconst school = Vue.extend({\n   template: ``,\n   data() { \n       return {}\n   }\n})\n\n```\n\n## 组件嵌套\n**组件嵌套：**一个组件也会用到其它多个组件，组件关系逐层嵌套，形成**父子组件**关系\n\n**使用方式：**在父组件中 **components** 配置项注册其子组件，组件在哪注册就要在哪使用\n\n**开发中的技巧：**定义一个名为 **app** 的组件，用于管理页面中**最上层**的所有组件，而 vm 本身只管理 app 组件\n\n```html\n<div id=\"root\"></div>\n<script>\n  // 子组件的定义要放到父组件前\n  const student = {\n      template: `\n          <div>\n              <h3>学生姓名：{{name}}</h3>\n              <h3>学生年龄：{{age}}</h3>\n          </div>\n      `,\n      data() {\n          return {\n              name: 'chuckle',\n              age: '19'\n          }\n      }\n  }\n  // 定义父组件\n  const school = {\n      // 在父组件中使用子组件\n      template: `\n          <div>\n              <h2>学校名：{{name}}</h2>\n              <hr />\n              <student></student>\n          </div>\n      `,\n      data() {\n          return {\n              name: '五道口'\n          }\n      },\n      // 注册子组件\n      components: {\n          student,\n      }\n  }\n  // 定义一个欢迎语组件，和school组件同级\n  const hello = {\n      template: `\n          <div>\n              <h3>{{welcome}}</h3>\n              <hr/>\n          </div>\n      `,\n      data() {\n          return{\n              welcome: '欢迎！'\n          }\n      }\n  }\n  // 定义app组件，管理所有组件\n  const app = {\n      template: `\n          <div>\n              <hello></hello>\n              <school></school>\n          </div>\n      `,\n      // 管理下一层的父级组件\n      components: {\n          school,\n          hello\n      }\n  }\n  new Vue({\n      el: '#root',\n      // 应用app组件，替换掉root容器\n      template:`<app></app>`,\n      components: {\n          // vm只管理app组件\n          app\n      }\n  })\n  </script>\n\n```\n\n## VueComponent构造函数\n每个**组件的本质**都是一个 `VueComponent()` 构造函数，它由 `Vue.extend()` 生成并返回\n\n**每次调用 `Vue.extend()` ，返回的都是一个全新的 `VueComponent()` 构造函数**\n\n打印app组件：\n\n```js\nconst app = Vue.extend({\n   template: ``,\n   components: {}\n})\nconsole.log(app)\n```\n\n```js 输出\nƒ VueComponent(options) {\n     this._init(options);\n  }\n```\n\n既然是构造函数，使用它就需要 new 创建实例\n只需要在合适的位置写 `<school></school>` ，Vue 在**解析模板时**会自动去创建对应的**VueComponent**构造函数的**实例**\n\n即Vue会在**解析模板**时**自动执行**：`new VueComponent(options)`\n\n**1、this的指向：**\n(1) `Vue.extend(options)` 组件配置中，this 指向 VueComponent 实例对象\n(2) `new Vue(options)` 配置中，this 指向 vm 实例对象\n\n**2、Vue对组件的关系设计：**\n1. **每种**组件定义时都需要调用 `Vue.extend()` ，它返回一个新的 `VueComponent()` 构造函数，即不同种类的组件，其对应的 **VueComponent** 构造函数不同，以此来**区分组件的种类**\n2. Vue在**解析模板时**，会对每个**组件标签**都调用一次对应的构造函数，**返回的实例**都是互不影响的，以此来区分**同种组件**的**不同实例**（同种组件在出现在页面不同位置，展示不同内容）\n\n## vm与vc\n`VueComponent()` 的实例对象，简称**vc**(也可称之为：组件实例对象)\n`Vue()` 的实例对象，简称**vm**。\n\n**对vm和vc的理解：**\n**1、**vm 和 vc 长得差不多（属性和方法都一样的），因为 `Vue(options)` 和 `VueComponent(options)` 两个构造函数，在源码中都是调用了其**原型上**的 `_init(options)`\n\n**2、**vm 或 vc 的 **`$children`** 属性以**数组**形式保存着 vm 或 vc 所**管理的组件**或**子组件**的**实例对象**\n\n**3、**组件是**可复用**的 Vue 实例（vm），所以它们与 `new Vue()` 接收相同的配置选项 **options**，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 **el** 这样**根实例特有**的选项。\n\n**4、**vc 由 vm 管理，vc 没有 el 配置，只有 vm 能通过 el 配置来指定为谁服务\n\n## 重要内置关系\n**VueComponent.prototype.\\_\\_proto\\_\\_ = Vue.prototype**\n\n复习**原型与原型链**：[JavaScript基础笔记(3)--原型与原型链](/article/7d8b8b34.html#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE)\n\n\\$mount、$watch 等属性和方法都在 **Vue.prototype** 上，也就是 Vue 的原型上\n\n**作用：**这个重要的内置关系将**组件的原型**与**Vue的原型**通过 **\\_\\_proto\\_\\_** 相连，使 **VueComponent** 继承 **Vue原型**，让组件实例顺着原型链也能使用\\$mount、$watch 等属性和方法，\n\n\n**目的：**让**组件实例对象**(vc)可以访问到**Vue原型**上的属性、方法\n\n## 单文件组件\n**单文件组件：**一个文件中仅包含一个组件，文件后缀为 **.vue**\n\n浏览器并不认识.vue文件，需要通过 **webpack** 或**脚手架**，将其加工为**JS文件**\n\n**文件名推荐规则：**单个单词**大写**，多个单词**双驼峰**\n\n.vue文件中代码分为**三个标签**：\n1. `<template>` => 组件的结构\n2. `<script>` => 组件交互相关代码，包含组件所用的**数据**、方法\n3. `<style>` => 组件的样式\n\n**主要的文件：**需放入脚手架中才能运行\n1、xxx.vue 各种组件\n2、App.vue 汇总所有组件\n3、main.js 入口文件，创建Vue实例，注册App组件并应用\n4、index.html 页面\n\n```html 一个简单的组件\n<template>\n    <!-- 组件的结构 -->\n    <div class=\"student\">\n        <h2>{{ name }}}</h2>\n        <h3>{{ age }}}</h3>\n    </div>\n</template>\n\n<script>\n// 组件交互相关代码\n// 省略Vue.extend,直接暴露组件的配置对象\nexport default {\n    name: 'Student', //最好与文件名保持一致\n    data() {\n        return {\n            name: 'chuckle',\n            age: '19'\n        }\n    }\n}\n</script>\n\n<style>\n/* 组件的样式 */\n.student {\n    background: #ccc;\n    border-radius: 8px;\n}\n</style>\n\n```\n\n必须有 **App.vue** 汇总所有组件\n\n```html\n<template>\n    <div>\n        <School></School>\n    </div>\n</template>\n\n<script>\n    // 引入Student组件\n    import School from \"./Student.vue\"\n\n    export default {\n        name: \"App\",\n        components: {\n            School\n        }\n    }\n</script>\n\n<style></style>\n\n```\n\n**main.js** 入口文件，创建Vue实例，注册App组件并应用\n\n```js\nimport App from \"./App.vue\" // 引入App组件\n\nnew Vue({\n    el: '#root',\n    template: '<App></App>',\n    components: {\n        App\n    }\n})\n\n```\n\nindex.html 页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <!-- 准备一个容器 -->\n    <div id=\"root\"></div>\n    <!-- 引入vue文件 -->\n    <script src=\"../../js/vue.js\"></script>\n    <!-- 引入入口文件 -->\n    <script src=\"./main.js\"></script>\n</body>\n</html>\n\n```\n\n# 脚手架Vue-cli\nVue **脚手架**是 Vue 官方提供的标准化开发工具（开发平台）\n\nVue 有多种脚手架，[Vue-cli](https://cli.vuejs.org/zh/) 是其中一种 \n\n## 起步\n**安装：**该全局模块会暴露一个**全局命令vue**\n\n```js\nnpm install -g @vue/cli\n```\n\n创建一个项目\n\n```js\nvue create <项目名>\n```\n\n选择项目的vue版本，babel用于ES6转ES5，eslint语法检查\n\n```js\nVue CLI v5.0.8\n? Please pick a preset:\n  Default ([Vue 3] babel, eslint) \n> Default ([Vue 2] babel, eslint) \n  Manually select features   \n```\n\n等待安装完毕，运行项目\n\n```js\nnpm run serve\n```\n\n## 项目文件结构\n默认 HelloWord 项目结构：\n\n```\n├─ public\n│  ├─ favicon.ico\n│  └─ index.html\n│\n├─ src\n│  ├─ assets\n│  │  └─ logo.png\n│  ├─ components\n│  │  └─ HelloWorld.vue\n│  ├─ App.vue\n│  └─ main.js\n│\n├─ .gitignore\n├─ vue.config.js\n├─ babel.config.js\n├─ jsconfig.json\n├─ package-lock.json\n├─ package.json\n\n```\n\n**文件解释：**\n\n**1、**根目录中的一些**配置文件：**\n1. **babel.config.js** babel控制文件，脚手架已写好，无需再动\n2. **package.json** 定义了当前项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等）\n3. **package-lock.json** 锁定所有模块的版本号,包括主模块和所有依赖子模块\n4. **.gitignore** git忽略文件配置\n5. **jsconfig.json** 指定根文件和JavaScript语言服务提供的功能选项，明确项目的文件范围\n6. **vue.config.js** 一个可选的脚手架配置文件，进行vue项目本地运行和构建相关配置，若根目录中存在这个文件，它会被 @vue/cli-service 自动加载\n\n**2、src文件夹：**有些熟悉的文件，main.js入口文件、app.vue组件等\n**-** **assets文件夹：**存放静态资源\n**-** **components：**存放组件，除了App组件\n\n```js main.js有一些变化\n// 整个项目的入口文件\n// 引入Vue\nimport Vue from 'vue'\n// 引入App组件，是所有组件的父组件\nimport App from './App.vue'\n\n// 关闭Vue的生产环境提示\nVue.config.productionTip = false\n\n// 创建Vue实例对象\nnew Vue({\n  // 将App组件放入容器中\n  render: h => h(App),\n}).$mount('#app') // 绑定容器\n\n```\n\n**3、public文件夹：**页面的根目录，存放了index.html和ico图标\n\n**应该知道：**main.js之所以是入口文件，而且它能找到public中的index.html去绑定容器，是脚手架配置、规定的\n\n## render函数\n在 main.js 中，`render: h => h(App)` 作用是将App组件放入容器中\n\n若使用之前的模板写法，控制台会报错\n\n```js 模板写法\nimport App from \"./App.vue\" // 引入App组件\nnew Vue({\n    el: '#root',\n    template: '<App></App>',\n    components: {\n        App\n    }\n})\n\n```\n\n**报错内容:** [vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.\n**意思是：**正在使用Vue的仅运行时版本（runtime模式），其中模板编译器不可用。将模板预编译为render函数，或者使用包含编译器的内部版本。\n\n**问题原因：**\nVue包含两个部分，**核心部分**与**模板解析器**，核心部分是生命周期与各种属性与函数，模板解析器用于解析模板，当通过cdn引入来使用Vue时，应该将两者都引入，但如果使用脚手架、webpack将.vue文件都翻译为.js文件，且**模板都已经解析为html**，模板解析器在**生产环境**就没有用了\n\n因为Vue中不是所有部分都在生产环境中用到，且模板解析器占Vue体积的三分之一，所以Vue除了完整版，还有许多精简版，带模板解析器的称为 **compiler（模板）模式**，反之称为 **runtime（运行时）模式**\n\n(1) vue.js 是完整版Vue，包含：核心功能+模板解析器\n(2) vue.runtime.xxx.js 是运行版Vue，只包含核心功能，没有模板解析器\n\n通过 `import Vue from 'vue'` 引入的就是不带模板解析器的精简版，vue模块的package.json的main/model字段默认为runtime模式，指向了”dist/vue.runtime.common.js”。\n\n**解决办法一**：引入完整版Vue，不推荐\n\n```js\nimport Vue from 'vue/dist/vue.js'\n```\n\n**解决办法二**：使用渲染函数 `render()` 代替模板写法\n\n**render** 配置项是一个函数，传入 **createElement** 参数也是一个函数\n\n`createElement()` 可以创建具体的元素，可以**传入一个组件**或是 `('标签名','标签内容')`的形式 ，返回创建好的元素\n\nVue会调用 `render()` 并接收其返回值，将 `createElement()` 的返回值（创建好的元素）返回即可\n\n```js\n// 完整写法\nrender(createElement) {\n    return createElement('h1', '你好啊')\n}\n// 箭头函数简写\nrender: h => h(App)\n```\n\n**注意：**在开发环境中有 vue-cli 自带有 **vue-template-compiler** 插件，能解析 **.vue** 文件中的 `<template></template>` 模板，但写在配置对象 **template** 属性中的模板没有插件能解析，所以要使用 `render()`\n\n> 以后一般也只有在创建vm时配置项里会用到render\n\n## 自定义脚手架配置\n脚手架默认使用main.js作为入口文件等默认配置都在一个文件中，该文件被隐藏了起来\n\n使用命令导出、查看脚手架配置文件的**拷贝**\n\n```js\nvue inspect > output.js\n```\n\n在[vue-cli配置参考项](https://cli.vuejs.org/zh/config/)中查看可配置项\n\n在 **vue.config.js** 文件中进行自定义配置\n\n```js\n// vue.config.js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  // 配置选项\n})\n```\n\n# ref标签属性\n替代 id 属性给元素或**子组件**注册**引用信息**（打标识）\n\n给**元素标签**或**组件标签**添加 **ref** 属性，就能在组件实例对象的 **$refs** 上获取**dom元素**或**子组件实例对象**\n\n```html\n<!-- 打标识 -->\n<h1 v-text=\"msg\" ref=\"xxx\"></h1>\n<School ref=\"xxx\"></School>\n<!-- 获取dom元素或子组件vc -->\n<script>\n    this.$refs.xxx\n</script>\n```\n\n```html\n<template>\n  <div>\n    <h1 v-text=\"msg\" ref=\"title\"></h1>\n    <button @click=\"showTitle\">显示/隐藏标题</button>\n    <School></School>\n  </div>\n</template>\n\n<script>\nimport School from \"./components/school.vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    School,\n  },\n  data() {\n    return {\n      msg: \"学校信息\",\n    };\n  },\n  methods: {\n    showTitle() {\n      this.$refs.title.classList.toggle('hide');\n    },\n  },\n};\n</script>\n\n<style>\n.hide {\n    opacity: 0;\n}\n</style>\n\n```\n\n# props配置项\n子组件的 **props** 配置项接收父组件通过**组件标签**传入的数据\n\n**作用：**实现父组件与子组件的通信\n\n通过标签属性给子组件**传数据**：\n\n**注意：**\n1. 普通属性传的是**字符串**，要传入**其它数据类型**的属性，需要 v-bind 绑定属性，传入**表达式**的值\n2. 传入引用数据类型时，传的是**引用**，浅拷贝\n\n```html\n<Student name=\"chuckle\" sex=\"男\" :age=\"18\"></Student>\n```\n\n子组件**接收数据**，三种写法\n\n```js\n// 简单接收，不对数据类型进行限制\nprops: ['name', 'age', 'sex']\n// 接收同时限制数据类型\nprops: {\n name: String,\n age: Number,\n sex: String\n}\n// 更多配置，必须的、默认值等\nprops: {\n name: {\n   type: String,\n   required: true // 必须的\n },\n age: {\n   type: Number,\n   required: true // 必须的\n },\n sex: {\n   type: String,\n   default: \"男\"\n }\n}\n\n```\n\n**props** 接收到的数据会代理到 **vc** 身上，但**不允许修改**只能读取（直接修改也有效果，但控制台会发出警告），所以也不能使用 **v-model** 绑定\n\n若需修改，应先将数据拷贝到data中，用一个新属性接收\n\n```js\ndata() {\n return {\n   myAge: this.age + 1\n };\n},\n```\n\n# mixins混入\n多个相似组件中通常会有重复的配置项，可以将这些配置项提取成一个**混入对象**，给这些组件引入复用（混入）\n\n将相同的配置项提取至 **mixin.js**\n\n```js mixin.js\nexport const mixin1 = {\n    data(){\n        return {\n            x: 100,\n            y: 200\n        }\n    }\n}\nexport const mixin2 = {\n    data() {\n        return {\n            name: '',\n        }\n    },\n    methods: {\n        showName(){\n            console.log(this.name);\n        }\n    },\n}\n\n```\n\n组件通过 **mixins** 配置项引入 **mixin.js** 中的配置\n\nVue会将这些外部的配置**混入**组件的同名配置中（混合合并），配置中**重复的属性**保留组件中的\n\n`mixins: []` 局部混入\n\n```js 局部组件混入\n// 引入混入对象文件\nimport {mixin1, mixin2} from '../mixin.js';\nexport default {\n    // 局部混入\n    mixins: [mixin1,mixin2],\n};\n```\n\n`Vue.mixin()` 全局混入\n\n```js 在main.js中全局混入，给所有组件\nimport {mixin1, mixin2} from '../mixin.js';\nVue.mixin(mixin1)\nVue.mixin(mixin2)\n```\n\n# 插件\nVue中插件本质是一个对象，对象中必须有一个 `install()` 方法\n\n在 **plugins.js** 或其它名字的独立js文件中定义插件\n\n```js\nexport default {\n    install(){\n        console.log('这是一个插件');\n    }\n}\n```\n\n在 **main.js** 中导入并使用 `Vue.use()` 应用插件\n\n```js\n// 导入插件\nimport plugins from \"./plugins\";\n// 使用插件\nVue.use(plugins);\n```\n\n插件对象的 `install()` 方法默认**第一个参数**接收 **Vue构造函数** 作为参数，在插件中可以进行各种全局配置以及在原型上添加属性和方法\n\n```js plugins.js\nimport {mixin1, mixin2} from './mixin.js';\nexport default {\n    // 第一个参数接收Vue构造函数作为参数\n    install(Vue){\n        // 配置全局过滤器\n        Vue.filter('interceptStr',(value, num=4)=>{\n            return value.slice(0,num)\n        })\n\n        // 注册全局自定义指令\n        Vue.directive('inHtml', function(el, binding){\n            el.innerHTML = binding.value\n        })\n\n        // 应用全局混入\n        Vue.mixin(mixin1)\n        Vue.mixin(mixin2)\n\n        // 在Vue原型上添加属性和方法\n        Vue.prototype.hello = function(){\n            console.log('Hello')\n        }\n\n    }\n}\n\n```\n\n**自定义参数：**\n`Vue.use()` 使用插件时也可以传入其它参数，会被 `install()` 方法接收，第一个参数仍然是 **Vue构造函数**\n\n```js\n// 传入三个自定义参数，三个数字\nVue.use(plugins,1,2,3);\ninstall(Vue,a,b,c){\n    console.log(a,b,c);// 1 2 3\n}\n```\n\n# scoped样式\n多个组件有多个 style 标签，所有组件样式都会汇总到一个 CSS 文件中\n\n当组件中有相同类名时，样式就会冲突，可以给组件的 style 标签加上 **scoped** 属性解决冲突\n\n**作用：**让样式仅在当前组件中生效，防止样式冲突\n\n**原理：**当style标签加上 **scoped** 属性后，Vue会给该组件所有标签元素都加上一个随机的 **data-v** 属性，css选择器也会自动选择 **data-v**\n\n```html\n<div data-v-22321ebb=\"\" class=\"demo\">\n    <h2 data-v-22321ebb=\"\">学生姓名：chuckle</h2>\n    <h2 data-v-22321ebb=\"\">学生性别：男</h2>\n    <h2 data-v-22321ebb=\"\">学生年龄：19</h2>\n    <hr data-v-22321ebb=\"\">\n</div>\n```\n\n```css\n.demo[data-v-22321ebb] {\n    background: rgb(78, 180, 220);\n}\n```\n\n**注意：**一般在 **App.vue** 的 style 标签中写全局共用样式，所以 App 不适合加 **scoped**\n\n**更多：** style 标签的 **lang** 属性可以指定 CSS 预处理语言，常用 **less**，使用 less 前需要安装 **less-loader** 用于解析 less\n\n```html\n<style lang=\"less\" scoped>\n</style>\n```\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Vue笔记[一]-初识","url":"/article/adf5c49.html","content":"\n# Vue简介\n[Vue](https://cn.vuejs.org/) 是一套用于**构建用户界面**的**渐进式** JavaScript 框架\n\n构建用户界面: 在合适的时刻将**数据**应用到合适的位置\n渐进式: Vue可以自底向上逐层的应用，即**需要什么用什么**，可以只用一个vue核心库，也可以装一堆插件库\n\n**Vue的特点：**\n1. **组件化**模式，提高代码复用率，让代码更好维护\n2. **声明式**编码，无需直接操作DOM，提高开发效率\n3. **响应性**，Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM\n4. 使用**虚拟DOM**和优秀的**Diff算法**，尽量复用DOM节点\n\n[Vue2](https://v2.cn.vuejs.org/)，[API](https://cn.vuejs.org/api/)\n\n体验Vue的方便：\n\n```js 命令式编码\nlet html = '';\ndata.forEach(item => {\n    html += `<li>${item.id}-${item.name}</li>`\n})\ndocument.getElementById('list').innerHTML = html;\n```\n\n```html 声明式\n<ul id=\"list\">\n    <li v-for=\"item in data\">\n        {{item.id}} - {{item.name}}\n    </li>\n</ul>\n```\n\n> 下面的笔记是从Vue2开始的，直到Vue3\n\n# 初次使用与理解\n使用cdn或本地文件引入\n\n```js\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/vue.js\"></script>\n```\n\n引入后，全局就多了一个名为 **Vue** 的**构造函数**，它接收一个配置对象参数\n\n初次使用步骤：\n1. 创建vue实例\n2. 挂载到容器\n3. 插值语法应用数据\n\n**思想：**将数据交给Vue实例动态地去使用，而不去直接操作DOM\n\n```html\n<!-- 容器 -->\n<div id=\"root\">\n  <!-- vue的插值语法 -->\n  <h1>hello {{msg}}</h1>\n</div>\n\n<script>\n// 创建vue实例\nnew Vue({\n   el: '#root', // element元素，挂载到哪个容器\n   // 数据对象，只能给该容器使用\n   data: {\n       msg: 'chuckle'\n   }\n});\n\n// 效果\n// hello chuckle\n</script>\n\n```\n\n插值语法 `{{ }}` 中写的是js**表达式**（表达式即能生成一个值的代码），访问的数据以data为基准，当data中的数据发生改变，vue会自动重新解析模板更新数据\n\n容器中的代码仍然符合html规范，vue会解析容器中的特殊语法（vue模板），然后应用数据和进行操作\n\n**注意：**容器与实例是**一一对应**的，且不能嵌套容器，但一个容器和实例可以拆分成许多**组件**\n\n# 模板语法\nVue有两种模板语法：\n1. **插值**语法 `{{ }}`\n2. **指令**语法 `v- `\n\n插值语法用于**标签体内容**\n指令语法用于**解析标签**（标签属性、标签体内容、绑定事件），数据都以data为基准\n\n`{{ }}` 能看见（写） Vue 实例和原型上所有的属性\n\ndata数据对象中的键值对，最终都会通过**数据代理**作为 Vue 实例的属性\n\n# 数据绑定\n**单向数据绑定** `v-bind`，只能由data去影响页面，可以简写为**冒号**\n**双向数据绑定** `v-model`，data和页面中数据变化都会互相影响\n\n**注意：** v-model只能用于**表单标签**的**value属性**上，v-model:value= 可以简写为 v-model=\n\n**v-bind** 案例：数据绑定标签属性\n\n```html\n<div class=\"root\">\n<!-- vue的插值语法 -->\n  <h1>hello {{msg}}</h1>\n  <!-- v-bind简写为冒号 -->\n  <a :href=\"url\">前往首页</a>\n</div>\n<script>\n// 创建vue实例\nnew Vue({\n  el: \".root\",\n  data: {\n    msg: \"chuckle\",\n    url: \"https://www.qcqx.cn/\"\n  },\n});\n</script>\n\n```\n\n**v-model**案例：输入框内容变化会影响 data.msg 的值\n\n```html\n<div class=\"root\">\n单向数据绑定<input type=\"text\" :value=\"msg\">\n<br />\n双向数据绑定<input type=\"text\" v-model=\"msg\">\n</div>\n<script>\n// 创建vue实例\nnew Vue({\n  el: \".root\",\n  data: {\n    msg: \"chuckle\"\n  },\n});\n</script>\n\n```\n\n# 挂载和数据写法\n**挂载容器**有两种写法：配置对象中的 **el** 属性和实例对象的 `$mount()` 方法 \n\n**tip:** Vue实例和原型上以 **$** 开头的属性和方法都是提供给程序员使用的\n\n```js 第一种\nnew Vue({\n  el: \".root\"\n});\n```\n\n```js 第二种\nconst vm = new Vue({ });\nvm.$mount('.root');\n```\n\n**data数据**也有两种写法：**对象式**和**函数式**\n函数式返回一个数据对象，**组件中需用函数式**，函数式中的this是Vue实例对象。由Vue所管理的函数都不要写成箭头函数\n\n```js 对象式\nnew Vue({\n  data: {\n    msg: \"chuckle\"\n  }\n});\n```\n\n```js 函数式\nnew Vue({\n  // data: function(),在对象属性值中写函数，一般删掉冒号和function\n  data(){\n    return{ msg: \"chuckle\" }\n  }\n});\n```\n\n# MVVM模型\nVue参考了[MVVM模型](https://zh.wikipedia.org/wiki/MVVM)\n1. **M：**模型(Model) - data 中的数据\n2. **V：**视图(View) - 模板\n3. **VM：**视图模型(ViewModel) - Vue 实例对象\n\nModel 通过 VM 向 View 绑定数据，View 通过 VM 监听 Model 的数据变化\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/53-2.webp width=\"50%\" loading=\"lazy\">\n\n前端的框架大多都遵循这种模型，将数据放到指定位置，写好指定的模板代码，如何将数据和模板关联起来是框架的事，需要学习框架的语法\n\n# 数据代理\n**数据代理：**通过一个对象代理对另一个对象中属性的操作（读/写）\n\nVue2中使用 `Object.defineProperty` 实现数据代理，Vue3使用 `Object.proxy()` 以后再说\n\n该方法可以向一个对象**添加新属性**或修改现有属性，且默认不可枚举、修改、删除\n\n```js\nconst obj = { name: 'chuckle' }\nObject.defineProperty(obj, 'age', {\n    value: 19,\n    enumerable: true, // 使新添加的属性可被枚举，默认false\n    writable: true, // 控制属性是否能被修改，默认false\n    configurable: true // 控制属性是否能被删除，默认false\n})\n\n```\n\n当 num 发生修改，obj.age 获取的值也会发生改变，当修改 obj.age ，num也会被修改，实现了两个对象间数据的双向绑定\n\n```js\nconst obj = { name: 'chuckle' }\nlet num = 19;\nObject.defineProperty(obj, 'age', {\n    // 当读取obj的age属性时，getter就会被调用，返回age的值\n    get() {\n        return num;\n    }\n    // 当修改obj的age属性时，setter就会被调用\n    set(value) {\n        num = value;\n    }\n})\n```\n\nVue中的数据代理：\n\n配置对象 data 中的键值对都会通过数据代理给 vm 管理，当读取或修改属性时触发对应的 getter 和 setter\n\n原来的data对象通过**数据劫持**变为 vm 上的 _data 属性，不直接赋值是为了实现响应式\n\n触发 setter 后，_data里对应的属性也会发生改变，Vue监听_data有发生改变，让模板（页面）也发生改变\n\n# 事件处理\n\n## v-on事件监听\n使用 `v-on` 指令进行事件监听，可简写为@，`@<事件名>=\"<回调函数名>\"`，也可以写一些简单的语句\n\n事件触发后的回调函数写在 **methods** 属性中，不做数据代理\n\n```html\n<div class=\"root\">\n  <button v-on:click=\"fun\">{{msg}}</button>\n  <!-- v-on:可以简写为@ -->\n  <button @click=\"fun\">{{msg}}</button>\n</div>\n<script>\n  new Vue({\n    el: \".root\",\n    data: {\n      msg: \"点击\",\n    },\n    methods: {\n      fun() {\n        alert(\"chuckle\");\n      },\n    },\n  });\n</script>\n\n```\n\nv-on 可以传入参数，默认传入 event，后续传入参数会覆盖 event，但可以传入 $event 来获取事件对象\n\n```html\n <div class=\"root\">\n   <button @click=\"fun('你好', $event)\">{{msg}}</button>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun(str, e) {\n         alert(`${str}chuckle`);\n         console.log(e);\n       },\n     },\n   });\n </script>\n\n```\n\n## 事件修饰符\nv-on 有事件修饰符。使用： `@<事件名>.<修饰符>` \n修饰符可以连着写多个 `@<事件名>.<修饰符>.<修饰符>`，分先后执行顺序\n\n**作用：**为了让方法中数据逻辑更加的纯粹，而不用去处理 DOM 的逻辑细节\n\n使用 prevent 修饰符代替 e.preventDefault() 阻止默认事件：\n\n```html e.preventDefault()和prevent修饰符阻止默认事件\n<!-- prevent修饰符 -->\n <div class=\"root\">\n   <a href=\"/\" @click.prevent=\"fun\">{{msg}}</a>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun() {\n         console.log('点击');\n       },\n     },\n   });\n </script>\n<!-- e.preventDefault() -->\n <div class=\"root\">\n   <a href=\"/\" @click=\"fun\">{{msg}}</a>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       msg: \"点击\",\n     },\n     methods: {\n       fun(e) {\n         console.log('点击');\n         e.preventDefault();\n       },\n     },\n   });\n </script>\n\n```\n\n**常用的点击事件修饰符：**\n1. **prevent** 阻止默认事件\n2. **stop** 阻止事件冒泡\n3. **once** 事件只触发一次\n4. **capture** 使用事件的捕获模式\n5. **self** 只有e.target是当前操作的元素才触发事件\n6. **passive** 事件的默认行为立即执行，无需等待回调函数执行完毕\n\n鼠标修饰符：\n1. left 左键\n2. right 右键\n3. middle 中建\n\n## 键盘事件\nVue中可以使用**按键别名**（修饰符）让特定按键去触发键盘事件，而无需使用e.key去判断\n\n**常用按键别名：**\n1. 回车 enter\n2. 删除、退格 delete\n3. 退出 esc\n4. 空格 space\n5. 换行 tab（不适合keyup 适合keydown）\n6. 上 up 下 down 左 left 右 right\n\n```html\n <div class=\"root\">\n   <input type=\"text\" @keyup.enter=\"fun\" placeholder=\"回车输入\"></input>\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     methods: {\n       fun(e) {\n         console.log(e.target.value);\n       },\n     },\n   });\n </script>\n```\n\n也可以通过 **.键名** 来绑定其它按键\n\n双驼峰的键名需要写成小写再用横杆连接，如 CapsLock 要写成 caps-lock\n\n```js\n@keyup.a=\"fun\" // 绑定字母A键\n@keyup.caps-lock=\"fun\" // 绑定切换大小写键\n@keyup.Control=\"fun\" // 绑定ctrl键\n```\n\n**系统修饰键：**ctrl、alt、shift、meta\n(1) 配合kyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n(2) 配合kydown使用：正常触发\n\n**自定义**键盘别名(不推荐使用)：\n\n```js\nVue.config.keyCodes.自定义键名=键码\n```\n\n技巧：利用keyup系统修饰键特性**绑定组合键**\n\n```js\n@keyup.ctrl.a=\"fun\" // 绑定ctrl+a，先按下ctrl再按下a，然后释放a才触发\n@keyup.alt.q=\"fun\" // 绑定alt+q\n```\n\n# 计算属性computed\n**计算属性：**通过已有的数据（属性）加工出一个新的属性\n\n在 `computed` 配置项中定义计算属性，计算属性要写成对象形式，并添加getter和setter(非必须)\n使用this访问vm上的属性\n\n计算属性会在**第一次**被调用后被**缓存**，即getter只触发一次，后续使用该属性会从缓存中拿\n当计算属性所**依赖**数据(在vm上的)发生变化时，会再次调用getter更新缓存\n\n**案例：**通过姓和名计算出全名\n\n```html\n <div class=\"root\">\n   姓：<input type=\"text\" v-model=\"firstName\"><br />\n   名：<input type=\"text\" v-model=\"lastName\"><br />\n   全名：<input type=\"text\" v-model=\"fullName\"><br />\n </div>\n <script>\n   new Vue({\n     el: \".root\",\n     data: {\n       firstName: \"张\",\n       lastName: \"三\"\n     },\n     // 计算属性配置项\n     computed:{\n          // 计算属性\n         fullName:{\n             get(){\n                 return `${this.firstName}-${this.lastName}`\n             },\n             set(name){\n                 let arr = name.split(\"-\");\n                 this.firstName = arr[0];\n                 this.lastName = arr[1];\n             }\n         }\n     }\n   });\n </script>\n\n```\n\n当计算属性**只读不写**时，可以简写，直接将计算属性值写成一个函数，作为getter\n\n```js\nnew Vue({\nel: \".root\",\ndata: {\n firstName: \"张\",\n lastName: \"三\"\n},\n// 计算属性配置项\ncomputed:{\n    // 计算属性\n    fullName(){\n        return `${this.firstName}-${this.lastName}`\n    }\n}\n}\n});\n\n```\n\n当计算量非常大的时候，而且访问量次数非常多，改变的时机却很小，那就需要用到computed；缓存会减少很多计算量\n\n**computed** 与 **methods** 区别：\n1. computed是属性访问，而methods是函数调用。computed带有缓存功能，而methods没有\n2. computed是响应式的，methods并非响应式\n3. computed是以对象的属性方式存在的，在视图层直接调用就可以得到值，如：`{{msg}}` ，而methods必须以函数形式调用，例如：`{{msg()}}` ，computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果\n4. computed带缓存，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行\n5. computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n\n# 监视属性watch\n**watch** 配置项中定义监视属性，监视某一**属性的变化**，监视属性本身也是一个配置项\n\n可以监视data中的属性，也可以监视计算属性，若属性不存在也不会报错\n\n**作用：**当属性值发生变化后进行某些操作\n\n```js\nwatch: {\n  <属性名>: {\n    <监视配置项>\n  }\n}\n```\n\n```html\n <div class=\"root\">\n     <h2>今天天气: {{weather}}</h2>\n     <button @click=\"changeWeather\">切换天气</button>\n </div>\n <script>\n   const vm = new Vue({\n     el: \".root\",\n     data: {\n         isHot: true,\n     },\n     computed: {\n         weather(){\n             return this.isHot ? \"炎热\" : \"凉爽\"\n         }\n     },\n     methods: {\n         changeWeather(){\n             this.isHot = !this.isHot;\n         }\n     },\n     watch: {\n         weather: {\n             // 初始化时调用一次handler\n             immediate: true,\n             // 当监视属性发生变化时触发handler\n             handler(newValue, oldValue){\n                 // 传入属性新老值两个参数\n                 console.log(newValue, oldValue);\n             }\n         }\n     }\n   });\n </script>\n\n```\n\n也可以通过vm的 `$watch()` 方法来监视某个属性\n\n```js\nvm.$watch(\"weather\", {\n  // 初始化时调用一次handler\n  immediate: true,\n  // 当监视属性发生变化时触发handler\n  handler(newValue, oldValue) {\n    // 传入属性新老值两个参数\n    console.log(newValue, oldValue);\n  },\n});\n\n```\n\n**深度监视：**\n\n当监视多级结构中的**某个属性**时，属性名要写成字符串，或者 num[a]\n\n```js\nconst vm = new Vue({\n  el: \".root\",\n  data: {\n      num: {\n        a: 1,\n        b: 2\n      }\n  },\n  watch: {\n      // 深度监视写成字符串\n      'num.a': {\n          // 初始化时调用一次handler\n          immediate: true,\n          // 当监视属性发生变化时触发handler\n          handler(newValue, oldValue){\n              // 传入属性新老值两个参数\n              console.log(newValue, oldValue);\n          }\n      }\n  }\n});\n```\n\n监视**整个**多级结构所有属性时，要添加配置项 **deep: true**，handler参数是该num对象\n\n```js\nconst vm = new Vue({\n  el: \".root\",\n  data: {\n      num: {\n        a: 1,\n        b: 2\n      }\n  },\n  watch: {\n      // 深度监视写成字符串\n      num: {\n          // 监视整个num和num里的属性\n          deep: true,\n          // 初始化时调用一次handler\n          immediate: true,\n          // 当监视属性发生变化时触发handler\n          handler(newValue, oldValue){\n              // 传入属性新老值两个参数\n              console.log(newValue, oldValue);\n          }\n      }\n  }\n});\n\n```\n\n当监视属性配置中只有 handler 方法时，可以简写\n\n```js\nwatch: {\n   weather(newValue, oldValue){\n      console.log(newValue, oldValue);\n   }\n}\n// 不再传一个配置对象，直接传一个函数作为handler\nvm.$watch(\"weather\", function(newValue, oldValue){\n  console.log(newValue, oldValue);\n});\n\n```\n\n**注意：**计算属性多个影响一个的时候用，监听属性一个影响多个或有复杂（异步）业务的时候用\n\n# 绑定class样式\n通过 **v-bind** 动态得将样式class应用到盒子上\n\n每个标签只能有一个 class 属性，但vue会自动将绑定的 class 合并到现有的 class 属性上\n\n有三种绑定形式：\n1. **字符串写法**，适用于样式的类名不确定，需要动态指定\n2. **数组写法**，适用于要绑定的样式个数不确定，名字也不确定\n3. **对象写法**，适用于要绑定的样式个数、名字确定，但需要动态决定用不用\n\n```css\n.basic {\n  border: 1px solid #222;\n  margin: 20px;\n}\n/* 控制盒子大小，互斥 */\n.big {\n  width: 300px;\n  height: 300px;\n}\n.small {\n  width: 100px;\n  height: 100px;\n}\n.normal {\n  width: 200px;\n  height: 200px;\n}\n/* 控制其它样式，可同时使用 */\n.fcolor {\n  color: rgb(227, 57, 57);\n}\n.bg {\n  background: #ccc;\n}\n.bdcolor {\n  border-color: rgb(20, 153, 149);\n}\n\n```\n\n```html\n <div id=\"root\">\n   <!-- 字符串写法，适用于样式的类名不确定，需要动态指定 -->\n   <div class=\"basic\" :class=\"size\" @click=\"changeSize\">{{msg}}</div>\n   <!-- 数组写法，适用于要绑定的样式个数不确定，名字也不确定 -->\n   <div class=\"basic normal\" :class=\"classArr\">{{msg}}</div>\n   <!-- 对象写法，适用于要绑定的样式个数确定，名字也确定，但需要动态决定用不用 -->\n   <div class=\"basic normal\" :class=\"classObj\">{{msg}}</div>\n </div>\n <script>\n   let sizeArr = [\"small\", \"normal\", \"big\"];\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       size: \"normal\",\n       classArr: [\"fcolor\", \"bg\", \"bdcolor\"],\n       classObj: {\n         // true则应用样式，false不应用\n         fcolor: false,\n         bg: true,\n         bdcolor: true,\n       },\n     },\n     methods: {\n       //点击随机切换大小\n       changeSize() {\n         this.size = sizeArr[Math.floor(Math.random() * sizeArr.length)];\n       },\n     },\n   });\n </script>\n\n```\n\n# 绑定style行内样式\n两种写法：对象写法、数组写法。对象中属性名单驼峰\n\n```html\n <div id=\"root\">\n     <!-- 对象写法 -->\n   <div class=\"basic\" :style=\"styleObj\">{{msg}}</div>\n   <!-- 数组写法 -->\n   <div class=\"basic\" :style=\"styleArr\">{{msg}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       styleObj: {\n         fontSize: '40px',\n         color: '#363636',\n         background: '#ccc',\n       },\n       // 数组内写样式对象，一般不用\n       styleArr: [\n         {\n             fontSize: '40px',\n         },\n         {\n             background: '#ccc',\n         }\n       ]\n     }\n   });\n </script>\n\n```\n\n# 条件渲染v-if\n条件渲染，符合某些条件才渲染元素，即通过指令去控制元素的显隐，不同指令实现原理不同\n\n`v-show=\"<表达式>\"` 表达式结果需能表示为布尔值\n\n**原理：**使用 `display:'none'` 隐藏元素，节点仍在\n\n`v-if=\"<表达式>\"` 表达式结果需能表示为布尔值\n\n**原理：**在模板解析时不渲染该元素，节点不存在，会用一个空注释占位\n\n```html\n <div id=\"root\">\n   <!-- v-show -->\n   <div v-show=\"isShow\">{{msg}}</div>\n   <!-- v-if -->\n   <div v-if=\"isShow\">{{msg}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       isShow: false,\n     },\n   });\n </script>\n\n```\n\n当显隐切换频率高使用 v-show 性能更好\n\n`v-else-if`和`v-else` 需配合 **v-if** 使用，效果和js中 if-else 一样\n\n使用这两个指令需要div结构**相邻**\n\n```html\n <div id=\"root\">\n   <!-- v-else-if -->\n   <div v-if=\"n === 1\">{{n}}</div>\n   <!-- 当if匹配到一个就不会再往后判断 -->\n   <div v-else-if=\"n === 1\">重复{{n}}</div>\n   <div v-else-if=\"n === 2\">{{n}}</div>\n   <div v-else-if=\"n === 3\">{{n}}</div>\n   <!-- v-else不用写表达式 -->\n   <div v-else>{{n}}</div>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       n: 1\n     },\n   });\n </script>\n\n```\n\n当多个标签显隐条件一样时，可以使用 `＜template＞` 标签包裹，在该标签中写 **v-if** ，实际html结构中不会存在该标签\n\n```html\n<template v-if=\"n===1\">\n  <h1>{{msg}}</h1>\n  <h2>{{msg}}</h2>\n  <h3>{{msg}}</h3>\n</template>\n```\n\n# 列表渲染v-for\n`v-for` 将数组或对象中一系列重复、相似的数据渲染到页面中，这些数据应该要有**唯一标识**（通常是id）\n\n使用方法类似js中的 **for-in**\n\n使用 v-for 遍历渲染需要在标签内绑定上 **key** 属性作为唯一标识\n\n```html 用法\n<ul>\n  <!-- 参数1 p是persons中的元素，参数2 index/key是索引，遍历数组时是从0开始的数组下标，遍历对象时是每个属性名-->\n  <!-- key标签属性是唯一标识 -->\n  <li v-for=\"(p,index) in persons\" :key=\"p.id\">{{index}} - {{p.name}} - {{p.age}}</li>\n</ul>\n```\n\n遍历数组：\n\n```html\n <div id=\"root\">\n   <ul>\n     <li v-for=\"(p,index) in persons\" :key=\"p.id\">{{index}} - {{p.name}} - {{p.age}}</li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 需渲染的数据\n       persons: [\n         { id: '001', name: 'chuckle', age:'19'},\n         { id: '002', name: 'qx', age:'18'},\n         { id: '003', name: 'giggles', age:'20'},\n       ],\n     },\n   });\n </script>\n\n```\n\n遍历对象：\n\n```html\n <div id=\"root\">\n   <ul>\n     <li v-for=\"(p,key) in commodity\" :key=\"key\">{{key}} - {{p}}</li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 需渲染的数据\n       commodity: {\n         name: '商品1',\n         price: 20,\n         place: '中国'\n       }\n     },\n   });\n </script>\n\n```\n\n## key\nv-for 遍历渲染时需要给每个标签绑定 key 属性，作为**唯一标识**\n\nkey 在 vue 内部**虚拟DOM**上使用，解析模板时不会渲染到页面上\n\n**作用：**vue在解析模板到真实DOM上时，会先将数据转为虚拟DOM，当数据发生变化，又会再生成一次虚拟DOM，然后会用diff算法**对比**新旧两份虚拟DOM，对比过程依赖 **key**，将key相同的标签内**所有属性和节点**单独进行对比，将相同的节点进行**dom复用**，不同的则**新覆盖旧**，新虚拟DOM中**没有的key则删除**对应标签\n\n**diff算法:** 对比两个新旧虚拟dom（两棵树）之间的差异的一种算法\n\n**选择key：**\n使用后端维护的唯一标识，id、手机号、学号等\n\n若不手动绑定key，vue会自动将index作为key\n一般不使用 index 作为key，因为index不与数据一一对应，会导致diff算法对比时发生问题（逆序操作时无法正常复用dom、虚拟dom中不存在的用户输入\\[input\\]会发生错位）\n\n如果不存在对数据的逆序添加、逆序明除等破坏顺序操作，仅用于渲染列表用于展示，可以使用index作为key\n\n## 列表过滤\n业务中经常需要对原数据进行搜索过滤后再展示，可以使用计算属性实现\n\n若业务较复杂也可使用监视属性实现，但应优先考虑计算属性\n\n```html\n <div id=\"root\">\n   <!-- 列表过滤 -->\n   <input type=\"text\" placeholder=\"模糊搜索姓名\" v-model=\"keyWord\">\n   <ul>\n     <li v-for=\"(p,index) in fillPersons\" :key=\"p.id\">\n       {{index+1}} - {{p.name}} - {{p.age}} - {{p.sex}}\n     </li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 搜索的关键字\n       keyWord: \"\",\n       // 需渲染的数据\n       persons: [\n         { id: \"001\", name: \"张三\", age: \"19\", sex: \"男\" },\n         { id: \"002\", name: \"李三\", age: \"18\", sex: \"女\" },\n         { id: \"003\", name: \"李四\", age: \"20\", sex: \"女\" },\n         { id: \"004\", name: \"刘四\", age: \"18\", sex: \"男\" },\n       ]\n     },\n     computed: {\n       // 通过搜索关键字和原数据计算出的数据\n       fillPersons: {\n         get(){\n           return this.persons.filter((item)=>{\n             return item.name.indexOf(this.keyWord) !== -1;\n           })\n         }\n       }\n     }\n   });\n </script>\n\n```\n\n## 列表排序\n实际业务中多是后端排好序，但前端排序有时也会用到\n\n列表排序和列表过滤通常一起用\n\n```html\n <div id=\"root\">\n   <!-- 列表过滤和排序 -->\n   <input type=\"text\" placeholder=\"模糊搜索姓名\" v-model=\"keyWord\" />\n   <br />\n   <button @click=\"sortType=1\">年龄升序</button>\n   <button @click=\"sortType=-1\">年龄降序</button>\n   <button @click=\"sortType=0\">原序</button>\n   <ul>\n     <li v-for=\"(p,index) in fillPersons\" :key=\"p.id\">\n       {{index+1}} - {{p.name}} - {{p.age}} - {{p.sex}}\n     </li>\n   </ul>\n </div>\n <script>\n   new Vue({\n     el: \"#root\",\n     data: {\n       msg: \"chuckle\",\n       // 控制排序类型,0原序1升-1降\n       sortType: 0,\n       // 搜索关键字\n       keyWord: \"\",\n       // 需渲染的数据\n       persons: [\n         { id: \"001\", name: \"张三\", age: 19, sex: \"男\" },\n         { id: \"002\", name: \"李三\", age: 18, sex: \"女\" },\n         { id: \"003\", name: \"李四\", age: 21, sex: \"女\" },\n         { id: \"004\", name: \"刘四\", age: 20, sex: \"男\" },\n       ],\n     },\n     computed: {\n       // 通过搜索和排序类型计算出的数据\n       fillPersons: {\n         get() {\n           // 根据关键字筛选\n           let arr = this.persons.filter((item) => {\n             return item.name.indexOf(this.keyWord) !== -1;\n           });\n           // 进行排序\n           if (this.sortType) arr.sort((a, b) => this.sortType * (a.age - b.age));\n           return arr;\n         },\n       },\n     },\n   });\n </script>\n\n```\n\n# 监视数据(响应式)原理\nVue 会监视 data 中所有层次的数据。当数据发生改变，会重新解析模板，也就是数据的**响应式**\n\n这种监视是通过**每个属性**对应的 **setter** 实现的，在 setter 中对数据进行实际的修改、重新解析模板等操作\n\n## 数据劫持\n对 data 中的数据进行加工，添加 getter、setter 以实现某些交互功能（响应式） 就是**数据劫持**\n\n与**数据代理**的区别：数据代理是通过一个对象代理对另一个对象中属性的操作（读/写），而数据劫持是对一个对象中原有的属性进行加工\n\n利用数据劫持简单复刻一下 Vue 的响应式：\n\n```js\n// data数据\nlet data = {\n   name: 'chuckle',\n   age: 19\n}\n// 创建监视实例对象，监视data中数据变化\nconst obs = new Observer(data)\n\n// vue实例对象\nlet vm = {}\n// 将obs引用地址赋给vm._data和data\n// 此刻就完成了数据劫持，原来的data的地址只有当时传入Observer的参数obj才知道\n// data只是地址发生了改变，但原来的数据仍然在一个地址中，被obs所管理\nvm._data = data = obs\n\n// 监视构造函数，能创建监视实例对象\n// 传入要监视的对象\nfunction Observer(obj) {\n   // 拿到对象后提取所有属性名到一个数组中\n   const keys = Object.keys(obj)\n   // 遍历keys，加工属性\n   keys.forEach((k)=>{\n       // 和数据代理一样，用到defineProperty\n       // 构造函数中的this是其实例对象\n       // 这一步相当于将data上的数据代理到实例对象上\n       Object.defineProperty(this,k,{\n           // 添加getter、setter。实现属性的读写\n           get(){\n               return obj[k]\n           },\n           set(val){\n               obj[k] = val\n               // 修改完值后，就可以去重新解析模板\n               parsingTemplates()\n           }\n       })\n   })\n}\n// vue重新解析模板的函数实现，怎么实现的暂时不研究\nfunction parsingTemplates(){\n   console.log('重新解析模板');\n}\n\n```\n\n输出 vm._data 对象：\n\n```js\nObserver {}\n  age: （…） // 19\n  name: （…） // 'qx'\n  get age: ƒ get()\n  set age: ƒ set(val)\n  get name: ƒ get()\n  set name: ƒ set(val)\n  [[Prototype]]: Object\n\n```\n\n**实现效果：**当修改 vm._data 中的数据，控制台会输出【重新解析模板】\n\n**发生了什么：**通过**数据代理**将 data 中数据的读和写操作代理到了**监视实例对象** obs 身上，并且在 setter 中调用**解析模板**的函数，这是实现**响应式**的关键，然后将 obs 引用地址赋值给 vm._data，上面这些步骤就实现了**数据劫持**，即 Vue 中并不是直接将 data 赋值给 vm._data，而是先劫持 data，对 data 进行加工后，将加工好的 obs 赋给 vm._data\n\n后面就是正常的数据代理操作，将 vm._data 通过数据代理到 vm 身上，方便操作\n\n**注意：**Vue中的响应式实现要比这完善得多\n1. 没有考虑data数据是多层次情况，Vue会找到data中所有层次的对象的属性进行加工\n2. 数组中元素的响应式\n\n## $set()追加属性\n通过之前的操作 Vue 可以响应式地监视 data 数据\n\n但如果不是编写代码时就写在 data 中的数据，而是之后通过 **.** 动态添加的属性，Vue则无法监视，修改这些属性值，模板不会重新解析，页面不会变化\n\n可以通过 `Vue.set()` 或 `vm.$set()` 动态添加可被 Vue 监视的属性\n传入三个参数 **(<目标对象>, <属性名>, <属性值>)**\n\n**作用：**向响应式对象中添加一个 property（属性），并让这个新 property 同样是响应式的，且触发视图更新。\n\n**注意：目标对象**不能是data或vm实例，只能是其中的某个**实际存在**的对象，\n\n```js\nconst vm = new Vue({\n  el: '#root',\n  data: { student: {} }\n})\n// 追加属性\nVue.set(vm.student, 'name', 'chuckle')\n// $set()还能用于修改属性值\n// 一般是在修改数组元素后为了能被Vue监视到这次修改而使用\nvm.$set(vm.student, 'name', 'qx')\n\n// 不能直接在data或vm实例上添加属性\nvm.$set(vm, 'name', 'qx')\nvm.$set(vm._data, 'name', 'qx')\n\n// 直接添加不会被Vue监视，无法响应式\nvm._data.student.name = 'chuckle'\nvm.student.name = 'chuckle'\n\n```\n\n## 对数组的监视\nJS中数组也是一个对象，但它不能添加getter和setter，也就是不能通过数据劫持来实现数组中元素的响应式，无法触发视图更新\n\nVue 无法在元素被**通过索引值**修改后，响应式地重新解析模板，触发视图更新\n\n```js\nconst vm = new Vue({\n  el: '#root',\n  data: { student: ['001', 'chuckle', '19'] }\n})\n// 修改student数组中第一个元素，不会触发视图更新\nvm.student[0] = '002';\n```\n\n**Vue对数组元素的监视：**将被监视的数组的**变更方法**进行了**包装**，调用这些变更方法就会触发**视图更新**。\n\n**变更方法：**push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n\n**包装:**在Vue中的数组上重写同名的变更方法，在重写的方法中也会调用原来 **Array** 上的变更方法，但还加入了视图更新等操作\n\n也可以通过 `$set()` 在变更数组时也触发视图更新：\n\n```js\n// 修改第二个元素\nvm.$set(vm.student, 1, 'qx')\n```\n\n# 收集表单数据\n**v-model** 对不同表单元素有特殊的处理\n1. 若 **< input type='text'/>** 文本输入框 v-model 收集 **value** 值，即收集用户在输入框的输入\n2. 若 **< input type='radio'/>** 单选框 v-model 收集 **value** 值，但要给标签配置 value 值\n3. 若 **< input type='checkbox'/>** 多选框\n  1. 没有配置value值，则默认收集checked，一个被勾选会导致全部被勾选\n  2. 配置value值后，v-model初始值为数组，收集的是value值作为元素到数组中，初始值为空字符串，则收集checked\n\nv-model 也有**修饰符**，对收集的数据进行简单处理\n1. lazy 失去焦点再收集数据\n2. number 输入字符串转为有效数字，通常和 **< input type='number'/>** 一起使用\n3. trim 去除字符串首尾空格\n\n```html 案例：用户信息收集\n<div id=\"root\">\n  <!-- 绑定提交事件，后续发送ajax请求 -->\n  <form @submit.prevent=\"submit\">\n      用户名： <input type=\"text\" v-model.trim=\"formInfo.username\" /><br />\n      密码： <input type=\"password\" v-model=\"formInfo.password\" /><br />\n      <!-- 数字输入 -->\n      年龄： <input type=\"number\" v-model.number=\"formInfo.age\" /><br />\n      <!-- 单选框 -->\n      性别：\n      <label for=\"man\">男</label>\n      <input type=\"radio\" v-model=\"formInfo.sex\" name=\"sex\" id=\"man\" value=\"男\"/>\n      <label for=\"woman\">女</label>\n      <input type=\"radio\" v-model=\"formInfo.sex\" name=\"sex\" id=\"woman\" value=\"女\"/><br />\n      <!-- 多选框 -->\n      爱好：\n      <label for=\"hobbyOne\">吃饭</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyOne\" value=\"吃饭\"/>\n      <label for=\"hobbyTwo\">睡觉</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyTwo\" value=\"睡觉\"/>\n      <label for=\"hobbyThree\">打豆豆</label>\n      <input type=\"checkbox\" v-model=\"formInfo.hobby\" name=\"hobby\" id=\"hobbyThree\" value=\"打豆豆\"/><br />\n      <!-- 下拉框 -->\n      城市：\n      <select v-model=\"formInfo.city\">\n          <option value=\"北京\">北京</option>\n          <option value=\"上海\">上海</option>\n          <option value=\"广州\">广州</option>\n      </select><br />\n      其他信息：\n      <textarea v-model.lazy=\"formInfo.other\"></textarea><br />\n      <input type=\"checkbox\" v-model=\"formInfo.agree\" name=\"agree\"/>接受用户协议<br />\n      <button>提交</button>\n  </form>\n</div>\n\n<script>\n  new Vue({\n      el: \"#root\",\n      data: {\n          // 表单信息对象\n          formInfo: {\n              username: \"\",\n              password: \"\",\n              age: \"\",\n              sex: \"\",\n              hobby: [],\n              city: \"\",\n              other: \"\",\n              agree: false,\n          },\n      },\n      methods: {\n          submit() {\n              // 输出收集的表单数据并转为json格式\n              console.log(JSON.stringify(this.formInfo));\n          },\n      },\n  });\n</script>\n\n```\n\n# 过滤器\nVue3中已废弃过滤器\n\n在 **filters** 中配置**局部**过滤器，`Vue.filter()` 中配置**全局**过滤器\n\n和计算属性一样，过滤器也是对现有数据进行加工，本质上是函数\n\n**使用：** `{{ 数据 | 过滤器1 | 过滤器2 }}` **管道符**分隔，会依次传参调用，也可以在指令语法中使用，前一个的结果作为后面过滤器的**第一个**参数，返回这作为结果，还可以再传额外的参数\n\n```html\n<div id=\"root\">\n  <h3>时间：{{ time | fmtTime | interceptStr }}</h3>\n</div>\n<script>\n  // 全局过滤器\n  Vue.filter('interceptStr',(value, num=4)=>{\n      return value.slice(0,num)\n  })\n  new Vue({\n      el: '#root',\n      data: {\n          time: 1683449879865,\n      },\n      // 局部过滤器\n      filters: {\n          fmtTime(value, str='YYYY-MM-DD HH:mm:ss'){\n              return dayjs(value).format(str);\n          }\n      }\n  })\n</script>\n\n```\n\n# 常见内置指令\n前面已经学习了不少内置指令，v-on、v-bind、v-model、v-show、v-if、v-for等\n\nVue中还有一些常见的内置指令：\n1. `v-text` innerText同款效果\n2. `v-html` innerHtml同款效果，需注意安全性问题xss攻击\n3. `v-clock` 当Vue接管容器时，删除所有v-clock属性，配合css属性选择器实现隐藏未编译的 Mustache 标签直到实例准备完毕，或加载动画\n```css\n[v-cloak] { display: none; }\n```\n4. `v-once` 只渲染元素和组件一次，后续重新解析模板渲染页面会直接复用带有v-once的标签，视为静态内容，这可以用于优化更新性能\n5. `v-pre` 跳过这个元素和它的子元素的编译过程，用于跳过没有指令和插值语法的节点，能加快编译。\n\n# 自定义指令\n指令通过操控dom来控制交互或样式，如 v-show 通过操控css display 属性，来控制元素显隐\n\nVue的指令就是将原生操控dom的JS代码进行了**封装**\n\n自定义指令需要亲自去写操控 dom 的JS代码\n\n**注册指令：**\n自定义指令函数式传入两个参数\n1. **el** 指令所在的标签dom元素\n2. **binding** 一个对象，包含绑定相关的信息，其中 **value** 属性值是表达式的值\n\n分为**全局指令**和**局部指令**:\n\n```js\n// 注册全局指令\nVue.directive('<指令名>', function(el, binding){\n  el.innerHTML = binding.value\n})\n// 注册局部指令\nnew Vue({\n  el: '#root',\n  data: { },\n  directives: {\n    '<指令名>'(el, binding){\n      el.innerHTML = binding.value\n    }\n  }\n})\n\n```\n\n**指令名的问题：**\n指令名不应该写成驼峰形式，要用**横杠形式**。若指令名为单驼峰形式，使用指令时会找不到指令\n\n```js\ndirectives: {\n    'num-tenfold'(el, binding){ }\n  }\n// 使用指令：\n// <span v-num-tenfold=\"n\"></span>\n```\n\n**注意：**指令中的this指向window\n\n## 指令内容写法\n自定义指令的内容有**两种写法**：对象式、函数式\n\n**1、对象式：**\n\n```html\n<div id=\"root\">\n  <h3>n值：{{n}}</h3>\n  <h3>\n      放大十倍n值：\n      <!-- v-tenfold让n值放大10倍再应用到标签内容上 -->\n      <span v-tenfold=\"n\"></span>\n  </h3>\n  <button @click=\"n++\">让n+1</button>\n</div>\n<script>\n  new Vue({\n      el: '#root',\n      data: {\n          n: 0\n      },\n      // 注册局部指令\n      directives: {\n          // 指令名不用带v-\n          tenfold: {\n              // 指令与元素成功绑定（还未放到页面上）时调用\n              bind(el, binding){\n                  el.innerHTML = binding.value * 10;\n              },\n              // 元素应用到页面后，进行dom相关操作\n              inserted(el, binding){\n                  // 让其父元素背景变灰色\n                  el.parentNode.style.background = \"#ccc\";\n              },\n              // 指令所在的模板被重新解析时调用\n              update(el, binding) {\n                  el.innerHTML = binding.value * 10;\n              },\n          }\n      }\n  })\n</script>\n\n```\n\n**对象式**指令被调用：\n1. 指令与元素成功绑定（还未放到页面上）时，调用对象中 `bind()` 函数\n2. 指令所在元素被插入页面上时，调用对象中 `inserted()` 函数\n3. 指令所在的模板被重新解析时，调用对象中 `update()` 函数\n\nVue在不同时刻会调用指令对象中不同的函数\n\n**2、函数式：**\n\n```html\n<div id=\"root\">\n  <h3>n值：{{n}}</h3>\n  <h3>\n      放大十倍n值：\n      <!-- v-tenfold让n值放大10倍再应用到标签内容上 -->\n      <span v-tenfold=\"n\"></span>\n  </h3>\n  <button @click=\"n++\">让n+1</button>\n</div>\n<script>\n  new Vue({\n      el: '#root',\n      data: {\n          n: 0\n      },\n      // 注册局部指令\n      directives: {\n          // 指令名不用带v-\n          tenfold(el, binding){\n              el.innerHTML = binding.value * 10;\n              // 因为没有inserted状态，且在bind状态时获取不到dom元素\n              // 父元素一开始并不会应用此灰色背景\n              // 后续重新解析模板时就有效果，因为元素已被应用可获取到父元素\n              el.parentNode.style.background = \"#ccc\";\n          }\n      }\n  })\n</script>\n\n```\n\n函数式将对象式的 `bind()` 与 `update()` 函数合二为一，Vue2中没有合并上 `inserted()` 函数的效果，即Vue2中函数式里一般不能进行dom相关操作\n\n**函数式**指令被调用：\n1. 指令与元素成功绑定（还未放到页面上）时\n2. 指令所在的模板被重新解析时\n\n","tags":["前端","Vue"],"categories":["学习笔记"]},{"title":"Promise异步编程","url":"/article/7a1fbbc5.html","content":"\n# 同步与异步\nJS是**单线程**语言，不能多个线程并发执行，即同一时间，只能处理一个任务\n\n单线程指的是浏览器中只有一个主线程(**JS引擎线程**)负责解释和执行JS代码，但是浏览器还提供了额外多个副线程用于实现**异步非阻塞**\n1、事件触发线程\n2、定时触发器线程\n3、异步http请求线程\n4、GUI渲染线程\n\n副线程处理完成之后会把对应的**回调函数**交给**消息队列**（任务队列）维护，JS引擎线程会在同步任务执行完后，去消息队列中每次取一个任务执行\n\n**两种任务**\n**同步任务：**在主线程上排队执行任务，只有前一个任务执行完毕，才能执行后一个任务\n**异步任务：**不进入主线程，而是进入**消息队列**的任务\n\n## 宏、微任务\n每次执行栈中执行的代码就是一个**宏任务**，在执行宏任务时遇到Promise等，会创建**微任务**（.then()里面的回调），并加入到微任务队列队尾。\n\n微任务必然是在某个宏任务执行过程时创建的\n\n宏任务来源：script，setTimeout，setInterval，setImmediate，I/O，requestAnimationFrame，UI rendering\n微任务来源：process.nextTick，promisesObject.observe，MutationObserver\n\n**微任务的执行：**在执行栈为空时，会从消息队列中取一个回调函数作为宏任务，在这个宏任务**执行前**，会执行微任务队列中**所有的**微任务\n\n## 事件循环\n事件循环就是主线程**重复**从消息队列中取消息（回调函数）并执行的过程\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/52-2.webp width=\"100%\" loading=\"lazy\">\n\n**参考：**\n[一篇搞定（Js异步、事件循环与消息队列、微任务与宏任务）](https://zhuanlan.zhihu.com/p/139967525)\n[JS的事件轮询(Event Loop)机制](https://juejin.cn/post/6844904047271477255)\n\n# Promise\nPromise(承诺) ES6的新类，是异步编程的新解决方案\n\n**作用：**把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数\n\n**回调地狱：**通过回调函数依次执行多个异步操作。Promise通过链式操作解决了回调地狱问题，也能更好地进行错误处理\n\n```js\nsetTimeout(function () {\n    console.log(\"等待一秒\");\n    setTimeout(function () {\n        console.log(\"再等一秒\");\n        setTimeout(function () {\n            console.log(\"又等一秒\");\n        }, 1000);\n    }, 1000);\n}, 1000);\n\n```\n\n以fetch为例，它返回一个Promise对象，承诺会在某个时刻返回请求到的数据，请求成功，会调用.then中的回调函数，失败则调用.catch中的\n\n任意一个then出现错误都会触发catch，而then不再往下执行，但catch后的then会继续执行\n\n.then中也可以返回一个Promise，如 res.json() 返回一个Promise，承诺之后将请求的数据返回为json格式，以此实现链式操作\n\n无论是成功还是失败，最后都会执行 .finally 中的回调函数，可以用于提示请求完成、关闭加载动画等\n\n```js\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> console.log(data) )\n.catch(err => console.error(err) )\n.finally(()=> console.log('请求结束') )\n```\n\n## 使用\nPromise本身是一个构造函数，其对象用来封装一个异步操作，并可以获取其成功或失败的结果值\n\n它拥有all、reject、resolve等方法，原型上有then、catch等方法\n\n**有三种状态：**pending（进行中）、resolved / fulfilled（已成功）和rejected（已失败），初始状态pending，只能转变为其它状态**一次**。\n状态\\[\\[PromiseState\\]\\]是Promise实例对象的属性，但并不是一个暴露的属性，无法获取和外部修改\n\nPromise的构造函数接收一个函数参数，传入两个参数：**resolve**，**reject**，分别表示异步操作执行**成功后的回调**函数和异步操作执行**失败后的回调**函数。\nresolve() 会将Promise的状态置为**resolved**，reject() 会将Promise的状态置为**rejected**\n\n`.then(onResolved, onRejected)` onResolved 和 onRejected 是两个回调函数，分别接收 resolve() 和 reject() 传入的参数，并在对应状态时回调\n\n> **注意：**Promise中所谓的成功或失败，需要根据业务的需要而定义，它只是提供了这两个状态供使用。\n\n```js\nconst p = new Promise((resolve, reject)=>{\n    // 随机生成0或1\n    let num = Math.round(Math.random());\n    // 定义num为1时是成功，0为失败，调用resolve()\n    if(num){\n        resolve(num);\n    }else{\n        reject(num);\n    }\n});\n\np.then(\n    data => { console.log(data) },\n    data => { console.log(data) }\n);\n\n```\n\nPromise封装AJAX\n\n```js\nfunction sendAJAX(url) {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.responseType = 'json';\n        xhr.open('GET', url, true);\n        xhr.send();\n        // 处理结果\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                 // 请求完成进行判断\n                if ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304) {\n                    // 定义为请求成功，将响应传入\n                    resolve(xhr.response);\n                } else {\n                    // 定义失败将状态码传入\n                    reject(xhr.status);\n                }\n            }\n        };\n    })\n}\n\n```\n\n使用封装好的 sendAJAX()\n\n```js\nsendAJAX('https://api.ooomn.com/api/yan?encode=json')\n.then(\n    res => console.log(res),\n    reason => console.log(reason)\n)\n.catch( err => console.log(err) )\n.finally(()=> console.log('请求完成') )\n```\n\n## 基本流程\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/52-3.webp width=\"100%\" loading=\"lazy\">\n\n## 属性和方法\n**1、\\[\\[PromiseResult\\]\\]** 承诺结果，保存着异步任务成功或失败的结果，即保存着 resolve() 或 reject() 传入的值，then中回调函数的参数可获取\n\n**2、**Promise构造函数传入的函数参数，其内部的操作是**同步**的\n\n```js\nnew Promise((resolve, reject) => {\n    console.log('1');\n})\n console.log('2');\n // 1\n // 2\n```\n\n**3、then 和 catch**\n**Promise.prototype.then** : (onResolved, onRejected) => {}\n(1) onResolved 函数: 成功的回调函数 (value) => {}\n(2) onRejected 函数: 失败的回调函数 (reason) => {}\n说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调\n返回一个新的 promise 对象\n\n**Promise.prototype.catch** : (onRejected) => {}\n(1) onRejected 函数: 失败的回调函数 (reason) => {}\n说明: then()的语法糖, 相当于: then(undefined, onRejected)\n\n> 通常不使用then的第二个参数，而是直接使用catch捕获失败\n\n### 静态方法\n**1、resolve 和 reject**\n**Promise.resolve** : (value) => {}\n(1) value: 成功的数据或 promise 对象\n说明: 当传入promise对象时，参数的结果决定了promise的结果。将状态从 pending 转为 fulfilled\n返回一个成功/失败的 promise 对象\n\n**Promise.reject** : (reason) => {}\n(1) reason: 失败的原因\n将状态从 pending 转为 rejected\n永远返回一个失败的 promise 对象\n\n```js\nlet p1 = Promise.resolve(123);\np1.then(data => console.log(data));// 123\n\nlet p2 = Promise.resolve(new Promise((resolve, reject) => {\n    reject('Error');\n}));\np2.catch(reason => {\n    console.log(reason);// Error\n})\n\n```\n\n**2、all**\n**Promise.all** : (promises) => {}\n(1) promises: 包含 n 个 promise 对象的数组\n返回一个新的 promise, 所有的 promise 都成功才成功, 只要一个失败就直接失败，多个失败返回第一个失败\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    resolve('OK');\n})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\nconst result = Promise.all([p1, p2, p3])\nresult.then(data=>console.log(data))\n// (3) ['OK', 'Success', 'Oh Yeah']\n\n```\n\n**3、race**\n**Promise.race** : (promises) => {}\n返回一个新的 promise, 第一个改变状态的 promise 的结果就是返回的结果状态\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\nconst result = Promise.race([p1, p2, p3]);\nresult.then(data => console.log(data));\n// Success\n\n```\n\n**3、any**\n**Promise.any** : (promises) => {}\n返回一个新的 promise, 只要有一个成功就成功，全失败才失败，返回第一个成功的结果\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('OK');\n    }, 1000);\n})\nlet p2 = Promise.reject('reject');\nlet p3 = Promise.reject('no no no');\nconst result = Promise.any([p1, p2, p3]);\nresult.then(data => console.log(data));\n// OK\n```\n\n**4、allSettled**\n**Promise.allSettled** : (promises) => {}\n返回一个新的 promise，固定成功不会失败, 所有的 promise 都完成后才完成，返回一个包含所有 promise 结果对象的数组，包含状态、value或reason。\n\n```js\nlet p1 = new Promise((resolve, reject) => {\n    reject(1)\n})\nlet p2 = Promise.resolve('Success');\nlet p3 = Promise.resolve('Oh Yeah');\nconst result = Promise.allSettled([p1, p2, p3])\nresult.then(data=>console.log(data))\n// [\n//     {status: 'rejected', reason: 1},\n//     {status: 'fulfilled', value: 'Success'},\n//     {status: 'fulfilled', value: 'Oh Yeah'},\n// ]\n```\n\n\n## 更多\n**1、then的返回值**\npromise.then()返回一个新 promise 对象\n其结果状态如下：\n(1) then中抛出异常，返回的 promise 状态为 rejected, reason 为抛出的异常\n(2) 返回的是非 promise 的任意值, 状态为 resolved, value 为返回的值\n(3) 返回的是另一个 promise, 该 promise 的结果就是返回的 promise 的结果\n\n```js\nconst obj = { name: 'chuckle' }\nconst p = new Promise((resolve, reject) => {\n    resolve(obj);\n})\np.then(data => {\n    console.log(data);// {name: 'chuckle'}\n    data.age = 19;\n    return Promise.resolve(JSON.stringify(data));\n}).then(data => {\n    console.log(data);// {\"name\":\"chuckle\",\"age\":19}\n}).then(data => {\n    console.log(data);// undefined\n})\n\n```\n\n**2、异常穿透**\n多个then链式调用，只需要在最后写一个catch，当一个then失败，就不再执行后续的then，直接到catch，catch后面的then会正常执行\n\n```js\nconst p = Promise.reject('err');\np.then(data => {\n    console.log(1);\n}).then(data => {\n    console.log(2);\n}).catch(err => {\n    console.log('err')\n}).then(data => {\n    console.log(3);\n})\n// err\n// 3\n\n```\n\n**3、中断Promise链**\n在回调函数中返回一个 **pendding** 状态的 promise 对象，因为then中回调函数是在 Promise 状态改变时调用的\n\n```js\nconst p = Promise.resolve('err');\np.then(data => {\n    console.log(1);\n}).then(data => {\n    console.log(2);\n    return new Promise(()=>{})\n}).then(data => {\n    console.log(3);\n})\n// 1\n// 2\n\n```\n\n# async-await\n使用Promise对象去实现异步操作，通常会出现一堆异步任务到点了该处理的情况，每次执行的顺序都不一定一样\n而**async-await**允许我们用同步编程的方式去写异步代码，async是基于Promise的语法糖\n\nasync函数永远返回一个Promise对象，和then的规则是一样的\n\nawait 右侧的表达式一般为 promise 对象, 但也可以是其它的值\n1、如果表达式是 promise 对象, await 返回的是 promise 成功的值\n2、如果表达式是其它值, 直接将此值作为 await 的返回值\n\n```js 声明一个async函数\nasync function fun(){\n    console.log('chuckle')\n    return 'qx'// 返回什么,返回的Promise对象的结果就是什么\n}\nconsole.log(fun())\n//Promise {<fulfilled>: 'qx'}\n// [[Prototype]]: Promise\n// [[PromiseState]]: \"fulfilled\"\n// [[PromiseResult]]: \"qx\"\nfun().then(data=>{\n    console.log(data);// qx\n})\n\n```\n\nasync函数中的 await 能让js引擎等待其后的代码(通常是返回Promise对象的函数)有结果后再往下执行\n\n```js\nfunction a(){\n    return new Promise((resolve, reject) =>{\n        setTimeout(() =>{\n            resolve(2)\n        }, 1000);\n    })\n}\nasync function fun(){\n    console.log(1)\n    let num = await a();\n    console.log(num)\n    console.log(3)\n}\nfun();\n// 1\n// 等待一秒后\n// 2\n// 3\n\n```\n\n当多个fetch运行时，结果输出顺序有时并不是代码顺序，有时我们需要它按顺序执行，如果嵌套到then中，反而不美观\n\n```js\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(1)\n})\n\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(2)\n})\n\nfetch('https://api.ooomn.com/api/yan?encode=json')\n.then(res=> res.json() )\n.then(data=> {\n    console.log(data)\n    console.log(3)\n})\n\n```\n\n使用 async 优化fetch\n\n```js\nasync function fun(){\n    const url = 'https://api.ooomn.com/api/yan?encode=json';\n    try{\n        let res = await Promise.all(\n            [fetch(url), fetch(url), fetch(url)]\n        );\n        let jsons = res.map(res => res.json());\n        // json()返回的是promise对象,还需要再进行一次Promise.all\n        let values = await Promise.all(jsons)\n        console.log(values);\n    } catch(err){\n        console.log(err);\n    }\n}\nfun();\n\n```\n\n让一个函数等待另一个函数中fetch执行完\n\n```js\nasync function fun(){\n    const url = 'https://api.ooomn.com/api/yan?encode=json';\n    try{\n        let res = await Promise.all(\n            [fetch(url), fetch(url), fetch(url)]\n        );\n        let jsons = res.map(res => res.json());\n        // json()返回的是promise对象,还需要再进行一次Promise.all\n        let values = await Promise.all(jsons)\n        return values;\n    } catch(err){\n        console.log(err);\n    }\n}\nasync function fn(){\n    let data = 1;\n    data = await fun();\n    console.log(data);\n}\nfn();// (3) [{…}, {…}, {…}]\n\n```\n\nasync-await等待AJAX请求完成，不使用.then\n\n```js\n// 之前封装的Promise形式AJAX\nfunction sendAJAX(url) {\n    // 返回一个Promise对象\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.responseType = 'json';\n        xhr.open('GET', url, true);\n        xhr.send();\n        // 处理结果\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                 // 请求完成进行判断\n                if ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304) {\n                    // 定义为请求成功，将响应传入\n                    resolve(xhr.response);\n                } else {\n                    // 定义失败将状态码传入\n                    reject(xhr.status);\n                }\n            }\n        };\n    })\n}\n\n// 点击按钮后等待请求完成再显示请求内容\nbtn.addEventListener('click',async function(){\n    let json = await sendAJAX('https://api.ooomn.com/api/yan?encode=json');\n    // 后面进行操作\n    console.log(json);\n});\n\n```\n\n# promisify\nJavascript异步演化史，是从callback到Promise再到Async/Await的历程\n\n对于一些老函数，可以使用 nodejs-util、其它第三方库中的 **promisify** 方法将其转为 Promise 形式的函数\n\npromisify函数作用就是把 callback 形式转成 promise 形式。\n\n只有符合 nodeCallback 的函数才能被 promisify 转化\nnodeCallback 有两个条件：1. 回调函数在主函数中的参数位置必须是最后一个；2. 回调函数参数中的第一个参数必须是 error \n\n```js nodejs中\nconst fs = require('fs');\nconst util = require('util');\nconst mineReadFile = util.promisify(fs.readFile);\n\nasync function main(){\n    try{\n        let data1 = await mineReadFile('./1.txt');\n        let data2 = await mineReadFile('./2.txt');\n        let data3 = await mineReadFile('./3.txt');\n        console.log(data1 + data2 + data3);\n    }catch(e){\n        console.log(e);\n    }\n}\nmain();\n\n```\n\n简单实现一个promisify\n\n```js\nvar promisify = (func, ctx) => {\n    // 返回一个新的function\n    return function() {\n        // 初始化this作用域\n        var ctx = ctx || this;\n        // 新方法返回的promise\n        return new Promise((resolve, reject) => {\n            // 调用原来的非promise方法func，绑定作用域，传参，以及callback（callback为func的最后一个参数）\n            func.call(ctx, ...arguments, function() {\n                // 将回调函数中的的第一个参数error单独取出\n                var args = Array.prototype.map.call(arguments, item => item);\n                var err = args.shift();\n                // 判断是否有error\n                if (err) {\n                    reject(err)\n                } else {\n                    // 没有error则将后续参数resolve出来\n                    args = args.length > 1 ? args : args[0];\n                    resolve(args);\n                }\n            });\n        })\n    };\n};\n\n// nodeCallback方法func1\nvar func1 = function(a, b, c, callback) {\n    callback(null, a+b+c);\n}\n// promise化后的func2\nvar func2 = promisify(func1);\n// 调用后输出6\nfunc1(1, 2, 3, (err, result) => {\n    if (!err) {\n        console.log(result); //输出6\n    }\n})\nfunc2(1, 2, 3).then(console.log); //输出6\n\n```\n\n# 输出顺序问题\n**1、**\n\n```js\nconst p = new Promise((resolve, reject) => {\n  console.log(1);\n  setTimeout(() => {\n    console.log('time');\n  }, 0);\n  resolve(2);\n  console.log(3);\n});\n\np.then((value) => {\n  console.log(value);\n});\nconsole.log(4);\n```\n\n```txt\n1\n3\n4\n2\ntime\n```\n\nPromise 构造函数的回调是同步的，更改状态后，后续的代码也会执行，then函数的回调是异步的，放到微任务队列中。\n\n**2、**\n\n```js\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve();\n  }, 1000);\n});\n\nconst p2 = p1.catch(() => {\n  return 2;\n});\n\nconsole.log('p1:', p1);\nconsole.log('p2:', p2);\n\nsetTimeout(() => {\n  console.log('p1:', p1);\n  console.log('p2:', p2);\n}, 2000);\n```\n\n```txt\np1: Promise { <pending> }\np2: Promise { <pending> }\np1: Promise { undefined }\np2: Promise { undefined }\n```\n\n**3、**\n\n```js\nasync function fn() {\n  console.log(1);\n  const n = await 2;\n  console.log(n);\n}\nfn();\nconsole.log(3);\n```\n\n```txt\n1\n3\n2\n```\n\n**4、**\n\n```js\nasync function fn() {\n  console.log(1);\n  const n = await 2;\n  console.log(n);\n}\n(async ()=>{\n  const n = await fn();\n  console.log(n);\n})();\nconsole.log(3);\n```\n\n```txt\n1\n3\n2\nundefined\n```\n\n**5、**\n\n```js\nPromise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);\n```\n\n```txt\n1\n```\n\nthen 方法只接收函数，若传其它东西，会被忽略，返回上一个promise的结果。\n\n**6、**\n\n```js\nvar a = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 1000);\n}).then((res) => {\n  console.log(res);\n  return 2;\n})\n\nvar b = new Promise(async (resolve, reject) => {\n  console.log(b);\n  await a;\n  console.log(a);\n  console.log(b);\n  await b;\n  resolve(3);\n});\n\nconsole.log('end');\n```\n\n```txt\nundefined\nend\n1\nPromise { 2 }\nPromise { <pending> }\n```\n\n# 手写Promise\n手写 Promise 即实现 [Promise A+](https://promisesaplus.com/) 规范。\n当然，A+规范非常详细，想100%实现也非常耗时、困难，这里只是简单实现 ES6-Promise 基本功能。\n\n**定义：**A+规范并没有设计如何创建、解决和拒绝 Promise，而是专注于提供一个通用的 .then 方法，换而言之，只要一个对象具有 .then 方法，并且符合规范（具有特定参数、返回特定值），就可以称之为 Promise。\n\n> Promise A+ 早于 ES6，是社区规范，为了解决回调地狱和异步实现不统一的问题。\n> ES6 的 Promise 符合 Promise A+ 规范，是对该规范的实现。提供了 Promise 类（构造函数）去构建一个 Promise 对象。并提供了除了 .then 方法之外的一些方法。\n\n## 状态与数据\n先仿照着 ES6-Promise 的样子，构造一个类，完成 `resolve` 和 `reject` 的基本功能，改变状态与数据。\n\n```ts\n// 执行器\ninterface Executor<T = any> {\n  (resolve: Resolve<T>, reject: Reject): void;\n}\n// resolve\ninterface Resolve<T = any> {\n  (value?: T): void;\n}\n// reject\ninterface Reject {\n  (reason?: any): void;\n}\n\n// 状态枚举\nenum State {\n  pending = \"pending\",\n  fulfilled = \"fulfilled\",\n  rejected = \"rejected\",\n}\n\n// 手写Promise\nclass MyPromise<T = any> {\n  // 状态\n  private state: State = State.pending;\n  // 结果\n  private result?: T;\n\n  constructor(executor: Executor<T>) {\n    // 捕获执行器抛出的错误，改为reject状态\n    try {\n      executor(this.resolve, this.reject);\n    } catch(error: any) {\n      this.reject(error);\n    }\n  }\n\n  // 任务完成\n  private resolve: Resolve<T> = (value) => {\n    this.changeState(State.fulfilled, value);\n  };\n\n  // 任务失败\n  private reject: Reject = (reason) => {\n    this.changeState(State.rejected, reason);\n  };\n\n  // 改变状态\n  private changeState(state: State, result?: T) {\n    // 只允许从pending状态改变一次\n    if (this.state !== State.pending) return;\n    this.state = state;\n    this.result = result;\n    console.log(this.state, this.result);\n  }\n}\n```\n\n## 微任务\nPromise是多平台的通用api，但不同运行环境事件循环并不相同。\n\n在node中使用nextTick近似为微任务，但实际上nextTick任务处于nextTick队列，在微队列前一个执行。\n\n而在浏览器环境，使用 `MutationObserver` 可以将函数放入微队列中，它用于观察一个DOM节点的变动，当节点变动时会将回调放入微队列中。\n\n最后，使用定时器来作为保底，尽管它属于宏队列。\n\n```ts\ninterface Callback {\n  (...argv: any): any;\n}\n// 将回调放入微任务队列\nexport function runMicroTask(callback: Callback) {\n  // 判断是否为node环境\n  if (typeof process !== \"undefined\" && process.nextTick) {\n    // node环境使用nextTick模拟微任务\n    // 实际上nextTick任务处于nextTick队列，在微队列前一个执行\n    process.nextTick(callback);\n  } else if (typeof MutationObserver !== \"undefined\") {\n    // 浏览器环境使用MutationObserver将函数放入微队列\n    // MutationObserver用于观察一个DOM节点的变动，当节点变动时会将回调放入微队列中。\n    const element = document.createElement(\"div\");\n    const observer = new MutationObserver(callback);\n    observer.observe(element, {\n      attributes: true, // 观察属性变动\n    });\n    element.className = \"\";\n  } else {\n    // 保底使用setTimeout\n    setTimeout(callback, 0);\n  }\n}\n```\n\n## then方法\nthen 方法是 Promise 的核心，本质是用来注册一个成功回调和一个失败回调，在完成后根据状态执行对应回调，并将其放入微队列。\n\n使用一个队列来保存需要执行的 then 回调，且封装为对象，保存一些上下文信息，以判断执行条件。\n\n在状态改变或挂载then时状态已被改变，则清空队列，并执行回调。\n\n在执行then回调时，需注意**穿透**和返回promise的情况。\n\n\n```ts\nimport { runMicroTask, isPromise, isFunction } from \"./utils/index\";\n\n// 执行器\ninterface Executor<T = any> {\n  (resolve: Resolve<T>, reject: Reject): void;\n}\n// resolve\ninterface Resolve<T = any> {\n  (value?: T): void;\n}\n// reject\ninterface Reject {\n  (reason?: any): void;\n}\n// A+规范then方法参数\ninterface OnFulfilled<T = any> {\n  (value?: T): any;\n}\ninterface OnRejected {\n  (reason?: any): any;\n}\n// 任务队列元素\ninterface QueueItem {\n  state: State;\n  fn: OnFulfilled | OnRejected | undefined;\n  resolve: Resolve;\n  reject: Reject;\n}\n\n// 状态枚举\nenum State {\n  pending = \"pending\",\n  fulfilled = \"fulfilled\",\n  rejected = \"rejected\",\n}\n\n// 手写Promise\nexport default class QXPromise<T = any> {\n  // 状态\n  private state: State = State.pending;\n  // 结果\n  private result?: T;\n  // 队列\n  private queue: Array<QueueItem> = [];\n\n  constructor(executor: Executor<T>) {\n    // 捕获执行器抛出的错误，改为reject状态\n    try {\n      executor(this.resolve, this.reject);\n    } catch (error: any) {\n      this.reject(error);\n    }\n  }\n\n  // 任务完成\n  private resolve: Resolve<T> = (value) => {\n    this.changeState(State.fulfilled, value);\n  };\n\n  // 任务失败\n  private reject: Reject = (reason) => {\n    this.changeState(State.rejected, reason);\n  };\n\n  // 改变状态\n  private changeState(state: State, result?: T) {\n    // 只允许从pending状态改变一次\n    if (this.state !== State.pending) return;\n    this.state = state;\n    this.result = result;\n    // console.log(this);\n    // 状态改变时执行队列\n    this.runQueue();\n  }\n\n  // 向队列中添加任务\n  private pushQueue(\n    state: State,\n    fn: OnFulfilled<T> | OnRejected | undefined,\n    resolve: Resolve<T>,\n    reject: Reject\n  ) {\n    this.queue.push({ state, fn, resolve, reject });\n  }\n\n  // 执行队列\n  private runQueue() {\n    if (this.state === State.pending) return;\n    if (this.queue.length <= 0) return;\n    // console.log(this.queue);\n    // 队列尾进头出\n    while (this.queue.length) {\n      this.runQueueItem(this.queue[0]);\n      this.queue.shift();\n    }\n  }\n\n  // 执行队列中的任务\n  private runQueueItem(item: QueueItem) {\n    // 状态不一致时不执行\n    if (this.state !== item.state) return;\n    // 将任务放入微任务队列\n    runMicroTask(() => {\n      // 如果任务不是函数，进行穿透\n      if (!isFunction(item.fn)) {\n        item.state === State.fulfilled\n          ? item.resolve(this.result)\n          : item.reject(this.result);\n        return;\n      }\n      // 执行任务函数\n      try {\n        // 解构出函数，使this指向不改变。\n        const { fn } = item;\n        const res = fn!(this.result);\n        // 判断返回值是否为Promise\n        if (isPromise(res)) {\n          // 等待Promise状态改变，再执行完成或失败\n          res.then(item.resolve, item.reject);\n          return;\n        }\n        item.resolve(res);\n      } catch (error: any) {\n        item.reject(error);\n      }\n    });\n  }\n\n  // then方法\n  public then(\n    onFulfilled?: OnFulfilled<T>,\n    onRejected?: OnRejected\n  ): QXPromise {\n    return new QXPromise((resolve, reject) => {\n      // 将then方法的回调放入队列，未来执行\n      // 现在不用考虑fn是否是可执行函数，因为在执行队列时会判断。不是函数会进行穿透。\n      this.pushQueue(State.fulfilled, onFulfilled, resolve, reject);\n      this.pushQueue(State.rejected, onRejected, resolve, reject);\n      // 若状态已改变，立即执行队列\n      // 因为then可能在状态改变以后又被调用。\n      this.runQueue();\n    });\n  }\n}\n```\n\n**测试：**\n\n```ts\n/* 测试 */\nconst p1 = new QXPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(2);\n  }, 1000);\n});\n\np1.then(\n  function (this: any, res) {\n    console.log(this, res);\n    // 测试返回Promise\n    return new QXPromise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(\"a\");\n      }, 500);\n    });\n  },\n  (err) => {\n    console.log(err);\n  }\n).then(\n  (res) => {\n    console.log(res);\n  },\n  (err) => {\n    console.log(err);\n  }\n);\n\nsetTimeout(() => {\n  p1.then((res) => {\n    // 测试抛出错误\n    throw 123;\n  }).then(\n    (res) => {\n      console.log(res);\n    },\n    (err) => {\n      console.log(\"err:\", err);\n    }\n  );\n}, 2000);\n\n// 与 ES6-Promise 互操作\nconst p2 = new QXPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(2);\n  }, 2000);\n});\n\np2.then((res) => {\n  console.log(res);\n  return Promise.resolve(\"b\");\n})\n  .then((res) => {\n    console.log(res);\n    return new QXPromise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(\"c\");\n      }, 500);\n    });\n  })\n  .then((res) => {\n    console.log(res);\n    return Promise.reject(\"d\");\n  }).then(()=>{},(err)=>{\n    console.log(err);\n  });\n\n// 兼容await\nfunction delay(duration: number) {\n  return new QXPromise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n(async ()=>{\n  console.log(\"start\");\n  await delay(3000);\n  console.log(\"end\");\n})()\n```\n\n现在 Promise A+ 规范以及基本实现完了，至于其它方法，如catch、all等，是 ES6 特有的方法，下面接着实现。\n\n## catch\ncatch 方法本质就是仅传入第二个回调的 then 方法。\n\n```ts\n// catch方法，本质就是then方法\npublic catch(onRejected: OnRejected): QXPromise {\n    return this.then(undefined, onRejected);\n}\n```\n\n**测试：**\n\n```ts\n// 测试catch\nconst p3 = new QXPromise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\"error!!!\");\n  }, 500);\n}).catch((err) => {\n  console.log(err);\n});\n```\n\n## finally\nfinally 像是一个中间商，它无论如何都会执行。\n\n且虽然叫做 finally 但其返回的也是 Promise，且忽略返回值进行穿透。但若出现错误，则为 reject。\n\n```ts\n// finally方法，本质也是then方法\npublic finally(onFinally: () => void): QXPromise {\n  // 无论状态如何，都会执行finally回调\n  return this.then(\n    (value) => {\n      onFinally();\n      // 返回值不变，继续传递resolve状态\n      return value;\n    },\n    (reason) => {\n      onFinally();\n      // 抛出错误，继续传递reject状态\n      throw reason;\n    }\n  );\n}\n```\n\n**测试：**\n\n```ts\n// 测试finally\nconst p4 = new QXPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"ok\");\n  }, 500);\n}).finally(() => {\n  console.log(\"finally\");\n}).finally(() => {\n  console.log(\"finally\");\n}).then((res) => {\n  console.log(\"after finally:\", res);\n}).finally(() => {\n  console.log(\"finally\");\n  throw \"finally error\";\n}).catch((err) => {\n  console.log(\"error:\", err);\n});\n```\n\n## resolve和reject\n这两个静态方法本质也是一次简单封装，用于快速返回一个已完成的promise。\n\nresolve规则：\n1. 传入本身就是ES6-Promise，直接返回这个Promise\n2. 传入PromiseLike，也就是实现了A+规范，返回新的Promise，状态保持一致\n3. 其余情况返回新的Promise，resolve传入的值\n\nreject规则：\n1. 直接reject传入的值。\n\n\n```ts\n// 静态resolve方法\nstatic resolve<T>(value: any): QXPromise<T> | Promise<T> {\n  // 如果是ES6-Promise实例，直接返回\n  if (value instanceof Promise) return value;\n  return new QXPromise((resolve, reject) => {\n    if (isPromise(value)) {\n      // 如果是PromiseLike，等待状态改变\n      value.then(resolve, reject);\n    } else {\n      // 直接resolve值\n      resolve(value);\n    }\n  });\n}\n\n// 静态reject方法\nstatic reject(reason: any): QXPromise {\n  return new QXPromise((_, reject) => {\n    reject(reason);\n  });\n}\n```\n\n**测试：**\n\n```ts\nconst p5 = QXPromise.resolve(\"resolve\");\np5.then((res) => {\n  console.log(res);\n});\nQXPromise.resolve(Promise.resolve(\"es6 resolve\")).then((res) => {\n  console.log(res);\n});\nQXPromise.resolve(Promise.reject(\"reject es6 resolve\")).catch((res) => {\n  console.log(res);\n});\nQXPromise.resolve(QXPromise.reject(\"my reject\")).catch((res) => {\n  console.log(res);\n});\nconst p6 = QXPromise.reject(\"reject\");\np6.catch((err) => {\n  console.log(err);\n});\n```\n\n## all\n`all` 静态方法传入一个 Promise 数组或**迭代器**，返回一个新 Promise，仅当所有传入的 Promise 成功才成功，一个失败则返回首个失败的原因。\n\n数组中传入其它值，会使用 `Promise.resolve()` 转为 Promise。传入非迭代器对象直接 reject。传入空数组直接返回成功，结果为空数组。\n\n```ts\nstatic all<T>(promises: Iterable<T | PromiseLike<T>>) {\n  return new QXPromise<T[]>((resolve, reject) => {\n    try {\n      const result: T[] = [];\n      let count = 0; // 总数计数\n      let fulfilledCount = 0; // Promise完成计数\n      for (const p of promises) {\n        let index = count; // 记录当前Promise的索引\n        this.resolve(p).then((data) => {\n          // 将结果放入对应索引的位置\n          result[index] = data;\n          // 完成计数+1\n          fulfilledCount++;\n          // 所有Promise完成后，resolve结果\n          if (fulfilledCount === count) {\n            resolve(result);\n          }\n        }, reject);\n        count++;\n      }\n      if (count === 0) {\n        // 如果传入空数组，直接resolve空数组\n        resolve([]);\n      }\n    } catch (error) {\n      // 捕获错误，直接reject\n      reject(error);\n    }\n  });\n}\n```\n\n**测试：**\n\n```ts\nconst pp = new QXPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(0);\n  }, 1000);\n});\nQXPromise.all([pp, 1, 2, 3])\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n## allSettled\n`allSettled` 方法，和 all 差不多，但不管成功失败都会成功，且结果为数组，中包含每个 Promise 的最终状态、成功结果或失败原因。\n\n```ts\n// allSettled返回结果类型\ninterface AllSettledResult<T> {\n  status: State.fulfilled | State.rejected;\n  value?: T;\n  reason?: any;\n}\ntype AllSettledResolveResult<T> = Required<\n  Pick<AllSettledResult<T>, \"status\" | \"value\">\n>;\ntype AllSettledRejectResult = Required<\n  Pick<AllSettledResult<never>, \"status\" | \"reason\">\n>;\n\nstatic allSettled<T>(promises: Iterable<T | PromiseLike<T>>) {\n  // 保存加工后的Promises\n  const promiseList: Array<any> = [];\n  // 对每个Promise进行加工\n  for (const p of promises) {\n    promiseList.push(\n      // 让每个Promise都变成始终成功返回Result的Promise\n      this.resolve(p).then(\n        (value): AllSettledResolveResult<T> => {\n          return { status: State.fulfilled, value };\n        },\n        (reason): AllSettledRejectResult => {\n          return { status: State.rejected, reason };\n        }\n      )\n    );\n  }\n  // 使用all方法，等待所有Promise完成，返回Result类型成功结果\n  return this.all<AllSettledResult<T>>(promiseList);\n}\n```\n\n**测试：**\n\n```ts\nQXPromise.allSettled([1, 2, QXPromise.reject(3)]).then((res) => {\n  res.forEach((item) => {\n    console.log(item);\n  });\n});\n// { status: 'fulfilled', value: 1 }\n// { status: 'fulfilled', value: 2 }\n// { status: 'rejected', reason: 3 }\n```\n\n## race\n`race` 就像竞速，第一个改变状态的 promise 的结果就是返回的结果状态，也即是新的 Promise 的成功与否取决于第一个完成的 Promise\n\n当传入空数组时，返回的 Promise 将永远 pending。\n\n```ts\nstatic race<T>(promises: Iterable<T | QXPromise<T> | PromiseLike<T>>) {\n  return new QXPromise<T>((resolve, reject) => {\n    for (const p of promises) {\n      // 只要有一个Promise状态改变，就立即改变\n      this.resolve(p).then(resolve, reject);\n    }\n  });\n}\n```\n\n**测试：**\n\n```ts\nQXPromise.race([QXPromise.reject(1), QXPromise.resolve(2)])\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(\"err\", err);\n  });\n```\n\n## 完整代码\nhttps://github.com/qxchuckle/qx-promise\n\n```ts src\\index.ts\nimport { runMicroTask, isPromise, isFunction } from \"./utils/index\";\n\n// 执行器\ninterface Executor<T = any> {\n  (resolve: Resolve<T>, reject: Reject): void;\n}\n// resolve\ninterface Resolve<T = any> {\n  (value?: T): void;\n}\n// reject\ninterface Reject {\n  (reason?: any): void;\n}\n// A+规范then方法参数\ninterface OnFulfilled<T, R = T> {\n  (value: T): R | QXPromise<R> | null | undefined;\n}\ninterface OnRejected<T = any, R = T> {\n  (reason: T): R | QXPromise<R> | null | undefined;\n}\n// 任务队列元素\ninterface QueueItem<T> {\n  state: State;\n  fn: OnFulfilled<T> | OnRejected | undefined | null;\n  resolve: Resolve;\n  reject: Reject;\n}\n// allSettled返回结果类型\ninterface AllSettledResult<T> {\n  status: State.fulfilled | State.rejected;\n  value?: T;\n  reason?: any;\n}\ntype AllSettledResolveResult<T> = Required<\n  Pick<AllSettledResult<T>, \"status\" | \"value\">\n>;\ntype AllSettledRejectResult = Required<\n  Pick<AllSettledResult<never>, \"status\" | \"reason\">\n>;\n\n// 状态枚举\nenum State {\n  pending = \"pending\",\n  fulfilled = \"fulfilled\",\n  rejected = \"rejected\",\n}\n\n// 手写Promise\nexport default class QXPromise<T = any> {\n  // 状态\n  private state: State = State.pending;\n  // 结果\n  private result?: T;\n  // 队列\n  private queue: Array<QueueItem<T>> = [];\n\n  constructor(executor: Executor<T>) {\n    // 捕获执行器抛出的错误，改为reject状态\n    try {\n      executor(this.resolve, this.reject);\n    } catch (error: any) {\n      this.reject(error);\n    }\n  }\n\n  // 任务完成\n  private resolve: Resolve<T> = (value) => {\n    this.changeState(State.fulfilled, value);\n  };\n\n  // 任务失败\n  private reject: Reject = (reason) => {\n    this.changeState(State.rejected, reason);\n  };\n\n  // 改变状态\n  private changeState(state: State, result?: T) {\n    // 只允许从pending状态改变一次\n    if (this.state !== State.pending) return;\n    this.state = state;\n    this.result = result;\n    // console.log(this);\n    // 状态改变时执行队列\n    this.runQueue();\n  }\n\n  // 向队列中添加任务\n  private pushQueue(\n    state: State,\n    fn: OnFulfilled<T> | OnRejected | undefined | null,\n    resolve: Resolve,\n    reject: Reject\n  ) {\n    this.queue.push({ state, fn, resolve, reject });\n  }\n\n  // 执行队列\n  private runQueue() {\n    if (this.state === State.pending) return;\n    if (this.queue.length <= 0) return;\n    // console.log(this.queue);\n    // 队列尾进头出\n    while (this.queue.length) {\n      this.runQueueItem(this.queue[0]);\n      this.queue.shift();\n    }\n  }\n\n  // 执行队列中的任务\n  private runQueueItem(item: QueueItem<T>) {\n    // 状态不一致时不执行\n    if (this.state !== item.state) return;\n    // 将任务放入微任务队列\n    runMicroTask(() => {\n      // 如果任务不是函数，进行穿透\n      if (!isFunction(item.fn)) {\n        item.state === State.fulfilled\n          ? item.resolve(this.result)\n          : item.reject(this.result);\n        return;\n      }\n      // 执行任务函数\n      try {\n        // 解构出函数，使this指向不改变。\n        const { fn } = item;\n        const res = fn!(this.result!);\n        // 判断返回值是否为Promise\n        if (isPromise(res)) {\n          // 等待Promise状态改变，再执行完成或失败\n          res.then(item.resolve, item.reject);\n          return;\n        }\n        item.resolve(res);\n      } catch (error: any) {\n        // console.log(error);\n        item.reject(error);\n      }\n    });\n  }\n\n  // then方法\n  public then<R1 = T, R2 = never>(\n    onFulfilled?: OnFulfilled<T, R1>,\n    onRejected?: OnRejected<T, R2>\n  ) {\n    return new QXPromise<R1 | R2>((resolve, reject) => {\n      // 将then方法的回调放入队列，未来执行\n      // 现在不用考虑fn是否是可执行函数，因为在执行队列时会判断。不是函数会进行穿透。\n      this.pushQueue(State.fulfilled, onFulfilled, resolve, reject);\n      this.pushQueue(State.rejected, onRejected, resolve, reject);\n      // 若状态已改变，立即执行队列\n      // 因为then可能在状态改变以后又被调用。\n      this.runQueue();\n    });\n  }\n\n  // catch方法，本质就是then方法\n  public catch(onRejected: OnRejected): QXPromise {\n    return this.then(undefined, onRejected);\n  }\n\n  // finally方法，本质也是then方法\n  public finally(onFinally: () => void): QXPromise {\n    // 无论状态如何，都会执行finally回调\n    return this.then(\n      (value) => {\n        onFinally();\n        // 返回值不变，继续传递resolve状态\n        return value;\n      },\n      (reason) => {\n        onFinally();\n        // 抛出错误，继续传递reject状态\n        throw reason;\n      }\n    );\n  }\n\n  // 静态resolve方法\n  static resolve<T>(value?: T | QXPromise<T> | PromiseLike<T>): QXPromise<T>{\n    // 如果是ES6-Promise实例，直接返回\n    if (value instanceof Promise) return value as QXPromise<T>;\n    return new QXPromise((resolve, reject) => {\n      if (isPromise(value)) {\n        // 如果是PromiseLike，等待状态改变\n        (value as QXPromise<T>).then(resolve, reject);\n      } else {\n        // 直接resolve值\n        resolve(value as T);\n      }\n    });\n  }\n\n  // 静态reject方法\n  static reject(reason?: any): QXPromise {\n    return new QXPromise((_, reject) => {\n      reject(reason);\n    });\n  }\n\n  // 静态all方法\n  static all<T>(promises: Iterable<T | QXPromise<T> | PromiseLike<T>>) {\n    return new QXPromise<T[]>((resolve, reject) => {\n      try {\n        const result: T[] = [];\n        let count = 0; // 总数计数\n        let fulfilledCount = 0; // Promise完成计数\n        for (const p of promises) {\n          let index = count; // 记录当前Promise的索引\n          this.resolve(p).then((data) => {\n            // 将结果放入对应索引的位置\n            result[index] = data;\n            // 完成计数+1\n            fulfilledCount++;\n            // 所有Promise完成后，resolve结果\n            if (fulfilledCount === count) {\n              resolve(result);\n            }\n          }, reject);\n          count++;\n        }\n        if (count === 0) {\n          // 如果传入空数组，直接resolve空数组\n          resolve([]);\n        }\n      } catch (error) {\n        // 捕获错误，直接reject\n        reject(error);\n      }\n    });\n  }\n\n  // 静态allSettled方法\n  static allSettled<T>(promises: Iterable<T | QXPromise<T> | PromiseLike<T>>) {\n    // 保存加工后的Promises\n    const promiseList: Array<any> = [];\n    // 对每个Promise进行加工\n    for (const p of promises) {\n      promiseList.push(\n        // 让每个Promise都变成始终成功返回Result的Promise\n        this.resolve(p).then(\n          (value): AllSettledResolveResult<T> => {\n            return { status: State.fulfilled, value };\n          },\n          (reason): AllSettledRejectResult => {\n            return { status: State.rejected, reason };\n          }\n        )\n      );\n    }\n    // 使用all方法，等待所有Promise完成，返回Result类型成功结果\n    return this.all<AllSettledResult<T>>(promiseList);\n  }\n\n  // 静态race方法\n  static race<T>(promises: Iterable<T | QXPromise<T> | PromiseLike<T>>) {\n    return new QXPromise<T>((resolve, reject) => {\n      for (const p of promises) {\n        // 只要有一个Promise状态改变，就立即改变\n        this.resolve(p).then(resolve, reject);\n      }\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\n```\n\n```ts src\\utils\\index.ts\ninterface Callback {\n  (...argv: any): any;\n}\n// 将回调放入微任务队列\nexport function runMicroTask(callback: Callback) {\n  // 判断是否为node环境\n  if (typeof process !== \"undefined\" && process.nextTick) {\n    // node环境使用nextTick模拟微任务\n    // 实际上nextTick任务处于nextTick队列，在微队列前一个执行\n    process.nextTick(callback);\n  } else if (typeof MutationObserver !== \"undefined\") {\n    // 浏览器环境使用MutationObserver将函数放入微队列\n    // MutationObserver用于观察一个DOM节点的变动，当节点变动时会将回调放入微队列中。\n    const element = document.createElement(\"div\");\n    const observer = new MutationObserver(callback);\n    observer.observe(element, {\n      attributes: true, // 观察属性变动\n    });\n    element.className = \"\";\n  } else {\n    // 保底使用setTimeout\n    setTimeout(callback, 0);\n  }\n}\n\n// 判断是否为对象\nexport function isObject(val: any) {\n  return val !== null && (typeof val === \"object\" || typeof val === \"function\");\n}\n\n// 判断是否为Promise\nexport function isPromise(p: any) {\n  return p instanceof Promise || (isObject(p) && typeof p.then === \"function\");\n}\n\n// 判断是否为函数\nexport function isFunction(val: any) {\n  return typeof val === \"function\";\n}\n```\n\n\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"AJAX请求相关","url":"/article/f3334fd0.html","content":"\n# AJAX简介\nAJAX（Asynchronous JavaScript And XML）即异步的 JS 和 XML，发送异步请求，无刷新获取数据\n\n作用：进行前后端交互，[前后端交互初步概念](https://www.qcqx.cn/article/709b5ecb.html)\n\n**组成：**\n1. XMLHttpRequest/Fetch API (异步的与服务器交换数据)\n2. JavaScript/DOM (信息显示/交互)\n3. CSS (给数据定义样式)\n4. XML/JSON (作为转换数据的格式)\n\n优点：\n1. 无需刷新页面而与服务器端进行通信，获取数据。\n2. 根据事件动态获取所需数据，提高效率。\n\n缺点：\n1. 跨域问题\n2. SEO不友好\n3. 无浏览历史\n\nXML可扩展标记语言，用于传输和存储数据\n\n结构上与html标签结构类似，但XML内都是自定义标签\n\n```js\n<student>\n  <name>chuckle</name>\n  <age>19</age>\n</student>\n```\n\n# 发请求\n浏览器内建有 XMLHttpRequest 构造函数，通过操控其构造出的对象，就能发送AJAX请求\n\nxhr的 **readyState** 的属性记录了当前响应处于哪个过程，其值的的变化会触发 **readystatechange** 事件\n0 未调用open方法，1 调用了open还未调用send，2 发送了请求还未收到响应，3 收到了部分响应，4 响应都接收完了\n\n**基本属性和方法：**\n1. open(请求方法, URL, 是否异步) 初始化\n2. send(请求体) 发送请求\n3. setRequestHeader() 设置请求头\n4. abort() 取消请求\n5. timeout 设置超时时间，超时触发timeout事件\n\n**响应相关：**\n1. status 响应状态码\n2. statusText 状态字符串\n3. getAllResponseHeaders() 获取所有响应头\n4. response 响应体\n5. responseType 设置响应类型，自动转换\n6. responseXML 接收 xml 格式的响应数据\n7. responseText 接收文本格式的响应数据\n\n##  GET请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.responseType = 'json';\n// 第三个参数为是否异步，默认true\nxhr.open('GET', 'https://kpb.qcqx.cn/api', true);\nxhr.send();\nxhr.onreadystatechange = () => {\n   if(xhr.readyState === 4 && ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304)){\n       let text = xhr.responseText;\n       console.log(xhr.status);\n       console.log(xhr.statusText);\n       console.log(xhr.getAllResponseHeaders());\n       console.log(xhr.response);\n       console.log(text);\n   }\n};\n\n```\n\n## POST请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.responseType = 'json';\nxhr.open(\"POST\", \"https://kpb.qcqx.cn/api/login\", true);\n// 设置请求头，需在open后send前设置\nxhr.setRequestHeader(\n \"content-type\",\n \"application/x-www-form-urlencoded\"\n);\nxhr.send(\"username=qx&password=123\");\nxhr.onreadystatechange = () => {\n if (\n   xhr.readyState === 4 &&\n   ((xhr.status >= 200 && xhr.status <= 300) || xhr.status === 304)\n ) {\n   console.log(xhr.status);\n   console.log(xhr.statusText);\n   console.log(xhr.getAllResponseHeaders());\n   console.log(xhr.response);\n }\n};\n\n```\n\n## 超时和错误处理\nxhr.timeout 设置超时时间，超时会触发timeout事件\n出错(网络错误)会触发error事件\n\n```js\nxhr.timeout = 2000; // 两秒超时\nxhr.ontimeout = ()=>{\n  console.log('连接超时');\n}\nxhr.onerror = ()=>{\n  console.log('出错了');\n}\n\n```\n\n## 取消请求\n`abort()` 可以取消一个请求\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://kpb.qcqx.cn/api', true);\nxhr.send();\nxhr.abort();// 取消请求\n```\n\n## 进度\n6个进度事件：\n1. `loadstart` 在接收到响应数据的第一个字节时触发\n2. `progress` 在接收响应期间持续不断地触\n3. `error` 在请求发生错误时触发\n4. `abort` 在因为调用abort()方法而终止连接时触发\n5. `load` 在接收到完整的响应数据时触发\n6. `loadend` 在通信完成或者触发error、abort或load事件后触发\n7. `timeout` 超时发生时触发\n\n```js\n// 下载进度\nxhr.onprogress = (e)=>{\n  // loaded 已经下载的字节数，total 总字节数\n  console.log((e.loaded / e.total * 100).toFixed(2) + '%');\n}\n// 上传进度\nxhr.upload.onprogress = (e)=>{\n  console.log((e.loaded / e.total * 100).toFixed(2) + '%');\n}\n```\n\n# JQ-AJAX\n使用JQ发送AJAX请求\n\nget和post方法：\n1. $.get(url, [data], [callback], [type])\n2. $.post(url, [data], [callback], [type])\nurl:请求的 URL 地址。\ndata:请求携带的参数。\ncallback:载入成功时回调函数。\ntype:设置返回内容格式\n\n通用方法 [ajax](https://www.bejson.com/apidoc/jquery/jQuery.Ajax.html)：\n\n```js\n$.ajax({\n  url: '',\n  type: 'GET',\n  // 请求头\n  headers: {\n    a: 100\n  }\n  // 数据类型\n  dataType: 'json',\n  // 请求体数据\n  data: {\n    username: 'qx',\n    password: '123'\n  },\n  // 请求超时时间\n  timeout: 2000,\n  // 是否异步处理，默认true\n  async: true,\n  // 请求成功回调\n  success: (data)=>{\n    console.log(data)\n  },\n  // 失败回调\n  error: (err)=>{\n    console.log(err)\n  }\n})\n\n```\n\n# Axios\n[Axios](https://github.com/axios/axios) 是一个简单的基于 promise 的 HTTP 客户端，适用于浏览器和 node.js。 Axios 在具有非常可扩展的接口的小包中提供了一个简单易用的库。\n\n**使用：**\n\n```code\nnpm install axios\n```\n\n```js cdn\n<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.min.js\"></script>\n```\n\n**常用方法：**\n**用于发送请求：**\n1. `axios(config)`: 通用/最本质的发任意类型请求的方式\n2. `axios(url[, config])`: 可以只指定 url 发 get 请求\n3. `axios.request(config)`: 等同于 axios(config)\n4. `axios.get(url[, config])`: 发 get 请求\n5. `axios.post(url[, data, config])`: 发 post 请求\n6. `axios.delete(url[, config])`: 发 delete 请求\n7. `axios.put(url[, data, config])`: 发 put 请求\n8. `axios.patch(url[, data, config])`: 发 patch 请求\n\n## 基本使用\n\nget请求：`axios.get()`\n\n```js\n// 设置baseURL\naxios.defaults.baseURL = 'https://kpb.qcqx.cn';\naxios.get('/api', {\n // url参数，查询字符串\n params: {},\n // 请求头\n headers: {\n   token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U'\n },\n}).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\npost请求：`axios.post()`\n\n```js\naxios.post('/api/login', {\n   // 第二个参数请求体\n   username: 'qx',\n   password: '123'\n },{\n  // 第三个参数其余配置\n }).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\n通用方法 `axios()`\n\n```js\naxios({\n url: '/api/login',\n method: 'post',\n // url参数，查询字符串\n params: {},\n // 请求头\n headers: {},\n // 请求体\n data: {\n   username: 'qx',\n   password: '123'\n },\n // 请求超时\n timeout: 5000\n}).then(res=>{\n // 响应对象\n console.log(res);\n // 响应体对象\n console.log(res.data);\n})\n\n```\n\n## 响应结果\n\n1. **config** 配置对象，里面有请求方法、请求头、请求url等\n2. **data** 响应体\n3. **headers** 响应头\n4. **request** axios发送请求时创建的原生的AJAX请求对象 XMLHttpRequest\n5. **status** 响应码\n6. **statusText** 响应状态字符串\n\n```js\n{data: Array(4), status: 200, statusText: 'OK', headers: i, config: {…}, …}\nconfig: {transitional: {…}, adapter: Array(2), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}\ndata: (4) [{…}, {…}, {…}, {…}]\nheaders: i {cache-control: 'no-cache', content-length: '299', content-type: 'application/json; charset=utf-8', expires: '-1', pragma: 'no-cache'}\nrequest: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}\nstatus: 200\nstatusText: \"OK\"\n[[Prototype]]: Object\n\n```\n\n## config配置对象\n\n1. **url** 给谁发送请求\n2. **method** 请求方法\n3. **baseURL** 设置url的基础结构\n4. **params** url参数，查询字符串\n5. **headers** 请求头\n6. **data** 请求体\n7. **timeout** 请求超时\n8. **transformRequest** 对请求的数据进行处理后再发送\n```js\ntransformRequest: [function (data, headers) {\n    return data;\n  }],\n```\n9. **transformResponse** 对响应体进行预处理\n```js\ntransformResponse: [function (data) {\n    return data;\n  }],\n```\n10. **paramsSerializer** url参数序列化，设置url参数的格式\n```js\nparamsSerializer: {\n    encode?: (param: string): string => { \n      // 自定义操作并返回转换后的字符串\n    },\n    // url参数序列化\n    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ),\n    indexes: false // 数组索引格式 null-无括号，false（默认）-空括号，true-带索引的括号\n  },\n// /api?a=100&b=200\n// /api/a/100/b/200\n// /api/a.100/b.200\n\n```\n11. **withCredentials**: 跨域请求是否携带cookie，默认false\n12. **responseType**: 响应体结果类型，默认json，array、buffer、document、json、text、stream\n13. **responseEncoding**: 响应结果的字符集，默认utf8\n14. **xsrfHeaderName**和**xsrfCookieName** 防止跨站请求攻击\n```markdown\nxsrfCookieName: 'XSRF-TOKEN', // default\nxsrfHeaderName: 'X-XSRF-TOKEN', // default\n在客户端第一次发送get请求时，服务器响应数据会携带一个会话cookie(XSRF-TOKEN)一同发送到客户端\n在后续请求发送前，http服务会从cookie中读取一个token(默认为XSRF-TOKEN)并且将其设置到HTTP头部(X-XSRF-TOKEN)一同发送到服务器。\n然后，服务器端会判断HTTP头部是否携带X-XSRF-TOKEN值，如果该值与之前发送的会话cookie值相同，就可以判定为来自己同一domain请求，否者会拦截该请求\n```\n15. **maxContentLength**: 2000 定义node.js中允许的http响应内容的最大大小\n16. **maxBodyLength**: 2000 定义http请求内容的最大大小\n17. **validateStatus** 请求成功的响应码范围\n```js\nvalidateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  }\n```\n18. **maxRedirects**: 21 node.js中允许最大重定向数\n19. **proxy**: 设置代理\n```js\nproxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    hostname: '127.0.0.1' //如果同时定义了“host”，则优先于“host”\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n```\n20. **cancelToken** 用于取消、打断请求，后面有详细介绍\n21. **signal** 使用AbortController取消Axios请求\n\n## 全局默认配置\n一些重复的配置项可以使用 **axios.defaults** 进行全局配置\n\n```js\n// 全局baseURL\naxios.defaults.baseURL = 'http://127.0.0.1';\n// 设置headers中默认token\naxios.defaults.headers.token = \"adra2nh12h4jh91\";\n```\n\n## 创建实例对象\n`axios.create(config)` 创建实例对象，传入配置项\n\n当需要大量发送请求时，可以创建一个实例对象，分别传入所需的基础配置项，可以减少代码的书写量，功能和axios几乎一样\n\n```js\nconst example = axios.create({\n  baseURL: 'http://127.0.0.1'\n});\n```\n\n发请求:\n\n```js\nexample({\n  url: '/api'\n}).then(res=>{\n  console.log(res)\n})\n```\n\n## 拦截器\n拦截器是一些函数，分为请求拦截器和响应拦截器，实例对象能单独添加\n\n可以添加多个拦截器，响应拦截器按代码位置先后**倒序**执行，响应拦截器顺序执行（请求拦截器进入的是堆栈，响应拦截器进入的是队列）\n\n**作用：**对请求的参数和内容进行检测（判断token，设置请求头）。对响应结果进行预处理（失败提醒、数据格式化）\n\n```js 基础使用\n// 请求拦截器\naxios.interceptors.request.use(function () {/*...*/})\n// 响应拦截器\naxios.interceptors.response.use(function () {/*...*/})\n// 实例对象添加拦截器\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n// 移除拦截器\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n// 清除请求或响应的所有拦截器\nconst instance = axios.create();\ninstance.interceptors.request.clear();\ninstance.interceptors.response.clear();\n\n```\n\n### 请求拦截器\n对请求的参数和内容进行检测（判断token，设置请求头）\n\n```js\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n```\n\n### 响应拦截器\n对响应结果进行预处理（失败提醒、数据格式化）\n\n```js\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n```\n\n## 取消请求\n**1、**使用 **cancelToken** 中断axios请求（v0.22.0后弃用），两种方式：\n\n```js CancelToken.source 工厂创建取消令牌\n//创建取消令牌的生成器对象\nconst CancelToken = axios.CancelToken\n//获取令牌对象\nconst source = CancelToken.source()\n\n// const source = axios.CancelToken.source()\naxios.get('/test',{\n\tcancelToken: source.token\n})\n\n//取消请求\nsource.cancel()\n\n```\n\n```js 将执行函数传递给 CancelToken 构造函数来创建取消标记\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new axios.CancelToken(function(c) {\n    // 执行器函数接收一个取消函数作为参数\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n\n```\n\n**2、**使用 **AbortController** :\n[AbortController](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 接口表示一个控制器对象，允许根据需要中止一个或多个 Web 请求\n\n通过AbortController创建一个信号对象signal，然后将signal传递给config的signal属性，调用AbortController对象的abort()方法来中止请求\n\n```js\n// 创建AbortController对象\nconst controller = new AbortController();\n// 获取信号对象\nconst { signal } = controller;\nconst config = {\n  method: 'get',\n  url: \"http://localhost:3000/posts\",\n  signal: signal\n}\naxios(config)\n.then((result) => {\n  console.log(result);\n  console.log(result.data);\n}).catch((err) => {\n  console.log(err);\n});\n// 取消请求\ncontroller.abort();\n\n```\n\n# Fetch\n\nget请求：\n\n```js\nconst options = {\n method: \"GET\",\n headers: {\n   token:\n     \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U\",\n },\n};\n\nfetch(\"https://kpb.qcqx.cn/api\", options)\n .then((response) => response.json())\n .then((response) => console.log(response))\n .catch((err) => console.error(err));\n\n```\n\npost请求：\n\n```js\nconst options = {\n method: \"POST\",\n headers: {\n   token:\n     \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InF4IiwiX2lkIjoiNjQ0NWZhMGYzNTBhYjM2NDM2NDEzNjcwIiwiaWF0IjoxNjgyNDIzOTExLCJleHAiOjE2ODI0MzM5OTF9.pbwr6YjZS-b52xBNISi1O4QemT0Rd-w8oyVI9GpSa6U\",\n   \"content-type\": \"application/x-www-form-urlencoded\",\n },\n // 请求体\n body: new URLSearchParams({\n   matter: \"吃饭\",\n   data: \"2023-04-24\",\n   type: \"支出\",\n   account: \"20\",\n   remark: \"在食堂吃的\",\n }),\n};\n\nfetch(\"https://kpb.qcqx.cn/api\", options)\n .then((response) => response.json())\n .then((response) => console.log(response))\n .catch((err) => console.error(err));\n\n```\n\n使用`AbortController`打断fetch请求，在执行fetch请求时，可以通过`AbortController`创建一个信号对象`signal`，然后将`signal`作为配置选项传递给`fetch()`方法，调用`AbortController`对象的`abort()`方法来中止请求。\n\n```js\n// 创建AbortController对象\nconst controller = new AbortController();\n// 获取信号对象\nconst { signal } = controller;\n// 将信号对象传入fetch配置项\nfetch(url, { signal })\n  .then(response => response.json())\n\n// 调用abort() 中止 fetch 请求\ncontroller.abort();\n```\n\nfetch 没有超时设置，所以需要通过 abort 和 setTimeout 来实现超时\n\n## 下载进度\nfetch 没有 progress 事件，需获取数据流手动计算下载进度。\n```js\nfetch(url).then(async res => {\n  // 克隆响应对象\n  const response = res.clone();\n  // 获取数据流\n  const reader = res.body.getReader();\n  // 获取数据总字节大小\n  const total = +res.headers.get('Content-Length');\n  // 接收到的数据大小\n  let loaded = 0;\n  // 读取数据\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    loaded += value.length;\n    console.log((loaded / total * 100).toFixed(2) + '%');\n  }\n  return response.text();\n}).then(data => {\n  console.log(data);\n}).catch(err => {\n  console.error(err);\n});\n```\n\n# 跨域\n**同源策略：**浏览器的一种安全策略，同源即协议、域名、端口号必须完全相同。违背同源策略就是跨域\n\n**CORS**（Cross-Origin Resource Sharing），跨域资源共享。官方的解决跨域方\n案，在后端进行设置。\n\nCORS通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。\n\nexpress设置cors：\n\n```js\n// 请求来源白名单\nconst allowedOrigins = [\"127.0.0.1:5500\", undefined];\napp.use((req, res, next) => {\n  const origin = req.headers.origin;\n  // 判断请求来源是否在白名单内\n  if (\n    (origin && allowedOrigins.some((item) => origin.includes(item))) ||\n    allowedOrigins.includes(origin)\n  ) {\n    // 设置允许跨域的域名，*代表允许任意域名跨域\n    res.header('Access-Control-Allow-Origin', origin);\n    // 允许的header类型，如下设置允许自定义header、允许Content-Type为非默认值等，按需删改\n    res.header('Access-Control-Allow-Headers', \"*, Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n    // 跨域允许的请求方式 \n    res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, PATCH ,OPTIONS');\n    // 跨域的时候是否携带cookie\n    // 需要与 XMLHttpRequest.withCredentials 或 Fetch API 的 Request() 构造函数中的 credentials 选项结合使用\n    res.header(\"Access-Control-Allow-Credentials\", true);\n    if (req.method.toLowerCase() == 'options') {\n      res.send(200); // 让options请求快速结束\n    }\n    else {\n      next();\n    }\n  } else {\n    res.status(403).send('Forbidden');\n  }\n})\n```\n\n**jsonp：**非官方的解决跨域方法\n\n利用一些天生具有跨域能力的标签发请求，如：img link iframe script。\n\n**步骤：**\n1. 新建一个script标签\n2. 设置 script 的 src，设置回调函数\n3. 将 script 添加到 body 中\n4. 服务端将数据扔进回调函数中返回\n5. script接收到响应会自动解析运行回调函数，从而获取到数据\n\n```js 简单案例\n<script src=\"https://127.0.0.1:3000/test\"></script>\n// 后端部分\nconst data = {\n  name: 'chuckle'\n}\napp.all('/test', (req,res)=>{\n  res.end(`console.log(${data.name})`);\n})\n\n```\n\nJQ实现jsonp\n\n```js\n$.getJSON(\"/api?callback=?\", function(data) {\n  // 获得数据\n  console.log(data);\n})\n// 后端设置\nconst data = {\n  name: 'chuckle'\n}\napp.all('/api', (req,res)=>{\n  // 将数据转化为字符串\n  let str = JSON.stringify(data);\n  // 接收回调函数\n  let cb = req.query.callback;\n  // 返回数据data\n  res.end(`${cb}(${str})`);\n})\n\n```\n\n\n","tags":["前端","AJAX"],"categories":["学习笔记"]},{"title":"NodeJS接口、会话控制","url":"/article/a1e193d6.html","content":"\n# 接口\n接口即API，是前后端通信的桥梁.用于实现前后端通信\n\n在NodeJS中，一个接口就是服务中的一个路由规则\n\nAPI给客户端返回结果通常是 **JSON** 格式\n\n后端直接使用ejs、pug渲染好页面再返回是前后端不分离的表现，后端（HTTP服务）通过API将数据交给前端（网页、APP、小程序），后端只需考虑提供前端所需要的数据，而不用管数据的渲染，API 是通用的，不同的类型的前端使用同一个API就能渲染出多种页面。\n\n## 接口的组成\n接口的组成会在API文档中详细说明，[随机图片验证码API文档](https://www.free-api.com/doc/582)\n\n1. 请求方式 GET / POST\n2. 接口地址 URL\n3. 请求参数\n4. 响应结果、格式\n\n## RESTful API\n[RESTful API 设计指南--阮一峰](https://www.ruanyifeng.com/blog/2014/05/restful_api.html)\nRESTful API 是一种接口的规范，为了减少前后端的沟通成本\n同一个URL路径（可带上路由参数）不同的请求方法代表不同的功能，且语义要相符，API 返回的状态码也要相符\n\n| 操作         | 请求类型 | URL      | 返回                 |\n| ------------ | -------- | -------- | -------------------- |\n| 新增         | POST     | /song    | 返回新生成的歌曲信息 |\n| 删除         | DELETE   | /song/10 | 返回一个空文档       |\n| 覆盖修改         | PUT      | /song/10 | 返回更新后的歌曲信息 |\n| 局部修改         | PATCH    | /song/10 | 返回更新后的歌曲信息 |\n| 获取所有     | GET      | /song    | 返回歌曲列表数组     |\n| 获取单个(id) | GET      | /song/10 | 返回单个歌曲信息     |\n\n状态码语义：404 找不到资源、403 禁止访问、500服务器内部错误\n\n~~当然通常是POST亿把梭哈~~\n\n## json-server\n[json-server](https://github.com/typicode/json-server) 是一个 JS 编写的全局工具包，可以快速搭建 RESTful API 服务，也用于前端临时搭建接口使用\n\n安装：`npm i -g json-server`\n\n新建一个json文件\n\n```json\n{\n  \"song\": [\n    { \"id\": 1, \"name\": \"干杯\", \"singer\": \"五月天\" },\n    { \"id\": 2, \"name\": \"当\", \"singer\": \"动力火车\" },\n    { \"id\": 3, \"name\": \"不能说的秘密\", \"singer\": \"周杰伦\" }\n  ]\n}\n\n```\n\n```js 使用：以 JSON 文件所在文件夹作为工作目录 ，执行该命令，端口默认3000\njson-server --watch <文件名>.json\n```\n\n命令行的提示：\n\n```js\n\\{^_^}/ hi!    \n\n  Loading 01.json\n  Done\n\n  Resources\n  http://localhost:3000/song\n\n  Home\n  http://localhost:3000\n\n```\n\n## 接口测试工具\n**常用接口测试工具：**[apipost](https://www.apipost.cn/)，[apifox](https://apifox.com/)，[postman](https://www.postman.com/)\n\n**apipost**基本使用：\n1. Header 设置请求头\n2. Query 设置查询字符串\n3. Body 设置请求体\n   1. none 没有内容\n   2. form-data 表单形式数据\n   3. x-www-form-urlencoded Query-String形式的数据\n   4. raw 原生请求体，json格式数据\n\n# 记账本添加API\n因为API即请求方法+路由，所以去修改routes文件夹下的路由，将原来的index.js页面路由放到web文件夹，新建账单相关接口路由account.js，放到api文件夹\n\n然后在app.js中使用路由，接口路径添加上api前缀\n\n```js /app.js\n// 导入接口路由\nvar accountRouter = require('./routes/api/account');\n// 使用接口路由，并添加api前缀\napp.use('/api', accountRouter);\n```\n\naccount.js总览，相同路径、不同请求方法、带路由参数来实现增删改查接口，符合RESTful API接口规范\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/50-2.webp width=\"50%\" loading=\"lazy\">\n\n**接口的设计：**\n1. 接口通常返回的都是 **JSON**\n2. 一个接口通常由**响应编号 code**、**响应信息 msg**、**响应数据 data** 组成\n3. 即使出现错误或失败也是通过响应编号去体现错误，而不设置状态响应码\n4. 响应编号，字符串，四个0表示成功，非0（如：1001）表示失败\n5. 响应信息，字符串，如：查找成功、删除成功\n\n```js /routes/api/account.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 获取所有记录接口\nrouter.get('/', function (req, res, next) {\n\n    // 读取所有数据，按日期降序\n    AccountModel.find().sort({ date: -1 })\n        .then(data => {\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            // 接口的状态信息标识在code中，不设置响应码\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1001',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 获取单条记录接口\nrouter.get('/:id', (req, res) => {\n    let { id } = req.params;\n    AccountModel.findById(id)\n        .then(data => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            });\n        })\n        .catch(err => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1004',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n})\n\n// 添加记录接口\nrouter.post('/', function (req, res, next) {\n\n    // 插入一条数据\n    AccountModel.create({\n        // 解构赋值\n        ...req.body,\n        // 覆盖修改日期为日期对象\n        date: moment(req.body.date).toDate()\n    })\n        .then(data => {\n            console.log(data);\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '添加成功',\n                // 响应的数据，返回创建成功的文档\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1002',\n                // 响应的信息\n                msg: '添加失败',\n                // 响应的数据\n                data: null\n            })\n        });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.delete('/:id', (req, res) => {\n    // 获取路由参数id\n    let id = req.params.id;\n    AccountModel.deleteOne({ _id: id })\n        .then(data => {\n            console.log(data);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '删除成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1003',\n                // 响应的信息\n                msg: '删除失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 更新账单接口\nrouter.patch('/:id', (req, res) => {\n    let { id } = req.params;\n    AccountModel.updateOne({ _id: id }, req.body)\n    .then(data => {\n        res.json({\n            code: '0000',\n            msg: '更新成功',\n            data: data\n        })\n    })\n    .catch(err=>{\n        res.json({\n            code: '1005',\n            msg: '更新失败',\n            data: null\n        })\n    })\n})\n\n\nmodule.exports = router;\n\n```\n\n# 会话控制\n每一个 HTTP 请求都是一个会话，但 HTTP 是一种无状态的协议，它没有办法区分不同的请求、不同的会话是否来自于同一个客户端，即无法区分、识别用户\n\n所以需要后端实现会话控制来区分用户，如使用注册登陆来区分用户，以此保护不同用户的**数据安全**\n\n常见的会话控制技术：**cookie**、**session**、**token**\n\n# cookie\ncookie 是 HTTP 服务器发送到用户浏览器并保存在本地的一小块数据，按域名划分，本质上是Key-Value键值对\n\n浏览器向服务端发送请求时，会自动携带对应域名下的所有 cookie 设置在请求头的 Cookie 属性中\n\n服务端通过响应报文的 set-cookie 在浏览器设置cookie\n\n## 设置cookie\n`cookie()` 在响应报文set-cookie中携带cookie\n\n设置浏览器关闭时自动销毁的cookie：\n\n```js\nres.cookie('name', 'chuckle');\n// 响应报文：\nSet-Cookie: name=chuckle; Path=/\n```\n\n设置一段时间后过期的cookie，设置时maxAge单位毫秒，响应报文中Max-Age单位秒\n\n```js\n// 设置maxAge，cookie存活多少ms\nres.cookie('user', 'giggles',{maxAge: 60000});\n// 响应报文：\nSet-Cookie: user=giggles; Max-Age=60; Path=/; Expires=Sun, 23 Apr 2023 01:12:07 GMT\n```\n\n后续请求头中Cookie属性携带cookie，Key-Value\n\n```js\nCookie: name=chuckle; user=giggles\n```\n\n## 删除cookie\n`clearCookie()` 通过设置对应cookie的过期时间为1970年，使cookie过期自动删除\n\n```js\nres.clearCookie('name');\nres.clearCookie('user');\n```\n\n```js 响应报文\nSet-Cookie: name=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT\nSet-Cookie: user=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT\n```\n\n## 获取cookie\n需要安装 [cookie-parser](https://www.npmjs.com/package/cookie-parser) 是一个中间件\n\n```js 使用cookie-parser\n// 导入\nconst cookieParser = require('cookie-parser');\n// 设置中间件\napp.use(cookieParser())\n```\n\n设置完中间件后，通过 **req.cookies** 即可获取所有cookie\n\n```js\nconsole.log(req.cookies);\n// {\n//   name: 'chuckle',\n//   user: 'giggles'\n// }\n```\n\n## cookie安全\n**1、httpOnly** 设置cookie时带上 httpOnly 属性，客户端脚本代码(js)尝试读取该cookie，浏览器将返回一个空字符串作为结果\n\nHttpOnly是包含在http返回头Set-Cookie里面的一个附加的属性\n\n```js\nres.cookie('name', 'chuckle',{httpOnly: true});\n// 响应报文\nSet-Cookie: name=chuckle; Path=/; HttpOnly\n```\n\n**2、加密cookie**，设置cookie时带上 **signed** 属性，并给 cookieParser(secret) 中间件传入一个字符串secret用于加密，获取时使用 **req.signedCookies**\n\n```js\n// 设置加密字符串\nconst secret = 'qx';\napp.use(cookieParser(secret))\n// 设置cookie\nres.cookie('number','123456',{signed: true,maxAge: 60*1000});\nconsole.log(req.signedCookies);// { number: '123456' }\n```\n\n在浏览器端查看该cookie，可以看到已经被加密\n\n```js\nnumber: s%3A123456.gnY%2Bp%2BEFLYanFxZP9eAYnlyW9IkToo4KlHZyIJ3DJgc\n```\n\n# session\nsession 在服务器端保存当前访问用户的相关信息（用户名、用户id、邮箱等）\n\n**作用：**识别用户\n\n**登陆例子:**\n当用户输入账号密码传给服务端后，会去数据库查找是否正确，如果正确，服务端会给这个用户创建一个session对象，保存当前用户的基本信息，该对象还会生成并保存一个唯一session_id会话id（sid，在数据库中字段名是_id），然后服务端会将sid以cookie形式返回给浏览器，浏览器之后的请求就会带上这个sid，服务端可以通过这个sid在一堆session对象数组中识别是哪个用户。\n\n## 使用session\n安装 [express-session](https://www.npmjs.com/package/express-session) 和 [connect-mongo](https://www.npmjs.com/package/connect-mongo) 两个包\n\nexpress-session用于将session存到内存中，connect-mongo可以将session存到数据库中，方便查看\n\n**设置中间件进行配置:**\n\n后续的增删改查操作，中间件会自动匹配好当前请求是哪个用户\n\n```js\n// 引入包\nconst session = require(\"express-session\");\nconst MongoStore = require('connect-mongo');\n// 使用中间件\napp.use(session({\n    name: 'sid', //设置cookie的name，默认值是：connect.sid\n    secret: 'chuckle', //参与加密的字符串（又称签名）\n    saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id\n    resave: true, //是否在每次请求时重新保存session，用于重置session过期时间\n    // 设置session存储位置\n    store: MongoStore.create({\n        // 存储到mongodb中\n        mongoUrl: 'mongodb://127.0.0.1:27017/test' //数据库的连接配置\n    }),\n    // 浏览器端cookie设置\n    cookie: {\n        httpOnly: true, // 开启后前端无法通过 JS 操作\n        maxAge: 1000 * 60 // 不仅控制cookie，也控制session的生命周期\n    },\n}))\n```\n\n## 设置session\n模拟登陆情况\n\n```js\napp.get('/login', (req, res) => {\n    let uname = req.query.username;\n    // 登陆需要传递查询字符串，账号和密码\n    if(req.query.username === 'chuckle' && req.query.password === '123456'){\n        // 设置session，就是把用户的基本信息传进去\n        req.session.username = uname;// 传入用户名\n        res.send('登陆成功');\n        return;\n    }\n    res.send('登陆失败');\n});\n// 响应报文\nSet-Cookie: sid=s%3A-5tzIG5ZCDk4JaT7POAgODadySTDZVur.H7%2Fh5xrNRApVa%2Fl1J4fynkE48fREOM1yfLjdZd68bps; Path=/; Expires=Sun, 23 Apr 2023 03:16:14 GMT; HttpOnly\n\n```\n\n数据库中：\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/50-3.webp width=\"100%\" loading=\"lazy\">\n\n## 读取session\n检测session是否存在，不存在则让用户登陆\n\n```js\napp.get('/', (req, res) => {\n    // 检测session中是否有用户信息\n    // 中间件已经自动获取当前cookie中的用户信息，从数据库中取出来，存到session内存中\n    if(req.session.username){\n        // 有信息则说明已经登陆，直接欢迎\n        res.send('Welcome');\n        return;\n    }\n    res.send('还未登陆');\n});\n\n```\n\n## 销毁session\n`destroy()`，如用户主动退出登陆\n\n```js\napp.get('/logout', (req, res) => {\n    // 中间件已经自动匹配好当前请求是哪个用户，直接调用destroy()即可销毁\n    req.session.destroy(()=>{\n        res.send('退出成功')\n    })\n});\n\n```\n\n# cookie与session区别\n1. 存在的位置\ncookie：浏览器端\nsession：服务端\n2. 安全性\ncookie 是以明文的方式存放在客户端的，安全性相对较低\nsession 存放于服务器中，所以安全性相对较好\n3. 网络传输量\ncookie 设置内容过多会增大报文体积， 会影响传输效率\nsession 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率\n4. 存储限制\n浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制（165）\nsession 数据存储在服务器中，所以没有这些限制\n\n\n# 记账本-注册登陆\n**效果：**不同用户登陆后显示对应用户的账单，没有登陆就跳转到登录页面\n\n大概步骤：\n1. 先在app.js中导入session操作相关的包，并设置中间件\n2. 创建注册登陆的ejs页面\n3. 创建用户文档模型，后续通过其将用户信息写入数据库\n4. 修改账单文档模型，添加一个userID字段来保存账单对应用户的_id，用以区分账单属于哪个用户\n5. 创建注册登陆的路由 auth.js，使用 [md5](https://www.npmjs.com/package/md5) 对密码进行加密\n6. 创建中间件 checkLoginMiddleware.js 来检测用户是否登陆\n7. 修改index.js路由，应用检测登陆的中间件，并根据业务需要调整部分代码\n\n**业务逻辑：**\n1. 用户注册后将用户名和经过md5加密后的密码保存在数据库users集合中，并且每次新注册会检测用户名是否已经存在\n2. 登陆时获取客户端传来的用户名和密码去数据库中找是否有对应的用户，因为保存在数据库中的密码是经过md5加密的，所以要将密码经过一次md5加密后再去查找，同一字符串经过md5加密后结果是相同的\n3. 用户存在即登陆成功，则将用户信息（用户名和_id）写入session\n4. 在新增账单记录时，从session中找到当前用户的_id，然后保存到账单文档的userID字段\n5. 渲染账单列表时，只渲染属于当前用户的账单文档，对比当前登陆用户的_id和每个文档userID是否相同\n6. 退出登陆即销毁当前的session\n7. 对于从请求头cookie中获得sid然后找到对应的session，并提取用户的信息，是express-session包内中间件自动完成的，后续业务只需要req.session.<属性名>即可获取当前用户的信息\n\n数据库：\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/50-4.webp width=\"100%\" loading=\"lazy\">\n\n先在app.js中导入session操作相关的包，并设置中间件\n\n```js app.js\n// 导入session操作相关包\nconst session = require(\"express-session\");\nconst MongoStore = require('connect-mongo');\n// 导入数据库连接配置文件\nconst { HOST, PORT, NAME } = require('./config');\n\n// 使用中间件\napp.use(session({\n  name: 'sid', //设置cookie的name，默认值是：connect.sid\n  secret: 'chuckle', //参与加密的字符串（又称签名）\n  saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id\n  resave: true, //是否在每次请求时重新保存session，用于重置session过期时间\n  // 设置session存储位置\n  store: MongoStore.create({\n    // 存储到mongodb中\n    mongoUrl: `mongodb://${HOST}:${PORT}/${NAME}` //数据库的连接配置\n  }),\n  // 浏览器端cookie设置\n  cookie: {\n    httpOnly: true, // 开启后前端无法通过 JS 操作\n    maxAge: 1000 * 60 * 60 * 24 * 7 // 不仅控制cookie，也控制session的生命周期\n  },\n}))\n\n```\n\n创建注册登陆的ejs页面\n\n```js /views/auth/reg.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/css/page.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>注册</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/login\">去登陆</a>\n        </div>\n        <form action=\"/reg\" method=\"post\" autocomplete=\"off\">\n          <div class=\"form-item\">\n            <label for=\"username\">用户名</label>\n            <input class=\"control\" type=\"text\" name=\"username\" id=\"username\" required/>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"password\">密码</label>\n            <input class=\"control\" type=\"text\" name=\"password\" id=\"password\" required/>\n          </div>\n          <hr />\n          <button>注册</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```js /views/auth/login.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/css/page.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>登陆</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/reg\">去注册</a>\n        </div>\n        <form action=\"/login\" method=\"post\" autocomplete=\"off\">\n          <div class=\"form-item\">\n            <label for=\"username\">用户名</label>\n            <input class=\"control\" type=\"text\" name=\"username\" id=\"username\" required/>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"password\">密码</label>\n            <input class=\"control\" type=\"text\" name=\"password\" id=\"password\" required/>\n          </div>\n          <hr />\n          <button>登陆</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```css /public/css/page.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\nhr{\n    margin: 20px auto;\n    border: 0;\n    border-top: 1px solid rgb(220, 220, 220);\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.home{\n    margin-top: 10px;\n    padding-left: 20px;\n    display: flex;\n    justify-content: space-between;\n}\n.home a{\n    color: rgb(33, 70, 181);\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.content-box form{\n    margin-top: 10px;\n}\n.form-item{\n    margin-bottom: 15px;\n}\n.form-item label{\n    display: block;\n    height: 32px;\n    line-height: 32px;\n    font-size: 18px;\n}\n.form-item>*{\n    width: 100%;\n}\n.form-item>.control{\n    padding: 6px 12px;\n    height: 36px;\n    font-size: 16px;\n    line-height: 36px;\n    color: #363636;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n    outline: none;\n    font-family:\"Microsoft YaHei\",微软雅黑;\n}\n.form-item>.control:focus{\n    border-color: #66afe9;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n}\n.form-item>textarea.control{\n    padding: 8px 12px;\n    height: 100px;\n    line-height: 1;\n    resize: none;\n}\n.content-box form>button{\n    width: 100%;\n    padding: 6px 12px;\n    margin-bottom: 15px;\n    border: 1px solid rgb(57, 162, 204);\n    background: rgb(37, 173, 204);\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    font-size: 17px;\n    color: #fff;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.content-box form>button:hover{\n    background: rgb(32, 153, 190);\n}\n\n```\n\n创建用户文档模型，后续通过其将用户信息写入数据库\n\n```js /models/UserModel.js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet UserSchema = new mongoose.Schema({\n    username: {\n        type: String,\n        required: true\n    },\n    password: {\n        type: String,\n        required: true\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('users', UserSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n修改账单文档模型，添加一个userID字段来保存账单对应用户的_id，用以区分账单属于哪个用户\n\n```js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet AccountSchema = new mongoose.Schema({\n    matter: {\n        type: String,\n        required: true\n    },\n    date: {\n        type: Date,\n        required: true\n    },\n    type: {\n        type: String,\n        enum: ['支出', '收入'],\n        default: '支出'\n    },\n    account: {\n        type: Number,\n        required: true\n    },\n    remark: {\n        type: String,\n        default: '无'\n    },\n    // 通过userID保存账单属于哪个用户的\n    userID:{\n        type: String,\n        required: true\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('accounts', AccountSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n创建注册登陆的路由 auth.js，使用 [md5](https://www.npmjs.com/package/md5) 对密码进行加密\n\n```js /routes/web/auth.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入用户文档模型\nconst UserModel = require('../../models/UserModel');\n// 导入md5对密码进行加密\nconst md5 = require('md5');\n\n// 注册\n// 注册页面路由\nrouter.get('/reg', (req, res) => {\n    res.render('auth/reg');\n})\n// 注册操作路由\nrouter.post('/reg', (req, res) => {\n    // 如果用户名重复就重新注册\n    UserModel.findOne({ username: req.body.username })\n        .then(data => {\n            // data不为空说明用户名重复\n            if (data) {\n                res.render('tip', { msg: '用户名已存在', url: '/reg' });\n                return;\n            }\n            // 用户名不重复则创建用户\n            UserModel.create({\n                ...req.body,\n                // 使用md5对密码进行加密\n                password: md5(req.body.password)\n            })\n                .then(data => {\n                    res.render('tip', { msg: '注册成功', url: '/login' });\n                })\n                .catch(err => {\n                    res.status(500).render('tip', { msg: '注册失败!', url: '/reg' });\n                })\n        })\n})\n\n// 登陆\n// 登陆页面路由\nrouter.get('/login', (req, res) => {\n    res.render('auth/login');\n})\n// 登陆操作路由\nrouter.post('/login', (req, res) => {\n    // 获取用户名和密码\n    let { username, password } = req.body;\n    // 如果用户名或密码为空则返回失败\n    if (!username || !password) {\n        res.render('tip', { msg: '用户名或密码错误', url: '/login' });\n        return;\n    }\n    // 查询数据库，看有没有该用户\n    // 要对密码也做一次md5加密然后去数据库对比\n    UserModel.findOne({\n        username: username,\n        password: md5(password)\n    })\n        .then(data => {\n            // 如果data为空说明用户不存在\n            if (!data) {\n                res.render('tip', { msg: '用户名或密码错误', url: '/login' });\n                return;\n            }\n            // 用户存在则将用户信息写入session\n            req.session.username = data.username;\n            req.session._id = data._id;\n            // 渲染成功提示页\n            res.render('tip', { msg: '登陆成功', url: '/' });\n        })\n        .catch(err => {\n            res.status(500).render('tip', { msg: '登陆失败!', url: '/login' });\n        })\n})\n\n// 退出登陆，避免跨站请求伪造，使用post\nrouter.post('/logout', (req, res) => {\n    // 销毁session\n    req.session.destroy(() => {\n        res.render('tip', { msg: '退出成功', url: '/login' });\n    });\n});\n\n\nmodule.exports = router;\n\n```\n\n创建中间件 checkLoginMiddleware.js 来检测用户是否登陆\n\n```js /middleware/checkLoginMiddleware.js\nconst checkLoginMiddleware = (req, res, next) => {\n    if (!req.session.username) {\n        // redirect重定向到登陆页面\n        return res.render('tip', { msg: '还未登陆!', url: '/login' });\n    }\n    next();\n}\n\nmodule.exports = checkLoginMiddleware;\n\n```\n\n修改index.js路由，应用检测登陆的中间件，并根据业务需要调整部分代码\n\n```js /routes/web/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 导入检测是否登陆的中间件、\nconst checkLoginMiddleware = require('../../middleware/checkLoginMiddleware');\n\n// 将首页重定向到账单页\nrouter.get('/', (req, res)=>{\n  res.redirect('/account');\n})\n\n// 记账本页面路由\nrouter.get('/account',checkLoginMiddleware, function (req, res, next) {\n  // 读取对应用户所有数据，按日期降序\n  AccountModel.find({userID: req.session._id}).sort({ date: -1 })\n    .then(data => {\n      // 将数据数组传递过去遍历渲染，为了格式化日期，将moment传入\n      res.render('index', { content: data, moment });\n    })\n    .catch(err => {\n      console.log(err);\n      // 查找失败则返回500\n      res.status(500).render('tip', { msg: '查找失败!', url: '/' });\n    })\n\n});\n\n// 添加记录页面路由\nrouter.get('/add',checkLoginMiddleware, function (req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add',checkLoginMiddleware,  function (req, res, next) {\n\n  // 插入一条数据\n  AccountModel.create({\n    // 解构赋值\n    ...req.body,\n    // 覆盖修改日期为日期对象\n    date: moment(req.body.date).toDate(),\n    // 将对应用户id传入\n    userID: req.session._id\n  })\n    .then(data => {\n      console.log(data);\n      // 成功跳转到提示页\n      res.render('tip', { msg: '添加成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      // 添加失败则返回500\n      res.status(500).render('tip', { msg: '添加失败!', url: '/' });\n    });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id',checkLoginMiddleware,  (req, res) => {\n  // 获取路由参数id\n  let id = req.params.id;\n  AccountModel.deleteOne({ _id: id })\n    .then(data => {\n      console.log(data);\n      // 删除成功跳转提示页\n      res.render('tip', { msg: '删除成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      res.status(500).render('tip', { msg: '删除失败!', url: '/' });\n    })\n\n});\n\nmodule.exports = router;\n\n```\n\n# token\ntoken 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token中保存着用户信息\n\n**作用：**实现会话控制，识别用户的身份，主要用于移动端 APP\n\n**与session区别：**token将用户信息存放于客户端，而session将用户信息存放于服务端，在客户端仅存放session的sid（_id）\n\n**token工作流程：**\n1. 用户填写账号和密码校验身份，校验通过后服务端响应 token，一般放在响应体中\n2. 后续发送请求时，需要手动将 token 添加在请求报文的 token 属性中，一般放在请求头中\n\n**token特点：**\n1. 数据存储在客户端，服务端压力更小\n2. 数据加密、可以避免 CSRF（跨站请求伪造），相对更安全\n3. 扩展性更强：服务间可以共享，增加服务节点更简单\n\n## JWT\nJWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证\n\ntoken实现身份验证有很多办法，但 JWT 使 token 的生成与校验更规范\n\n使用 [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) 包 来操作 token\n\n**使用：**\n1. `sign()` 生成token\nsign(用户信息数据对象, 加密字符串, 配置对象)\n2. `verify` 校验解析token\nverify(token, 加密字符串, 回调函数)\n\n```js\nconst jwt = require('jsonwebtoken');\n// 生成token\n// sign(用户信息数据对象, 加密字符串, 配置对象)\n// 在配置对象中设置生命周期等等\nlet token = jwt.sign({\n    username: 'chuckle',\n    id: '123456'\n}, 'qx', {\n    // 设置生命周期，单位秒\n    expiresIn: 60\n});\n\nconsole.log(token);\n// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNodWNrbGUiLCJpZCI6IjEyMzQ1NiIsImlhdCI6MTY4MjI2NTI3OSwiZXhwIjoxNjgyMjY1MzM5fQ._Or0D76QY78NofSGpZt81-B_T8K4iX_v0jEzDBvnObk\nlet t = token;\n\n// 校验解析token，获得用户信息\n// verify(token, 加密字符串, 回调函数)\njwt.verify(token, 'qx', (err, data) => {\n    if(err){\n        console.log('校验失败');\n        return;\n    }\n    console.log(data);\n    //{ username: 'chuckle', id: '123456', iat: 1682265279, exp: 1682265339 }\n});\n\n```\n\n# 记账本-接口token\n记账本的页面端已经做了会话控制、用户区分，但API接口仍然没有做约束、没区分用户，下面使用token进行会话控制\n\n## 注册登陆接口\n注册登陆接口，即注册成功则在数据库users集合中新建一个用户文档，登陆成功则返回一个token\n\n在api路由文件夹中新建auth.js，作为注册登陆接口的路由\n\n```js /routes/api/auth.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入用户文档模型\nconst UserModel = require('../../models/UserModel');\n// 导入md5对密码进行加密\nconst md5 = require('md5');\n// 导入jwt控制token\nconst jwt = require('jsonwebtoken');\n// 导入配置文件，获取加密字符串\nconst config = require('../../config');\n\n// 注册\n// 注册操作API\nrouter.post('/reg', (req, res) => {\n    // 如果用户名重复就重新注册\n    UserModel.findOne({ username: req.body.username })\n        .then(data => {\n            // data不为空说明用户名重复\n            console.log(data);\n            if (data) {\n                res.json({\n                    code: '2003',\n                    msg: '用户名已存在',\n                    data: null\n                })\n                return;\n            }\n            // 用户名不重复则创建用户\n            UserModel.create({\n                ...req.body,\n                // 使用md5对密码进行加密\n                password: md5(req.body.password)\n            })\n                .then(data => {\n                    res.json({\n                        code: '0000',\n                        msg: '注册成功',\n                        data: {\n                            username: req.body.username\n                        }\n                    })\n                })\n                .catch(err => {\n                    res.json({\n                        code: '2004',\n                        msg: '注册失败',\n                        data: null\n                    })\n                })\n        })\n})\n\n// 登陆\n// 登陆操作API\nrouter.post('/login', (req, res) => {\n    // 获取用户名和密码\n    let { username, password } = req.body;\n    // 如果用户名或密码为空则返回失败\n    if (!username || !password) {\n        res.json({\n            code: '2001',\n            msg: '用户名或密码错误',\n            data: null\n        })\n        return;\n    }\n    // 查询数据库，看有没有该用户\n    // 要对密码也做一次md5加密然后去数据库对比\n    UserModel.findOne({\n        username: username,\n        password: md5(password)\n    })\n        .then(data => {\n            // 如果data为空说明用户不存在\n            if (!data) {\n                res.json({\n                    code: '2001',\n                    msg: '用户名或密码错误',\n                    data: null\n                })\n                return;\n            }\n            // 创建并返回token\n            let token = jwt.sign({\n                username: data.username,\n                _id: data._id\n            }, config.token_secret, {\n                expiresIn: 60 * 24 * 7\n            });\n            res.json({\n                code: '0000',\n                msg: '登陆成功',\n                data: {\n                    token: token\n                }\n            })\n        })\n        .catch(err => {\n            res.json({\n                code: '2002',\n                msg: '登陆出错',\n                data: null\n            })\n        })\n})\n\n// 退出登陆\nrouter.post('/logout', (req, res) => {\n    // 客户端删除token即可\n    res.json({\n        code: '0000',\n        msg: '退出成功',\n        data: null\n    })\n});\n\n\nmodule.exports = router;\n\n```\n\n其中token的加密字符串 token_secret 保存在配置文件中\n\n```js /config.js\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test',\n    session_secret: 'chuckle',\n    token_secret: 'chuckle'\n}\nmodule.exports = config;\n\n```\n\n## 业务接口\n有了token后，要对 account.js 里原有的业务接口进行修改，并添加一个中间件对token进行校验，校验完后将token中的用户信息（username和userID）写入req中\n\n中间件 checkTokenMiddleware.js\n\n```js middleware/checkTokenMiddleware.js\nconst jwt = require(\"jsonwebtoken\");\nconst config = require('../config');\n\nconst checkTokenMiddleware = (req, res, next) => {\n    // 获取请求头中的token\n    let token = req.get('token');\n    // 没有token则报错\n    if (!token) {\n        res.json({\n            code: '2008',\n            msg: '缺失token',\n            data: null\n        })\n        return;\n    }\n    jwt.verify(token, config.token_secret, (err, data) => {\n        if (err) {\n            res.json({\n                code: '2009',\n                msg: 'token校验失败',\n                data: null\n            })\n            return;\n        }\n        // 校验成功后，将username和userID绑定到req上\n        req.username = data.username;\n        req.userID = data._id;\n        next();\n    })\n}\n\nmodule.exports = checkTokenMiddleware;\n\n```\n\n在业务接口中应用中间件\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../../models/AccountModel');\n\n// 导入token校验中间件\nconst checkTokenMiddleware = require('../../middleware/checkTokenMiddleware');\n\n// 获取所有记录接口\nrouter.get('/', checkTokenMiddleware, function (req, res, next) {\n\n    // 读取所有数据，按日期降序\n    AccountModel.find({userID: req.userID}).sort({ date: -1 })\n        .then(data => {\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            // 接口的状态信息标识在code中，不设置响应码\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1001',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 获取单条记录接口\nrouter.get('/:id', checkTokenMiddleware, (req, res) => {\n    let { id } = req.params;\n    AccountModel.findById(id)\n        .then(data => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '读取成功',\n                // 响应的数据\n                data: data\n            });\n        })\n        .catch(err => {\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1004',\n                // 响应的信息\n                msg: '读取失败',\n                // 响应的数据\n                data: null\n            })\n        })\n})\n\n// 添加记录接口\nrouter.post('/', checkTokenMiddleware, function (req, res, next) {\n\n    // 插入一条数据\n    AccountModel.create({\n        // 解构赋值\n        ...req.body,\n        // 覆盖修改日期为日期对象\n        date: moment(req.body.date).toDate(),\n        userID: req.userID\n    })\n        .then(data => {\n            console.log(data);\n            // 接口返回json\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '添加成功',\n                // 响应的数据，返回创建成功的文档\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1002',\n                // 响应的信息\n                msg: '添加失败',\n                // 响应的数据\n                data: null\n            })\n        });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.delete('/:id', checkTokenMiddleware, (req, res) => {\n    // 获取路由参数id\n    let id = req.params.id;\n    AccountModel.deleteOne({ _id: id })\n        .then(data => {\n            console.log(data);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '0000',\n                // 响应的信息\n                msg: '删除成功',\n                // 响应的数据\n                data: data\n            })\n        })\n        .catch(err => {\n            console.log(err);\n            res.json({\n                // 响应编号，四个0表示成功，非0表示失败\n                code: '1003',\n                // 响应的信息\n                msg: '删除失败',\n                // 响应的数据\n                data: null\n            })\n        })\n\n});\n\n// 更新账单接口\nrouter.patch('/:id', checkTokenMiddleware, (req, res) => {\n    let { id } = req.params;\n    AccountModel.updateOne({ _id: id }, req.body)\n    .then(data => {\n        res.json({\n            code: '0000',\n            msg: '更新成功',\n            data: data\n        })\n    })\n    .catch(err=>{\n        res.json({\n            code: '1005',\n            msg: '更新失败',\n            data: null\n        })\n    })\n})\n\n\nmodule.exports = router;\n\n```\n\n最后在app.js中应用路由\n\n```js\n// 导入注册登陆API路由\nvar authApiRouter = require('./routes/api/auth');\n// 使用注册登陆API路由\napp.use('/api', authApiRouter)\n```\n\n# 记账本完全体\n记账本演示：[KeepingBook](https://kpb.qcqx.cn/)\n\ngithub地址：[KeepingBook-vercel](https://github.com/qxchuckle/KeepingBook-vercel)\n\nAPI文档：[KeepingBook-api](https://console-docs.apipost.cn/preview/3d8ecc659c1e192b/da97e0b2ec13fd71)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"NodeJS-MongoDB","url":"/article/bd0448f7.html","content":"\n# 简介\n[MongoDB](https://www.mongodb.com/) 基于分布式文件存储的数据库\n\n相较于用 db.json 纯文件管理数据，用数据库管理数据速度更快、扩展性高、安全性高\n\nMongoDB的操作语法与JS相似\n\n**核心概念：**\n1. 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存\n放很多集合\n2. 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档，一个集合存放一种文档（字段类型相同的文档）\n3. 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象，一个文档中有许多字段（对象的属性）\n\n# 命令行交互\n在将bin文件夹添加至环境变量后，在终端中输入 **mongod** 启动服务端，**mongo** 启动客户端\n\n**1、数据库命令**\n\n```js\n// 显示所有的数据库\nshow dbs\n// 切换到指定数据库，若不存在则创建\nuse <数据库名>\n// 显示当前所在的数据库\ndb\n// 删除当前数据库\nuse <数据库名>\ndb.dropDatabase()\n\n```\n\n**2、集合命令**\n\n```js\n// 创建集合\ndb.createCollection('集合名')\n// 显示当前数据库中的所有集合\nshow collections\n// 删除某个集合\ndb.集合名.drop()\n// 重命名集合\ndb.集合名.renameCollection('新名')\n\n```\n\n**3、文档命令**\n\n```js\n// 插入文档\ndb.集合名.insert(文档对象)\n// 查询文档，_id 是 mongodb 自动生成的唯一编号，用来唯一标识文档\ndb.集合名.find(查询条件)\n// 更新文档\ndb.集合名.update(查询条件,新的文档)\n// 删除文档\ndb.集合名.remove(查询条件)\n\n```\n\n# Mongoose\n[Mongoose](https://mongoosejs.com/) 是一个对象文档模型库，在异步环境中工作，用代码操作 mongodb 数据库\n\n**连接数据库：**\n\n```js\nconst mongoose = require('mongoose');\n\n// 连接数据库 mongodb://127.0.0.1:<端口号，默认27017可不写>/<数据库名，没有会自动创建>\nmongoose.connect('mongodb://127.0.0.1/test');\n\n// 设置回调\n// 连接成功回调，使用once回调函数只执行一次\nmongoose.connection.once('open', () => {\n    console.log('连接成功');\n});\n// 连接错误回调\nmongoose.connection.on('error', () => {\n    console.log('连接失败');\n});\n// 连接关闭回调\nmongoose.connection.on('close', () => {\n    console.log('连接关闭');\n});\n\n```\n\n**常用方法：**\n**1、创建文档模型对象：**\n1. `mongoose.Schema()` 创建文档的结构对象，约束文档字段的数据类型\n2. `mongoose.model(<集合名称>, <结构对象>)` 创建模型对象，对文档操作的封装对象，集合有则使用无则自动创建，集合名称会**自动变为复数**\n\n**2、插入、增加文档：**\n1. `create())` 创建并插入一个新文档\n2. `insertMany()` 传入文档数组批量添加新文档\n\n**3、删除文档：**\n1. `deleteOne()` 删除一条文档\n2. `deleteMany()` 批量删除\n\n**4、更新文档：**\n1. `updateOne()` 更新一条文档\n2. `updateMany()` 批量更新\n\n**5、查找、读取文档：**\n1. `findOne()` 查找一条\n2. `findById()` 通过_id找一条\n3. `find()` 批量查找，无论找到多少条都返回数组\n\n**6、条件控制：**\n1. \\> `$gt`\n2. < `$lt`\n3. \\>= `$gte`\n4. <= `$lte`\n5. !== `$ne`\n6. || `$or` 也可以用 ||\n7. && `$and` 也可以用 &&\n8. 正则匹配 `{author: /鱼/}`\n\n**7、规则控制：**\n1. `select()` 字段筛选\n2. `sort()` 排序\n3. `skip()` 数据截取，跳过\n4. `limit()` 数据截取，限定\n\n## 插入文档\n**插入新文档流程：**在open事件的回调函数中操作\n1. `mongoose.Schema()` 创建文档的结构对象，约束文档字段的数据类型\n2. `mongoose.model(<集合名称>, <结构对象>)` 创建模型对象，对文档操作的封装对象，集合有则使用无则自动创建，集合名称会**自动变为复数**\n3. `模型对象.create({文档数据对象}).then(data=>{})` 创建新文档\n\n```js\n// 在open事件的回调函数中操作\nmongoose.connection.once('open', () => {\n    console.log('连接成功');\n    // 创建文档的结构对象BookSchema\n    // 并约束文档字段的数据类型\n    let BookSchema = mongoose.Schema({\n        name: String,\n        author: String,\n        price: Number\n    });\n    // 创建模型对象，对文档操作的封装对象，第一个参数是集合，会自动创建\n    let BookModel = mongoose.model('books', BookSchema);\n    // 使用模型对象去增删改查\n    // 创建新文档\n    BookModel.create({\n        name: '三体',\n        author: '刘慈欣',\n        price: 30\n    }).then(data=>{\n        console.log(data);\n        // {\n        //     name: '三体',\n        //     author: '刘慈欣',\n        //     price: 30,\n        //     _id: new ObjectId(\"6442809af5fae6b874c172f0\"),\n        //     __v: 0\n        // }\n    }).catch(err=>{\n        console.log(err);\n    })\n    // 关闭数据库连接（项目运行过程中不会添加该代码）\n    // mongoose.disconnect();\n});\n\n```\n\n## 批量插入文档\ncreate() 一次只能新增一个文档，使用 `insertMany()` 传入文档数组批量添加新文档\n\n```js 使用文档模型对象的insertMany()方法批量插入文档\nmongoose.connection.once('open', () => {\n  // 文档结构对象\n  let BookSchema = new mongoose.Schema({\n    name: String,\n    author: String,\n    price: Number,\n    is_hot: Boolean\n  });\n  // 文档模型对象\n  let BookModel = mongoose.model('novels', BookSchema);\n  // 批量添加文档\n  BookModel.insertMany([{\n    name: '西游记',\n    author: '吴承恩',\n    price: 19.9,\n    is_hot: true\n  }, {\n    name: '红楼梦',\n    author: '曹雪芹',\n    price: 29.9,\n    is_hot: true\n  }, {\n    name: '三国演义',\n    author: '罗贯中',\n    price: 25.9,\n    is_hot: true\n  }, {\n    name: '水浒传',\n    author: '施耐庵',\n    price: 20.9,\n    is_hot: true\n  }, {\n    name: '活着',\n    author: '余华',\n    price: 19.9,\n    is_hot: true\n  }, {\n    name: '狂飙',\n    author: '徐纪周',\n    price: 68,\n    is_hot: true\n  }, {\n    name: '大魏能臣',\n    author: '黑男爵',\n    price: 9.9,\n    is_hot: false\n  },\n  {\n    name: '知北游',\n    author: '洛水',\n    price: 59,\n    is_hot: false\n  },{\n    name: '道君',\n    author: '跃千愁',\n    price: 59,\n    is_hot: false\n  },{\n    name: '七煞碑',\n    author: '游泳的猫',\n    price: 29,\n    is_hot: false\n  },{\n    name: '独游',\n    author: '酒精过敏',\n    price: 15,\n    is_hot: false\n  },{\n    name: '大泼猴',\n    author: '甲鱼不是龟',\n    price: 26,\n    is_hot: false\n  },\n  {\n    name: '黑暗王者',\n    author: '古羲',\n    price: 39,\n    is_hot: false\n  },\n  {\n    name: '不二大道',\n    author: '文刀手予',\n    price: 89,\n    is_hot: false\n  },\n  {\n    name: '大泼猴',\n    author: '甲鱼不是龟',\n    price: 59,\n    is_hot: false\n  },\n  {\n    name: '长安的荔枝',\n    author: '马伯庸',\n    price: 45,\n    is_hot: true\n  },\n  {\n    name: '命运',\n    author: '蔡崇达',\n    price: 59.8,\n    is_hot: true\n  },\n  {\n    name: '如雪如山',\n    author: '张天翼',\n    price: 58,\n    is_hot: true\n  },\n  {\n    name: '三体',\n    author: '刘慈欣',\n    price: 23,\n    is_hot: true\n  },\n  {\n    name: '秋园',\n    author: '杨本芬',\n    price: 38,\n    is_hot: true\n  },\n  {\n    name: '百年孤独',\n    author: '范晔',\n    price: 39.5,\n    is_hot: true\n  },\n  {\n    name: '在细雨中呼喊',\n    author: '余华',\n    price: 25,\n    is_hot: true\n  }]);\n\n});\n\n```\n\n## 字段\n文档结构可选的常用**字段类型：**\n1. String 字符串\n2. Number 数字\n3. Boolean 布尔值\n4. Array 数组，也可以使用 [] 来标识\n5. Date 日期\n6. Buffer Buffer 对象\n7. Mixed 任意类型，需要使用 mongoose.Schema.Types.Mixed 指定\n8. ObjectId 文档对象 ID，用于设置外键，保存其它文档的id，需要使用 mongoose.Schema.Types.ObjectId 指定\n9. Decimal128 高精度数字，需要使用 mongoose.Schema.Types.Decimal128 指定\n\n**字段值验证：**一些内建验证器，可以对字段值进行验证，或者说进一步约束字段内容\n1. required: true 设置必填项\n2. default: 'qx' 设置默认值\n3. enum: ['男','女'] 枚举值，字段值必须在数组中\n4. unique: true 设置值唯一，需要重建集合才有效果\n\n在创建文档的结构对象时添加字段验证\n\n```js\nlet BookSchema = mongoose.Schema({\n  name: { \n      type: String,\n      required: true, // 必填项\n      unique: true, // 唯一值\n  },\n  author: {\n      type: String,\n      default: '匿名' // 默认值\n  },\n  style: {\n      type: String,\n      required: true, // 必填项\n      enum: ['科幻','言情','玄幻'] // 枚举值\n  },\n  price: {\n      type: Number,\n      required: true // 必填项\n  },\n});\n\n```\n\n## 删除文档\n`deleteOne()` 删除一条文档，`deleteMany()` 批量删除\n\n```js\n// 删除单条文档\nBookModel.deleteOne({ _id: '64428b3a01df4070e7bc2df3' })\n  .then(data => {\n      console.log(data);// { acknowledged: true, deletedCount: 1 }\n  })\n  .catch(err => {\n      console.log('删除失败');\n  })\n\n// 批量删除文档\nBookModel.deleteMany({ is_hot: false })\n  .then(data => {\n      console.log(data);// { acknowledged: true, deletedCount: 9 }\n  })\n  .catch(err => {\n      console.log('删除失败');\n  })\n\n```\n\n## 更新文档\n`updateOne()` 和 `updateMany()`\n\n```js\n// 更新单条\nBookModel.updateOne({name: '红楼梦'}, {price: 9.9})\n  .then(data=>{\n      console.log(data);\n  })\n//更新多条\nBookModel.updateMany({is_hot: true}, {is_hot: false})\n  .then(data=>{\n      console.log(data);\n      // {\n      //   acknowledged: true,\n      //   modifiedCount: 12,\n      //   upsertedId: null,\n      //   upsertedCount: 0,\n      //   matchedCount: 12\n      // }\n  })\n\n```\n\n## 查找文档\n`findOne()` 查找一条，`findById()` 通过_id找一条，`find()` 批量查找，无论找到多少条都返回数组\n\n```js\n// 读取单条\nBookModel.findOne({name: '狂飙'})\n  .then(data=>{\n      console.log(data);\n      // {\n      //   _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84f9a\"),\n      //   name: '狂飙',\n      //   author: '徐纪周',\n      //   price: 68,\n      //   is_hot: true,\n      //   __v: 0\n      // }\n  })\n// 通过_id获取\nBookModel.findById('6442a4a0f5bcc6fb8cc84fa7')\n  .then(data=>{\n      console.log(data);\n      // {\n      //   _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84fa7\"),\n      //   name: '三体',\n      //   author: '刘慈欣',\n      //   price: 23,\n      //   is_hot: true,\n      //   __v: 0\n      // }\n  })\n//读取多条，没用参数则获取全部文档\nBookModel.find({author: '余华'})\n  .then(data=>{\n      console.log(data);\n      // [\n      //   {\n      //     _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84f99\"),\n      //     name: '活着',\n      //     author: '余华',\n      //     price: 19.9,\n      //     is_hot: true,\n      //     __v: 0\n      //   },\n      //   {\n      //     _id: new ObjectId(\"6442a4a0f5bcc6fb8cc84faa\"),\n      //     name: '在细雨中呼喊',\n      //     author: '余华',\n      //     price: 25,\n      //     is_hot: true,\n      //     __v: 0\n      //   }\n      // ]\n  })\n\n```\n\n## 条件控制\nmongodb中没有条件运算符，必须使用替代符号\n1. \\> `$gt`\n2. < `$lt`\n3. \\>= `$gte`\n4. <= `$lte`\n5. !== `$ne`\n6. || `$or` 也可以用 ||\n7. && `$and` 也可以用 &&\n\n```js\n// 价格高于20\nBookModel.find({price: {$gte:20}})\n// 价格高于20且低于30\nBookModel.find({ $and: [{ price: { $gte: 20 }, price: { $lt: 30 } }] })\nBookModel.find({ price: { $gte: 20 } && { $lt: 30 } })\n// 查找甲鱼不是龟写的价格低于30的书\nBookModel.find({ $and: [{ author: '甲鱼不是龟', price: { $lt: 30 } }] })\n\n```\n\n**正则匹配：**条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询\n\n```js\n// 搜索作者名带鱼写的书\nBookModel.find({ author: /鱼/})\n```\n\n## 规则控制\n**1、字段筛选** `select()` 查找时只查找文档的某些字段，提高查找效率，1 需要，0 排除，_id默认为1\n\n```js 查找价格低于30的书，字段只包含书名、作者和价格\nBookModel.find({price: { $lt: 30 }}).select({name:1,author:1,price:1})\n  .then(data=>{\n      console.log(data);\n  })\n```\n\n**2、排序** `sort()`，按某个字段的升序（1）或降序（-1）排序\n\n```js 查找所有书，按价格升序排序，字段只包含书名、作者和价格\nBookModel.find().sort({price:1}).select({name:1,author:1,price:1})\n  .then(data=>{\n      console.log(data);\n  })\n```\n\n**3、数据截取**，`skip()` 跳过，`limit()` 限定\n\n```js 查找所有书，按价格降序排序，字段只包含书名和价格，只取前三本书\nBookModel.find().sort({price:-1}).select({name:1,price:1}).limit(3)\n.then(data=>{\n  console.log(data);\n})\n```\n\n```js 查找所有书，按价格降序排序，字段只包含书名和价格，跳过最贵的前三本书\nBookModel.find().sort({price:-1}).select({name:1,price:1}).skip(3)\n.then(data=>{\n  console.log(data);\n})\n```\n\n## 代码模块化\nmongoose的模块化：\n1. 将数据库连接部分独立，并放入一个函数中暴露出去\n2. 将数据库中不同的文档对象模型每个单独一个js文件独立到modules文件夹中，将文档对象模型暴露出去\n3. 将数据库的连接信息独立到config.js再暴露出去给db.js使用\n4. index.js导入数据库连接函数和文档对象模型，并将连接数据库成功后的操作，都放在数据库连接函数的第一个参数中，作为连接成功的回调函数\n\n```js 原来的文件\nconst mongoose = require('mongoose');\n\nmongoose.set('strictQuery', true);\n\nmongoose.connect('mongodb://127.0.0.1:27017/test');\n\nmongoose.connection.once('open', () => {\n    // 文档结构对象\n    let BookSchema = new mongoose.Schema({\n        name: String,\n        author: String,\n        price: Number,\n        is_hot: Boolean\n    });\n    // 文档模型对象\n    let BookModel = mongoose.model('novels', BookSchema);\n    // 读取单条\n    BookModel.findOne({name: '狂飙'})\n        .then(data=>{\n            console.log(data);\n        })\n    // 通过_id获取\n\n});\n\n// 设置连接错误的回调\nmongoose.connection.on('error', () => {\n    console.log('连接失败');\n});\n\n//设置连接关闭的回调\nmongoose.connection.on('close', () => {\n    console.log('连接关闭');\n});\n\n```\n\n**模块化后：**\n\n作用：当需要对数据库中一个集合操作时，只需要在models文件夹中新建该集合的文档对象模型，然后在index.js中导入，当要连接其它mongodb数据库时也只需要修改config.js\n\n```js index.js\nconst mongoose = require('mongoose');\n// 将数据库连接函数导入\nconst db = require('./db/db');\n// 导入BookModel文档对象模型\nconst BookModel = require('./models/BookModel');\n// 传入两个回调函数\ndb(() => {\n    // 连接成功则对数据库进行操作，增删改查\n    // 查找《狂飙》的信息\n    BookModel.findOne({ name: '狂飙' })\n        .then(data => {\n            console.log(data);\n        })\n});\n\n```\n\n```js config.js\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test'\n}\nmodule.exports = config;\n\n```\n\n```js ./db/db.js\n// 暴露一个函数，success数据库连接成功的回调，error连接失败的回调\nmodule.exports = function (success, error = () => { console.log('连接失败'); }) {\n\n    const mongoose = require('mongoose');\n    // 导入数据库连接配置文件\n    const {HOST,PORT,NAME} = require('../config');\n\n    mongoose.connect(`mongodb://${HOST}:${PORT}/${NAME}`);\n\n    mongoose.connection.once('open', () => {\n        success();\n    });\n    // 设置连接错误的回调\n    mongoose.connection.on('error', () => {\n        error();\n    });\n    //设置连接关闭的回调\n    mongoose.connection.on('close', () => {\n        console.log('连接关闭');\n    });\n\n}\n\n```\n\n```js ./models/BookModel.js\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet BookSchema = new mongoose.Schema({\n    name: String,\n    author: String,\n    price: Number,\n    is_hot: Boolean\n});\n// 文档模型对象\nlet BookModel = mongoose.model('novels', BookSchema);\n// 将文档模型对象暴露出去\nmodule.exports = BookModel;\n\n```\n\n# 图形化管理\n使用图形化软件更方便操控数据库 [Robo3T](https://github.com/Studio3T/robomongo) [Navicat](https://www.navicat.com.cn/)\n\n# 记账本优化\n使用 mongodb 数据库替代 lowdb 文件管理，使用 [moment](https://momentjs.com/) 处理日期类型\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/49-2.webp width=\"85%\" loading=\"lazy\">\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/49-3.gif width=\"60%\" loading=\"lazy\">\n\n**主要文件：**\n**数据库相关：**\n\n```js /db/db.js 数据库连接函数，连接成功后才能在回调函数中做后续业务\n// 暴露一个函数，success数据库连接成功的回调，error连接失败的回调\nmodule.exports = function (success, error = () => { console.log('连接失败'); }) {\n\n    const mongoose = require('mongoose');\n    // 导入数据库连接配置文件\n    const { HOST, PORT, NAME } = require('../config');\n\n    mongoose.connect(`mongodb://${HOST}:${PORT}/${NAME}`);\n\n    mongoose.connection.once('open', () => {\n        success();\n    });\n    // 设置连接错误的回调\n    mongoose.connection.on('error', () => {\n        error();\n    });\n    //设置连接关闭的回调\n    mongoose.connection.on('close', () => {\n        console.log('连接关闭');\n    });\n\n}\n\n```\n\n```js /models/AccountModel.js 账本的文档对象模型，用于约束和操控数据库集合中的文档，增删改查\nconst mongoose = require('mongoose');\n// 文档结构对象\nlet AccountSchema = new mongoose.Schema({\n    matter: {\n        type: String,\n        required: true\n    },\n    date: {\n        type: Date,\n        required: true\n    },\n    type: {\n        type: String,\n        enum: ['支出', '收入'],\n        default: '支出'\n    },\n    account: {\n        type: Number,\n        required: true\n    },\n    remark: {\n        type: String,\n        default: '无'\n    }\n});\n// 文档模型对象\nlet AccountModel = mongoose.model('accounts', AccountSchema);\n// 将文档模型对象暴露出去\nmodule.exports = AccountModel;\n\n```\n\n```js config.js 数据库连接配置\nconst config = {\n    HOST: '127.0.0.1',\n    PORT: 27017,\n    NAME: 'test'\n}\nmodule.exports = config;\n\n```\n\n**启动http服务的www文件：**导入数据库连接函数，将http服务的代码都扔进db的回调函数中，待数据库连接成功再执行回调函数运行http服务\n\n```js /bin/www\n#!/usr/bin/env node\n// 导入数据库连接函数\nconst db = require('../db/db');\n// 将http相关操作放到连接成功的回调中\ndb(()=>{\n/**\n * Module dependencies.\n */\n\nvar app = require('../app');\nvar debug = require('debug')('keepingbook:server');\nvar http = require('http');\n\n/**\n * Get port from environment and store in Express.\n */\n\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n/**\n * Create HTTP server.\n */\n\nvar server = http.createServer(app);\n\n/**\n * Listen on provided port, on all network interfaces.\n */\n\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n\n/**\n * Normalize a port into a number, string, or false.\n */\n\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n\n  return false;\n}\n\n/**\n * Event listener for HTTP server \"error\" event.\n */\n\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n\n/**\n * Event listener for HTTP server \"listening\" event.\n */\n\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\n})\n\n```\n\n**路由相关：**index.js内有增删该查的页面、接口路由，在这个文件中引入文档对象模型，就能在对应路由内对数据库文档做对应操作\n\n```js /route/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 导入moment处理日期\nconst moment = require('moment');\n\n// 导入文档模型对象\nconst AccountModel = require('../models/AccountModel');\n\n// 记账本页面路由\nrouter.get('/', function (req, res, next) {\n\n  // 读取所有数据，按日期降序\n  AccountModel.find().sort({ date: -1 })\n    .then(data => {\n      // 将数据数组传递过去遍历渲染，为了格式化日期，将moment传入\n      res.render('index', { content: data, moment });\n    })\n    .catch(err => {\n      console.log(err);\n      // 查找失败则返回500\n      res.status(500).render('tip', { msg: '查找失败!', url: '/' });\n    })\n\n});\n\n// 添加记录页面路由\nrouter.get('/add', function (req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add', function (req, res, next) {\n\n  // 插入一条数据\n  AccountModel.create({\n    // 解构赋值\n    ...req.body,\n    // 覆盖修改日期为日期对象\n    date: moment(req.body.date).toDate()\n  })\n    .then(data => {\n      console.log(data);\n      // 成功跳转到提示页\n      res.render('tip', { msg: '添加成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      // 添加失败则返回500\n      res.status(500).render('tip', { msg: '添加失败!', url: '/' });\n    });\n\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id', (req, res) => {\n  // 获取路由参数id\n  let id = req.params.id;\n  AccountModel.deleteOne({ _id: id })\n    .then(data => {\n      console.log(data);\n      // 删除成功跳转提示页\n      res.render('tip', { msg: '删除成功!', url: '/' });\n    })\n    .catch(err => {\n      console.log(err);\n      res.status(500).render('tip', { msg: '删除失败!', url: '/' });\n    })\n\n});\n\n\nmodule.exports = router;\n\n```\n\n除了index.ejs，其它页面无变化\n\n```js index.ejs渲染日期时，调用moment去格式化\n<div class=\"date\"><%= moment(item.date).format('YYYY-MM-DD') %></div>\n```\n\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"Express框架","url":"/article/8ddaf637.html","content":"\n# express框架\n[express](https://www.expressjs.com.cn/) 是一个web框架，也是npm的一个工具包，功能和http模块类似，但功能更加强大，开发服务端效率更高\n\n基本使用步骤：\n1. 导入express框架\n2. 创建服务器实例对象\n3. 绑定事件\n4. 监听端口，启动服务器\n\n```js\n//导入express\nconst express = require('express');\n// 创建对象\nconst app = express();\n//创建路由，req请求报文的封装对象，res响应报文\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome');\n})\n// 监听端口启动服务\napp.listen(3000, () => {\n    console.log('服务启动');\n});\n\n```\n\n## 路由\n**路由：**确定如何响应客户端对特定端点的请求\n\n```js 使用方法，由请求方法、路径、回调函数组成\napp.<method>(path，(req, res) => {})\n```\n\n```js\n//创建路由，req请求报文的封装对象，res响应报文\n//从上往下匹配，匹配到则不再往后匹配\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome /home');\n})\n\napp.get('/', (req, res) => {\n    res.end('Welcome /');\n});\n\napp.post('/login', (req, res) => {\n    res.end('Welcome /login');\n});\n\napp.all('/test', (req, res)=>{\n    res.end('Welcome /test');\n});\n// 匹配所有路径和方法，可以放在最后进行404响应\napp.all('*', (req, res)=>{\n    res.end('404');\n});\n\n```\n\n## 获取请求报文\n\n```js\napp.get('/', (req, res) => {\n    //express兼容原生操作\n    console.log(req.method);//请求方法\n    console.log(req.url);//请求url\n    console.log(req.httpVersion);//http版本\n    console.log(req.headers);//请求头\n    //express封装方法\n    console.log(req.path);//请求路径\n    console.log(req.query);//查询字符串\n    console.log(req.ip);//用户ip\n    console.log(req.get('host'));//获取特定请求头的属性值\n\n    res.send('Welcome /');\n});\n\n```\n\n### 路由参数\n路由参数指的是 URL 路径中的参数（数据），如多篇文章按1.html、2.html往后排，匹配路由参数从而无需写多个路由\n\n获取路由参数：`req.params.id`\n\n```js\napp.get('/:id.html',(req, res) => {\n    res.send('id为' + req.params.id);\n}); \n```\n\n路由参数练习：\n\n```json\n{\n  \"singers\": [\n    {\n      \"singer_name\": \"周杰伦\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M0000025NhlN2yWrP4.webp\",\n      \"other_name\": \"Jay Chou\",\n      \"singer_id\": 4558,\n      \"id\": 1\n    },\n    {\n      \"singer_name\": \"林俊杰\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001BLpXF2DyJe2.webp\",\n      \"other_name\": \"JJ Lin\",\n      \"singer_id\": 4286,\n      \"id\": 2\n    },\n    {\n      \"singer_name\": \"G.E.M. 邓紫棋\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001fNHEf1SFEFN.webp\",\n      \"other_name\": \"Gloria Tang\",\n      \"singer_id\": 13948,\n      \"id\": 3\n    }\n  ]\n}\n\n```\n\n```js\nconst express = require('express');\n// 创建对象\nconst app = express();\n//导入json文件\nconst {singers} = require('./JSON/singers.json');\n\napp.get('/singer/:id.html',(req, res) => {\n    let {id} = req.params;\n    let result = singers.find((item)=>{\n        if(item.id === Number(id)){\n            return true;\n        }\n    });\n    // console.log(result);\n    if(!result){\n        res.send(\"404\");\n        return;\n    }\n    res.send(`\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Document</title>\n    </head>\n    <body>\n        <h2>${result.singer_name}</h2>\n        <img src=${result.singer_pic}}></img>\n    </body>\n    </html>\n    `);\n}); \n\napp.listen(3000, () => {\n    console.log('服务启动');\n})\n\n```\n\n## 响应设置\n一般响应\n\n```js\napp.get('/', (req, res)=>{\n    // 原生响应\n    res.statusCode = 200;\n    res.statusMessage = 'OK';\n    res.setHeader('Content-Type', 'text/html;charset=UTF-8');\n    // express\n    res.status(200);\n    res.set('Content-Type', 'text/html');\n    res.send('你好');//自动添加字符集，不乱码\n    // 连贯操作\n    res.status(200).set('xxx','yyy').send('你好');\n});\n\n```\n\n其它响应，一般不能多个同时成功响应\n\n```js\napp.get('/', (req, res)=>{\n    // 302重定向\n    res.redirect('https://www.baidu.com/');\n    // 下载响应\n    res.download('../3.mp4');\n    // 响应JSON\n    res.json({\n            a:1\n        });\n    // 响应文件内容\n    res.sendFile(__dirname + '/package.json');\n});\n\n```\n\n## 中间件\n中间件（Middleware）本质是一个回调函数\n\n中间件函数可以像路由回调一样访问请求对象（request），响应对象（response）\n\n**作用：**使用函数封装公共操作，简化代码\n\n**类型：**全局中间件、路由中间件\n\n每一个请求到达服务端后都会执行全局中间件函数\n满足某个路由规则的请求会触发指定路由中间件函数\n\n```js 声明中间件函数\nfunction middleware(req,res,next){\n//实现功能代码\n//执行next函数\n//调用next()执行完中间件函数后，继续执行路由中的回调函数\nnext();\n}\n```\n\n### 全局中间件\n每一个请求到达服务端后都会执行全局中间件函数\n\napp.use是专门解析中间件函数的方法，使用之后express会将http请求响应对象交给中间件函数，中间件函数处理完通过next()方法传递给下一中间件函数，直到返回响应数据\n\n可以使用 app.use() 定义多个全局中间件\n\n案例：\n\n```js 利用中间件对所有路由记录访问路径和用户ip\n// 声明中间件\nfunction middleware1(req, res, next) {\n    let {url, ip} = req;\n    fs.appendFileSync(path.resolve(__dirname + '/1.log'), `${url} ${ip}\\r\\n`);\n    // 中间件函数处理完请求后，通过next方法将http请求对象交给下一个中间件或路由，直到返回响应\n    next();\n}\nfunction middleware2(req, res, next) {\n    let {url, ip} = req;\n    console.log(url, ip);\n    next();\n}\n// 使用app.use定义全局中间件，express将http请求对象交给中间件\napp.use(middleware1);\napp.use(middleware2);\n\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\napp.get('/admin', (req, res)=>{\n    res.send('后台');\n});\n\n```\n\n### 路由中间件\n满足某个路由规则的请求会触发指定路由中间件函数\n\n只需要对某一些路由进行功能封装，则使用路由中间件，可以设置多个中间件函数\n\n```js 格式\napp.get('/路径',`中间件函数1`,`中间件函数2`,(req,res)=>{});\n```\n\n案例：\n\n```js 访问后台和设置页的请求必须携带code为123的参数\nfunction checkCode(req, res, next){\n    if (req.query.code === '123'){\n        next();//继续执行路由回调\n    }else{\n        res.send('code参数错误');\n    }\n}\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\n// 放到需要的路由上\napp.get('/admin', checkCode, (req, res)=>{\n    res.send('后台');\n});\napp.get('/setting', checkCode, (req, res)=>{\n    res.send('设置');\n});\n\n```\n\n## 静态资源中间件\nexpress内置处理静态资源的中间件\n\n```js\napp.use(express.static('<静态资源目录>'));\n```\n\n设置后，所有静态资源都会根据静态资源目录去寻找，index.html、index.css等为默认打开的资源\n\n果静态资源与路由规则同时匹配，从上而下谁先匹配谁就响应\n\n一般用路由响应动态资源，如搜索结果等，用静态资源中间件响应静态资源，如html、css等\n\n```js\n// 设置静态资源目录，会自动添加Mime类型\napp.use(express.static('../public-test'));\n```\n\n## 获取请求体\nexpress 可以使用 [body-parser](https://www.npmjs.com/package/body-parser) 包处理请求体，该包内置许多中间件来处理请求体，需要先npm安装`npm i body-parser`\n\n包内常用中间件，当中间件解析完请求后会向 req 对象上添加 body 属性，里面包含了请求体对象\n\n```js\n// 解析 json 格式的中间件\nvar jsonParser = bodyParser.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\n```\n\n案例：\n\n```js 获取表单post提交的用户名和密码，get请求则显示登录页面\nconst bodyParser = require('body-parser');\n// 获取表单post提交的用户名和密码，get请求则显示登录页面\napp.get('/login', (req, res)=>{\n    // 响应登录页面\n    res.sendFile(__dirname + '/login.html');\n});\n// 获取 bodyParser 包中的中间件函数\n// 解析 json 格式的中间件\n// 自带的express.json()也能解析json格式\nvar jsonParser = bodyParser.json() // express.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\napp.post('/login', urlencodedParser, (req, res) => {\n    // 当urlencodedParser中间件执行完毕，会向req对象上添加一个body属性\n    console.log(req.body);//{ username: '543', password: '345' }\n    // 成功获取包含用户名和密码的对象\n    res.send('登录成功!');\n});\n```\n\n## 防盗链\n请求报文中的 referer 会携带当前访问资源的域名和端口，限制 referer 的值即可实现防盗链\n\n```js 全局中间件实现防盗链\napp.use((req, res, next) => {\n    // 获取请求头中的referer\n    let referer = req.get('referer');\n    // referer不为空再去执行\n    if (referer) {\n        // 解析referer\n        let url = new URL(referer);\n        // url.hostname 获取域名，判断是否是目标域名\n        if (url.hostname !== '127.0.0.1') {\n            res.status(404).send('404 Not Found');\n            return;\n        }\n    }\n    next();\n});\n\n```\n\n## 路由模块化Router\nRouter 是一个完整的中间件和路由系统，相当于一个小型的 app 对象。\n\n```js 声明Router和app\nconst router = express.Router();\nconst app = express();\n```\n\n```js home.js一个完整的路由\nconst express = require('express');\n\nconst router = express.Router();// 相当于一个小型的app对象\n\nrouter.get('/home', (req, res)=>{\n    res.send('首页');\n});\n\nrouter.get('/search', (req, res)=>{\n    res.send('搜索');\n});\n\n// 将路由暴露出去\nmodule.exports = router;\n\n```\n\n```js 在主文件需要导入路由并使用\nconst express = require('express');\n// 导入路由\nconst homeRouter = require('./home.js');\nconst adminRuter = require('./admin.js');\n\nconst app = express();\n// 使用路由\napp.use(homeRouter);\napp.use(adminRuter);\n\napp.all('*', (req, res) => {\n    res.send('404 Not Found');\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\napp.use可以添加一个路径参数，来给路由添加前缀\n\n```js\napp.use('/', indexRouter);\napp.use('/users', usersRouter);// 路由中的路径都会自动添加这个前缀\n```\n\n## 模板引擎ejs\n模板引擎是分离**用户界面**和**业务数据**的一种技术，在许多语言都有的一种通用技术\n\n[EJS](https://ejs.devjs.cn/) 是一个高效的 Javascript 的模板引擎，用于分离html和服务端js\n\n```js\nconst ejs = require('ejs');\n// 字符串\nlet str1 = 'qx';\nlet str2 = `${str1}chuckle`;\nconsole.log(str2);// qxchuckle\n\n// 使用ejs\nlet str = '<%= str %>chuckle';\nlet result = ejs.render(str, {str:str1});\nconsole.log(result);// qxchuckle\n\n```\n\n将 ejs 模板写在单独的文件再由fs读入\n\n```js\nlet str = fs.readFileSync('./01.html').toString();\nlet [name,age] = ['chuckle',19]\nlet result = ejs.render(str, {name,age});\nconsole.log(result);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h2><%= name %></h2>\n    <h3><%= age %></h3>\n</body>\n</html>\n\n```\n\nejs列表渲染：\n\n```js 原生js, js和html耦合在一起\nconst arr = [1,2,3,4];\nlet html = '<ul>';\narr.forEach(item=>{\n    html += `<li>${item}</li>`;\n})\nhtml += '</ul>';\nconsole.log(html);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\n```js 使用ejs, 分离html和服务端js\nconst arr = [1,2,3,4];\nlet html = `<ul>\n    <% arr.forEach(item => { %>\n        <li><%= item %></li>\n    <% }) %>\n</ul>`;\nlet result = ejs.render(html, {arr});\nconsole.log(result);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\nejs条件渲染\n\n```js\nlet isLogin = true;\nlet html = `<% if(isLogin) { %>\n    <span>登陆</span>\n<%}else{ %>\n    <span>注册</span>\n<%} %>`;\nlet result = ejs.render(html, {isLogin});\nconsole.log(result);\n// <span>登陆</span>\n\n```\n\n### express使用ejs\n使用 app.set() 设置express使用的模板引擎、设置模板文件存放位置\n\n```js\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n```\n\n然后就可以用res调用render方法响应渲染好的页面\n\n```js\n// res.render('<模板文件名>','<数据>');\nlet name = 'chuckle';\n// 在模板文件夹中创建home.ejs\nres.render('home', {name});\n```\n\n完整案例：\n\n```js\nconst express = require('express');\nconst path = require('path');\n\nconst app = express();\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n// 然后就可以用res调用render方法\napp.get('/', (req, res) => {\n    // res.render('<模板文件名>','<数据>');\n    let name = 'chuckle';\n    // 在模板文件夹中创建home.ejs\n    res.render('home', {name});\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## express-generator\nexpress-generator是一个node的自动化创建项目工具，类似于vue-cli，能快速构建express项目标准骨架\n\n安装后会暴露一个全局命令：express\n\n```js 安装\nnpm install -g express-generator\nexpress -v //查看版本和帮助\n```\n\n构建项目：\n\n```js\nexpress -e <文件夹名称>// -e参数是添加ejs支持\n```\n\n1. app.js是项目主文件；\n2. views目录用于存放页面文件；\n3. routes目录用于存放路由文件；\n4. public用于存放静态文件；\n5. bin中的www是项目的启动文件；\n\n## 文件上传\n在index.js中添加两个路由,get显示表单，post接收上传的数据\n\n```js\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  res.send('上传成功');\n});\n\n```\n\n新建 portrait.ejs 创建表单页面，对于文件上传，form表单必须添加 enctype=\"multipart/form-data\" 属性\n\n```ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h3>文件上传</h3>\n    <form action=\"/portrait\" method=\"post\" enctype=\"multipart/form-data\">\n        用户名：<input type=\"text\" name=\"username\"><br />\n        头像：<input type=\"file\" name=\"portrait\"><br />\n        <button>提交</button>\n    </form>\n</body>\n</html>\n\n```\n\n处理文件上传需要使用 [formidable](https://www.npmjs.com/package/formidable) 包，它是用于解析表单数据的 Node.js 模块，尤其是文件上传。\n\n```js 完整的index.js\nvar express = require('express');\nvar router = express.Router();\n// 导入formidable\nconst formidable = require('formidable');\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  // 创建表单对象\n  const form = formidable({ \n    multiples: true,\n    // 设置上传文件的保存目录\n    uploadDir: __dirname + '/../public/images',\n    // 保持文件后缀\n    keepExtensions: true\n  });\n  // 解析表单对象\n  form.parse(req, (err, fields, files) => {\n    if (err) {\n      next(err);\n      return;\n    }\n    // fields存放除文件上传的一般表单提交\n    console.log(fields);\n    // files保存文件上传\n    console.log(files);\n    // res.json({ fields, files });\n    // 保存上传文件的存放路径，以后将此数据保存在数据库中\n    let url = 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/' + files.portrait.newFilename;\n    res.send(url);// 给用户返回url路径\n  });\n});\n\nmodule.exports = router;\n\n```\n\n## lowdb包\n在保存一些简单数据时可以使用 [lowdb](https://www.npmjs.com/package/lowdb/v/1.0.0) 包，在json中进行增删改查数据，推荐使用1.0.0版本\n\n案例：\n\n```js\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync('db.json')\n// 获取db对象\nconst db = low(adapter)\n// 初始化数据，也可以手动自定义初始化\ndb.defaults({ posts: [], user: {} }).write()\n\n// 增删改都需要最后调用write()\n// 往posts这个数组尾中添加元素\ndb.get('posts')\n    // push从尾部插入元素\n    .push({ id: 1, title: 'lowdb is awesome'})\n    .write()\ndb.get('posts')\n    // unshift从头插入元素\n    .unshift({ id: 2, title: 'lowdb is awesome'})\n    .write()\n\n// 获取数据\nlet value = db.get('posts').value();\nconsole.log(value);\n// 获取单条数据\nlet single = db.get('posts').find({id: 1}).value();\nconsole.log(single);\n\n// 删除所有匹配的数据，返回被删除的数据\ndb.get('posts').remove({id: 1}).write();\n\n// 更新数据,先获取再修改\ndb.get('posts').find({id: 2}).assign({title: 'chuckle'}).write();\n\n```\n\n## 案例-记账本\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/49-3.gif width=\"60%\" loading=\"lazy\">\n\n主要的一些文件\n\n主要路由：\n\n```js /routes/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 使用lowdb存储数据\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync(__dirname + '/../data/db.json')\n// 获取db对象\nconst db = low(adapter)\n\n// 导入shortid为数据生成id\nconst shortid = require('shortid');\n\n// 记账本页面路由\nrouter.get('/', function(req, res, next) {\n  // 获取所有账单记录数据\n  let content = db.get('content').value();\n  // 将数据数组传递过去遍历渲染\n  res.render('index', {content});\n});\n\n// 添加记录页面路由\nrouter.get('/add', function(req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add', function(req, res, next) {\n  // 生成唯一id\n  let id = shortid.generate();\n  // 往db.josn写入数据\n  db.get('content').unshift({id:id, ...req.body}).write();\n  // 跳转到提示页\n  res.render('tip',{msg: '添加成功!', url: '/'});\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id',(req, res) => {\n  let id =  req.params.id;// 获取路由参数\n  db.get('content').remove({id}).write();\n  res.render('tip',{msg: '删除成功!', url: '/'});\n});\n\n\nmodule.exports = router;\n\n```\n\n页面ejs：\n\n```html /views/index.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>记账本</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/css/index.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>记账本</h2>\n        </div>\n        <div class=\"add\">\n          <a href=\"/add\">添加</a>\n        </div>\n        <div class=\"record-box\">\n          <% content.forEach(item=>{%>\n          <div class=\"record-item\">\n            <div class=\"date\"><%= item.date %></div>\n            <div class=\"type <%= item.type==='支出'?'expenditure':'income'%>\">\n              <%= item.type %>\n            </div>\n            <div class=\"record-body\">\n              <div class=\"record-content\">\n                <div class=\"matter\"><%= item.matter %></div>\n                <div class=\"account\"><%= item.account %> 元</div>\n              </div>\n              <a href=\"/delete/<%= item.id %>\" class=\"delete\">删除</a>\n            </div>\n          </div>\n          <%})%>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/add.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/css/add.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>添加记录</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/\">账单列表</a>\n        </div>\n        <form action=\"/add\" method=\"post\">\n          <div class=\"form-item\">\n            <label for=\"matter\">事项</label>\n            <input class=\"control\" type=\"text\" name=\"matter\" id=\"matter\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"date\">时间</label>\n            <input class=\"control\" type=\"date\" name=\"date\" id=\"date\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"type\">类型</label>\n            <select class=\"control\" name=\"type\" id=\"type\">\n              <option selected=\"\">支出</option>\n              <option>收入</option>\n            </select>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"account\">金额</label>\n            <input class=\"control\" type=\"text\" name=\"account\" id=\"account\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"remark\">备注</label>\n            <textarea class=\"control\" name=\"remark\" id=\"remark\"></textarea>\n          </div>\n          <hr />\n          <button>添加</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/tip.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/css/tip.css\" />\n  </head>\n  <body>\n    <div class=\"content\">\n      <h3><%= msg %></h3>\n      <a href=\"<%= url %>\">返回</a>\n    </div>\n  </body>\n</html>\n\n```\n\ncss：\n\n```css /public/css/index.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.add{\n    margin-top: 10px;\n    padding-left: 20px;\n}\n.add a{\n    text-decoration: none;\n}\n.record-box{\n    margin-top: 10px;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.record-item{\n    margin-bottom: 15px;\n    border: 1px solid rgb(226, 226, 226);\n    border-radius: 6px;\n    -webkit-border-radius: 6px;\n    -moz-border-radius: 6px;\n    -ms-border-radius: 6px;\n    -o-border-radius: 6px;\n    position: relative;\n}\n.record-item>.date{\n    height: 34px;\n    background: rgb(174, 209, 237);\n    padding: 6px 12px;\n    font-size: 14px;\n    line-height: 22px;\n}\n.record-body{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    padding: 10px 20px;\n    justify-content: space-between;\n    align-content: center;\n}\n.record-content{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    flex: 1;\n}\n.record-body>.delete{\n    padding-left: 10px;\n    margin-left: 10px;\n    border-left: 1px solid rgb(201, 201, 201);\n    color: rgb(33, 70, 181);\n}\n.record-item>.type{\n    position: absolute;\n    top: 5px;\n    right: 10px;\n    font-size: 14px;\n    padding: 0 6px;\n    height: 22px;\n    line-height: 22px;\n    color: #fff;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n.type.expenditure{\n    background: rgb(241, 141, 158);\n}\n.type.income{\n    background: rgb(85, 194, 134);\n}\n\n```\n\n```css /public/css/add.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\nhr{\n    margin: 20px auto;\n    border: 0;\n    border-top: 1px solid rgb(220, 220, 220);\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.home{\n    margin-top: 10px;\n    padding-left: 10px;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.content-box form{\n    margin-top: 10px;\n}\n.form-item{\n    margin-bottom: 15px;\n}\n.form-item label{\n    display: block;\n    height: 32px;\n    line-height: 32px;\n    font-size: 18px;\n}\n.form-item>*{\n    width: 100%;\n}\n.form-item>.control{\n    padding: 6px 12px;\n    height: 36px;\n    font-size: 16px;\n    line-height: 36px;\n    color: #363636;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n    outline: none;\n    font-family:\"Microsoft YaHei\",微软雅黑;\n}\n.form-item>.control:focus{\n    border-color: #66afe9;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n}\n.form-item>textarea.control{\n    padding: 8px 12px;\n    height: 100px;\n    line-height: 1;\n    resize: none;\n}\n.content-box form>button{\n    width: 100%;\n    padding: 6px 12px;\n    margin-bottom: 15px;\n    border: 1px solid rgb(57, 162, 204);\n    background: rgb(37, 173, 204);\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    font-size: 17px;\n    color: #fff;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.content-box form>button:hover{\n    background: rgb(32, 153, 190);\n}\n\n```\n\n```css /public/css/tip.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    margin: 0 auto;\n    max-width: 300px;\n    padding: 20px 30px;\n    background: rgba(77, 190, 215, 0.6);\n    margin-top: 20px;\n    display: flex;\n    align-items: center;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n\n```","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"初识NodeJS","url":"/article/109cbe0a.html","content":"\n# 初识\nNodeJS是使用C++编写的基于ChromeV8引擎，开源、跨平台的JavaScript运行环境\n\n[中文API文档](https://nodejs.cn/api/)\n\n# Buffer\nBuffer(缓冲区)存放二进制数据的缓存区，类似数组Array\n\n```js\nlet buf = Buffer.alloc(10);//每个二进制位都清0\nlet buf_2 = Buffer.allocUnsafe(10);//不清0，可能有旧数据，但速度较快\n```\n\n字符串转二进制编码，每个字符按编码转为二进制存入\n\n```js\nlet buf_3 = Buffer.from('hello');\nconsole.log(buf_3);\n// <Buffer 68 65 6c 6c 6f>\n```\n\n将数组存入Buffer\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4);\n// <Buffer 6f 70 71 72>\n```\n\n`toString()`Buffer转字符串\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4.toString());// 默认采用UTF-8\n// opqr\n```\n\n使用下标访问Buffer\n\n```js\nlet buf_5 = Buffer.from('chuckle');\nconsole.log(buf_5[0]);//十六进制，99\nconsole.log(buf_5[0].toString(2));//转为二进制，1100011\nbuf_5[0] = 90;// 修改\nconsole.log(buf_5[0]);//十六进制，90\n```\n\n溢出，舍弃高位\n\n```js\nbuf_5[0] = 360;// 101101000\nconsole.log(buf_5[0]);//十六进制，104\nconsole.log(buf_5[0].toString(2));//1 0110 1000 => 110 1000\n```\n\nBuffer存中文，UTF-8中一汉字占三个字节\n\n```js\nlet buf_6 = Buffer.from('今天你好');\nbuf_6.write('轻笑');// 覆盖前两个\nconsole.log(buf_6);//<Buffer e8 bd bb e7 ac 91 e4 bd a0 e5 a5 bd>\nconsole.log(buf_6.toString());//轻笑你好\n```\n\n# fs模块\n文件系统（fs 模块）中的方法均有异步和同步版本，异步有回调函数，参数为err错误信息\n\n创建 text.txt 并写入内容\n\n```js\nconst fs = require('fs');\n//异步\nfs.writeFile('./text.txt', '轻笑chuckle', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n//同步\nfs.writeFileSync('./text.txt', '轻笑chuckle');\n\n```\n\n`appendFile` 追加写入\n\n```js\nfs.appendFile('./text.txt', '\\r\\n追加内容', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n// writeFile添加配置项实现追加写入\nfs.writeFile('./text.txt', '\\r\\n追加内容',{flag: 'a'} , err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n\n```\n\n`createWriteStream` 流式写入，适合频繁或大文件写入，与文件的连接不断开\n\n```js\nconst ws = fs.createWriteStream('.text.txt');\nws.write('1');\nws.write('2');\nws.write('3');\nws.close();// 断开连接，会自动断开，close可加可不加\n```\n\n`readFile` 文件读取\n\n```js\n// 回调函数两个参数，错误信息和文件内容\nfs.readFile('./text.txt', (err, data)=>{\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log(data.toString());\n});\n// 同步读取，直接返回文件内容\nlet data = fs.readFileSync('./text.txt');\nconsole.log(data.toString());\n\n```\n\n`createReadStream` 流式读取\n\n```js\nconst rs = fs.createReadStream('./1.mp4');\nrs.on('data', chunk =>{\n    console.log(chunk);// Buffer\n    console.log(chunk.length);// 每次读取64kb\n});\nrs.on('end', ()=>{\n    console.log('读取完成');\n});\n\n```\n\n复制文件，使用流式操作更快，占用内存更少\n\n```js\n// readFile\nfs.readFile('./text.txt', (err, data) =>{\n    if(err){\n        return console.error(err);\n    }\n    fs.writeFile('./text2.txt', data, err =>{});\n});\n// 流式操作\nconst rs = fs.createReadStream('./1.mp4');\nconst ws = fs.createWriteStream('./2.mp4');\nrs.on('data', chunk =>{\n    ws.write(chunk);\n});\n// 流式操作pipe\nrs.pipe(ws);\n\n```\n\n`rename` 文件重命名和移动\n\n```js\nfs.rename('./1.mp4', './3.mp4', err=>{});\nfs.rename('./3.mp4', './mp4/3.mp4', err=>{});\n```\n\n`unlink` 删除文件\n\n```js\nfs.unlink('./2.mp4', err=>{});\nfs.rm('./2.mp4', err=>{});\n```\n\n`mkdir` 创建文件夹\n\n```js\nfs.mkdir('./a', err=>{});\n// 递归创建\nfs.mkdir('./a/b/c', {recursive: true},err=>{});\n```\n\n`readdir` 读取文件夹，读取到一个目标文件夹下文件名的数组\n\n```js\nfs.readdir('./mp4', (err, data)=>{\n    console.log(data);// [ '3.mp4' ]\n});\n```\n\n`rmdir` 删除文件夹\n\n```js\nfs.rmdir('./a/b/c', err=>{});\n// 递归删除，文件夹非空时使用\nfs.rmdir('./a', {recursive: true},err=>{});\n// 或使用rm\nfs.rm('./a',{recursive: true} ,err=>{});\n```\n\n`stat` 查看资源状态\n\n```js\nfs.stat('./3.mp4', (err, data)=>{\n    console.log(data);// 输出信息\n    console.log(data.isDirectory());//是否是文件夹\n    console.log(data.isFile());//是否是普通文件\n});\n```\n\n**__dirname** 保存js文件所在目录的绝对路径，避免工作路径不同、工作区不同，导致相对路径不同而出bug\n\n```js\nfs.writeFileSync(__dirname + '/1.txt', 'chuckle');\n```\n\n批量重命名文件，在文件名前加上0\n\n```js\nfs.readdir(__dirname + '/rename', (err, data)=>{\n    data.forEach((item, index)=>{\n        let data = item.split('.');\n        let [num, suffix] = data;\n        if(Number(num)<10){\n            num = '0' + num;\n        }\n        fs.renameSync(`${__dirname}/rename/${item}`, `${__dirname}/rename/${num}.${suffix}`);\n    });\n});\n\n```\n\n# path模块\n`resolve` 拼接规范的绝对路径\n\n```js\nconst path = require('path');\nlet path1 = path.resolve(__dirname + '/rename');\nconsole.log(path1);// c:\\chuckle\\qx\\nodejs\\rename\n```\n\n其它方法\n\n```js\nconsole.log(path.sep);// 获取当前系统的路径分隔符\n// /\nconsole.log(path.parse(__filename));// 解析路径并返回对象\n// {\n//   root: 'c:\\\\',\n//   dir: 'c:\\\\chuckle\\\\qx\\\\nodejs',\n//   base: 'fs.js',\n//   ext: '.js',\n//   name: 'fs'\n// }\nconsole.log(path.basename(__filename));// 获取路径的基础名称\n// fs.js\nconsole.log(path.dirname(__filename));// 获取路径的目录名\n// c:\\chuckle\\qx\\nodejs\nconsole.log(path.extname(__filename));// 获取文件的扩展名\n// .js\n\n```\n\n# http模块\n搭建http服务：\n\n```js\n// 导入 http 模块\nconst http = require('http');\n// 创建服务对象\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');// 设置字符集防止乱码\n    response.end('你好');// 响应文本\n});\n\n// 监听端口，启动服务\nserver.listen(9000, ()=>{\n    // 当服务启动时运行回调函数\n    console.log('服务启动');\n});\n\n```\n\n## 获取请求报文\n\n获取请求行和请求头，修改createServe的回调函数\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    // 获取请求方法\n    console.log(request.method);\n    // 获取请求url，只包含路径和查询字符串\n    console.log(request.url);\n    // 获取http协议版本号\n    console.log(request.httpVersion);\n    // 获取http的请求头\n    console.log(request.headers);\n    // 获取请求头中单独的属性值\n    console.log(request.headers.host);\n    response.end('hello world');\n});\n\n```\n\n获取请求体\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    //获取请求体\n    let body = '';\n    // request也是一个可读流，绑定data事件一点点获取内容\n    request.on('data', chunk=>{\n        body += chunk;\n    })\n    // 绑定end事件\n    request.on('end', ()=>{\n        console.log(body);\n        // 响应\n        response.end('hello http');\n    });\n});\n\n```\n\n## 获取请求路径和查询字符串\n使用**url模块**获取请求路径和查询字符串\n\n```js\nconst url = require('url');// 导入url模块\nconst server = http.createServer((request, response)=>{\n    // 获取请求路径和查询字符串\n    console.log(request.url);\n    // 使用url模块解析url\n    let res = url.parse(request.url, true);// 第二个参数true将query属性值变为一个对象\n    console.log(res);\n    // Url {\n    //   protocol: null,\n    //   slashes: null,\n    //   auth: null,\n    //   host: null,\n    //   port: null,\n    //   hostname: null,\n    //   hash: null,\n    //   search: '?psw=1234&name=chuckle',\n    //   query: [Object: null prototype] { psw: '1234', name: 'chuckle' },\n    //   pathname: '/search',\n    //   path: '/search?psw=1234&name=chuckle',\n    //   href: '/search?psw=1234&name=chuckle'\n    // }\n    console.log(res.path);// 获取路径\n    console.log(res.query);// 获取查询字符串对象\n    console.log(res.query.psw);// 获取查询字符串中的属性值\n});\n\n```\n\n使用**URL类**获取请求路径和查询字符串\n\n```js\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    console.log(url);\n    // URL {\n    //   href: 'http://127.0.0.1:9000/search?psw=1234&name=chuckle',\n    //   origin: 'http://127.0.0.1:9000',\n    //   protocol: 'http:',\n    //   username: '',\n    //   password: '',\n    //   host: '127.0.0.1:9000',\n    //   hostname: '127.0.0.1',\n    //   port: '9000',\n    //   pathname: '/search',\n    //   search: '?psw=1234&name=chuckle',\n    //   searchParams: URLSearchParams { 'psw' => '1234', 'name' => 'chuckle' },\n    //   hash: ''\n    // }\n    console.log(url.pathname);// 获取路径\n    console.log(url.searchParams);// 获取查询字符串map对象\n    console.log(url.searchParams.get('psw'));// map对象用get获取属性值\n});\n\n```\n\n## 请求路径练习\n根据请求路径响应不同内容\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    // 获取请求方法\n    let {method} = request;\n    // 获取请求路径\n    let {pathname} = url;\n    // 根据请求路径响应不同内容\n    if (method === 'GET' && pathname === '/login'){\n        response.end('login');\n    }else if (method === 'GET' && pathname === '/reg'){\n        response.end('reg');\n    }else{\n        response.end('Not Found');\n    }\n});\nserver.listen(9000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## 设置响应报文\n设置响应码、响应头、响应体\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    // 1.设置响应状态码\n    response.statusCode = 200;\n    // 2.设置响应状态的描述\n    response.statusMessage = 'chuckle';\n    // 3.响应头，两个参数，响应名和值，可自定义\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    response.setHeader('Server', 'nodejs');\n    response.setHeader('MyHeader', 'chuckle');\n    // 设置多个同名响应头\n    response.setHeader('test', ['a', 'b', 'c']);\n    // 4. 设置响应体，end只能执行一个，write可以有多个\n    response.write('chuckle');\n    response.write('qx');\n    // end是必须的，但设置write后一般end设为空\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n配合fs模块响应文件\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    response.write(html);\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 响应文件练习\n根据文件路径响应不同内容，下面这种写法不方便，后面有优化\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    let css = fs.readFileSync(__dirname + '/2.css');\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    let {pathname} = url;\n    if(pathname === '/'){\n        response.write(html);\n    }else if(pathname === '/2.css'){\n        response.write(css);\n    }else {\n        response.statusCode = 404;\n        response.write('404');\n    }\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n优化版：静态资源响应服务\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 设置资源mime类型\nmime类型用于表示文档、文件或字节流的性质和类型\n\nHTTP服务可以设置响应头 Content-Type 来表明响应体的mime类型，浏览器会根据该类型决定如何处理资源\n\n常见mime类型：\n**1、html** text/html\n**2、css** text/css\n**3、js** text/javascript\n**4、png** image/png\n**5、jpg** image/jpeg\n**6、gif** image/gif\n**7、mp4** video/mp4\n**8、mp3** audio/mpeg\n**9、json** application/json\n\n对于未知的资源类型，可以选择 application/octet-stream 刘览器在遇到该类型的响应时，会对响应体内容进行独立存储，实现下载效果\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        console.log(type);\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 完善错误处理\n[Node.js常见系统错误](https://nodejs.cn/api/errors.html#common-system-errors)\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\nlet errs = {\n    ENOENT: 404,\n    EPERM: 403\n}\n\nconst server = http.createServer((request, response)=>{\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    // 请求方法错误\n    console.log(request.method);\n    if(request.method !== 'GET'){\n       response.statusCode = 405;\n       response.end('出错了');\n       return;\n    }\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            let errCode = errs[err.code] ? errs[err.code] : 500;\n            console.log(errCode);\n            response.statusCode = errCode;\n            response.write('出错了');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 模块化\n将一个复杂的程序文件，按一定规则拆分为多个文件，即模块化，每个小文件就算一个模块\n\n模块内部数据是私有的，但可以主动度外暴露出去\n\n**模块化项目：**\n编写项目时一个个模块编写，再组合起来\n\n**模块化优点：**\n1、防止命名冲突\n2、高服用性\n3、高维护性\n\n# 暴露数据\n在模块中使用`module.exports`和`exports`向外暴露数据，但两者不能同时使用\n\n隐式关系：exports = module.exports = {}\n\n```js\nlet name = 'chuckle';\nlet age = 19;\nfunction fun() {\n    console.log(name);\n}\nmodule.exports = {\n    name,\n    fun\n}\nexports.age = age;\n\n```\n\n# 导入模块\n1. 导入js/sjon文件或c编写的mode扩展插件可以省略后缀，同名优先导入js\n2. 导入自己的模块最好使用相对路径 **./**\n3. 导入其它类型的文件会以js文件处理\n4. 导入**文件夹**，首先会去找文件夹内package.json里main属性对应的文件，如果没用main属性或package.json则去找文件夹内的index.js或index.json，如果还没找到则报错，main属性对应的文件不存在也会报错\n5. 导入nodejs内置模块时，直接写模块名即可\n\n```js\nconst mod = require('./1.js');\nconst mod = require('./1');\n```\n\n# 包管理工具\n包，即package，是一组特定功能的源码集合，即别人写好的各种工具\n\n管理包，即对包进行下载、安装、删除、上传操作\n\n常见包管理工具：npm、yarn、cnpm\n\n## npm\nNode Package Manager即npm，是nodejs内置的包管理工具\n\npackage.json 是包必须有的配置文件\npackage-lock.json 存放依赖包的版本信息\n\nrequire导入npm包流程：\n1、在当前文件夹下的node_modules中找同名文件夹\n2、在上级目录中node_modules中找同名文件夹，直到磁盘根目录\n\n```js\nnpm i <包名@版本号>// 安装\nnpm r <包名>// 移除\n```\n\nnpm配置命令别名，修改package.json的 **scripts** 属性，通过npm run <命令名>运行命令，会自动向上寻找，添加start属性，可以省略run，直接npm start\n\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"server\": \"node ./index.js\",\n    \"start\": \"node ./index.js\"\n},\n// 使用\nnpm run server\nnpm start\n\n```\n\n通过指定源来提高包安装速度\n\n```js\nnpm i <包名> --registry=https://registry.npmmirror.com\n```\n\n## 开发和生产依赖\n开发环境：写源代码、工程文件时的环境，一般指程序员的电脑，只能由程序员访问\n生产环境：项目代码正式运行的环境，一般指服务器，所有用户都能访问\n\n开发依赖：只在写代码时用到的依赖包，安装时添加 -D 或 --save-dev\n生产依赖：默认项，既在写代码时使用，又在代码运行时使用的依赖包，安装时添加 -S 或 --save 参数，\n\npackage.json中，dependencies属性保存生产依赖包信息，devDependencies属性保存开发依赖包信息\n\n## 全局安装\n开发和生产依赖都是局部安装的包，存放在工作目录的node_modules文件夹中\n \n全局安装 npm i -g 不受工作目录位置限制，无需导入，一般是在命令行中通过独立命令去使用\n\nnpm root -g 查看全局安装包的位置\n\n只有全局类的工具如 gulp、nodemon等才适合全局安装，通过查看包的文档来确定安装方式\n\n## cnpm\n[cnpm--npmmirror镜像站](https://npmmirror.com/)\n使用方式和npm一样，是淘宝构建的完整 npmjs.org 镜像，了解即可，大多还是使用npm\n\n修改npm的源地址来使用淘宝镜像\n\n```js\n// 查看npm的源\nnpm config list\n// 不推荐，该源无法上传包\nnpm config set registry https://registry.npmmirror.com/\n// 安装时临时指定源\nnpm i <包名> --registry=https://registry.npmmirror.com\n// 使用nrm管理源，推荐\nnpm i -g nrm\nnrm use taobao\nnrm ls// 列出可切换的所有源\nnpm install -g nrm open@8.4.2 --save// 使用nrm有报错则运行此命令\n\n```\n\n## yarn\n[yarn](https://yarnpkg.com/) 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具\n\nyarn和npm需要按需选用，包管理工具不能混用，yarn的锁文件是yarn.lock\n\n`npm i -g yarn`安装yarn\n\n常用命令：\n1. 初始化 yarn init / yarn init -y\n2. 安装包\n    1. yarn add <包名> 生产依赖\n    2. yarn add <包名> --dev 开发依赖\n    3. yarn global add <包名> 全局安装，第一次使用记得手动配置环境变量\n3. 删除包\n   1. yarn remove uniq 删除项目依赖包\n   2. yarn global remove nodemon 全局删除包\n4. 安装项目依赖 yarn\n5. 运行命令别名 yarn <别名>\n6. 全局安装包的位置 yarn global bin\n\n## 管理npm包\n\n1. 修改 package.json 中的版本号\n2. npm publish 提交包\n3. npm unpublish --force 删除包\n\n# nvm管理node版本\nnvm 全称 Node Version Manager 用来管理 node 版本的工具\n\n常用命令：\n1. nvm list available 显示所有可以下载的 Node.js 版本\n2. nvm list 显示已安装的版本\n3. nvm install 18.12.1 安装 18.12.1 版本的 Node.js\n4. nvm install latest 安装最新版的 Node.js\n5. nvm uninstall 18.12.1 删除某个版本的 Node.js\n6. nvm use 18.12.1 切换 18.12.1 的 Node.js\n\n设置下载node的镜像\n\n```bash\nexport NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/\n```\n\n","tags":["前端","NodeJS"],"categories":["学习笔记"]},{"title":"文章摘要、相关推荐生成AI","url":"/article/17d3383a.html","content":"\n# 前言\n[@Heo](https://blog.zhheo.com/)又整了新活，给文章加上了AI，我也开写，竞速。\n\n**项目地址**[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n\n大半夜领先一点就睡不着的屑Heo\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/46-2.webp width=\"60%\">\n\n**有这些特性：**\n1. **真AI！**，接入tianliGPT，JS动态获取全文所有纯文本，传给api实时获取文章摘要（受限于tianliGPT的成本，目前仍有缓存机制）\n2. 基于tianliGPT标注关键词、Python分析相关度的相关文章AI推荐\n3. 遇到标点符号慢下来，动态打字速度\n4. 使用requestAnimationFrame优化性能，动态清除setTimeout、打断fetch请求，交互放心\n5. 使用IntersectionObserver监听，当容器在视口不可见后停止生成摘要，重新出现在视口后继续生成\n6. 模拟GPT的光标效果\n7. 多个按钮实现多个功能，自我介绍、文章摘要、推荐相关文章等\n8. 良好兼容性，性能消耗小。\n9. 适配pjax\n10. 简单引入js后，即可生成QX-AI并自动挂载初始化\n11. 配置项多样，高度自定义\n12. 支持切换摘要、摘要语音朗读\n  \n**未来的计划：**\n1. 目前数据库文章量已经够多，计划构建一个博文社区\n\n# 5.0积累更新\n**待 5.* 版本稳定后发布 6.0 版本**\n\n**项目地址**[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n\n**更多详情请看项目仓库README**\n\n**新特性：**\n1. 优化文章内容的获取\n2. 新增适配pjax的配置项\n3. 自定义css配置项\n4. 添加svg图标\n5. 新增文章截取相关配置项\n6. 更新CSS，优化UI样式\n7. 新增注入额外CSS配置项\n8. 新增切换简介功能及相关配置\n9. 新增摘要语音朗读功能\n10. 新增UI文字自定义配置\n11. 新增页面排除配置项\n12. 标识访客唯一ID\n13. 新增直接显示摘要的配置项\n14. 优化JS的业务逻辑，精简代码\n15. 新增自动挂载：自动获取文章内容所在容器元素，而无需el配置项\n16. 新增白名单：只让指定页面显示摘要AI\n17. js动态插入css，无需额外引入\n18. 新增控制打字机效果的配置项，包括：是否启用打字机效果、打字速度\n19. 新增矩阵穿梭功能及按钮，矩阵穿梭：随机前往一个部署了AI摘要的网站\n20. 新增是否启用矩阵穿梭功能的配置项，默认开启\n\n# 4.0重磅更新\n**新特性：**\n1. 新增相关文章AI推荐\n2. 引入缓存机制，减轻后端压力\n3. 优化代码及性能\n\n## 快速上手\n项目地址[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n\n非常简单，引入下面这些代码到你的网站内，并修改配置项后即可\n\nTIP: 为避免CDN和浏览器缓存的影响，建议指定资源版本号使用\n\n```html\n<!-- css -->\n<link rel=\"stylesheet\" href=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.css\">\n<!-- chuckle-post-ai.js现在可以在网页结构的任何位置插入，只要你能够 -->\n<script src=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.js\"></script>\n<!-- 但要确保的是，AI构造代码一定要在chuckle-post-ai.js之后插入 -->\n<script data-pjax defer>\n  // AI构造函数\n  new ChucklePostAI({\n    /* 必须配置 */\n    // 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n    el: '#post>#article-container',\n    // 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n    key:'123456',\n    /* 非必须配置 */\n    // 文章标题所在的元素属性的选择器，默认获取当前网页的标题\n    title_el: '.post-title',\n    // 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all\n    rec_method: 'web',\n    // 获取文章内容时，需要排除的元素及其子元素，默认如下\n    exclude: ['highlight', 'Copyright-Notice', 'post-ai', 'post-series', 'mini-sandbox']\n  })\n</script>\n```\n\n**AI构造函数 `ChucklePostAI({ /* 传入配置对象 */ })` 详解**\n1. `el` 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n2. `key` 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n3. `title_el` 文章标题所在的元素属性的选择器，默认获取当前网页的标题\n4. `rec_method` 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all\n5. `exclude` 获取文章内容时，需要排除的元素及其子元素\n\ntianliGPT的key请到[爱发电](https://afdian.net/item/f18c2e08db4411eda2f25254001e7c00)中购买，10元5万字符（常有优惠）。请求过的内容再次请求不会消耗key，可以无限期使用。\n\n更多详情请看项目仓库README\n\n# 3.0全新版本\n**新特性：**\n1. 简单引入js后，即可生成QX-AI并自动挂载初始化\n2. 新增项目地址[Post-Summary-AI](https://github.com/qxchuckle/Post-Summary-AI)\n3. 优化代码逻辑，引入外部配置\n\n## 快速上手\n非常简单，引入下面这些代码到你的网站内即可，其中JS的引入的位置应该在文章内容之后\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.css\">\n<script data-pjax defer=\"true\">\n  var ai_option = {\n    el: '#post #article-container',\n    key:'123456'\n  }\n</script>\n<script src=\"https://cdn1.tianli0.top/gh/qxchuckle/Post-Summary-AI/chuckle-post-ai.js\" data-pjax defer=\"true\"></script>\n```\n\n**ai_option配置详解：**\n1. **el** 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面\n2. **key** 驱动AI所必须的key，即是tianliGPT后端服务所必须的key\n\n更多详情请看项目仓库README\n\n# 2.0之前旧版配置\n**注意：**\n1、为确保 recommendList() 函数正常运行、相关推荐能正常生成，btf主题用户请打开文章页侧边栏中的两个板块：最新文章和相关推荐，非btf用户也许需要手动更改相关js\n2、tianliGPT中国大陆访问速度快，key与域名相绑定，无需担心盗刷，一次生成后续不消耗key字数，tianliGPT的key购买渠道：[购买tianliGPT-Key](https://afdian.net/item/2e07e870dad911edacb852540025c377)\n3、如有bug，请在评论区讨论，请忽略js中的不规范命名和一堆变量，会优化的咕咕咕。\n\n手动修改js中这部分常量以使用AI实时简介\n\n```js\n//默认true，使用tianliGPT，false使用官方api，记得配置Key\nconst choiceApi = true;\nconst apiKey = \"填入chatGPT的apiKey\";\n//tianliGPT的参数\nconst tlReferer = 'https://你的授权域名/';\nconst tlKey = '填入tianliGPT的key';\n```\n\n虽然以及有AI实时生成了，但还是需要预设的，在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介或提升去点AI生成按钮，不想出现AI模块的文章就删去这个配置项\n\n```markdown\n---\ntitle:\nai: 暂无预设简介，请点击下方生成AI简介按钮。\n---\n```\n\n## 2.0版\n**新特性：**\n1. 真！AI，接入tianliGPT或是使用官方api接口，随意选择\n2. 前端限制请求频率、动态打断fetch\n3. 压缩文本降低key压力，纯文本1000字以上的文章，截取前500后200中间300字生成摘要，降低key字数消耗，当然，可以给 getTextContent 传入第二个参数为false，从而不压缩文本\n\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/post-ai.js\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n4-16修复了若干bug\n\n```js\nfunction allAI() {\n  let animationRunning = true; // 标志变量，控制动画函数的运行\n  let explanation = document.querySelector('.ai-explanation');\n  let abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n  let post_ai = document.querySelector('.post-ai');\n  let ai_btn_item = document.querySelectorAll('.ai-btn-item');\n  let ai_str = '';\n  let ai_str_length = '';\n  let delay_init = 600;\n  let i = 0;\n  let j = 0;\n  let sto = [];\n  let elapsed = 0;\n  let completeGenerate = false;\n  let controller = new AbortController();//控制fetch\n  let signal = controller.signal;\n  //默认true，使用tianliGPT，false使用官方api，记得配置Key\n  const choiceApi = true;\n  const apiKey = \"填入chatGPT的apiKey\";\n  //tianliGPT的参数\n  const tlReferer = 'https://你的授权域名/';\n  const tlKey = '填入tianliGPT的key';\n  //-----------------------------------------------\n  const animate = (timestamp) => {\n    if (!animationRunning) {\n      return; // 动画函数停止运行\n    }\n    if (!animate.start) animate.start = timestamp;\n    elapsed = timestamp - animate.start;\n    if (elapsed >= 20) {\n      animate.start = timestamp;\n      if (i < ai_str_length - 1) {\n        let char = ai_str.charAt(i + 1);\n        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n        if (explanation.firstElementChild) {\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        explanation.innerHTML += char;\n        let div = document.createElement('div');\n        div.className = \"ai-cursor\";\n        explanation.appendChild(div);\n        i++;\n        if (delay === 150) {\n          document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n        }\n        if (i === ai_str_length - 1) {\n          observer.disconnect();// 暂停监听\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        sto[0] = setTimeout(() => {\n          requestAnimationFrame(animate);\n        }, delay);\n      }\n    } else {\n      requestAnimationFrame(animate);\n    }\n  };\n  const observer = new IntersectionObserver((entries) => {\n    let isVisible = entries[0].isIntersecting;\n    animationRunning = isVisible; // 标志变量更新\n    if (animationRunning) {\n      delay_init = i === 0 ? 200 : 20;\n      sto[1] = setTimeout(() => {\n        if (j) {\n          i = 0;\n          j = 0;\n        }\n        if (i === 0) {\n          explanation.innerHTML = ai_str.charAt(0);\n        }\n        requestAnimationFrame(animate);\n      }, delay_init);\n    }\n  }, { threshold: 0 });\n  function clearSTO() {\n    if (sto.length) {\n      sto.forEach((item) => {\n        if (item) {\n          clearTimeout(item);\n        }\n      });\n    }\n  }\n  function resetAI(df = true) {\n    i = 0;//重置计数器\n    j = 1;\n    clearSTO();\n    animationRunning = false;\n    elapsed = 0;\n    if (df) {\n      explanation.innerHTML = '生成中. . .';\n    } else {\n      explanation.innerHTML = '请等待. . .';\n    }\n    // console.log(completeGenerate);\n    if (!completeGenerate) {\n      controller.abort();\n      // console.log(completeGenerate);\n    }\n    ai_str = '';\n    ai_str_length = '';\n    observer.disconnect();// 暂停上一次监听\n  }\n  function startAI(str, df = true) {\n    resetAI(df);\n    ai_str = str;\n    ai_str_length = ai_str.length;\n    observer.observe(post_ai);//启动新监听\n  }\n  function aiIntroduce() {\n    startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n  }\n  function aiAbstract() {\n    startAI(abstract_value);\n  }\n  function aiRecommend() {\n    resetAI();\n    sto[2] = setTimeout(() => {\n      explanation.innerHTML = recommendList();\n    }, 300);\n  }\n  function aiGoHome() {\n    startAI('正在前往博客主页...', false);\n    sto[2] = setTimeout(() => {\n      pjax.loadUrl(\"/\");\n    }, 1000);\n  }\n  async function aiGenerateAbstract() {\n    // if(!verifyDomainName()){btf.snackbarShow('未经授权的域名');return;}\n    // if(!completeGenerate){\n    //   btf.snackbarShow('AI摘要正在生成，请勿重复发起');\n    //   return;\n    // }\n    if (clickFrequency()) {\n      return;\n    }\n    localStorage.setItem('aiTime', Date.now());\n    resetAI();\n    const ele = document.querySelector('#article-container');\n    const content = getTextContent(ele);\n    console.log(content);\n    const response = await getGptResponse(content, choiceApi);//true使用tianliGPT，false使用官方api\n    console.log(response);\n    startAI(response);\n  }\n  function recommendList() {\n    let info = `推荐文章：<br />`;\n    let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n    if (!thumbnail||thumbnail.length===0) {\n      info = '很抱歉，无法找到类似的文章，你也可以看看本站最近更新的文章：<br />';\n      thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n    }\n    info += '<div class=\"ai-recommend\">';\n    thumbnail.forEach((item, index) => {\n      info += `<div class=\"ai-recommend-item\"><span>推荐${index + 1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n    });\n    info += '</div>'\n    return info;\n  }\n  //ai首屏初始化，绑定按钮注册事件\n  function ai_init() {\n    explanation = document.querySelector('.ai-explanation');\n    abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n    post_ai = document.querySelector('.post-ai');\n    ai_btn_item = document.querySelectorAll('.ai-btn-item');\n    const funArr = [aiIntroduce, aiAbstract, aiRecommend, aiGenerateAbstract];\n    ai_btn_item.forEach((item, index) => {\n      item.addEventListener('click', () => {\n        funArr[index]();\n      });\n    });\n    aiIntroduce();\n  }\n  function clickFrequency(t = 3000) {\n    let time = Date.now() - localStorage.getItem('aiTime');\n    if (time < t) {\n      btf.snackbarShow(`${3 - parseInt(time / 1000)}后才能再次点击真AI简介`);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  // 真AI简介相关函数\n\n  // function verifyDomainName(){\n  //   const domain = window.location.hostname;\n  //   const authorized = ['www.qcqx.cn','www.chuckle.top','127.0.0.1'];\n  //   return authorized.includes(domain)\n  // }\n  //获取某个元素内的所有纯文本，并按顺序拼接返回\n  function getText(element) {\n    //需要排除的元素及其子元素\n    const excludeClasses = ['highlight', 'Copyright-Notice', 'post-ai', 'post-series', 'mini-sandbox',];\n    let textContent = '';\n    for (let node of element.childNodes) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        //如果是纯文本节点则获取内容拼接\n        textContent += node.textContent.trim();\n      } else if (node.nodeType === Node.ELEMENT_NODE) {\n        let hasExcludeClass = false;//跟踪元素是否包含需要排除的类名\n        //遍历类名\n        for (let className of node.classList) {\n          //如果包含则hasExcludeClass设为true，且break跳出循环\n          if (excludeClasses.includes(className)) {\n            hasExcludeClass = true;\n            break;\n          }\n        }\n        //如果hasExcludeClass为false，即该标签不包含需要排除的类，可以继续向下遍历子元素\n        if (!hasExcludeClass) {\n          //不同元素内获取的文本用句号隔开\n          let innerTextContent = getText(node);\n          // if (textContent && innerTextContent) {\n          //   //如果本来有标点符号则不添加\n          //   if (/[：:,.，。?？/；;!！（）、)(]$/.test(textContent) || /^[：:,.，。?？/；;!！（）、@#￥$%&)(]/.test(innerTextContent)) {\n          //     textContent += innerTextContent;\n          //   } else {\n          //     textContent += '。' + innerTextContent;\n          //   }\n          // } else {\n          //   textContent += innerTextContent;\n          // }\n          textContent += innerTextContent;\n        }\n      }\n    }\n    //返回纯文本节点的内容\n    return textContent.replace(/\\s+/g, '');\n  }\n  //获取各级标题\n  function extractHeadings(element) {\n    const headings = element.querySelectorAll('h1, h2, h3, h4');\n    const result = [];\n    for (let i = 0; i < headings.length; i++) {\n      const heading = headings[i];\n      const headingText = heading.textContent.trim();\n      result.push(headingText);\n      const childHeadings = extractHeadings(heading);\n      result.push(...childHeadings);\n    }\n    return result.join(\";\");\n  }\n  //按比例切割字符串\n  function extractString(str) {\n    // 截取前500个字符\n    var first500 = str.substring(0, 500);\n    // 截取末尾200个字符\n    var last200 = str.substring(str.length - 200);\n    // 截取中间300个字符\n    var midStartIndex = (str.length - 300) / 2; // 计算中间部分的起始索引\n    var middle300 = str.substring(midStartIndex, midStartIndex + 300);\n    // 将三个部分拼接在一起\n    var result = first500 + middle300 + last200;\n    // 返回截取后的字符串\n    return result;\n  }\n  //获得字符串，默认进行切割，false返回原文纯文本\n  function getTextContent(element, i = true) {\n    let content;\n    if (i) {\n      content = `文章的各级标题：${extractHeadings(element)}。文章内容的截取：${extractString(getText(element))}`;\n    } else {\n      content = `${getText(element)}`;\n    }\n    return content;\n  }\n  //发送请求获得简介\n  async function getGptResponse(content, i = true) {\n    completeGenerate = false;\n    controller = new AbortController();\n    signal = controller.signal;\n    let response = '';\n    if (i) {\n      try {\n        response = await fetch('https://summary.tianli0.top/', {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Referer\": tlReferer\n          },\n          body: JSON.stringify({\n            content: content,\n            key: tlKey\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求tianliGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.summary;\n      // console.log(outputText);\n      completeGenerate = true;\n      return outputText;\n    } else {\n      const prompt = `你是一个摘要生成工具，你需要解释我发送给你的内容，不要换行，不要超过200字，只需要介绍文章的内容，不需要提出建议和缺少的东西。请用中文回答，文章内容为：${content}`;\n      const apiUrl = \"https://api.openai.com/v1/chat/completions\";\n      try {\n        response = await fetch(apiUrl, {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": `Bearer ${apiKey}`\n          },\n          body: JSON.stringify({\n            model: \"gpt-3.5-turbo\",\n            messages: [{ \"role\": \"user\", \"content\": prompt }],\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求chatGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.choices[0].message.content;\n      completeGenerate = true;\n      return outputText;\n    }\n  }\n  ai_init();\n}\nallAI();\n\n```\n\n添加CSS，颜色变量可F12自取，建议自己重新配色(2.0版本无css更新)\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n\n## 1.1版\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/post-ai.js?2\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n\n```js\nif (true) {\n let animationRunning = true; // 标志变量，控制动画函数的运行\n const explanation = document.querySelector('.ai-explanation');\n const abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n const post_ai = document.querySelector('.post-ai');\n let ai_str = '';\n let ai_str_length = '';\n let delay_init = 600;\n let i = 0;\n let j = 0;\n let sto = [];\n let elapsed = 0;\n const animate = (timestamp) => {\n   if (!animationRunning) {\n     return; // 动画函数停止运行\n   }\n   if (!animate.start) animate.start = timestamp;\n   elapsed = timestamp - animate.start;\n   if (elapsed >= 20) {\n     animate.start = timestamp;\n     if (i < ai_str_length-1) {\n       let char = ai_str.charAt(i+1);\n       let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n       if(explanation.firstElementChild){\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       explanation.innerHTML += char;\n       let div = document.createElement('div');\n       div.className = \"ai-cursor\";\n       explanation.appendChild(div);\n       i++;\n       if(delay === 150){\n         document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n       }\n       if(i === ai_str_length-1){\n         observer.disconnect();// 暂停监听\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       sto[0] = setTimeout(() => {\n         requestAnimationFrame(animate);\n       }, delay);\n     }\n   } else {\n     requestAnimationFrame(animate);\n   }\n };\n const observer = new IntersectionObserver((entries) => {\n   let isVisible = entries[0].isIntersecting;\n   animationRunning = isVisible; // 标志变量更新\n   if(animationRunning){\n     delay_init = i===0 ? 200 : 20;\n     sto[1] = setTimeout(() => {\n       if(j){\n         i = 0;\n         j = 0;\n       }\n       if(i===0){\n         explanation.innerHTML = ai_str.charAt(0);\n       }\n       requestAnimationFrame(animate);\n     }, delay_init);\n   }\n }, { threshold: 0 });\n function clearSTO(){\n   if(sto.length){\n     sto.forEach((item)=>{\n       if(item){\n         clearTimeout(item);\n       }\n     });\n   }\n }\n function startAI(str,df=true){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   if(df){\n     explanation.innerHTML = '生成中. . .';\n   }else{\n     explanation.innerHTML = '请等待. . .';\n   }\n   ai_str = str;\n   ai_str_length = ai_str.length;\n   observer.disconnect();// 暂停上一次监听\n   observer.observe(post_ai);//启动新监听\n }\n function aiIntroduce(){\n   startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n }\n function aiAbstract(){\n   startAI(abstract_value);\n }\n function aiRecommend(){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   explanation.innerHTML = '生成中. . .';\n   ai_str = '';\n   ai_str_length = '';\n   observer.disconnect();// 暂停上一次监听\n   sto[2] = setTimeout(() => {\n     explanation.innerHTML = recommendList();\n   }, 600);\n }\n function aiGoHome(){\n   startAI('正在前往博客主页...',false);\n   sto[2] = setTimeout(() => {\n     pjax.loadUrl(\"/\");\n   }, 1000);\n }\n const ai_btn_item = document.querySelectorAll('.ai-btn-item');\n ai_btn_item.forEach((item, index)=>{\n   item.addEventListener('click', ()=>{\n     switch(index) {\n       case 0:\n         aiIntroduce();\n         break;\n       case 1:\n         aiAbstract();\n         break;\n       case 2:\n         aiRecommend();\n         break;\n       case 3:\n         aiGoHome();\n       break;\n     } \n   });\n });\n function recommendList(){\n   let info = `推荐文章：<br />`;\n   let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n   if(!thumbnail){\n     info = '很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br />';\n     thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n   }\n   info += '<div class=\"ai-recommend\">';\n   thumbnail.forEach((item, index)=>{\n     info += `<div class=\"ai-recommend-item\"><span>推荐${index+1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n   });\n   info += '</div>'\n   return info;\n }\n aiIntroduce();\n}\n\n```\n\n添加CSS，颜色变量可F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n使用：在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介\n\n```markdown\n---\ntitle: 文章添加AI摘要和推荐\nai: 本文介绍了如何通过手动生成GPT网页版摘要，再用JS模拟GPT打字生成效果，实现AI摘要。作者详细讲解了实现思路，包括停顿、延迟等策略，以及如何监听视口并控制生成。作者还提到了未来计划，即使用API生成更多摘要。此外，作者还给出了修改 post.pug 和 CSS 的代码。\n---\n\n```\n\n\n## 1.0版\n才两个小时就沦为旧版的屑\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n   .post-ai\n   .ai-title\n   i.fa-brands.fa-airbnb\n   .ai-title-text AI摘要\n   .ai-tag GPT-4\n   .ai-explanation #{page.ai}\n   script.\n   if (true) {\n     let animationRunning = true; // 标志变量，控制动画函数的运行\n     const explanation = document.querySelector('.ai-explanation');\n     const post_ai = document.querySelector('.post-ai');\n     const ai_str = explanation.innerHTML;\n     const ai_str_length = ai_str.length;\n     let delay_init = 600;\n     let i = 0;\n     explanation.innerHTML = 'AI摘要生成中. . .';\n     const animate = (timestamp) => {\n       if (!animationRunning) {\n         return; // 动画函数停止运行\n       }\n       if (!animate.start) animate.start = timestamp;\n       const elapsed = timestamp - animate.start;\n       if (elapsed >= 20) {\n         animate.start = timestamp;\n         if (i < ai_str_length-1) {\n           let char = ai_str.charAt(i+1);\n           let delay = /[,.，。!?！？]/.test(char) ? 160 : 20;\n           if(explanation.firstElementChild){\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           explanation.innerHTML += char;\n           let div = document.createElement('div');\n           div.className = \"ai-cursor\";\n           explanation.appendChild(div);\n           i++;\n           if(delay === 160){\n             document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n           }\n           if(i === ai_str_length-1){\n             observer.disconnect();// 暂停监听\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           setTimeout(() => {\n             requestAnimationFrame(animate);\n           }, delay);\n         }\n       } else {\n         requestAnimationFrame(animate);\n       }\n     };\n     const observer = new IntersectionObserver((entries) => {\n       let isVisible = entries[0].isIntersecting;\n       animationRunning = isVisible; // 标志变量更新\n       if(animationRunning){\n         delay_init = i===0 ? 600 : 20;\n         setTimeout(() => {\n           if(i===0){\n             explanation.innerHTML = ai_str.charAt(0);\n           }\n           requestAnimationFrame(animate);\n         }, delay_init);\n       }\n     }, { threshold: 0 });\n     observer.observe(post_ai);\n   }\n\n```\n\n添加CSS，颜色变量F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n\n```\n","tags":["瞎折腾","ChatGPT"],"categories":["项目"]},{"title":"JavaScript—DOM案例","url":"/article/b0cb9f85.html","content":"\n# 搜索框下拉栏\n\n<div id=\"search-sandbox\"></div>\n\n```html\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        ul{\n            list-style: none;\n        }\n        .search-box{\n            position: relative;\n            width: 200px;\n            margin: 20px;\n            border-radius: 6px;\n        }\n        .search-box input{\n            width: 100%;\n            height: 40px;\n            font-size: 16px;\n            line-height: 100%;\n            border: 1px solid #65a8e2;\n            outline: none;\n            padding: 0 6px;\n            border-radius: 6px;\n            transition: all 0.3s;\n        }\n        .result-list{\n            width: 100%;\n            position: absolute;\n            top: 40px;\n            border: 1px solid #65a8e2;\n            height: auto;\n            border-top: 0;\n            background: rgba(200, 236, 243, 0.7);\n            border-radius: 0 0 6px 6px;\n            display: none;\n        }\n        .result-list li{\n            height: auto;\n        }\n        .result-list a{\n            transition: all 0.3s;\n            text-decoration: none;\n            color: #363636;\n            padding: 5px 10px;\n            display: block;\n            font-size: 14px;\n        }\n        .result-list a:hover{\n            background-color: rgba(210, 210, 210, 0.9);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"search-box\">\n        <input type=\"search\" placeholder=\"输入搜索内容\">\n        <ul class=\"result-list\">\n            <li><a href=\"#\">搜索词1</a></li>\n            <li><a href=\"#\">搜索词2</a></li>\n            <li><a href=\"#\">搜索词3</a></li>\n            <li><a href=\"#\">搜索词4</a></li>\n            <li><a href=\"#\">搜索词5</a></li>\n            <li><a href=\"#\">搜索词6</a></li>\n        </ul>\n    </div>\n    <script>\n        const input = document.querySelector('input');\n        const list = document.querySelector('.result-list');\n        input.addEventListener('focus',()=>{\n            list.style.display = \"block\";\n            input.style.borderRadius = '6px 6px 0 0'\n        });\n        input.addEventListener('blur',()=>{\n            list.style.display = \"none\";\n            input.style.borderRadius = '6px'\n        });\n    </script>\n</body>\n</html>\n\n```\n\n# 评论发布、字数统计\n\n<div id=\"input-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            box-sizing: border-box;\n        }\n\n        .comment-box {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n        }\n\n        .comment-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        #comment-tx {\n            outline: none;\n            border-color: transparent;\n            resize: none;\n            background: #f5f5f5;\n            border-radius: 4px;\n            flex: 1;\n            padding: 10px;\n            transition: all 0.3s;\n            font-size: 12px;\n            height: 60px;\n        }\n\n        #comment-tx:focus {\n            border-color: #e4e4e4;\n            background: #fff;\n            height: 85px;\n        }\n\n        .comment-box button {\n            background: #00aeec;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            margin-left: 10px;\n            width: 70px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .comment-count {\n            width: 500px;\n            height: auto;\n            display: flex;\n            justify-content: flex-end;\n        }\n\n        .comment-count span {\n            margin-right: 80px;\n            color: #999;\n            margin-top: 5px;\n            transition: all 0.3s;\n            opacity: 0;\n        }\n\n        .content-list {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n            flex-direction: column;\n            flex-wrap: nowrap;\n        }\n\n        .content-item {\n            display: flex;\n            border-bottom: 1px solid #e4e4e4;\n            padding-bottom: 10px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-items: flex-start;\n            margin-bottom: 15px;\n        }\n\n        .content-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        .content-warp {\n            width: calc(100% - 65px);\n            padding-right: 8px;\n        }\n\n        .content-name {\n            font-size: 16px;\n            margin-bottom: 6px;\n        }\n\n        .content-comment {\n            font-size: 18px;\n            white-space: normal;\n            word-break: break-all;\n            word-wrap: break-word;\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"comment-box\">\n        <div class=\"comment-avatar\"></div>\n        <textarea id=\"comment-tx\" placeholder=\"发一条友善的评论，回车发布评论\" maxlength=\"200\"></textarea>\n        <button>发布</button>\n    </div>\n    <div class=\"comment-count\">\n        <span>0/200字</span>\n    </div>\n    <div class=\"content-list\">\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">评论一</div>\n            </div>\n        </div>\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">22222222222222222222222222222222222222222222222222222222222222222222222222\n                </div>\n            </div>\n        </div>\n    </div>\n    <script>\n        // 评论输入框\n        const count = document.querySelector('.comment-count span');\n        const tx = document.querySelector('#comment-tx');\n        tx.addEventListener('focus', () => {\n            count.style.opacity = 1;\n        });\n        tx.addEventListener('blur', () => {\n            count.style.opacity = 0;\n        });\n        tx.addEventListener('input', () => {\n            count.innerHTML = `${tx.value.length}/200字`\n        });\n        // 评论展示\n        const contentList = document.querySelector('.content-list');\n        function applyComment() {\n            let comment = tx.value;\n            let html = `<div class=\"content-item\">\n                <div class=\"content-avatar\"></div>\n                <div class=\"content-warp\">\n                    <div class=\"content-name\">chuckle</div>\n                    <div class=\"content-comment\">${comment}</div>\n                </div>\n            </div>`;\n            contentList.insertAdjacentHTML('afterbegin', html);\n        }\n        tx.addEventListener('keyup', (e) => {\n            if (e.key == 'Enter') {\n                if (tx.value.trim()) {\n                    applyComment();\n                }\n                tx.value = '';\n                count.innerHTML = `${tx.value.length}/200字`\n            }\n        })\n        const button = document.querySelector('.comment-box button');\n        button.addEventListener('click', () => {\n            if (tx.value.trim()) {\n                applyComment();\n            }\n            tx.value = '';\n            count.innerHTML = `${tx.value.length}/200字`\n        })\n    </script>\n</body>\n</html>\n\n```\n\n# 轮播图\n当然还是直接用插件方便[swiper](https://www.swiper.com.cn/)\n\n<div id=\"rotBox-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .rot-box {\n            max-width: 560px;\n            height: 400px;\n            overflow: hidden;\n            border-radius: 12px;\n            box-shadow: 0 3px 8px 6px rgba(7, 17, 27, 0.05);\n            margin: 10px;\n        }\n\n        .rot-img {\n            width: 100%;\n            height: 80%;\n            display: flex;\n            flex-direction: row;\n            flex-wrap: wrap;\n            justify-content: center;\n            position: relative;\n        }\n\n        .rot-img img {\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        }\n\n        .rot-footer {\n            height: 20%;\n            background-color: rgb(100, 67, 68);\n            padding: 12px 12px 0 12px;\n            position: relative;\n        }\n\n        .rot-toggle {\n            position: absolute;\n            right: 10px;\n            top: 15px;\n            display: flex;\n        }\n\n        .rot-toggle button {\n            margin-right: 12px;\n            width: 28px;\n            height: 28px;\n            appearance: none;\n            border: none;\n            background: rgba(255, 255, 255, 0.1);\n            color: #fff;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .rot-toggle button:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n\n        .rot-title {\n            margin: 0;\n            color: #fff;\n            font-size: 18px;\n            margin-bottom: 10px;\n            margin-left: 10px;\n        }\n\n        ul.rot-select {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n            display: flex;\n            align-items: center;\n            margin-left: 10px;\n            height: 12px;\n        }\n\n        ul.rot-select li {\n            width: 8px;\n            height: 8px;\n            margin: 4px;\n            border-radius: 50%;\n            background: #fff;\n            opacity: 0.4;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        ul.rot-select li.active {\n            width: 12px;\n            height: 12px;\n            opacity: 1;\n        }\n        @media screen and (max-width:500px) {\n            .rot-box {\n                height: 320px;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"rot-box\">\n        <div class=\"rot-img\">\n            <img src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/41-1.webp\">\n        </div>\n        <div class=\"rot-footer\">\n            <div class=\"rot-title\">标题零</div>\n            <ul class=\"rot-select\">\n                <li class=\"active\"></li>\n            </ul>\n            <div class=\"rot-toggle\">\n                <button class=\"rot-prev\">&lt;</button>\n                <button class=\"rot-next\">&gt;</button>\n            </div>\n        </div>\n    </div>\n    <script>\n        const rotDate = [\n            {\n                url: 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/43-1.webp',\n                title: '标题一'\n            },\n            {\n                url: 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/42-1.webp',\n                title: '标题二'\n            },\n            {\n                url: 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/41-1.webp',\n                title: '标题三'\n            },\n            {\n                url: 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-1.webp',\n                title: '标题四'\n            },\n            {\n                url: 'https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/39-1.webp',\n                title: '标题五'\n            },\n        ];\n        //生成[0,arr长度)的随机整数\n        function getRandom(arr) {\n            return parseInt(Math.random() * arr.length);\n        }\n        const rotSelect = document.querySelector('.rot-select');\n        // 数组中有多少对象加几个li\n        rotSelect.innerHTML = '';// 先清空ul的内容\n        for (let i = 0; i < rotDate.length; i++) {\n            rotSelect.innerHTML += '<li></li>';\n        }\n        //让第一个li变成小白点\n        document.querySelector('.rot-select li:first-child').classList.toggle('active');\n        // 一开始随机选一张\n        // 获取要操作的元素\n        const img = document.querySelector('.rot-img img');\n        const title = document.querySelector('.rot-title');\n        const rot_li = document.querySelectorAll('.rot-select li');\n        // 数据数组长度\n        const dateLength = rotDate.length;\n        // 轮播展示序号，默认第一个\n        var num = 0;\n        // 轮播的对象,默认第一个\n        var rot = rotDate[num];\n        // 修改轮播容器的内容\n        function applyDate() {\n            //换标题和图片\n            rot = rotDate[num];\n            img.src = rot.url;\n            title.innerHTML = rot.title;\n            //移除之前的小白点，给当前li添加小白点\n            if (document.querySelector('.rot-select .active')) {\n                document.querySelector('.rot-select .active').classList.remove('active');\n            }\n            rot_li[num].classList.toggle('active');\n        }\n        // 随机展示一个\n        function ranDate(){\n            var random = getRandom(rotDate);\n            rot = rotDate[random];\n            num = random;\n            applyDate();\n        }\n        // 上一张\n        function prevDate() {\n            num > 0 ? --num : num = dateLength - 1;\n            applyDate();\n        }\n        // 下一张\n        function nextDate() {\n            //控制下一张是哪个\n            num = ++num % dateLength;\n            applyDate();\n        }\n        //获取两个按钮\n        const rotPrev = document.querySelector('.rot-prev');\n        const rotNext = document.querySelector('.rot-next');\n        //注册事件\n        rotPrev.addEventListener('click', () => {\n            prevDate();\n        })\n        rotNext.addEventListener('click', () => {\n            nextDate();\n        })\n        // 点击小圆点切换展示\n        rot_li.forEach((item, index, arr) => {\n            item.addEventListener('click', () => {\n                //让轮播展示序号变为当前点击的li的序号\n                num = index;\n                applyDate();\n            });\n        });\n        // 鼠标悬停停止轮播\n        const rotBox = document.querySelector('.rot-box');\n        rotBox.addEventListener('mouseenter',()=>{\n            clearInterval(itv);\n            console.log('暂停轮播');\n        });\n        // 鼠标移出恢复轮播\n        rotBox.addEventListener('mouseleave',()=>{\n            //未确保不重复定时，先清除一次\n            clearInterval(itv);\n            itv = setInterval(nextDate, 1000);\n            console.log('恢复轮播');\n        });\n        // 一开始随机展示一个，注释掉则默认展示第一个\n        //ranDate();\n        // 定时器轮播\n        var itv = setInterval(nextDate, 1000);\n        \n    </script>\n</body>\n</html>\n\n```\n\n# tab切换\n**1、for循环注册鼠标悬停版：**\n\n<div id=\"tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            padding: 2px 15px 0;\n            font-size: 18px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n            border-bottom: 1px solid #333;\n            margin-bottom: -1px;\n        }\n        .tab-nav ul li.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 30px;\n            display: block;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n        .tab-item{\n            display: none;\n        }\n        .tab-item.active{\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li class=\"active\"><a href=\"javascript:;\">栏1</a></li>\n                <li><a href=\"javascript:;\">栏2</a></li>\n                <li><a href=\"javascript:;\">栏3</a></li>\n                <li><a href=\"javascript:;\">栏4</a></li>\n                <li><a href=\"javascript:;\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelectorAll('.tab-nav ul li');\n        const tabItem = document.querySelectorAll('.tab-item');\n        tabNav.forEach((item,index)=>{\n            item.addEventListener('mouseenter',()=>{\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                item.classList.add('active');\n                tabItem[index].classList.add('active');\n            });\n        });\n    </script>\n</body>\n<div id=\"tab-sandbox\"></div>\n</html>\n\n```\n\n**2、事件委托鼠标点击版：**\n\n<div id=\"tab2-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            font-size: 18px;\n            border-bottom: 1px solid transparent;\n            margin-bottom: -1px;\n        }\n\n        .tab-nav ul li a.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 33px;\n            display: block;\n            padding: 2px 15px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n\n        .tab-item {\n            display: none;\n        }\n\n        .tab-item.active {\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li><a href=\"javascript:;\" data-id=\"0\" class=\"active\">栏1</a></li>\n                <li><a href=\"javascript:;\" data-id=\"1\">栏2</a></li>\n                <li><a href=\"javascript:;\" data-id=\"2\">栏3</a></li>\n                <li><a href=\"javascript:;\" data-id=\"3\">栏4</a></li>\n                <li><a href=\"javascript:;\" data-id=\"4\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelector('.tab-nav ul');\n        const tabItem = document.querySelectorAll('.tab-item');\n        //利用事件委托减少注册\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                e.target.classList.add('active');\n                tabItem[e.target.dataset.id].classList.add('active')\n            }\n        });\n    </script>\n</body>\n\n</html>\n\n```\n\n# 表单全选反选\n\n<div id=\"input-check-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        table {\n            border-collapse: collapse;\n            border-spacing: 0;\n            border: 1px solid #c0c0c0;\n            width: 500px;\n            text-align: center;\n        }\n\n        th {\n            background-color: rgb(40, 170, 220);\n            font: bold 16px;\n            color: #fff;\n            height: 22px;\n        }\n        td {\n            border: 1px solid #d0d0d0;\n            color: #363636;\n            padding: 6px 10px;\n            background: #f9f9f9;\n        }\n        tr td:not(:first-child){\n            min-width: 50px;\n        }\n        tr th:first-child{\n            width: 70px;\n        }\n    </style>\n</head>\n\n<body>\n    <table>\n        <tr>\n            <th>\n                <input type=\"checkbox\" id=\"check-all\">\n                <span>全选</span>\n            </th>\n            <th>书名</th>\n            <th>作者</th>\n            <th>价格</th>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>毛泽东选集</td>\n            <td>毛泽东</td>\n            <td>56</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>资本论</td>\n            <td>马克思</td>\n            <td>129</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>三体</td>\n            <td>刘慈欣</td>\n            <td>46</td>\n        </tr>\n    </table>\n    <script>\n        const checkAll = document.querySelector('#check-all');\n        const checks = document.querySelectorAll('.check-one');\n        checkAll.addEventListener('click',()=>{\n            checks.forEach((item)=>{\n                item.checked = checkAll.checked;\n            });\n        });\n        checks.forEach((item)=>{\n            item.addEventListener('click',()=>{\n                checkAll.checked = document.querySelectorAll('.check-one:checked').length === checks.length;\n            })\n        })\n    </script>\n</body>\n\n</html>\n\n```\n\n# 导航栏、电梯导航、哔哩tab\n\n<div id=\"nav-bl-tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            padding-bottom: 500px;\n        }\n\n        .tab-box {\n            width: 500px;\n            height: auto;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            display: flex;\n            list-style: none;\n            border-bottom: 1px solid #333;\n            background: rgb(233, 233, 233);\n            height: 40px;\n            flex-direction: row;\n            flex-wrap: nowrap;\n            justify-content: center;\n            align-items: center;\n            position: relative;\n        }\n\n        .tab-nav a {\n            margin: 5px;\n            padding: 0 10px;\n            text-decoration: none;\n            color: #000;\n            height: 40px;\n            line-height: 40px;\n        }\n\n        .tab-nav a.active {\n            color: rgb(23, 180, 215);\n        }\n\n        .tab-bar {\n            position: absolute;\n            width: 40px;\n            height: 3px;\n            background: rgb(23, 180, 215);\n            bottom: -1px;\n            transition: all 0.3s;\n        }\n\n        .item-box {\n            background: rgb(220, 220, 220);\n        }\n\n        .item {\n            text-align: center;\n            padding: 10px;\n            display: none;\n        }\n\n        .item.active {\n            display: block;\n            height: 100px;\n        }\n\n        /* 导航栏 */\n        #nav {\n            width: 100%;\n            height: 50px;\n            text-align: center;\n            line-height: 50px;\n            background: rgba(120, 182, 191, 0.5);\n            font-size: 20px;\n            position: fixed;\n            top: -50px;\n            transition: all 0.3s;\n            z-index: 9999;\n        }\n\n        .box {\n            margin-top: 10px;\n            width: 200px;\n            height: 200px;\n            background: rgb(144, 193, 230);\n            margin-bottom: 200px;\n            border-radius: 6px;\n        }\n\n        /* 电梯导航 */\n        .ele-nav {\n            position: fixed;\n            bottom: 20%;\n            background: rgb(233, 233, 233);\n            right: 10%;\n            border: 1px solid #333;\n            border-bottom: 0;\n            border-radius: 6px;\n            overflow: hidden;\n            transition: all 0.3s;\n            opacity: 0;\n            z-index: -99;\n        }\n        .ele-item.active{\n            color: rgb(23, 180, 215);\n            background: rgb(252, 200, 200);\n        }\n        .ele-item,\n        .back-top {\n            padding: 10px;\n            border-bottom: 1px solid #333;\n            user-select: none;\n            transition: all 0.3s;\n        }\n        .ele-item:hover,\n        .back-top:hover{\n            color: rgb(23, 180, 215);\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"nav\">导航栏</div>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <a href=\"javascript:;\" class=\"active\">栏1</a>\n            <a href=\"javascript:;\">栏2</a>\n            <a href=\"javascript:;\">栏3</a>\n            <a href=\"javascript:;\">栏4</a>\n            <a href=\"javascript:;\">栏114514</a>\n            <div class=\"tab-bar\"></div>\n        </div>\n\n        <div class=\"item-box\">\n            <div class=\"item active\">项目一</div>\n            <div class=\"item\">项目二</div>\n            <div class=\"item\">项目三</div>\n            <div class=\"item\">项目四</div>\n            <div class=\"item\">项目114514</div>\n        </div>\n    </div>\n    <div class=\"ele-nav\">\n        <div class=\"ele-item\">去第一个</div>\n        <div class=\"ele-item\">去第二个</div>\n        <div class=\"ele-item\">去第三个</div>\n        <div class=\"ele-item\">去第四个</div>\n        <div class=\"back-top\">回到顶部</div>\n    </div>\n    <div class=\"box\">第一个盒子,滚动到此(往上55像素)显示导航栏和电梯导航</div>\n    <div class=\"box\">第二个盒子</div>\n    <div class=\"box\">第三个盒子</div>\n    <div class=\"box\">第四个盒子</div>\n    <script>\n        //网页导航栏,还有电梯导航的显示和隐藏\n        const nav = document.querySelector('#nav');\n        const box = document.querySelectorAll('.box');\n        const ele_nav = document.querySelector('.ele-nav');\n        window.addEventListener('scroll', () => {\n            let n = window.scrollY;\n            let m = box[0].offsetTop;\n            let tf = n >= m-55;//减去55像素，不让电梯导航点击去第一个后消失\n            nav.style.top = tf ? '0px' : '-50px';\n            ele_nav.style.opacity = tf ? '1' : '0';\n            ele_nav.style.zIndex = tf ? '99' : '-99';\n        });\n        //bilibili导航\n        const bar = document.querySelector('.tab-bar');\n        const tabNav = document.querySelector('.tab-nav');\n        const tab_a = document.querySelectorAll('.tab-nav a');\n        const item = document.querySelectorAll('.item-box .item');\n        //给每个a依次添加data-id\n        tab_a.forEach((item, index) => {\n            item.dataset.id = index;\n        });\n        //将a的点击事件委托给tab-nav\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                //tab导航切换\n                document.querySelector('.tab-nav a.active').classList.remove('active');\n                document.querySelector('.item.active').classList.remove('active');\n                e.target.classList.add('active');\n                item[e.target.dataset.id].classList.add('active');\n                //bar移动和动态改变宽度\n                bar.style.width = `${e.target.offsetWidth}px`;\n                bar.style.left = `${e.target.offsetLeft}px`;\n            }\n        });\n        tab_a[0].click();//先初始化一次bar的位置\n        //电梯导航\n        //给每个电梯导航依次添加data-name\n        document.querySelectorAll('.ele-item').forEach((item, index) => {\n            item.dataset.name = `b${index+1}`;\n        });\n        //给每个box依次添加电梯导航对应的自定义属性的class\n        box.forEach((item, index) => {\n            item.classList.add(`b${index+1}`);\n        });\n        //移除ele的active\n        function reactive(){\n            let ele_active = document.querySelector('.ele-item.active');\n            if(ele_active){\n                //如果有，先清除\n                ele_active.classList.remove('active');\n            }\n        }\n        //去指定盒子,事件委托\n        ele_nav.addEventListener('click', (e) => {\n            let cname = e.target.className;\n            if (cname === 'ele-item'||cname === 'ele-item active') {\n                reactive();\n                //给点击的item添加active\n                e.target.classList.add('active');\n                //去对应的盒子\n                //通过自定义属性获取对应的盒子class名\n                let box = document.querySelector(`.${e.target.dataset.name}`);\n                // 其实监听滚动后，没必要再手动去给active，但想点击后导航立刻变色的话，可以取消下面的注释\n                // //先立刻移除页面滚动监听\n                // window.removeEventListener('scroll', scroll_light_ele);\n                // //一秒后重新监听\n                // setTimeout(() => {\n                //     //防止重复注册，先移除页面滚动监听\n                //     window.removeEventListener('scroll', scroll_light_ele);\n                //     window.addEventListener('scroll', scroll_light_ele);\n                // }, 800);\n                //更新当前页面在哪个盒子的范围位置\n                box_num = e.target.dataset.name.replace(/[^\\d]/g, \" \");\n                //滚动到指定位置\n                window.scrollTo({\n                    top: box.offsetTop - 50,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n            }\n            //点击返回顶部\n            if (cname === 'back-top') {\n                reactive();\n                window.scrollTo({\n                    top: 0,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n                box_num = -1;\n            }\n        });\n        //获取盒子的高度数组减去55px\n        const box_top_arr = Array.from(box).map((item)=>{\n            return item.offsetTop-55;\n        })\n        var box_num = -1;//记录当前在哪个盒子范围内\n        //页面滚动到对应box让电梯导航对应导航高亮\n        function scroll_light_ele(){\n            let n = window.scrollY;\n            let num = box_top_arr.reduce((prev, item, index)=>{\n                return n >= item ? index : prev;\n            },-1);\n            if(num === box_num){\n                //说明还在这个盒子范围内，直接返回\n                return;\n            }else{\n                //更新位置\n                box_num = num;\n            }\n            if(num > -1){\n                reactive();\n                document.querySelector(`[data-name=\"b${num+1}\"]`).classList.add('active');\n            }else{\n                box_num = -1;\n            }\n        }\n        window.addEventListener('scroll', scroll_light_ele);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 倒计时\n\n<div id=\"time-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        .time-box {\n            padding: 20px 15px;\n            background: rgb(30, 171, 210);\n            width: fit-content;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n            font-size: 18px;\n        }\n\n        .time-now {\n            width: 100%;\n            text-align: center;\n        }\n\n        .time-title {\n            font-size: 26px;\n            text-align: center;\n            width: 100%;\n            margin: 6px 0;\n        }\n\n        .clock {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            margin: 10px 0;\n        }\n        .hour,.minutes,.second{\n            font-size: 20px;\n            margin: 2px;\n            padding: 2px 3px;\n            border-radius: 4px;\n            background: rgba(36, 36, 36, 0.65);\n            color: #fff;\n        }\n        .colon{\n            font-size: 20px;\n            font-weight: bolder;\n            padding: 2px;\n        }\n        .target{\n            width: 100%;\n            text-align: center;\n            margin: 6px 0 0;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"time-box\">\n        <div class=\"time-now\">今天是1970年1月1日</div>\n        <div class=\"time-title\">倒计时</div>\n        <div class=\"clock\">\n            <div class=\"hour\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"minutes\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"second\">00</div>\n        </div>\n        <div class=\"target\">目标时间00:00:00</div>\n    </div>\n\n    <script>\n        const hour = document.querySelector('.hour');\n        const minutes = document.querySelector('.minutes');\n        const second = document.querySelector('.second');\n        const time_now = document.querySelector('.time-now');\n        const target = document.querySelector('.target');\n        const now = new Date();\n        const time = '18:00:00';\n        const targetTime = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()} 18:00:00`;\n        const last = new Date(targetTime);\n        let count = (last.getTime() - now.getTime()) / 1000;\n        function countDown() {\n            let h = parseInt(count / 60 / 60 % 24);\n            h = h < 10 ? '0' + h : h;\n            let m = parseInt(count / 60 % 60);\n            m = m < 10 ? '0' + m : m;\n            let s = parseInt(count % 60);\n            s = s < 10 ? '0' + s : s;\n            hour.innerHTML = h;\n            minutes.innerHTML = m;\n            second.innerHTML = s;\n            count--;\n            if (count == 0) {\n                count = 0;\n            }\n        }\n        time_now.innerHTML = `今天是${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日`;\n        target.innerHTML = `目标时间${time}`\n        countDown();\n        setInterval(countDown, 1000);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 学生信息表\n<a href=\"/dom/stu-info.html\" target=\"_blank\">学生信息表</a>\n\n本地存储，数据驱动，刷新不丢失\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        a {\n            text-decoration: none;\n            color: rgb(226, 14, 14);\n        }\n\n        .info-box {\n            width: 800px;\n            margin: 0 auto;\n            position: relative;\n        }\n\n        h1 {\n            text-align: center;\n            margin: 20px;\n            user-select: none;\n        }\n\n        .info {\n            width: 100%;\n            text-align: center;\n            margin: 40px 0;\n        }\n\n        .ipt-name {\n            width: fit-content;\n            display: inline-block;\n            line-height: 25px;\n            font-size: 16px;\n        }\n\n        .info input,\n        .info select {\n            width: 70px;\n            outline: none;\n            border-radius: 5px;\n            border: 1px solid #b8daff;\n            height: 25px;\n            padding: 0 5px;\n            margin: 0 15px 0 2px;\n        }\n\n        input.sname {\n            width: 80px;\n        }\n\n        input.age {\n            width: 40px;\n        }\n\n        .info button {\n            width: 60px;\n            height: 25px;\n            border-radius: 5px;\n            cursor: pointer;\n            background: rgb(82, 191, 231);\n            outline: none;\n            border: 1px solid rgb(98, 98, 98);\n            color: #fff;\n            font-size: 15px;\n        }\n\n        table {\n            margin: 0 auto;\n            width: 100%;\n            padding: 0 20px;\n            color: #363636;\n            border-collapse: collapse;\n            border-spacing: 0;\n        }\n\n        th {\n            padding: 5px 10px;\n            background: #cfe5ff;\n            font-size: 20px;\n            font-weight: 400;\n        }\n\n        td,\n        th {\n            border: 1px solid #b8daff;\n        }\n\n        td {\n            padding: 5px 10px;\n            text-align: center;\n            font-size: 16px;\n        }\n\n        tbody tr {\n            background: #fff;\n        }\n\n        tbody tr:hover {\n            background: #e1ecf8;\n        }\n        .info-num{\n            right: 10px;\n            width: fit-content;\n            position: absolute;\n            margin-top: -20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"info-box\">\n        <h1>新增学生信息</h1>\n        <form class=\"info\" autocomplete=\"off\">\n            <div class=\"ipt-name\">姓名</div>\n            <input type=\"text\" class=\"sname\" name=\"sname\">\n            <div class=\"ipt-name\">年龄</div>\n            <input type=\"text\" class=\"age\" name=\"age\">\n            <div class=\"ipt-name\">性别</div>\n            <select class=\"gender\" name=\"gender\">\n                <option value=\"男\">男</option>\n                <option value=\"女\">女</option>\n            </select>\n            <div class=\"ipt-name\">年级</div>\n            <select class=\"grade\" name=\"grade\">\n                <option value=\"大一\">大一</option>\n                <option value=\"大二\">大二</option>\n                <option value=\"大三\">大三</option>\n                <option value=\"大四\">大四</option>\n            </select>\n            <div class=\"ipt-name\">专业</div>\n            <select class=\"major\" name=\"major\">\n                <option value=\"计科\">计科</option>\n                <option value=\"机械\">机械</option>\n                <option value=\"会计\">会计</option>\n            </select>\n            <button class=\"add-info\">录入</button>\n        </form>\n        <h1>学生信息</h1>\n        <div class=\"info-num\">共有0条数据</div>\n        <table>\n            <thead>\n                <tr>\n                    <th>序号</th>\n                    <th>姓名</th>\n                    <th>年龄</th>\n                    <th>性别</th>\n                    <th>年级</th>\n                    <th>专业</th>\n                    <th>操作</th>\n                </tr>\n            </thead>\n            <tbody></tbody>\n        </table>\n    </div>\n    <script>\n        var arr = [\n            {\n                name: '张三',\n                age: 19,\n                gender: '男',\n                grade: '大一',\n                major: '计科'\n            },\n            {\n                name: '李四',\n                age: 18,\n                gender: '男',\n                grade: '大二',\n                major: '机械'\n            },\n            {\n                name: '李丽',\n                age: 18,\n                gender: '女',\n                grade: '大三',\n                major: '会计'\n            }\n        ];\n        const info = document.querySelector('.info');\n        const items = document.querySelectorAll('.info [name]');\n        const tbody = document.querySelector('tbody');\n        const infoNum = document.querySelector('.info-num');\n        info.addEventListener('submit', (e) => {\n            e.preventDefault();\n            let i = Array.from(items).reduce((prev, item) => {\n                return item.value === '' ? prev : prev += 1;\n            }, 0);\n            console.log(i);\n            if (i != items.length) {\n                return alert('输入内容不能为空');\n            }\n            let obj = {\n                name: info.children[1].value,\n                age: info.children[3].value,\n                gender: info.children[5].value,\n                grade: info.children[7].value,\n                major: info.children[9].value\n            }\n            console.log(obj);\n            //更新数据\n            arr.push(obj);\n            //重置表单\n            info.reset();\n            //信息本地存储\n            localStorage.setItem('info', JSON.stringify(arr));\n            //调用渲染函数\n            render();\n        });\n        function render() {\n            tbody.innerHTML = '';\n            let trArr = arr.map((item, index) => {\n                return `<tr>\n                    <td>${index + 1}</td>\n                    <td>${item.name}</td>\n                    <td>${item.age}</td>\n                    <td>${item.gender}</td>\n                    <td>${item.grade}</td>\n                    <td>${item.major}</td>\n                    <td><a href=\"javascript:\">删除</a></td>\n                </tr>`\n            });\n            tbody.innerHTML = trArr.join('');\n            infoNum.innerHTML = `共有${arr.length}条数据`;\n        }\n        //删除，事件委托\n        tbody.addEventListener('click', (e) => {\n            let target = e.target;\n            if (target.tagName === 'A') {\n                let num = e.target.parentNode.parentNode.firstElementChild.innerHTML\n                //拿到序号，删除一个\n                let tf = confirm(`确认删除第 ${num} 个学生信息吗？`);\n                if (tf) {\n                    arr.splice(num - 1, 1);\n                    localStorage.setItem('info', JSON.stringify(arr));\n                    render();\n                }\n            }\n        });\n        function infoInit() {\n            //先获取本地数据\n            let info = JSON.parse(localStorage.getItem('info'));\n            if (info) {\n                arr = info;\n            }\n            render();\n        }\n        //初始化\n        infoInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 注册界面\n\n<a href=\"/dom/reg.html\" target=\"_blank\">注册界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .reg-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .reg-box .reg-title {\n            width: 100%;\n            text-align: center;\n            margin: 15px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .reg-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .reg-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .reg-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"reg-box\">\n        <div class=\"reg-title\">新用户注册</div>\n        <form class=\"reg-form\">\n            <div class=\"form-item\">\n                <input name=\"uname\" type=\"text\" placeholder=\"设置用户名\" maxlength=\"12\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <div class=\"code-box\">\n                    <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\">\n                    <div class=\"msg\"></div>\n                    <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                </div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"password\" type=\"password\" placeholder=\"输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item\">\n                <input class=\"password-again\" type=\"password\" placeholder=\"再次输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n            <button class=\"reg-submit\">提交</button>\n        </form>\n    </div>\n\n    <script>\n        const code = document.querySelector('.code-box .code');\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', () => {\n                if (code_flag) {\n                    //存入点击发送验证码时的时间戳\n                    localStorage.setItem('code_time', new Date().getTime());\n                    code_flag = false;//可以点击\n                    code_limit_time();\n                    //这里就可以去做请求短信接口\n                }\n            });\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //输入框验证函数\n        function input_verification(input, rex, msg) {\n            let div = input.nextElementSibling;\n            if (rex.test(input.value)) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = msg;\n                return false;\n            }\n        }\n\n        // 输入框内容检查\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        const code_input = document.querySelector('.form-item input[name=\"code\"]');\n        const password = document.querySelector('.form-item input[name=\"password\"]');\n        const password_again = document.querySelector('input.password-again');\n        const agree = document.querySelector('.agree-check .agree');\n        //用户名验证\n        function inspect_uname() {\n            return input_verification(uname, /^\\w{4,12}$/g, \"4到12位用户名，只能包含数字、字母、下划线\") ? true : false;\n        }\n        //手机号验证\n        function inspect_phone() {\n            return input_verification(phone, /^1[3-9][0-9]{9}$/g, \"11位手机号\") ? true : false;\n        }\n        //检查验证码是否是6位数字\n        function inspect_code() {\n            return input_verification(code_input, /^\\d{6}$/g, \"6位数字验证码\") ? true : false;\n        }\n        //密码验证，开头必须是字母，6到20位\n        function inspect_password() {\n            return input_verification(password, /^(?=.*[a-z])(?=.*\\d)[a-z\\d]{6,20}$/gi, \"6到20位密码，必须包含数字和字母\") ? true : false;\n        }\n        //验证两次密码输入是否相同\n        function inspect_password_again() {\n            let div = password_again.nextElementSibling;\n            if (password_again.value === password.value) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"两次密码不一致\";\n                return false;\n            }\n        }\n        // 检查协议是否同意\n        function inspect_agree() {\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        //监听各个输入框内容是否改变\n        uname.addEventListener('change', () => {\n            inspect_uname();\n        });\n        phone.addEventListener('change', () => {\n            inspect_phone();\n        });\n        code_input.addEventListener('change', () => {\n            inspect_code();\n        });\n        password.addEventListener('change', () => {\n            inspect_password();\n            if (password_again.value) {\n                inspect_password_again();\n            }\n        });\n        password_again.addEventListener('change', () => {\n            inspect_password_again();\n        });\n        //密码点击查看隐藏\n        const see_psw = document.querySelectorAll('.form-item .see')\n        see_psw.forEach((item, index) => {\n            item.addEventListener('click', () => {\n                let input = item.parentNode.firstElementChild;\n                if (input.type === \"password\") {\n                    item.innerHTML = \"隐藏\";\n                    input.type = \"text\";\n                } else {\n                    item.innerHTML = \"显示\";\n                    input.type = \"password\";\n                }\n            });\n        });\n        //点击提交表单\n        const btn_submit = document.querySelector('.reg-submit');\n        const reg_form = document.querySelector('.reg-form');\n        reg_form.addEventListener('submit', (e) => {\n            //提交前再次把所有输入框检查一遍\n            if (!inspect_uname()) { e.preventDefault(); }\n            if (!inspect_phone()) { e.preventDefault(); }\n            if (!inspect_code()) { e.preventDefault(); }\n            if (!inspect_password()) { e.preventDefault(); }\n            if (!inspect_password_again()) { e.preventDefault(); }\n            if (!inspect_agree()) { e.preventDefault(); }\n        })\n        //初始化函数\n        function regInit() {\n            codeInit();\n        }\n        //执行初始化\n        regInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 登陆界面\n\n<a href=\"/dom/login.html\" target=\"_blank\">登录界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .login-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .login-box .login-title {\n            width: 100%;\n            text-align: center;\n            margin: 12px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .login-tab {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            align-items: center;\n            user-select: none;\n        }\n\n        .login-tab-line {\n            width: 1px;\n            height: 20px;\n            background: rgb(30, 110, 140);\n        }\n\n        .login-tab-item {\n            margin: 0px 10px;\n            transition: all 0.2s;\n        }\n\n        .login-tab-item.active {\n            color: #4b98db;\n        }\n\n        .login-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .login-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .login-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n\n        .login-form {\n            display: none;\n        }\n\n        .login-form.active {\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"login-box\">\n        <div class=\"login-title\">登陆</div>\n        <div class=\"login-tab\">\n            <div class=\"login-tab-item active\" data-id=\"0\">密码登陆</div>\n            <div class=\"login-tab-line\"></div>\n            <div class=\"login-tab-item\" data-id=\"1\">短信登陆</div>\n        </div>\n        <div class=\"form-box\">\n            <form class=\"login-form active\">\n                <div class=\"form-item\">\n                    <input name=\"uname\" type=\"text\" placeholder=\"用户名 / 手机号\" maxlength=\"13\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <input name=\"password\" type=\"password\" placeholder=\"密码\" maxlength=\"20\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                    <div class=\"see\">显示</div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <form class=\"login-form\">\n                <div class=\"form-item\">\n                    <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <div class=\"code-box\">\n                        <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\" required>\n                        <div class=\"msg\"></div>\n                        <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                    </div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n        </div>\n    </div>\n\n\n    <script>\n        const login_tab = document.querySelector('.login-tab');\n        const login_form = document.querySelectorAll('.login-form');\n        const code = document.querySelector('.code-box .code');\n        const agree = document.querySelector('.agree-check .agree');\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        login_tab.addEventListener('click', (e) => {\n            let class_name = e.target.className;\n            if (class_name === 'login-tab-item') {\n                document.querySelector('.login-tab-item.active').classList.remove('active');\n                e.target.classList.add('active');\n                //切换登录方式清空input\n                document.querySelectorAll('.login-form.active input').forEach((item) => {\n                    item.value = '';\n                })\n                document.querySelector('.login-form.active').classList.remove('active');\n                login_form[e.target.dataset.id].classList.add('active');\n            }\n        });\n        //短信模块\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        function codeClick() {\n            if (code_flag) {\n                //存入点击发送验证码时的时间戳\n                localStorage.setItem('code_time', new Date().getTime());\n                code_flag = false;//可以点击\n                code_limit_time();\n                //这里就可以去做请求短信接口\n            }\n        }\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', codeClick);\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //密码点击查看隐藏\n        const see_psw = document.querySelector('.form-item .see')\n        see_psw.addEventListener('click', () => {\n            let input = see_psw.parentNode.firstElementChild;\n            if (input.type === \"password\") {\n                see_psw.innerHTML = \"隐藏\";\n                input.type = \"text\";\n            } else {\n                see_psw.innerHTML = \"显示\";\n                input.type = \"password\";\n            }\n        });\n        // 检查协议是否同意\n        function inspect_agree() {\n            console.log(11);\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        function subInit() {\n            login_form.forEach((item, index) => {\n                item.addEventListener('submit', (e) => {\n                    e.preventDefault();\n                    if (!inspect_agree()) {\n                        return;\n                    }\n                    //存储用户名或手机号\n                    localStorage.setItem('user', uname.value||phone.value);\n                    //这里作跳转\n                    // location.href = '/'\n                });\n            })\n        }\n        //初始化函数\n        function loginInit() {\n            codeInit();\n            subInit();\n        }\n        //执行初始化\n        loginInit();\n    </script>\n</body>\n</html>\n\n```\n\n\n\n\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/mini-sandbox.min.js?3\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/45.js?2\"></script>\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript笔记DOM操作","url":"/article/6c6d4353.html","content":"\n# DOM简介\nHTML是一种纯文本格式的文件，也就是文档，[HTML基础笔记](/article/1475187a.html)\n\n**DOM：**Document Object Model 文档对象模型，将 HTML 文档结构化表示\n\nDOM 让网页 HTML 中的元素以树的方式呈现，并提供了访问、操控 DOM 树中各个节点的API，是为了让 JS 操作 HTML 元素而制定的一个规范，如今可看作是 JS 的一部分\n\n每个载入浏览器的 HTML 文档都会成为 Document 对象，Document 对象是 Window 对象的一部分，可通过 window.document 或 document 对其进行访问\n\n```html 获取DOM对象\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div>一个div</div>\n    <script>\n      console.log(document);\n      console.log(window.document);\n    </script>\n</body>\n</html>\n\n```\n\n控制台输出：获取到了网页所有元素，整个html文档\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/44-2.webp width=\"70%\">\n\n**DOM树：**\n网页中的一切元素都是 DOM 树中的节点\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/44-3.webp width=\"80%\">\n\n**节点类型：**\n1. **文档节点：**文档本身，整个 document 文档\n2. **元素节点：**所有 HTML 标签元素，<head> <body> <div> <span>\n3. **属性节点：**所有标签元素内的属性，id、class、href、name\n4. **文本节点：**标签元素内的文本\n5. **注释节点：**HTML中的注释，<\\!-- 注释 --\\>\n\n# 获取DOM元素\n**获取dom节点对象的方法：**\n1. `getElementById('id名')` 根据id获取**第一个dom对象**（通常id唯一）\n2. `getElementsByClassName('class类名')` 根据class名获取**dom对象数组 NodeList**\n3. `getElementsByTagName('标签名')` 根据标签名获取**dom对象数组**\n4. `getElementsByName('name名')` 根据name属性值获取**dom对象数组**，一般不用\n5. `querySelector('CSS选择器')` 查找匹配指定CSS选择器的**第一个dom对象**\n6. `querySelectorAll('CSS选择器')` 查找匹配指定CSS选择器的所有元素，返回**dom对象数组**\n\n获取到的dom对象数组都是伪数组\n\nJS获取的都是对象，使用`console.dir()`能更直观地看一个对象。\n\n## 操作元素的内容\n获取到dom对象后，通过两个**属性**就能获取、修改元素中的内容\n1. `innerText` **不解析**标签\n2. `innerHTML` **解析**标签，通常用这个\n\n使用 += 保留元素中原有内容，并在元素中末尾添加新内容\n\n## 操作元素的属性\n获取到dom对象后，直接访问**属性**（如src、href、id、class）就能进行修改或赋值。\n\n也可以使用 `getAttribute()` 和 `setAttribute()` 方法来获取和设置属性。\n\n```html\n<img src=\"1.webp\" alt=\"一张图片\">\n<script>\n  const img = document.querySelector('img');\n  img.src = \"2.webp\"\n</script>\n```\n\n## 操控元素样式\n**1、通过 style 属性控制元素样式：**css带有 - 连接符的属性，在js中采用小驼峰命名法获取\n\n```html\n<div class=\"box\"></div>\n<script>\nconst box = document.querySelector('.box');\nbox.style.background = 'blue';\nbox.style.backgroundColor = 'green';//background-color\n</script>\n```\n\n**2、通过类名控制元素样式：**直接修改style属性过于麻烦，可以先把样式写给一个类，再将类名赋给 **className** 属性，+= 保留原有类名\n\n```html\n<style>\n  .box1{\n    width: 100px;\n    height: 100px;\n  }\n  .box2{\n    width: 200px;\n    background: rgb(88, 164, 192);\n  }\n</style>\n<div class=\"box1\"></div>\n<script>\n  const box = document.querySelector('.box1');\n  box.className += ' box2';\n</script>\n```\n\n使用 += 号来保留原有class还是不够规范\n\n可以使用 **classList** 属性来添加、删除、切换(有就删除，没有就加上)类名\n\n```js\n// 添加一个类名\n元素.classList.add('类名');\n// 删除一个类名\n元素.classList.remove('类名');\n// 切换一个类名\n元素.classList.toggle('类名');\n```\n\n## 操作表单元素\ninput 标签框内的文本存放在其value属性中，获取即可\n\n```js\nconst ipt = document.querySelector('input');\nconsole.log(ipt.value);\n```\n\n操作 input 的 type 属性，来控制输入框样式\n\n```js\nconst ipt = document.querySelector('input');\nipt.type = 'password';\n```\n\n一些布尔值的属性(赋任意值都代表true)，disabled、checked、selected，添加上就有效果\n\n```js\nconst ipt = document.querySelector('input');\nipt.checked = true;\n```\n\n## 自定义属性\n**标准属性：**标签自带的属性，class、id、title等\n\n**自定义属性：**H5的新东西,以 data- 开头，格式 **data-自定义后缀** ，`对象.dataset.自定义后缀` 获取\n\n```html\n<div class=\"box\" data-id=\"123456\"></div>\n<script>\n  const box = document.querySelector('.box');\n  console.log(box.dataset.id);//123456\n</script>\n```\n\n# 定时器\n**1、间歇函数** `setInterval()` 每隔一段时间自动执行一段代码\n\n```js\nsetInterval(()=>{\n  console.log(1);\n},1000);\nsetInterval(fun,1000);\n```\n\n清除间歇函数定时器 `clearInterval()` ：\n\n```js\nvar itv = setInterval(fun,1000);\nclearInterval(itv);\n```\n\n**2、延时函数** `setTimeout()` 延时一段时间后执行代码\n\n```js\nsetTimeout(()=>{\n  console.log(1);\n},1000);\n```\n\n清除延时函数定时器 `clearTimeout()`\n\n# 事件\n**DOM事件：**在文档或浏览器窗口中产生的一系列交互，如拖动元素、点击按钮、提交表单等。\n\nJavaScript 以**事件驱动**为核心，通过监听事件或给事件绑定JS，可以在事件发生时执行特定 JS 以完成交互。\n\n{% folding, 常见事件  %}\n这里都是事件名，属性名一般在事件名前加 on\n\n**鼠标事件：**\n1. **click** 鼠标左键/键盘回车\n2. **dbclick** 双击鼠标左键\n3. **mouseenter** 光标移入元素，不冒泡\n4. **mouseleave** 光标移出元素，不冒泡\n5. **mouseover** 光标移入元素，冒泡\n6. **mouseout** 光标移出元素，冒泡\n7. **mousedown** 按下任意鼠标键\n8. **mouseup** 释放任意鼠标键\n9.  **mousewheel** 鼠标滚轮滚动\n10. **mousemove** 光标在元素上移动\n\n**用户界面事件：**\n1. **load** 页面或资源加载完成\n2. **unload** 卸载完成\n3.  **error** JS出错或资源加载失败\n4.  **select** 选中文字\n5.  **resize** 调整窗口大小\n6.  **scroll** 包含滚动条的元素\n\n**焦点事件：**\n1.  **blur** 失去焦点，不冒泡\n2.  **focus** 获得焦点，不冒泡\n3.  **focusout** 失去焦点，冒泡\n4.  **focusin** 获得焦点，冒泡\n\n**键盘和输入事件：**\n1. **keydown** 按下键盘某个键\n2. **keyup** 释放键盘某个键\n3. **input** 当输入框文本改变时立即触发\n4. **change** 当输入框内容发生改变,失去焦点时触发\n5. **textInput** 文本输入\n\n**HTML5事件：**\n1. **contextmenu** 右键菜单\n2. **beforeunload** 页面卸载之前\n3. **DOMContentLoaded** DOM树构建完成\n4. **readystatechange** 加载状态变化\n5. **hashchange** URL散列值变化\n\n{% endfolding %}\n\n**事件的三要素：**事件源、事件、事件驱动程序\n\n**事件源：**触发事件的元素，获取事件源，即获取DOM节点\n**事件：**JS定义的各种事件\n**事件驱动程序：**触发事件后进行的操作\n\n## 事件监听\n使用 `addEventListener` 监听事件\n\n```js\n元素对象.addEventListener('事件类型', 执行的函数)\n```\n\n可以重复绑定。\n\n## 事件对象\n事件对象存放了事件触发时的相关信息，如鼠标点击的位置坐标、键盘按下了哪个键\n\n事件绑定的回调函数的第一个参数就是事件对象event、e\n\n```js\n元素.addEventListener('事件',(e)=>{\n  console.lig(e);\n});\n```\n\n**事件对象常见属性：**\n1. **type** 当前事件类型\n2. **clientX 、 clientY** 获取光标相对于浏览器可见窗口左上角的位置\n3. **offsetX 、 offsetY** 获取光标相对于当前DOM元素左上角的位置\n4. **key** 当前按下的键盘键的值\n\n```js 监听是否按下回车\nconst ipt = document.querySelector('input');\nipt.addEventListener('keyup', (e)=>{\n  if(e.key == 'Enter'){ console.log('回车'); };\n});\n```\n\n## 常用事件\n**1、焦点事件 focus blur** 见案例-搜索框下拉栏\n\n**2、键盘事件 keydown keyup input** 见案例-评论发布、字数统计\n\n**3、mouseover 与 mouseenter**\nmouseover/mouseout 有冒泡效果，mouseenter/mouseleave 没有冒泡效果\n\n使用mouseover，有冒泡效果，所以鼠标从监听的元素到其子元素，虽然子元素没用绑定鼠标进入事件，但该事件会冒泡到父元素的同名事件，所以也会触发进入\n\n通常用 mouseenter/mouseleave\n\n**4、加载事件 load、DOMContentLoaded**\n**load** 监听某个元素内的所有资源（dom、css、img）加载完毕\n\n```js\n//等待页面所有资源加载完毕，再执行回调函数\nwindow.addEventListener('load', ()=>{})\n//等待图片加载完毕\nimg.addEventListener('load', ()=>{})\n```\n\n**DOMContentLoaded** 监听HTML文档加载完毕该事件就被触发，不等待css等其它资源\n\n```js\ndocument.addEventListener('DOMContentLoaded', ()=>{})\n```\n\n**5、滚动事件 scroll**\n当某个元素的滚动条滚动时，触发该事件，不冒泡\n\n通常配合元素的 **scrollTop** 和 **scrollLeft** 两个属性，获取的是**数字型**，不带单位，但意思是像素px，可读写，可让js去控制滚动\n\n```js\n//整个页面卷去的高度，document.documentElement获取html标签\ndocument.documentElement.scrollTop\n//元素被卷去的高度\ndiv.scrollTop\n```\n\n这两个属性都用来获取被卷去的大小，即元素随着滚动超出可视窗口的大小（单位px）\n**scrollTop** 滚动条往下，元素向上移动，即获取该元素向上移动超出可视区域的高度\n**scrollLeft** 滚动条往右，元素向左移动，即获取该元素向左移动超出可视区域的宽度\n\n获取页面滚动高度的时候优先考虑使用 window.pageYOffset 然后在使用scrollTop\n\n```js\nvar _scrollLeft = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft\nvar _scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop\n```\n\n**一些小案例：**\n\n```js \nwindow.addEventListener('scroll', function () {\n    const n = document.documentElement.scrollTop\n    if (n >= 100) { // 页面滚动高度超过100px进行一些操作\n    } else { // 页面滚动高度小于100px进行恢复操作\n    }\n})\n```\n\n```js 回到顶部\nconst backTop = document.querySelector('#backTop')\nbackTop.addEventListener('click', function () {\n  // document.documentElement.scrollTop = 0\n  // window.scrollTo(x, y)\n  window.scrollTo(0, 0)\n})\n```\n\n**5、窗口尺寸变化事件 resize**\n浏览器窗口大小发生变化的时候触发的事件\n\n```js\nwindow.addEventListener('resize', ()=>{})\n```\n\n**6、移动端触摸事件 touchstart touchend touchmove**\n\n**touchstart** 手指触摸到元素时触发\n**touchend** 手指从元素离开时触发\n**touchmove** 手指在元素上滑动时触发\n\n\n## 事件流\n**事件流：**事件完整执行过程中的流动路径\n\n两个阶段：**捕获**阶段、**冒泡**阶段\n\n捕获阶段从父节点到子，冒泡阶段从子到父\n\n处理函数默认在冒泡阶段执行，从子节点到父节点，依次向上调用所有父级元素的**同名事件**。\n\n**让处理函数在捕获阶段触发：**冒泡阶段不再触发\n\n```js 传入第三个参数true\n元素.addEventListener(事件类型, 处理函数, true);\n```\n**阻止冒泡：**\n默认存在冒泡模式，子元素触发事件也会触发父级同名事件，阻止冒泡能把事件限制在当前元素内。\n\n`stopPropagation()` **阻止事件流动**传播(包括冒泡和捕获)，但不影响当前元素上其他已经注册的事件监听器执行。\n`stopImmediatePropagation()` **阻止事件流动**传播，且阻止当前元素上其他已经注册的事件监听器执行。\n\n```js\n事件对象.stopPropagation();\n```\n\n## 解绑事件\n`removeEventListener()` 对某个元素解绑某个处理函数，匿名、箭头函数无法被解绑\n\n```js\n元素.removeEventListener(事件类型, 处理函数);\nbtn.removeEventListener('click', fn);\n```\n\n## 事件委托\n**事件委托：**一种技巧，减少事件注册次数，提高程序性能。\n\n事件冒泡可以用来实现事件委托，给父元素注册事件，当触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。\n\n**案例：**当多个子元素需要注册点击事件时，可以将点击事件注册到父元素上，再由父元素的事件对象e去找被点击的子元素，`e.target` 就能找到实际触发事件的子元素，再用其className、id、tagName 来确定业务上应该要触发事件的子元素。\n\n```js\nconst ul = document.querySelector('ul');\nul.addEventListener('click', function (e) {\n    if (e.target.tagName === 'LI') {\n        e.target.style.color = 'red'\n    }\n})\n```\n\n## 阻止元素默认行为\n使用 `e.preventDefault()` 阻止元素默认行为\n\n```js 让a标签点击不跳转链接\n//<a href=\"http://www.baidu.com\">百度一下</a>\nconst a = document.querySelector('a')\na.addEventListener('click', function (e) {\n    e.preventDefault()\n})\n```\n\n# 元素的属性、方法\n获取到元素后常用的属性和方法\n## 元素的尺寸与位置\n获取元素的宽高：**clientWidth**、**clientHeight**两个属性，不包含padding、border，**offsetWidth**、**offsetHeight**包含padding、border\n\n获取窗口的宽高：`document.documentElement.clientWidth`\n\n**offsetTop**、**offsetLeft**获取元素距离自己最近一位带有定位的祖先元素的左、上位置\n\n`getBoundingClientRect()` 获取元素的大小和相对于**可视窗口**的位置，返回一个对象里面有width、height、top等属性\n\n## 元素节点操作\n**1、关系查找元素节点**，以元素节点之间的关系进行查找，父找子、子找父、找兄弟\n\n查找最近一级的**父节点**：`子元素.parentNode`\n\n查找最近一级的所有**子节点**，返回伪数组：`父元素.children`\n`firstElementChild` 第一个子节点\n`lastElementChild` 最后一个子节点\n\n**上一个**兄弟节点：`previousElementSibling`\n**下一个**兄弟节点：`nextElementSibling`\n\n**2、创建节点**\n\n`document.createElement('标签名')`\n\n**3、增加节点：**\n\n`appendChild(插入的元素)` 在指定节点的子节点列表**末尾**添加新的子节点\n\n`insertBefore(插入的元素,[放到哪个元素的前面])` 在节点的子节点列表**任意位置前**插入新的节点，默认在子节点列表的**末尾**插入\n\n**4、克隆节点**\n\n`元素.cloneNode(布尔)` 参数为true，后代节点也会被克隆，false克隆时不包含后代节点(即只克隆标签)，默认false\n\n**5、删除节点**\n\n`父元素.removeChild(子元素)` 通过父节点删除子节点\n\n\n# BOM\n**BOM** (Browser Object Model ) 是浏览器对象模型，提供了一些属性与方法\n\n## window对象\nwindow对象是一个全局对象，是BOM的顶层对象，也是js中最顶级的对象，document、alert()、console、定时器等都是其属性和方法\n\n所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法\n\nwindow对象下的属性和方法调用的时候可以省略window\n\n## location对象\nlocation拆分并保存了URL地址的各个组成部分\n\n常见属性和方法\n1. **href** 获取完整的URL地址，也可以赋值进行地址跳转\n2. **search** 获取地址中携带的参数，?后面的部分\n3. **hash** 获取地址中的哈希值，#后面的部分\n4. `reload()` 刷新当前页面，传入参数true表示强制刷新\n\n## navigator对象\nnavigator保存了浏览器的相关信息\n\n常见属性和方法\n1. **userAgent** 获取浏览器的类型、版本\n\n## history对象\nhistory管理历史记录，如前进、后退、历史记录等\n\n常见属性和方法\n1. `back()` 浏览器后退功能\n2. `forward()` 浏览器前进功能\n3. `go()` 参数1前进一个页面，-1后退一个页面，0刷新当前页面\n\n## 本地存储\n将数据存储这浏览器中，刷新页面不丢失数据，sessionStorage 和 localStorage，现在主要用**localStorage**\n\n本地存储只能存字符串或数值型\n\nlocalStorage 以**键值对**的形式存储，可以多页面共享\nsessionStorage 以**键值对**的形式存储，生命周期为关闭浏览器就消失，数据同一个页面共享\n\n新增/修改：`setItem`\n\n```js\nlocalStorage.setItem(key, value);\n```\n\n读取：`getItem`\n\n```js\nlocalStorage.getItem(key);\n```\n\n删除：`removeItem`\n\n```js\nlocalStorage.removeItem(key);\n```\n\n**存储复杂数据类型：**存一个对象\n\n由于本地存储只能存字符串，所以需要将对象先转为JSON字符串再存储，使用时再把JSON转为对象\n\n`JSON.parse()` 将数据转换为 JavaScript 对象\n`JSON.stringify()` 将 JavaScript 对象转换为 JSON 字符串\n\n```js\nconst obj = {\n    name: 'chuckle',\n    age: '19'\n}\nlocalStorage.setItem('obj', JSON.stringify(obj));\nvar obj2 = JSON.parse(localStorage.getItem('obj'));\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(3)","url":"/article/7d8b8b34.html","content":"\n# JS函数简介\n\n使用**function**关键字定义函数对象，函数的typeof类型也是**function**\n\n```js\nfunction hello(){\n    console.log('hello');\n}\nconsole.log(typeof hello)//function\nconsole.log(fun instanceof Object)//true\n```\n\n使用**函数表达式**创建**匿名函数**，即将匿名函数赋值给一个变量\n\n```js\nvar fun = function(){\n\tconsole.log(\"匿名函数\");\n};\nfun();//匿名函数\n```\n\n函数是对象，也可以new出来，但一般不用这种形式，Function里面的**参数都必须是字符串格式**\n\n```js\nvar fun = new Function('a', 'b', 'console.log(a + b);');\nfun(1,2); // 3\n```\n\n使用**return**终止函数或返回一些数据，默认返回undefined\n\n**函数名**就是整个函数，JS加载的时候，只加载函数名，不加载函数体\n\n```js\nfunction fun(){\n    console.log(\"hello\");\n};\nconsole.log(fun);//输出fun(){console.log(\"hello\");}\nconsole.log(fun());//先执行函数，再输出返回值\n```\n\n## 函数的调用\n\n**1、**调用函数可以函数名调用，可以用**call()**方法\n\n```js\nfunction fun(){ console.log('hello'); }\nfun(); // hello\nfun.call(); // hello\n```\n\n**2、**在对象中保存多个函数，通过对象的方法来调用，函数作为**对象的属性**保存，这个函数就是**对象的方法**\n\n```js\nvar obj = {\n    fun1: function(){\n        console.log(\"函数一\");\n    },\n    fun2: function(){\n        console.log(\"函数二\");\n    }\n}\nobj.fun1();// 函数一\nobj.fun2();// 函数二\n\n```\n\n**3、立即执行函数**，在定义后立即执行\n\n```js\n(function() {\n\tconsole.log('立即执行函数');\n})();\n//立即执行函数\n```\n\n**4、**通过**构造函数**调用\n\n```js\nfunction Fun() {\n\tconsole.log(\"这是一个函数\");\n}\nnew Fun();// 这是一个函数\n```\n\n**5、绑定事件函数**，触发事件后立即执行的函数\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log('点击按钮后，要做的事情');\n};\n```\n\n**6、定时函数**\n\n```js\nsetInterval(function () {\n    console.log(\"hello\");\n}, 1000);//每1000ms执行一次\n```\n\n## 形参和实参\n**形参：**函数在定义时要求传入的一些参数\n**实参：**调用函数时传入的一些参数\n\n实参将**按顺序传递**给函数中对应的形参\n\n```js\nfunction fun(a, b){//该函数需要两个形参\n    console.log(a + b);\n};\n//调用时传入两个实参\nfun(1, 2)// 3\n```\n\n实参和形参，数量可以不同，调用函数时，解析器不会检查实参的数量。\n\n**实参多余形参：**忽略多余的实参\n**实参少余形参：**没有接收到值的形参默认为undefined，undefined参与运算为NaN\n\n```js\nfunction fun(a, b){ console.log(a + b); };\nfun(1, 2)// 3\nfun(1, 2, 3)// 3\nfun(1)// NaN\n```\n\n调用函数时，解析器也不会检查实参类型，实参可以是**任意数据类型**\n\n## 类数组对象arguments\n在调用函数时，浏览器每次都会传递进两个隐含的参数：（箭头函数没有自己的this和arguments。）\n1. 函数的上下文对象 **this**\n2. 封装实参的对象 **arguments**\n\narguments是一个类数组对象（伪数组），不是一个真正的数组，除了length属性、可以通过索引获取元素之外没有任何数组属性和方法。\n\n`Array.from()`能将伪数组转为真数组\n\n```js\nfunction fun(a, b){ \n    console.log(arguments);// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    console.log(Array.from(arguments));// [1, 2]\n    console.log(typeof arguments);// object，arguments 的原型是 Object，而数组的原型是 Array\n    return a + b;\n};\nfun(1, 2);\n```\n\n**案例：**将传入的实参进行求和，无论实参的个数有多少：\n\n```js\nfunction fun() {\n    var arr = Array.from(arguments);\n    var result = arr.reduce((prev, item) => {\n        return prev + item;// 累计求和\n    }, 0);\n    return result;\n}\nvar sum = fun(0, 1, 2, 3, 4, 5, 6);\nconsole.log(sum); // 21\n\n```\n\n**arguments.callee**返回正在执行的函数\n\n```js\nfunction fun() {\n    console.log(arguments.callee);\n}\nfun();// 返回了fun这个函数对象， fun() {console.log(arguments.callee);}\n```\n\n通过**arguments**修改传入的实参\n\n```js\nfunction fun(a, b){ \n    //修改传入的最后一个参数为0\n    arguments[arguments.length-1] = 0;\n    return a + b;\n};\nconsole.log(fun(1, 2));// 1\n```\n\n# 作用域\n变量或函数的作用范围。作用域在函数定义时，就确定。\n**全局作用域**：作用于整个script标签内，或作用于一个独立的JS文件\n**函数作用域**：作用于函数部\n**块级作用域**：ES6新增，作用于一个区块{}内\n\n在全局作用域中有一个全局对象 **window**(~~和微软没有半毛钱关系~~)，它代表的是浏览器的窗口，由浏览器创建。\n\n创建的**全局变量**都会作为 window 对象的**属性**保存。\n创建的**全局函数**都会作为 window 对象的**方法**保存。\n\n变量如果未经声明(没有var、let、const)就赋值，是**全局变量**\n\n```js\nvar a = 1;\n(function() {\n    var [a, b] = [0, 0];\n    console.log(a);// 0\n    console.log(window.a);// 1,访问全局变量a\n})();\nconsole.log(b);// 报错Uncaught ReferenceError:b is not defined\n```\n\n**连续赋值**时，除了第一个声明的变量之外，后面的变量都是全局变量\n\n```js\nfunction fun(){\n    var a = b = 1; // 连续赋值，a是函数作用域变量，b是全局变量\n}\nfun();\nconsole.log(a);// 报错Uncaught ReferenceError: a is not defined\nconsole.log(b);// 1\n```\n\n\n## 变量、函数提升\n\n**全局作用域的预处理：**JS在解析代码之前，将当前 JS 代码中所有变量的定义和函数的定义，放到所有代码的最前面，先进行声明但不进行赋值，默认都是undefined。\n\n任何变量，如果**未经声明**(没有var、let、const)就赋值，此变量是属于 window 的属性，而且**不会做变量提升**\n\n```js\nconsole.log(a);//undefined\nvar a = 1;\n\nconsole.log(b);//报错Uncaught ReferenceError:b is not defined\nb = 1;//赋值但没定义，相当于window.b，不进行变量提升\nconsole.log(b);//1\n```\n\n其它作用域也有类似的预处理，这就是**变量提升**，即将变量声明提升到它所在作用域的最开始的部分。\n\n**函数的声明提前（函数提升）：**\n使用**函数声明**的形式创建的函数**function fun(){}**，**会**被函数提升，可以提前调用函数，能正常执行。\n使用**函数表达式**创建的函数**var fun = function(){}**，**不会**被函数提升，但属于变量提升，不能提前调用，会被认为不是一个函数。\n\n函数的形参就相当于在函数作用域中声明了变量。\n\n```js\nconsole.log(fun1(1, 2));// 3，提前调用可以正常执行函数\nfunction fun1(a, b){ return a + b; }\n\nfun2();//报错Uncaught TypeError: fun2 is not a function\nvar fun2 = function(){}\n```\n\n**函数提升优先于变量提升**\n\n```js\nfun(); // 先函数提升，所以输出B\n\n// 函数提升\nfunction fun() {\n  console.log('B');\n}\n\nconsole.log(fun);// ƒ fun() {console.log('B');}\n\n// 变量提升，此时相当于重新声明fun变量\nvar fun = function () {\n  console.log('A');\n};\n\nfun(); // A\n\n```\n\n**函数的嵌套：**会出现**作用域链**，在嵌套函数中，变量会从内到外逐层寻找它的定义（查找时，采用就近原则）。\n\n```js\nvar a = 0;\n\nfunction fn() {\n    // 外部函数\n\n    fun();//函数提升，提前调用也正常执行\n    function fun() {\n        // 内部函数\n        console.log(a);//先找到var  a = 1\n        //输出undefined，因为实际代码中变量的调用在变量声明之前，属于变量提升，默认值为undefined\n    }\n\n    var  a = 1;\n    //fun()若内部函数在此执行，则会输出 1\n}\nfn();\n\n```\n\n# this指向\n[JavaScript的this原理--阮一峰](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)\n\n`this` 即‘当前’，指的是**函数运行时所在的环境**，它永远指向函数的真实调用者，如果没有调用者，就指向全局对象window。\n\n```js foo()绑定给多个对象\nvar a = -1;\nfunction foo(){\n    console.log(this.a);\n};\nvar obj1 = {\n    a:1,\n    foo:foo\n};\nvar obj2 = {\n    a:0,\n    foo:foo\n};\nobj1.foo();// 1\nobj2.foo();// 0\nfoo();// -1\nwindow.foo();// -1\n\n```\n\nthis在**函数调用时**绑定，函数执行时会创建一个活动记录，这个记录里包含了该函数中定义的参数，也包含函数在哪里被调用（调用栈）,this就是其中的一个属性。\n\n## 绑定规则\n1. **默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n2. **对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n3. **构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n4. **以事件绑定函数的形式调用时，this指向绑定事件的对象**\n5. **箭头函数中的this：**指向函数作用域所用的对象\n\n\n**1、默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\n\nfun();//输出 Window、0、1\nwindow.fun();//输出 Window、0、1\n//fun代码块中，this指的都是window，而a变量是全局变量，即是window的属性，所以this.a访问的是window.a\n```\n\n**2、对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;// 先把对象中的a值改为0\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun//将fun绑定给obj对象的fun属性，此时fun的this指向obj这个真实调用者\n}\nobj.fun();//输出 obj对象{a: 1, fun: ƒ}、0、1\n\n```\n\n**多层对象**时，内部方法this指向离被调用函数最近的对象\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj1 = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun,//将fun绑定给obj1对象的fun属性\n    obj2: {\n        a: 2,\n        fun: fun\n    }\n}\nobj1.fun();//输出 obj1对象{a: 0, obj2: {…}, fun: ƒ}、1，2\nobj1.obj2.fun();//输出 obj2对象{a: 0, fun: ƒ}、2，3\n\n```\n\n上面代码中，若obj2中没有a属性，this.a是undefined，即无论对象嵌套多少层，this只会指向**直接调用该函数**的对象（离被调用函数最近的对象）\n\n**this永远指向函数的真实调用者**\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 2;\n    this.foo = fun2;\n}\nfunction fun2() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: new fun().foo\n}\nobj.fun();// 1，多次引用的传递，实际上是obj调用了fun2\n\n```\n\n**隐式绑定的丢失:**通过赋值，导致隐式绑定的丢失。\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: fun\n}\nobj.fun();// 1\nvar foo = obj.fun;\nfoo();// 0\n\n```\n\n上面代码中，obj的fun属性引用了fun函数的引用内存地址，在obj.fun()调用函数时，fun函数中的this会动态绑定对象(当前函数的直接调用者，即obj对象)，将obj.fun的引用地址赋值给了foo那么foo也引用了fun函数的引用内存地址，使用foo()时，fun函数中的this也会动态绑定对象(当前函数的直接调用者，即window对象)。\n\n**3、构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n\n```js\nfunction Fun(name, age){\n    this.name = name;// 让构造函数创建的实例对象中的name属性等于传入的实参name\n    this.age = age;\n}\nvar fun = new Fun('chuckle', 19);\nconsole.log(fun);//Fun {name: 'chuckle', age: 19}\nconsole.log(typeof fun);// object构造函数返回创建的对象\n```\n\n**4、以事件绑定函数的形式调用时，this指向绑定事件的对象**\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log(this);//this指向带有btn id的整个标签\n    //<button id=\"btn\"></button>\n};\n\n```\n\n**5、箭头函数中的this：**指向函数作用域所用的对象\n\n**箭头函数的重要特征**：箭头函数**没有**自己的this和arguments，但它会继承自己**定义时**所处的**外层执行环境的this指向**，指向当前**定义时所在的对象**，call()、apply()、bind()等方法**无法改变**箭头函数继承的this指向。\n\n简单地说，箭头函数会找它的上一级作用域。如果父级作用域还是箭头函数，就再往上找，一层层找，直到找到this指向的对象\n\n```js\nvar obj = {\n    a: 1,\n    fun: ()=>{\n        console.log(this);\n    }\n}\n//obj是一个全局变量，fun是一个箭头函数，在定义时指向这个全局变量的作用域，即window对象\nobj.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n多层对象时，仍然指向最外部对象定义时所在的环境\n\n```js\nvar obj1 = {\n    a: 1,\n    obj2: {\n        a: 2,\n        fun: ()=>{\n            console.log(this);\n        }\n    }\n}\n//obj2是obj1的属性，obj是一个全局变量，所以定义时箭头函数this仍然指向window对象\nobj1.obj2.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n用构造函数创建对象，创建出来的对象中的箭头函数和普通函数，都指向构造函数创建出来的对象，但一个是在定义时指向obj对象，一个是在调用时指向obj对象\n\n```js\nfunction foo(){\n    console.log(this);\n}\nfunction Fun(){\n    this.fun = ()=>{\n        console.log(this);\n    };\n    this.foo = foo;\n}\nvar obj = new Fun();\nobj.fun();//Fun {fun: ƒ, foo: ƒ}\nobj.foo();//Fun {fun: ƒ, foo: ƒ}\nconsole.log(typeof obj);// object\n\n```\n\n**普通函数中的箭头函数：**\n\n箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量window。\n\n或者说，**普通函数中的箭头函数的this被绑定到该函数执行的作用域上**\n\n```js\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n        //对象内部方法的this指向调用此方法的对象\n\t\tvar b = this.birth;// 1990\n        //箭头函数的this就是这个外层的普通函数的this，所以在定义时就指向obj\n\t\tvar fn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\n\n```\n\n```js\nvar birth = 2000\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n\t\tfn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\nvar foo = obj.getAge;//发生隐式绑定的丢失，函数的作用域从obj对象变为全局window\nfoo();// 23，\n\n```\n\n## 改变this指向的方法\nJS在Function的porpertype属性上提供了3个方法来强行修改**函数内部**的this指向，不想改变this指向则**传入null或this**，这三个方法都**不会改变原函数的指向（动态的）**\n\n1. `call()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n2. `apply()`：传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n3. `bind()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**（一个改变了this指向和已经传入了参数的新函数）\n\n**1、`call()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n\n```js 语法\nfun.call(想要将this指向的对象, 函数实参1, 函数实参2);\n```\n\n通过call()调用函数，不改变指向\n\n```js\nvar a = 1;\nfunction fun() {\n    console.log(this);// window\n    console.log(this.a);\n}\n//将this的指向又传给this，指向没有被改变\nfun.call(this); // 1\nfun(); // 1\nfun.call(); // 1\nfun.call(window); // 1\nfun.call(null); // 1\n\n```\n\n通过call()改变this指向\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun() {\n    console.log(this);\n    console.log(this.a);\n}\nfun(); // window 1\nfun.call(obj); // obj 0\n\n```\n\n**2、`apply()`：**传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n\n```js 语法\nfun.apply(想要将this指向的对象, [函数实参1, 函数实参2]);\n```\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n};\n\nfunction fun(name) {\n    console.log(this);// 输出obj对象{name: 'chuckle', age: 19}\n    console.log(this.name);//chuckle\n    this.name = name;//改变obj的name属性为传入的实参\n    console.log(this.name);//qx\n}\n\nfun.apply(obj, ['qx']);//传一个实参，也需要传数组\nconsole.log(obj);//{name: 'qx', age: 19},name被改变\n\n```\n\n通过apply()求数组的最大值：\n\n数组本身没有求最大值的方法，但是数学对象中有**Math.max**(数字1，数字2...)，apply可以传入一个数组作为其参数，不改变其指向即可\n\n```js\nvar arr = [4, 2, 6, 5];\nvar maxValue = Math.max.apply(this, arr);// 不改变执行，传入一个数组作为参数\nconsole.log(maxValue);// 6\n```\n\n**3、`bind()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun(a) {\n    console.log(this.a + a);\n}\nvar result = fun.bind(obj, 10); //返回指定this和指定实参的原函数拷贝\nconsole.log(typeof result);// function\nresult(10);// 10\nresult(20);// 10\n\nvar result = fun.bind(obj);\nresult(10);// 10\nresult(20);// 20\n\n```\n\n# 内存回收机制\nJS具有内存自动回收机制，周期性的找出不再继续使用的变量，然后释放其占用的内存。\n\n在闭包中，如果引用了外部的变量，则无法进行释放和回收，造成**内存泄漏**\n\n**常见内存泄漏：**全局变量、闭包、Dom元素的引用、定时器\n\nIE回收不了闭包里面引用的变量，但2023年了，主流浏览器都能回收闭包内不再使用的变量，[js闭包测试--司徒正美](https://www.cnblogs.com/rubylouvre/p/3345294.html)\n\n```js\nfor(let i = 0; i < 5; i++) {\n//for循环中是块级作用域，每执行一次循环，j就会被自动回收，所以不会报错（const 不能重新赋值）\n  const j = '局部变量'\n  console.log(j);\n}\n```\n\n# 闭包\n如果**外部作用域**有权访问另外一个**函数内部的局部变量**时，那就产生了**闭包**。这个内部函数称之为**闭包函数**\n\n**函数**和**函数内部能访问到的变量**的总和，就是一个闭包。\n\n闭包是JS函数作用域的副产品，因为JS的函数内部可以使用函数外部的变量。\n\n**闭包的生命周期:**\n**产生：**内部函数被声明时就产生了。\n**死亡：**嵌套的内部函数成为垃圾对象时。（比如fun = null，就可以让 fun 成为垃圾对象）\n\n**闭包的作用：**将函数内部的变量(局部变量)能被外部访问，隐藏一些变量，延长局部变量的生命周期\n\n```js\nfunction fun1() {\n  let a = 10;\n  return function fun2() {\n    console.log(a);\n  };\n}\n//获取到一个能访问fun1内部的变量的函数\nvar result = fun1();\n//在fun1函数的外部，执行了内部函数fun2，并访问到了fun1的内部变量a\nresult();// 10\n\n```\n\n上面的代码中，通过一些操作，让外部作用域（即全局作用域）有权访问函数fun1中的局部变量，在fun1中就产生了闭包，函数fun1是闭包函数，闭包是fun2和fun2所能访问到的变量a。\n\n**延长局部变量的生命周期：**\n\n```js\n// fun1执行完一次，局部变量就立即销毁，下次调用a还是0;\nfunction fun1() {\n  let a = 0;\n  a++;\n  console.log(a);\n}\nfun1();// 1\nfun1();// 1\n\n// 由于产生了闭包，fun2函数还要继续调用变量a，所以fun1函数中的变量a不会立即销毁，仍然保留在内存中。\n// 只有等所有函数把变量a调用完了，变量a才会销毁。\nfunction fun1() {\n  let a = 0;\n  function fun2() {\n    a++;\n    console.log(a);\n  };\n  return fun2;\n}\nvar result = fun1();\nresult();// 1\nresult();// 2\n\n```\n\n**隐藏一些变量：**\n\n打游戏时通常有血条和蓝条，我们当然不希望用户window.blood就能修改血量。将血量变量blood放进匿名函数中，在函数内部去声明一些修改血量的代码再赋给全局变量，就能在匿名函数外部通过这些函数去修改血量，但不能直接访问血量。\n\n```js\n!function(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    window.reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    window.increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    window.checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n}();\n// 先连续扣血\nreduceBlood();// 血量还有9\nreduceBlood(5);// 血量还有4\n//再加血\nincreaseBlood();// 血量还有5\nincreaseBlood(5);// 血量还有10\n//查询血量\ncheckBlood(); // 血量还有10\n\n```\n\n**封装JS模块:**定义具有特定功能的JS模块，将所有的数据和功能都封装在一个函数内部，只向外暴露指定的对象或方法。模块的调用者，只能调用模块暴露的对象或方法来实现对应的功能\n\n如果不想将这三个函数直接赋给全局变量，也可以让函数返回一个装有三个方法的对象\n\n```js\nfunction Blood(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    const reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    const increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    const checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n    // 返回一个对象，包含三个方法\n    return {\n        reduceBlood: reduceBlood,\n        increaseBlood: increaseBlood,\n        checkBlood: checkBlood\n    }\n};\n\nvar figure1 = new Blood();\nvar figure2 = new Blood();\n\nfigure1.checkBlood(); // 血量还有10\nfigure2.checkBlood(); // 血量还有10\n\n//可以看到，figure1和figure2是独立的,两个闭包函数是互不影响\n//减少1的血量不会减少2，血量不会互相干扰\nfigure1.reduceBlood(5);// 血量还有5\nfigure2.reduceBlood();// 血量还有9\n\n// 人物死亡需要重新创建角色，记得回收闭包\n// figure1 = null;\n\n```\n\n# 面向对象概述\nJava中已经学习过了什么是面向对象,这里不再扯概念。\n\nJS是基于**原型**的面向对象，JS中的对象（Object）是依靠**构造器**（constructor）和**原型**（prototype）构造出来的\n\n在ES6中，新引入了**类**（Class）和**继承**（Extends）来实现面向对象\n\n**面向对象的编程思想：**对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口\n\n调用对象的属性：`obj.name`或`obj['name']`\n\n## 对象的创建\n**创建对象：**\n\n**1、对象字面量{}**\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    obj2: {\n        a: 1,\n        b: 2\n    },\n    foo: function(){\n        console.log(`我的名字${this.name}`);\n    }\n}\nobj.foo();// 我的名字chuckle\nconsole.log(obj.name);// chuckle\nconsole.log(obj['name']);// chuckle\n\n```\n\n**2、工厂模式 new Object()** 大量创建同种对象\n\n```js\nfunction createPerson(name, age) {\n    //创建一个新的对象\n    var obj = new Object();\n    //向对象中添加属性\n    obj.name = name;\n    obj.age = age;\n    return obj;// 返回这个对象的引用\n}\n\nvar obj1 = createPerson('chuckle', 19);// {name: 'chuckle', age: 19}\nvar obj2 = createPerson('qx', 18);// {name: 'qx', age: 18}\n// 所以创建的对象都是 Object 这个类型\nconsole.log(typeof obj1);// object\nconsole.log(typeof obj2);// object\n\n```\n\n**3、构造函数**\n\n```js\nfunction Person(name, age) {\n    //构造函数中this指的是当前对象实例\n    this.name = name;\n    this.age = age;\n    this.foo = function () {\n        console.log(this.name);\n    };\n}\n\nvar p1 = new Person('chuckle', 19);\nconsole.log(p1);// Person {name: 'chuckle', age: 19, foo: ƒ}\nconsole.log(typeof p1);// object\np1.foo();// chuckle\n\n```\n\n## 构造函数\n**构造函数：**是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。\n\n创建构造函数时，里面的属性和方法前必须加this，this就表示当前要构造的对象。\n\n普通函数是直接调用，而构造函数需要使用 new 关键字来调用。\n\n**构造函数的执行流程：**\n1. 立刻创建一个对象\n2. 将新建的对象设置为函数中this，使得在构造函数中可以使用this来引用新建的对象\n3. 遂行执行函数中的代码，给这个新对象添加属性和方法\n4. 将新建的对象作为返回值返回(构造函数中无需return)\n\n```js\n// 构造函数\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nvar stu = new Student('chuckle');// Student {name: 'chuckle'}\n\n//上面的代码相当于：\nfunction Student(name) {\n    var obj = new Object();\n    obj.name = name;\n    return obj;\n}\nvar stu = Student('chuckle');// {name: 'chuckle'}\n\n```\n\n**静态成员和实例成员：**\n**1、静态成员**:构造函数本身上添加的成员，静态成员只能通过构造函数访问，不能通过对象访问\n**2、实例成员**:构造函数内部通过this添加的成员，实例成员只能通过实例化的对象进行访问\n\n```js\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nStudent.sName = 'qx';// 添加静态成员\nvar stu = new Student('chuckle');// 通过构造函数创建实例对象\n// 实例成员只能通过实例化的对象进行访问\nconsole.log(stu.name);// chuckle\nconsole.log(Student.name);// Student,函数的name是它的函数名\n// 静态成员只能通过构造函数访问，不能通过对象访问\nconsole.log(stu.sName);// undefined\nconsole.log(Student.sName);// qx\n\n```\n\n**类、实例**\n使用**同一个**构造函数创建的对象，都称为一类对象，也将**构造函数称为类**。通过一个构造函数创建的对象，称为该**类的实例**。\n\n使用 **instanceof** 可以检查一个对象是否为一个类的实例。\n\n```js\nfunction Person() {}\nfunction Dog() {}\nvar person = new Person();\nvar dog = new Dog();\n\nconsole.log(person instanceof Person); // true\nconsole.log(dog instanceof Person); // false\n//所有的对象都是Object的实例，所有类都是Object的子类。\nconsole.log(person instanceof Object); // true\n\n```\n\n## 对象的基本操作\n1. **向对象中添加属性：**`对象.属性名 = 属性值`\n2. **获取对象中的属性：**`对象.属性名`\n3. **修改对象的属性值：**`对象.属性名 = 新值`\n4. **删除对象的属性：**`delete 对象.属性名`\n5. **in 运算符：**`属性名 in 对象`检查一个对象中是否含有指定的属性\n\n```js\nvar obj = {};// 创建\nobj.name = 'chuckle';// 添加\nconsole.log(obj.name);// chuckle\nobj.name = 'qx';// 修改\nconsole.log(obj.name);// qx\ndelete obj.name;// 删除\nconsole.log('name' in obj);// false\n```\n\n## 遍历对象\n遍历对象时，要根据对象的结构配合使用多种方法，通常还需要配合数组的遍历方法\n\n**1、`for-in`遍历对象的属性，再使用**`对象[属性名]`**获取属性值**\n\n**for-of**用于遍历数组的元素，直接获取元素。\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\nfor(let i in obj){\n    //第一层循环获取student和teacher两个属性\n    console.log(i);//输出属性名\n    //obj[i]获取属性值，是数组，遍历数组使用for-of，虽然用for-in也行，这里都作展示\n    for(let j of obj[i]){\n        console.log(`${j.name}:${j.age}`);\n    }\n    // for(let j in obj[i]){\n    //     console.log(`${obj[i][j].name}:${obj[i][j].age}`);\n    // }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**2、`Object.keys`返回对象自身属性名组成的数组，`Object.values`返回对象自身属性值组成的数组**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.keys(obj).forEach((key) => {\n    console.log(key);//输出属性名\n    obj[key].forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\nObject.values(obj).forEach((value) => {\n    value.forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n\nchuckle:19\nqx:18\n张三:37\n李四:35\n```\n\n**3、`Object.entries()`返回Object.keys与Object.values的结合体，一个嵌套的数组，数组内包括了属性名与属性值，下标0存储属性名**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.entries(obj).forEach((item)=>{\n    console.log(item[0]);//输出属性名\n    //属性值仍是数组，接着遍历，数组中存着对象，直接去访问对象的属性拿到属性值输出\n    item[1].forEach((item)=>{\n         console.log(`${item.name}:${item.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**4、`Object.getOwnPropertyNames()`与Object.keys差不多**，不同的是会返回对象的所有属性，包括了不可枚举属性，如数组对象的length\n\n**5、`Object.getOwnPropertySymbols()`返回对象内的所有Symbol属性的数组**，对象初始化的时候，内部不包含任何Symbol属性\n\n## 对象访问器\nJS提供了Getter（**get**关键字）和 Setter（**set**关键字） 来定义对象访问器（属性访问器）\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    get getAge() {\n        return this.age;\n    },\n    set setAge(age) {\n        this.age = age;\n    }\n}\nconsole.log(obj.getAge);// 19\nobj.setAge = 20;\nconsole.log(obj.getAge);// 20\n\n```\n\n使用 getter 和 setter 可以确保更好的**数据质量**，一些会随时间而变等的属性（如年龄），实际无需静态地存储在对象中，且可以对数据进行加工处理，类似数据库中的视图的功能\n\n```js\nvar obj = {\n    name: 'chuckle',\n    birthYear: 2003,\n    get age() {\n//年龄不适合直接存储在对象中，我们可以存储生日，而年龄属性则作为一个getter进行处理后再返回\n        return  new Date().getFullYear() - this.birthYear;\n    },\n//如果去修改年龄，实际上应该修改birth出生年份\n    set age(age) {\n        this.birthYear = new Date().getFullYear() - age;\n    }\n}\nconsole.log(obj.age);// 20，对象中实际上没有age\nobj.age = 19;\nconsole.log(obj.age);// 19\nconsole.log(obj.birthYear);// 2004\n\n```\n\n# Object对象\nJavaScript中的对象其实就是一组数据和功能的集合。\n\n**Object对象**是所有对象的祖宗，其他对象都继承自Object，即其它对象都是Object的实例\n\n每个Object类型的实例**共有的属性和实例方法**（定义在Object原型对象Object.prototype上的方法。可以被Object实例直接使用）：\n1. **constructor：**保存用于创建当前对象的构造函数。\n2. **\\_\\_proto\\_\\_：**隐式原型，指向的Object原型对象（父对象，所有类型的对象都有这个属性）\n3. **`hasOwnProperty()`：**检测实例中是否有指定属性。\n4. **`isPrototypeOf()`：**判断传入的对象是否是当前对象的原型\n5. **`propertyIsEnumerble()`：**检查指定属性能否使用for-in来枚举遍历\n6. **`toLocaleString()`：**返回对象的字符串表示\n7. **`toString()`：**返回对象的字符串表示\n8. **`valueOf()`：**返回对象本身\n   \n**静态方法：**直接定义在Object对象的方法，`Object.`直接调用\n\n**控制对象状态的方法：**\n1. **`preventExtensions()`：**防止对象扩展\n2. **`isExtensible()`：**判断对象是否可扩展\n3. **`seal()`：**禁止对象配置\n4. **`isSealed()`：**判断一个对象是否可配置\n5. **`freeze()`：**冻结一个对象\n6. **`isFrozen()`：**判断一个对象是否被冻结\n\n**对象属性模型的相关方法**\n1. **`keys()`：**返回对象自身属性名组成的数组\n2. **`getOwnPropertyNames()`：**与keys()差不多，但返回对象所有属性的数组，包括了不可枚举属性，如数组对象的length\n3. **`getOwnPropertyDescriptor()`：**获取某个属性的描述对象，参数(对象,属性名的字符串)\n4. **`defineProperty()`：**通过描述对象，定义或修改某个属性。给对象添加一个属性并指定该属性的配置\n5. **`defineProperties()`：**通过描述对象，定义多个属性。\n6. **`hasOwn()`：**判断是否为自身的属性\n\n**原型链相关方法**\n1. **`is()`：**比较两个值是否严格相等，严格比较\n2. **`create()`：**指定原型对象和属性，返回一个新的对象\n3. **`values()`：**返回对象自身属性值组成的数组\n4. **`entries()`：**返回一个数组，元素是对象自身的（不含继承的）所有可遍历属性的键值对数组\n5. **`fromEntries()`：**将一个键值对数组转为对象。\n6. **`assign()`：**对象的合并，复制一个或者多个对象来创建一个对象，浅拷贝，将源对象的所有可枚举的自身属性，复制到目标对象\n7. **`getPrototypeOf()`：**获取对象的原型对象(Prototype对象)\n8. **`setPrototypeOf()`：**设置对象的原型对象\n\n`Object.keys(obj).length`获取对象的长度\n\n`Object.prototype.toString.call()`可以在任意值(对象)上调用这个方法，以判断这个值的类型\n\n```js\n//[object Number]第一个值代表是对象，第二个值表示该值的构造函数即类型\nObject.prototype.toString.call(2); // \"[object Number]\"\nObject.prototype.toString.call(\"\"); // \"[object String]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(Math); // \"[object Math]\"\nObject.prototype.toString.call({}); // \"[object Object]\"\nObject.prototype.toString.call([]); // \"[object Array]\"\n\n```\n\n# JSON\n**JSON**（JavaScript Object Notation），即JavaScript对象表示法，它是一种**数据交换的文本格式**，使用JS语法来描述数据对象，而不是一种编程语言。\n\n大多数语言都支持对json的解析。JS中可以原生地把json转为object对象。\n\n**数据结构：**Object、Array\n**基本类型：**string，number，true，false，null(json无法表示undefined)\n\n```json\n{}//这是一个json\nnull//也可是一个json\n1//也可是一个json\n//下面也是一个json\n[\n    {},\n    {}\n]\n\n{ \n\t\"name\":\"chuckle\", \n\t\"age\":\"19\" \n}\n\n//一个常见的json\n{\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n}\n\n```\n\n对象和 json 没有长度，json.length 的打印结果是 undefined\n\n**使用for-in遍历json：**\n\n```js\n//将json存在变量中\nvar json = {\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n};\n\nfor (let i in json) {\n    console.log(i);\n    for(let j in json[i]){\n        console.log(`${json[i][j].name}:${json[i][j].age}`);\n    }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\nfor-in获取json对象的**属性**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(i);\n}\n// name\n// age\n```\n\nfor-in获取json对象的**属性的值**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(json[i]);\n}\n// chuckle\n// 19\n```\n\n前端收到的api通常也是json格式，如一言api：\n\n```json\n{\n    \"code\": 200,\n    \"type\": \"一言\",\n    \"content\": \"总觉得跟你在一起，不管多高的地方都可以到达。\"\n}\n\n```\n\n**`JSON.parse()`** 将数据转换为 JavaScript 对象\n**`JSON.stringify()`** 将 JavaScript 对象转换为字符串\n\n# Map对象\nMap对象保存键值对，元素会保持其插入时的顺序。\n\nMap的键可以是任意数据类型，包括函数、对象或任意基本类型。\n\n在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效\n\n```js 创建一个Map\nvar m = new Map();\n//或传入一个嵌套数组\nm = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n```\n\nObject与Map增删改查基本操作。\n\n```js\nvar o = {};\nvar m = new Map();\n//添加\no.x = 1;\nm.set('x', 1);\n//修改\no.x = 2;\nm.set('x', 2);\n//递增\no.x++;\nm.set('x', m.get('x')+1);\n//获取\no.x;\nm.get('x');\n//删除\ndelete o.x;\nmap.delete('x');\n\n```\n\nMap的键值对个数可以通过size属性获取\n\n```js\nvar m = new Map();\nm.set('x', 1);\nm.set('y', 2);\nconsole.log(m);//Map(2) {'x' => 1, 'y' => 2}\nconsole.log(m.size);//2\n```\n\n## Map的方法\n**基本方法：**\n1. **`get()`：**获取元素\n2. **`set()`：**设置元素\n3. **`has()`：**检查是否有指定key\n4. **`clear()`：**清空map\n5. **`delete()`：**删除指定元素\n\n**遍历方法：**\n1. **`keys()`：**提取键并返回**键**的迭代器MapIterator对象\n2. **`values()`：**提取值并返回**值**的迭代器MapIterator对象\n3. **`entries()`：**提取键值对并返回取**键值对**的迭代器MapIterator对象\n4. **`forEach()`：**传入回调函数(value, key)=>{}\n\n```js\nvar m = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n\nconsole.log(m.keys());//MapIterator {'x', 'y'}\nconsole.log(m.values());// MapIterator {1, 2}\nconsole.log(m.entries());// MapIterator {'x' => 1, 'y' => 2}\n\n//迭代器可以用for-of遍历\nfor (let [key, value] of m.entries()) {\n    console.log(key, value);//x 1, y 2\n}\n\nm.forEach((value, key) => {\n    console.log(key, value);//x 1, y 2\n})\n\n```\n\n# Set对象\n**Set**是**唯一值**的集合，与map类似，map存放的是键值对，而set只存放唯一值。\n\n**创建set对象：**\n\n```js\nvar s = new Set();\nvar s = new Set([1,2,3]);\n```\n\nset对象与数组也很像，可以互相转换\n\n```js\nvar arr1 = [1, 2, 3];\nvar s = new Set(arr1);//数组转为set对象，会去重\nvar arr2 = [...s];//set对象转为数组\n```\n\n可利用set值唯一的特性做**数组去重、并集、交集、差集**操作\n\n```js\n//1、去重\nvar s = new Set([1,2,3,3,2,1]);\nvar arr = [...s];//[1,2,3]\n\n//2、并集\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s = new Set([...arr1, ...arr2]); // {1, 2, 3, 4}\nvar arr = [...s];// [1,2,3,4]\n\n//3、交集，arr1和arr2共有的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => s2.has(x));//[2, 3]\n\n//4、差集,arr1去除arr2中的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => !s2.has(x));//[1]\n\n```\n\nSet值个数可以通过size属性获取\n\n```js\nvar s = new Set([1,2,3]);\nconsole.log(s);//Set(3) {1, 2, 3}\nconsole.log(s.size);//3\n```\n\n## Set的方法\n1. **`add()`：**添加新元素\n2. **`delete()`：**删除指定元素\n3. **`clear()`：**清空所有元素\n4. **`has()`：**判断是否存在某值\n5. **`forEach()`：**遍历每个元素，传入回调函数\n6. **`keys()`：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n7. **`values()`：**同keys()\n8. **`entries()`：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n**add()、delete()、clear()、has() ：**\n\n```js\nvar s = new Set([1,2,3]);\ns.add(4);\nconsole.log(s);//Set(4) {1, 2, 3, 4}\ns.delete(2);\ns.has(2);//false\ns.clear();\nconsole.log(s.size);// 0\n\n```\n\n**keys()、values() ：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.values();\nconsole.log(setIter);//SetIterator {1, 2, 3}\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // 2\nconsole.log(setIter.next().value); // 3\n```\n\n**entries() ：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.entries();\nconsole.log(setIter);//SetIterator {1 => 1, 2 => 2, 3 => 3}\nconsole.log(setIter.next().value); // [1, 1]\nconsole.log(setIter.next().value); // [2, 2]\nconsole.log(setIter.next().value); // [3, 3]\n```\n\n**forEach() ：**遍历每个元素，传入回调函数，参数：回调函数、thisArg执行回调函数时可以当作this来使用。\n回调函数参数：值（key）、值（value）、set对象\n\n```js\nvar s = new Set([1,2,3]);\ns.forEach((key,value,set)=>{\n    console.log(key,value);//1 1, 2 2, 3 3\n});\n```\n\n# 浅拷贝和深拷贝\n**浅拷贝：**只拷贝最外面一层的数据；更深层次的对象，只拷贝引用，浅拷贝的时候，是属于传址，而非传值。\n**深拷贝：**拷贝多层数据；每一层级别的数据都会拷贝，深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。\n\n**区分深拷贝与浅拷贝：**B复制了A，修改A，B也一样被修改是浅拷贝，B没变，是深拷贝。\n\n```js 浅拷贝举例\nvar a = [0,1,2,3];\nvar b = a;// 浅拷贝，传地址\nconsole.log(a===b);// 指向地址相同，true\na[0]=1;// 修改a\nconsole.log(b[0]);// 1，b也改变\n```\n\n通过`Object.assign()`实现浅拷贝:\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19\n};\nvar obj2 = Object.assign(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19}\nobj2.name = \"qx\";\nconsole.log(obj1.name);//qx,修改obj2，obj1也会被修改\n\n```\n\n## 实现深拷贝\n\n**通过`for-in`递归实现深拷贝**，即递归遍历整个对象，找到简单值，将值复制\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = {};\n\ndeepCopy(obj2,obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\nfunction deepCopy(newObj, oldObj) {\n    //遍历属性名或数组下标\n    for (let key in oldObj) {\n        // 获取属性值 oldObj[key]\n        let item = oldObj[key];//依次获取属性值\n        //下面进行创建属性与属性值的复制\n        if (item instanceof Array) {\n            // 判断这个值是否是数组\n            newObj[key] = [];\n            deepCopy(newObj[key], item);//递归\n        } else if (item instanceof Object) {\n            // 判断这个值是否是对象\n            newObj[key] = {};\n            deepCopy(newObj[key], item);//递归\n        } else {\n            // 简单数据类型，直接赋值\n            newObj[key] = item;\n        }\n    }\n}\n\n```\n\n通过JSON对象的**parse**和**stringify**方法实现**深拷贝**\n\n```js\nfunction deepClone(obj){\n    let str = JSON.stringify(obj);//将对象转为字符串这个基本类型\n    return JSON.parse(str);//再将字符串转为新对象，新对象与原对象就没有关系了\n}    \nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = deepClone(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\n```\n\n数组等对象的`slice()`不是完全的**深拷贝**，因为数组中存的是对象的引用地址，slice()只将地址拷贝了过去\n\n```js\nvar a = [0, 1, [1, 1, 1], 2, 3];\nvar b = a.slice();\n//修改b的第一层不影响a\nconsole.log(a[0]);// 0\nb[0] = 9;\nconsole.log(a[0]);// 0\nconsole.log(b[0]);// 9\n//修改嵌套的多层数组有影响\nconsole.log(a[2][0]);// 1\nb[2][0] = 0;\nconsole.log(a[2][0]);// 0\nconsole.log(b[2][0]);// 0\n\n```\n\n# 迭代器Iterator\n迭代以从一个数据集中按照一定的顺序，不断取出数据的过程。\n\n**迭代与遍历的区别：**\n1. 迭代强调依次取数据的过程，不保证把所有的数据都取完\n2. 遍历强调的是要把所有的数据依次全部取出\n\n迭代器是能调用`next()`实现迭代的一种对象，该方法返回一个具有两个属性的对象（value：可迭代对象迭代至此的值，done：布尔，是否已经取出所有数据）\n\n通过可迭代对象中的迭代器工厂函数`Symbol.iterator`来生成迭代器。每次生存的迭代器之间互不干扰。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nconsole.log(arrIter);// Array Iterator {}\nwhile(true){\n var next = arrIter.next();\n var value = next.value;\n var done = next.done;\n if(done){\n    break;\n }else{\n    console.log(value);// 1 2 3 4\n }\n}\n\n```\n\n迭代器对象可作为可迭代对象，**for-of**遍历可迭代对象\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    console.log(i);// 1 2 3 4\n}\n```\n\n如果可迭代对象在迭代期间被修改了，迭代器得到的结果也是修改后的。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    arr[2] = 0;\n    console.log(i);// 1 2 0 4\n}\n```\n\n当迭代到 **done: true** 时迭代器会处于一种完成但并不完成的状态，还能重复调用 next()，结果都是 **{ value: undefined, done: true }**\n\n# 正则表达式\n**正则表达式：**用某种模式去匹配一类字符串的公式，[正则表达式在线测试](https://c.runoob.com/front-end/854/)\n\n**正则表达式主体和修饰符：**\n\n```md 修饰符，修饰符用于执行区分大小写和全局匹配，顺序：/gim\ni：不区分大小写的匹配\ng：全局匹配（匹配所有匹配而非在找到第一个匹配后停止）\nm：多行匹配\n```\n\n```md 方括号 和 | ，表示或，匹配某个范围内的字符\n[abc] 匹配方括号之间的任何字符\n[^abc] 任何不在方括号之间的字符\n[0-9] 匹配 0 到 9 的数字。\n[a-z] 匹配从小写 a 到小写 z 的字符\n(aa|bb|cc) 匹配aa或bb或cc\n```\n\n```md 元字符，拥有特殊含义的字符\n.(点号) 匹配单个字符，除了换行和行结束符\n\\w 匹配数字、字母及下划线。\n\\W 匹配非单词字符\n\\d 匹配数字\n\\D 匹配非数字字符\n\\s 匹配空白字符\n\\S 匹配非空白字符\n\\b 匹配单词边界\n\\B 匹配非单词边界\n\n```\n\n```md 特殊转义符\n\\n 匹配换行符 \n\\r 匹配回车符 \n\\t 匹配制表符 \n\\f 匹配换页符 \n\\v 匹配垂直制表符 \n\\0 匹配null字符\n\\\\ 匹配\\\n\\\" 匹配 \"\n\\' 匹配 '\n\\xxx 匹配以八进制数 xxx 规定的字符\n\\xdd 匹配以十六进制数 dd 规定的字符\n\\uxxxx 匹配以十六进制数 xxxx 规定的 Unicode 字符\n\n```\n\n```md 量词，限定符，定位符\n+ 重复1次或更多次\n* 重复任意次数\n{n} 重复n次\n{n,} 重复n次或更多次（最少n次)\n{n,m} 重复n到m次\n^ 限定开始位置的字符\n$ 限定结尾位置的字符，如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式\n? 非贪婪模式，找到到第一个就不再往后匹配，正则默认贪婪匹配，在同一个匹配项中，尽量匹配更多所搜索的字符\n?=n 匹配其后有紧接指定字符串 n 的字符串\n?!n 匹配其后没有紧接指定字符串 n 的字符串\n?<=n 找到n但不匹配n\n\n```\n\n## RegExp对象\n\n在js中，正则表达式也是对象，**RegExp**是一个预定义了属性和方法的正则表达式对象\n\n```js\nvar re = /正则表达式主体/修饰符(可选);// re = /Hello/g\nvar re = new RegExp(\"正则表达式\"); // 参数是字符串\nvar re = new RegExp(\"正则表达式\", \"匹配模式\"); // 两个参数都是字符串\n```\n\n**RegExp对象的属性和方法：**\n1. **global：**\t判断是否设置了 \"g\" 修饰符\n2. **ignoreCase：**判断是否设置了 \"i\" 修饰符\n3. **multiline：**判断是否设置了 \"m\" 修饰符\n4. **lastIndex：**规定下次匹配的起始位置\n5. **source：**返回正则表达式的匹配模式\n6. **`test()`：**判断指定字符串是否符合正则规则，返回布尔\n7. **`exec()`：**返回一个数组，存放正则匹配的结果。无匹配返回 null\n8. **`toString()`：**返回正则表达式的字符串。\n\n\n`exec()`在 regexp 的属性 lastIndex 指定的字符处开始检索字符串，当它找到了与表达式相匹配的文本时，在匹配之后，它将把 regexp 的 lastIndex 属性设置为匹配文本后的第一个字符所在位置（调用test()也会改变lastIndex），可以通过反复地调用 exec() 方法来遍历字符串中的所有匹配文本，当 exec() 再也找不到匹配的文本时，它将返回 null，并且把属性 lastIndex 重置为 0\n\n**返回值：**匹配到的文本的数组，数组有四个属性，index 匹配文本第一个字符的位置，input 需匹配的原字符串，groups 当初中命名的分组时匹配到的分组对象\n\n```js\nvar str=\"Hello world! Hello china!\";\nvar re = /hello/gi;\nconsole.log(re.lastIndex);// 0\nconsole.log(re.test(str));// true\nconsole.log(re.lastIndex);// 5\nconsole.log(re.exec(str));// true\n//['Hello', index: 13, input: 'Hello world! Hello china!', groups: undefined]\nconsole.log(re.lastIndex);// 18\n\n```\n\n检查一个字符串是否是一个合法手机号\n\n以1开头（^1 表示1开头）\n第二位是3~9之间任意数字[3-9]\n三位以后任意9位数字[0-9]{9}重复9次的0-9\n\n```js\nvar str = \"15123456789\";\nvar re = /^1[3-9][0-9]{9}$/;\nconsole.log(re.test(str));// true\n```\n\n判断字符串是否为电子邮件\n\n```js\nvar str = \"916017604@qq.com\"\nvar re = /^\\w{3,}(\\.\\w+)*@[A-z0-9]+(\\.[A-z]{2,5}){1,2}$/\nconsole.log(re.test(str));// true\n```\n\n**支持正则表达式的 String 对象的方法：**\n1. **`search()`** 使用表达式来搜索匹配，然后返回匹配的位置\n2. **`replace()`** 返回模式被替换处修改后的字符串，不改变原字符串，返回替换后的字符串\n3. **`match()`** 返回匹配到的字符串的数组\n\n```js\nvar str = \"你好世界\"; \nvar n = str.match(/你好/);\nconsole.log(n[0]);// 你好\nconsole.log(str.replace(/世界/, '太阳系'));// 你好太阳系\n```\n\n```js 提取电话号码\nvar str = \"我的电话号码是15123456789\"; \nvar n = str.match(/1[3-9][0-9]{9}/);\nconsole.log(n[0]);// 15123456789\n```\n\n```js 替换url内的域名\nvar str = \"http://127.0.0.1:4000/\"; \nvar re = /(?<=(http|https):\\/\\/).+?(?=\\/)/g;\nvar n = str.replace(re, 'www.qcqx.cn');\nconsole.log(n);// http://www.qcqx.cn/\n```\n\n# 原型与原型链\n**省流：**\n原型其实就是一个对象，实例继承原型对象的属性，通过继承的这种方式，new出来的实例也有了这个属性\n\n对象的构造函数有一个 **prototype** 的属性，通过这个属性就能访问到原型\n\n对象有一个 **\\_\\_proto\\_\\_** 属性，指向构造函数的 **prototype** 的属性，所以也可以访问到原型\n\n构造函数也有 **\\_\\_proto\\_\\_** 属性，也是对象，因为所有函数都是 Function 构造的，所以都等于 Function.prototype\n\n原型也是对象，也有 **\\_\\_proto\\_\\_** 属性，通常浏览器称之为 **[[Prototype]]** ，它指向原型的原型，像单链表的next指针一样，构成原型链，直到Object构造函数，因为 Object 对象的原型 Object.prototype.__proto__ 为空null没有下一个原型了，Object.prototype是原型的终点\n\n原型与原型链其实是为了实现继承，原型就像java中的类，由构造函数构造的对象都继承了这个构造函数原型的属性和方法，当然，每个对象后续都可以添加自己的属性和方法来覆盖继承自原型的属性和方法。\n\n原型链中每个节点是构造函数的原型，每个节点有一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n普通对象也可以利用 Object.create() 作为新生成对象的原型。\n\n## 原型\n每个 JS 对象一定对应一个原型对象，并从这个原型对象继承属性和方法。\n\n**对象**只有隐式原型 **\\_\\_proto\\_\\_**\n**函数**有隐式原型 **\\_\\_proto\\_\\_** ，还有显式原型 **prototype**\n\n**对象**的 **\\_\\_proto\\_\\_** 指向 **其构造函数.prototype**，或者说 **对象.\\_\\_proto\\_\\_** 等于 **其构造函数.prototype** 保存的东西是一样的\n**函数**的 **\\_\\_proto\\_\\_** 都指向**Function.prototype**，因为所有函数都是由Function构造的，值为 ƒ(){[native code]}\n\n**函数**的 **prototype** 指向一个对象，就是通常所说的原型对象，一定有两个属性，**constructor** 指向构造函数本身，**[[Prototype]]**就是\\_\\_proto\\_\\_，它连接起一个个原型，构成**原型链**，Object 对象的原型 Object.prototype.__proto__ 为空null\n\n**两种获取对象隐式原型的方式：**对象的**\\_\\_proto\\_\\_** 属性（非标准），`Object.getPrototypeOf()`方法(标准)\n**获取显式原型：**构造函数.prototype\n\n```js\nvar obj = new Object();\nconsole.log(obj.__proto__);\nconsole.log(Object.getPrototypeOf(obj));\n//{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n//    constructor: ƒ Object()\n//    __proto__: null 原型的__proto__指向下一个原型，而Object对象的原型 Object.prototype.__proto__ 为空null\n//    原型上还有各种方法，所有Object和Object的子类都会继承这些属性和方法\n\nconsole.log(Object.__proto__);\nconsole.log(Function.prototype);\n//ƒ () { [native code] }\n\n```\n\n只有一个Object对象不够直观，新建一个构造函数，new一个Person对象\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\nconsole.log(person.__proto__);\nconsole.log(Object.getPrototypeOf(person));\n```\n\n下面的输出就是Person对象的原型，可以发现原型上并没有a属性，在构造函数中通过this直接定义实例成员，会作为实例对象的属性，而不是出现在原型上再被对象继承。\n\n```js 输出\n{constructor: ƒ}\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n这个原型上只有两个属性，我们可以在原型上添加属性和方法，所有对象都会继承这些属性和方法，哪怕是在这之前已经实例化的对象。\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\nconsole.log(Object.getPrototypeOf(person));\n```\n\n可以看到原型上出现了a属性，值为0\n\n```js 输出\n{a: 0, constructor: ƒ}\n    a: 0\n    b: 2\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n试着在实例化对象中使用继承来的a、b属性\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\n//使用继承来的a、b属性\nconsole.log(person.a);// 1\nconsole.log(person.__proto__.a);// 0\nconsole.log(person.b);// 2\n\n```\n\nperson.a 输出 1，访问的是实例成员a，也就是说对象的属性可以覆盖继承来的同名属性\n\n```js 输出\n1\n0\n2\n```\n\n再看原型中的的 constructor 属性，它指向该原型对应的构造函数，可以在控制台中展开\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/43-2.webp width=\"45%\">\n\n构成了一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n## 原型链\n原型是原型链上的节点，各个原型通过 **\\_\\_proto\\_\\_** 相连接，对象可以继承原型链上从Object构造函数开始至该对象构造函数的所有原型的属性和方法，即继承了其所有父级的所有属性和方法，且逐层可以覆盖\n\n**制造原型链：**\n\n**直接操作prototype属性：**\n\n```js\nfunction Parent(){}\nfunction Child(){\n    this.a=1;\n}\nParent.prototype.b = 2;// 在原型上添加属性\nParent.c = 0;//在构造函数上添加静态成员\n// 通过原型的__proto__连接起两个原型，表示Child继承Parent\nChild.prototype.__proto__ = Parent.prototype\n// 也可以通过setPrototypeOf设置原型的原型，来连接两个原型\nObject.setPrototypeOf(Child.prototype,Parent.prototype);\n\nvar child = new Child();\n\nconsole.log(child.a);// 1,访问实例成员\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.c);// undefined，不能通过原型链访问原型对应构造函数的静态成员\n\n```\n\n可以在控制台展开 **[[Prototype]]** 属性来查看原型链\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/43-3.webp width=\"50%\">\n\n通过 `Object.create()` 建立原型链，在Vue源码中 Object.create() 的使用频率非常高\n\n`Object.create()` 用于创建一个新对象，使用现有的对象来作为新创建对象的原型\n\n原型和普通对象都有__proto__和constructor属性，且作用都一样，利用Object.create()可以将一个普通对象作为新对象的原型\n\n```js\nfunction Parent(){\n    this.p = 0;\n}\nParent.prototype.b = 2;\nvar parent =  new Parent();\nparent.a = 1;\n\n// 使用现有的对象来作为新创建对象的原型\nvar child = Object.create(parent);\n\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.p);// 0\nconsole.log(child.a);// 1\n\n```\n\n将原型与构造函数的循环、原型与原型的链、构造函数的实例组成一张图：\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/43-4.webp width=\"100%\">\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(2)","url":"/article/c32976c2.html","content":"\n# JS对象简介\n尽管JavaScript里没有Java，但两者都是面向对象语言，按顺序学过java这部分也是大差不差。\n\n在JavaScript中，对象是一组**无序的相关属性**和**方法**的集合。\n对象中的属性均是**键值对**，属性名是键，属性值是值。\n\n**new**关键字可以创建对象的实例。\n\n```js\nvar chuckle = ['轻笑', 19, '男'];\n//虽然数组也是个对象，这js中是引用类型，但这样定义chuckle，值的表示不直观\n//使用对象来表示，结构会更清晰\nvar chuckle = {};//也可以new Object()来创建一个对象\nchuckle.name = '轻笑';\nchuckle.age = 19;\nchuckle.sex = '男';\n\nconsole.log(chuckle);\n//{name: '轻笑', age: 19, sex: '男'}\nconsole.log(chuckle.name);//轻笑\n```\n\n对象的属性值可以是任何的数据类型，也可以是个函数\n\n```js\nvar obj = new Object();\nobj.fun = function(){\n  console.log('这是一个函数');\n};\nconsole.log(obj.fun);//获取而不执行函数\nconsole.log(obj.fun());//执行函数,这是一个函数\n```\n\n对象的属性也可以是另一个对象\n\n```js\nvar obj1 = new Object(); obj1.inObj;\nvar obj2 = new Object(); obj2.name = \"一个对象\";\n//将整个obj2对象，设置为obj1的属性，保存的是对象的地址\nobj1.inObj = obj2;\nconsole.log(obj1.inObj);//{name: '一个对象'}\nconsole.log(obj1.inObj.name);//一个对象\n```\n\n对象变量保存的是对象的地址，当两个变量指向同一个对象时，两个变量都可以修改对象中的属性。\n\n**对象的分类**:\n1. **内置对象**: 由ES标准中定义的对象，如：Object、Math、Date、String、Array、Number、Boolean、Function等。\n2. **宿主对象**: 由JS的运行环境提供的对象，如浏览器提供了BOM、DOM，console、document。\n3. **自定义对象**: 开发者创建的对象。\n\n# 基本包装类型\n基本数据类型string无法绑定属性和方法，但将其转换为**基本包装类型**，就可以。\n\n```js\nvar str = '';\nstr.name = '一个字符串';//不会报错，但无法绑定\nconsole.log(str.name);//输出undefined\n```\n\n实际上，当我们对基本数据类型调用属性和方法(如str.length)时，js会自动将其临时转换为对应的基本包装类型（隐式类型转换），再调用内置方法。\n\n**基本包装类型**包括：**Number**、**Boolean**、**String**，它们都属于引用数据类型，可以绑定属性和方法。\n\n```js\nvar strObj = new String('');\nstrObj.name = '一个字符串';\nconsole.log(strObj.name);//一个字符串\n```\n\n1. `String()`：将基本数据类型字符串，转换为 String 对象。\n2. `Number()`：将基本数据类型的数字，转换为 Number 对象。\n3. `Boolean()`：将基本数据类型的布尔值，转换为 Boolean 对象。\n\n**注意**，在实际应用中一般不会使用基本数据类型的对象\n\n在底层，字符串以字符数组的形式保存\n\n```js\nvar str = 'chuckle';//保存方式[\"c\", \"h\", \"u\", \"c\", \"k\", \"l\", \"e\"]\nconsole.log(str.length);//7\nconsole.log(str[2]); //因为是数组，可以直接访问下标，字符串中的第3个字符,u\n```\n\n# 内置对象\n**内置对象**是语言自带的一些对象，提供了最基本最常用的**属性**和**方法**。\n\n**Arguments**(函数参数集合)，**Array**(数组)，**Boolean**(布尔对象)，**Math**(数学对象)，**Date**(日期时间)，**Error**(异常对象)，**Function**(函数构造器)，**Number**(数值对象)，**Object**(基础对象)，**RegExp**(正则表达式对象)，**String**(字符串对象)\n\n# 字符串对象String\n[String字符串--JavaScript基础笔记(1)](/article/3f7cd15d.html#String字符串)\n\n**字符串的所有方法，都不会改变原字符串**\n\n1. `indexOf()/lastIndexOf()`：获取字符串中指定内容的索引\n2. `search()`：获取字符串中指定内容的索引（参数里一般是正则）\n3. `includes()`：字符串中是否包含指定的内容\n4. `startsWith()`：字符串是否以指定的内容开头\n5. `endsWith()`：字符串是否以指定的内容结尾\n6. `charAt()`和`str[index]`：返回字符串指定位置(下标)的字符\n7. `charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码\n8. `slice()`：截取指定范围的字符串，可传入负值，代表倒数第几个字符（截取时包括该字符）\n9. `substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换\n10. `substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n11. `String.fromCharCode()`：据字符的 Unicode 编码获取字符\n12. `concat()`：拼接两个字符串，不如直接用+号\n13. `split()`：字符串转换为数组 【重要】\n14. `replace()`：替换字符串内容\n15. `repeat()`：重复该字符串指定次数\n16. `toUpperCase()` 和 `toLowerCase()`：大小写转换\n17. `trim()`：去除字符串头尾的空格\n\n## 查找字符\n**1、`indexOf()/lastIndexOf()`：获取字符串中指定内容的索引**\n\n`indexOf()`从前向后查找，`lastIndexOf()`从后向前，用法一致。\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'abc cba';\nconsole.log(str.indexOf('c'));//2\nconsole.log(str.lastIndexOf('c'));//4\n\nconsole.log(str.indexOf('a'));//0\nconsole.log(str.lastIndexOf('a'));//6\n```\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc'));//2,代表uc第一个字符u是字符串中第三个字符\n```\n\n添加起始位置参数，指定查找的起始位置\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc',2));//从下标2即字符串第三个字符开始找起，输出2\nconsole.log(str.indexOf('uc',3));//从下标3即字符串第四个字符开始找起，输出-1\n```\n\n**案例**：查找字符串\"abcabcabc\"中，所有 a 出现的位置以及次数\n\n```js\nvar str = \"abcabcabc\";\nvar num = 0;//记录次数\nvar index = -1;//记录位置下标，从-1开始\ndo{\n  index = str.indexOf('a', index + 1);//找到一个就从下一个字符下标开始找\n  if(index !== -1){\n    console.log(index);//输出下标0,3,6\n  }\n}while(index !== -1);//找到了就接着去找，直到找不到\n```\n\n**2、`search()`：获取字符串中指定内容的索引（参数里一般是正则）**\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'CHUCKLE';\nconsole.log(str.search('uc')); //-1\nconsole.log(str.search(/uc/i)); //2 正则写法，忽略大小写\n```\n\n**3、`includes()`：字符串中是否包含指定的内容**\n\n**功能**：判断字符串中是否含有指定内容。有返回 true；否则返回 false。可以传入起始位置参数。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.includes('uc')); //true\nconsole.log(str.includes('ab')); //false\nconsole.log(str.includes('ab',5)); //false\n```\n\n**4、`startsWith()`：字符串是否以指定的内容开头**\n\n**功能**：判断字符串是否以指定的字符串开头。是返回 true；否则返回 false。可以指定起始位置下标，指定的位置则当做字符串开头。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.startsWith('uc')); //false\nconsole.log(str.startsWith('c')); //true\nconsole.log(str.startsWith('uc',2)); //true\n```\n\n**5、`endsWith()`：字符串是否以指定的内容结尾**\n\n**功能**：判断字符串是否以指定的字符串结尾。是返回 true；否则返回 false。可以指定检索的字符串长度（检索到第几个字符）。\n\n```js\nvar str = \"chuckle\"\nconsole.log(str.endsWith('uc')); //false\nconsole.log(str.endsWith('e')); //true\nconsole.log(str.endsWith('uc',4)); //true\n```\n\n## 获取指定位置的字符\n**1、`charAt()`和`str[index]`：返回字符串指定位置(下标)的字符**\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.charAt(2));//u\nconsole.log(str[2]);//u\n```\n\n**2、`charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码**\n\n```js 判断字符串中是否有非英文字符\nvar str = \"chuckle轻笑\";\nfor(let i = 0; i < str.length; i++){\n  let char = str.charCodeAt(i);//保存该字符的Unicode编码\n  if(!(char >= 0 && char <= 127)){//英文字符的Unicode编码在0~127\n    console.log(`存在非英文,在第${i+1}个字符`);//存在非英文,在第8个字符,存在非英文,在第9个字符\n  }\n}\n```\n\n## 字符串截取\n**1、`slice()`：截取指定范围的字符串**，可传入负值，代表倒数第几个字符（截取时包括该字符）\n\n```js 两个参数都是索引值。正数时包左不包右\n新字符串 = str.slice(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.slice(2));//chuckle,从下标2开始截取到最后\nconsole.log(str.slice(2,str.length));//chuckle\nconsole.log(str.slice(2, -1));//chuckl,从下标2开始截取到倒数第一个字符，包括，-0无效\nconsole.log(str.slice(5, 2));//无效范围，返回空字符串\n```\n\n**2、`substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换。\n\n```js 两个参数都是索引值。包左不包右\n新字符串 = str.substring(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substring(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substring(2,str.length)); //chuckle\nconsole.log(str.substring(5, 2)); //chu，自动交换位置，相当于截取下标2到5\nconsole.log(str.substring(2, -1)); //qx，-1看作0，然后自动交换位置\n```\n\n**3、`substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n\n```js\n新字符串 = str.substr(开始索引, 截取的长度);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substr(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substr(2,100)); //chuckle，截取长度超过剩余长度时，只会截取剩余的字符\nconsole.log(str.substr(100, 10)); //空字符串，截取不到任何字符\n```\n\n## 其它方法\n\n**`String.fromCharCode()`：据字符的 Unicode 编码获取字符**\n\n```js\nvar a = String.fromCharCode(97);\nconsole.log(a);//a\n```\n\n**`concat()`：拼接两个字符串，不如直接用+号**，数组中也有此方法，用于两个数组的拼接，那边常用\n\n```js\nvar str1 = \"qx\";\nvar str2 = \"chuckle\";\nstr2 = str1.concat(str2);//qxchuckle\n```\n\n**`split()`：字符串转换为数组 【重要】**\n\n**功能**：通过指定的分隔符，将字符串拆分成数组，分隔符不会出现在数组中。不传入参数则将整个字符串作为数组的一个元素存入。\n\n```js\nvar str = \"qx,chuckle,轻笑\";\nconsole.log(str.split(',')); //['qx', 'chuckle', '轻笑']\nconsole.log(str.split('')); //['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split()); //['qx,chuckle,轻笑']\n```\n\n**`replace()`：替换字符串内容**\n\n**功能**：将字符串中的指定内容，替换为一段字符串，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则。\n\n```js\n新的字符串 = str.replace(被替换的子串，新的子串);\n```\n\n```js\nvar str = \"生活就像海洋，只有咕噜咕噜\";\nstr = str.replace('咕噜咕噜','意志坚强的人才能到达彼岸');\nconsole.log(str);//生活就像海洋，只有意志坚强的人才能到达彼岸\n```\n\n**`repeat()`：重复该字符串指定次数**\n\n```js\nvar str = \"chuckle!\"\nstr = str.repeat(2);//重复两次\nconsole.log(str);//'chuckle!chuckle!'\n```\n\n**`trim()`：去除字符串头尾的空格**\n\n```js\nvar str = '   a   b   c   ';\nconsole.log(str);//'   a   b   c   '\nconsole.log(str.length);//15\n\nconsole.log(str.trim());//'a   b   c'\nconsole.log(str.trim().length);//9\n```\n\n**`toUpperCase()` 和 `toLowerCase()`：大小写转换**\n\n```js\nvar str = 'abcdEFG';\n//转换成小写\nconsole.log(str.toLowerCase()); //abcdefg\n//转换成大写\nconsole.log(str.toUpperCase()); //ABCDEFG\n```\n\n**html方法**：不常用，多数是拼接成模板字符串返回\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.anchor('chuckle'));//<a name=\"chuckle\">chuckle</a>\nconsole.log(str.big());//<big>chuckle</big>\nconsole.log(str.sub());//<sub>chuckle</sub>\nconsole.log(str.sup());//<sup>chuckle</sup>\nconsole.log(str.link('https://www.qcqx.cn/'));//<a href=\"https://www.qcqx.cn/\">chuckle</a>\nconsole.log(str.bold());//<b>chuckle</b>\n```\n\n# 数值对象Number\n[Number数值型介绍--JavaScript基础笔记(1)](/article/3f7cd15d.html#Number数值型)\n\n1. `Number.isInteger()`：判断是否为整数\n2. `toFixed(num)`：保留小数点后num位（四舍五入），返回字符串\n\n**`Number.isInteger()`：判断是否为整数**\n\n```js\n布尔值 = Number.isInteger(数字);\n```\n\n```js\nvar a = 10;\nconsole.log(Number.isInteger(a));//true\na = -10;\nconsole.log(Number.isInteger(a));//true\na = 1.00;\nconsole.log(Number.isInteger(a));//true,虽然有小数点，但后面都是0，所以会被当做整数\na = 3.14;\nconsole.log(Number.isInteger(a));//false\n```\n\n**`toFixed(num)`：保留小数点后num位（四舍五入）**，返回字符串，将字符串转为整数可用**Number()**，详见[数据类型转换--JavaScript基础笔记(1)](/article/3f7cd15d.html#数据类型转换)\n\n```js 注意返回字符串！\n字符串 = nb.toFixed(num);\n```\n\n```js\nvar nb = 3.1415926;\nconsole.log(nb.toFixed(1));//3.1\nconsole.log(nb.toFixed(3));//3.142\nconsole.log(nb.toFixed(4));//3.1416\n```\n\n# 数学对象Math\n**Math**不是一个构造函数，无需创建对象即可直接使用其属性和方法，它是一个工具类，里面封装了数学运算相关的属性和方法。\n\n1. `Math.PI`：圆周率\n2. `Math.abs()`：获取绝对值\n3. `Math.random()`：生成0-1之间的随机浮点数，[0,1)\n4. `Math.floor()`：向下取整（往小取值）\n5. `Math.ceil()`：向上取整（往大取值）\n6. `Math.round()`：四舍五入取整（正数四舍五入，负数五舍六入）\n7. `Math.max(x, y, z)`：返回多个数中的最大值\n8. `Math.min(x, y, z)`：返回多个数中的最小值\n9.  `Math.pow(x,y)`：乘方：返回 x 的 y 次幂\n10. `Math.sqrt()`：开方：对一个数进行开方运算\n\n**`Math.abs()`：获取绝对值**，可传入字符串，自动做隐式转换。\n\n```js\nconsole.log(Math.abs(10));//10\nconsole.log(Math.abs(-10));//10\nconsole.log(Math.abs('-10'));//10\nconsole.log(Math.abs(-3.14));//3.14\nconsole.log(Math.abs('123abc'));//NaN\n```\n\n**`Math.random()`：生成0-1之间的随机浮点数，[0,1)**\n\n```js 一些技巧\n//生成 [0, x) 之间的随机整数\nMath.round(Math.random()*x);\n//生成 [x, y) 之间的随机整数\nMath.round(Math.random()*(y-x)+x)\n//生成 [x, y]之间的随机整数\nMath.floor(Math.random()*(y-x+1))+x;\n```\n\n# 时间对象Date\n**Date**用于处理日期和时间，Date是一个**构造函数**，需要**new实例化**后才能使用。\n\n**无参时获取系统时间**\n\n```js\nvar date = new Date();\nconsole.log(date);//Wed Mar 29 2023 15:08:02 GMT+0800 (中国标准时间)\nconsole.log(typeof date);//object\n```\n\n**传递参数**,意思是给时间对象Date设定一个具体的时间，基准时间为**1970年1月1日 00:00:00**，具体小时差别要看时区，东八区+8小时。\n\n```js 使用方法\nvar date = new Date(传入毫秒数（时间戳）);//表示基准时间加上这个毫秒数\n//至少要两个参数，不能缺少年，会自动进位，其余默认都是首时间\nvar date = new Date(年,月,日,时,分,秒,毫秒);//月份是0到11之间的整数值，表示从一月到十二月\n//传入时间字符串，有格式要求，星期 月 日 年 时:分:秒\nvar date = new Date(时间字符串);\n//Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)\n```\n\n```js\n//传入2000毫秒，表示基准时间过2s\nvar date = new Date(2000);//Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)\n//设定日期为2023年3月，传入2代表3月\nvar date = new Date(2023,2);//Wed Mar 01 2023 00:00:00 GMT+0800 (中国标准时间)\n//传入时间字符串，有格式要求，分隔符任意,可以看到，星期不对会自动修正\nvar date = new Date('Wed Apr 21 2023');//Fri Apr 21 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date = new Date(\"2023/3/29 11:11:11\");//Wed Mar 29 2023 11:11:11 GMT+0800 (中国标准时间)\n```\n\n**常用方法**\n1. `getFullYear()`：获取年份\n2. `getMonth()`：获取月，0到11之间的整数值，表示从一月到十二月\n3. `getDate()`：获取日：1-31\n4. `getDay()`：获取星期：0-6，0代表星期日\n5. `getHours()`：获取小时：0-23\n6. `getMinutes()`：获取分钟：0-59\n7. `getSeconds()`：获取秒：0-59\n8. `getMilliseconds()`：获取毫秒\n9. `setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒。返回时间戳\n10. `toUTCString()`：将当日的日期（根据 UTC）转换为字符串\n11. `toJSON()`：将日期转为json格式\n12. `getTime()`：获取时间戳\n13. `toLocaleString()` 格式化输出 2023/4/12 09:39:49\n\n```js 举例：\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nconsole.log(date.getFullYear());//2023\nconsole.log(date.getMonth());//2\nconsole.log(date.getDate());//29\nconsole.log(date.getDay());//3\nconsole.log(date.getHours());//15\nconsole.log(date.getMinutes());//52\nconsole.log(date.getSeconds());//6\nconsole.log(date.getMilliseconds());//495\n\n```\n\n**`toUTCString()`：将当日的日期（根据 UTC）转换为字符串**\n\n```js\nvar d = new Date();//Wed Mar 29 2023 16:11:02 GMT+0800 (中国标准时间)\nd.toUTCString()//'Wed, 29 Mar 2023 08:11:02 GMT'\n```\n\n**`setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒**,返回时间戳\n\n```js\nvar d = new Date(2023,0);\nvar t = d.setFullYear(2020,10);\nconsole.log(t);//1604160000000\nconsole.log(new Date(t));//Sun Nov 01 2020 00:00:00 GMT+0800 (中国标准时间)\n```\n\n**`toJSON()`：将日期转为json格式**\n\n```js\nvar d = new Date(2023,0);\nvar t = d.toJSON();\nconsole.log(t);//2022-12-31T16:00:00.000Z\n```\n\n## 获取时间戳\n\n**`getTime()`：获取时间戳**，也就是返回从基准时间至今的毫秒数(时间戳也可以是秒数，但函数返回的是毫秒数)。\n\n```js\nvar date = new Date(2023,0);\nconsole.log(date);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\nvar time = date.getTime();//1672502400000\nvar date = new Date(time);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\n```\n\n还有其它方法可以获取时间戳：\n\n```js\nvar time1 = +new Date();\nconsole.log(time1);//1680076996003\n\nvar time2 = new Date().getTime();\nconsole.log(time2);//1680076996003\n\nvar time3 = new Date().valueOf();\nconsole.log(time3);//1680076996003\n\nvar time4 = new Date() * 1;\nconsole.log(time4);//1680076996003\n\nvar time5 = Number(new Date());\nconsole.log(time5);//1680076996003\n\n```\n\n获取**当前时间的时间戳**可以用这种方法\n\n```js\nconsole.log(Date.now());//1680077268109\n```\n\n## 转为指定格式\n使用 `toLocaleString()` 简单格式化输出\n\n```js\nnew Date().toLocaleString();\n// 2023/4/12 09:39:49\n```\n\n也可以通过Date的**prototype属性**在原型上添加自定义的属性和方法，给Date对象添加**format()**方法，该方法封装如下：\n\n```js\nDate.prototype.format = function(fmt) { \n  var o = { \n    \"M+\" : this.getMonth()+1,                 //月份 \n    \"d+\" : this.getDate(),                    //日 \n    \"h+\" : this.getHours(),                   //小时 \n    \"m+\" : this.getMinutes(),                 //分 \n    \"s+\" : this.getSeconds(),                 //秒 \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \n    \"S\"  : this.getMilliseconds()             //毫秒 \n  }; \n  if(/(y+)/.test(fmt)) {\n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); \n  }\n  for(var k in o) {\n    if(new RegExp(\"(\"+ k +\")\").test(fmt)){\n      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));\n    }\n  }\n  return fmt; \n}        \n\n```\n\n```js 使用案例,分隔符任意\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nvar time = date.format(\"yyyy-MM-dd hh:mm:ss\");\nconsole.log(time);// 2023-03-29 15:52:06\ntime = date.format(\"yyyy/MM/dd\");\nconsole.log(time);// 2023/03/29\ntime = date.format(\"yyyy年MM月dd日 hh时mm分ss秒\");\nconsole.log(time);// 2023年03月29日 15时52分06秒\n\n```\n\n还可引入各种**时间库**来处理，如[momentjs](http://momentjs.cn/)、[Day.js](https://day.js.org/)\n\n# 数组对象Array\n下面是一个普通对象和数组对象：\n\n```js\nvar obj = {name: 'chuckle' , age: 19 };\nvar arr = [\"chuckle\",\"19\"];\n```\n\n普通对象使用字符串作为属性名，而数组使用**数字作为索引**，数组适合用于存储同类型的一组数据，如列表数据。\n\n数组中的元素可以是**任意的数据类型**，可以是对象、函数、数组。也可以同时存储**不同类型数据**。\n\n**1、使用字面量创建数组：**\n\n```js\nvar arr = []; // 创建空数组\narr = [1, 2, 3]; // 带初始值的数组\n```\n\n**2、使用构造函数创建数组对象：**\n\n```js\nvar arr = new Array(); // 创建空数组\narr = new Array(4); // 创建大小为4的数组，初始值都为空属性\narr = new Array(1,2,3); // 带初始值的数组\n```\n\nJS中的数组会**自动扩容**，当我们访问数组大小以外的下标时，会返回undefined，但可以直接给超过数组大小的下标赋值，并自动给扩容的下标赋空属性，注意，**空属性也会计入数组的长度 arr.length**。\n\n```js\nvar arr = [1, 2, 3];\nconsole.log(arr); // [1, 2, 3]\nconsole.log(arr.length); // 3\nconsole.log(arr[6]);// undefined\n\narr[6] = 7;\nconsole.log(arr); // [1, 2, 3, 空属性 × 3, 7]\nconsole.log(arr[4]); // undefined\nconsole.log(arr.length); // 7\n```\n\n## 解构赋值\n解构赋值是ES6中新增的一种赋值方式。可以方便地把数组中的元素按顺序赋值给其他多个变量。\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b, c] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\n```\n\n先指定变量的默认值，**会被覆盖**\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b = 0, c = 0, d = 0] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\nconsole.log(d);// 0,数组中无第四个元素，保持原值\n```\n\nES6中新增的**扩展运算符**`...`打包**剩余的数据**作为一个**新数组**。**打包时**扩展运算符只能写在最后。\n\n```js\nvar [a, ...b] = [1, 2, 3];\nconsole.log(a); // 1\nconsole.log(b); // [2, 3]\n```\n\n## 数组属性和方法\n`arr.length`：**数组的长度**，数组中元素的个数\n\n**数组的方法：**\n1. **类型相关方法：**\n   1. `Array.isArray()`：判断是否为数组\n   2. `toString()`：将数组转换为字符串\n   3. `join()`：将数组转换为字符串,可以指定分隔符\n   4. `Array.from()`：将**伪数组**或可遍历对象转为真数组\n   5. `Array.of(a,b,c)`：将多个值按顺序转为数组\n   6. 字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组\n2. **元素的添加和删除：**\n   1. `push()`：从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   2. `pop()`：删除数组中**最后一个**元素，返回被删除的元素，**改变原数组**\n   3. `unshift()`：从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   4.  `shift()`：删除数组中**第一个**元素，返回被删除的元素，**改变原数组**\n   5.  `splice()`：从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n   6.  `slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n   7.  `concat()`：合并多个数组，返回合并后的新数组，**不改变原数组**\n   8.  `fill()`：用固定的值**填充数组**，返回新数组，**改变原数组**\n3.  **数组排序：**\n    1.  `reverse()`：反转数组，返回反转后的数组，**改变原数组**\n    2.  `sort()`：排序，元素默认按照**Unicode编码**，从小到大进行排序，**改变原数组**\n4.  **查找数组元素：**\n    1.  `indexOf()`：**从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    2.  `lastIndexOf()`：**从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    3.  `includes()`：判断数组是否包含一个指定的值，返回**布尔**\n    4.  `find(function())`：返回**第一个**符合传入测试（函数）条件的数组元素。\n    5.  `findIndex(function())`：返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n    6.  `every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**\n    7.  `some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**\n    8.  `valueOf()`：返回数组本身，意义不大，数组名就代表该数组了\n5.  **遍历数组：**\n    1.  `for循环`遍历，大多数语言对于数组通用的遍历方法\n    2.  `forEach()`传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n    3.  `for of`，ES6新增循环遍历数组方法\n    4.  `map()`，遍历数组，并对数组中的每一项进行加工。\n    5.  `filter()`：数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n    6.  `reduce()`：参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n### 类型相关方法\n**`Array.isArray()`：判断是否为数组**\n\n```js\nvar a = [];\nconsole.log(Array.isArray(a));//true\na = {};\nconsole.log(Array.isArray(a));//false\n```\n\n**`toString()`：将数组转换为字符串**，每一项用逗号分割。\n\n大多数的数据类型都可以使用.toString()方法，将其转换为字符串。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.toString());//1,2,3,[object Object],function(){}\n```\n\n还可以使用`String()`将数组转换为字符串\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(String(a));//1,2,3,[object Object],function(){}\n```\n\n**`join()`：将数组转换为字符串,可以指定分隔符**，默认为逗号分割。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.join());//1,2,3,[object Object],function(){}\nconsole.log(a.join(' '));//1 2,3 [object Object] function(){}\nconsole.log(a.join('|'));//1|2,3|[object Object]|function(){}\n```\n\n可以使用`JSON.stringify()`将某个对象转换成 JSON 字符串形式，数组中的空属性会转为null。\n\n```js\nvar arr = [];\narr[5] = 6;\nconsole.log(arr); // [空属性 × 5, 6]\nconsole.log(JSON.stringify(arr)); // [null,null,null,null,null,6]\n```\n\n**字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组**，默认为逗号分割，找不到指定分隔符时也会用逗号分割\n\n```js\nvar str = \"qx,chuckle,轻笑\"\nconsole.log(str.split());//['qx,chuckle,轻笑']\nconsole.log(str.split(''));//['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split('-'));//['qx,chuckle,轻笑']\nconsole.log(str.split('c'));// ['qx,', 'hu', 'kle,轻笑']\n```\n\n**`Array.from()`：将伪数组或可遍历对象转为真数组**\n\n**伪数组**也有length属性，可以使用索引对数据进行操作，但是没有**真数组**的方法，因为该对象的原型不指向Array，需要将伪转真才能调用数组的方法。\n\n伪数组一般不会直接创建，而是通过一些js操作得到，通过浏览器方法获取标签、字符串、接受实参的函数arguments得到参数的伪数组，因为伪数组具有长度和索引，所以可以使用循环语句遍历。\n\n```js\nvar str = \"chuckle\";\nstr.push('qx');//报错str.push is not a function\nvar a = Array.from(str);\nconsole.log(a);//['c', 'h', 'u', 'c', 'k', 'l', 'e']\na.push('qx')\nconsole.log(a);// ['c', 'h', 'u', 'c', 'k', 'l', 'e', 'qx']\n```\n\n**`Array.of(a,b,c)`：将多个值按顺序转为字符串**，和`new Array()`差不多，区别是只有一个参数时，在**new Array()**表示数组的长度，而在**of()**仍然代表数组的元素\n\n```js\nvar arr = Array.of(1, [2,3], 'qx');\nconsole.log(arr);// [1, Array(2), 'qx']\narr = Array.of(3);\nconsole.log(arr);// [3]\narr = new Array(3);\nconsole.log(JSON.stringify(arr));// [null,null,null]\n```\n\n### 元素的添加和删除\n**`push()`：**从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.push(4,5,'123'));// 6\nconsole.log(JSON.stringify(arr));// [1, 2, 3, 4, 5, '123']\n```\n\n**`pop()`：**删除数组中**最后一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.pop());// 3\nconsole.log(JSON.stringify(arr));// [1,2]\n```\n\n**`unshift()`：**从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.unshift('0123',0));// 5\nconsole.log(JSON.stringify(arr));// [\"0123\",0,1,2,3]\n```\n\n**`shift()`：**删除数组中**第一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.shift());// 1\nconsole.log(JSON.stringify(arr));// [2,3]\n```\n\n**`splice()`：**从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n\n```js 语法，索引值为负代表从倒数第几个开始删\n新数组 = 原数组.splice(起始索引);\n新数组 = 原数组.splice(起始索引, 需要删除的个数);\n新数组 = 原数组.splice(起始索引, 需要删除的个数, 新的元素1, 新的元素2...);\n```\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(1));// 删除下标1后的所有元素，[2, 3, 4, 5]\nconsole.log(JSON.stringify(arr));// [1]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2));// 从下标1开始删两个元素，包括下标1，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2,'a','b'));// 删完后再从删除的起始位置插入'a','b'元素，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,\"a\",\"b\",4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(-2));// 从倒数第2个元素开始删后面的所有元素，[4, 5]\nconsole.log(JSON.stringify(arr));// [1,2,3]\n```\n\n搭配`indexOf()`，删除指定内容的元素\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(arr.indexOf(3), 1));// 删除3这个元素，[3]\nconsole.log(JSON.stringify(arr));// [1,2,4,5]\n```\n\n\n\n`slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n\n```js 语法，负数代表倒数索引\n新数组 = 原数组.slice(开始位置的索引);\n新数组 = 原数组.slice(开始位置的索引, 结束位置的索引);//提取的元素中，包含开始位置，不包含结束位置\n```\n\n```js\nvar arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.slice()); // 不带参数提取所有元素,['a', 'b', 'c', 'd']\nconsole.log(arr.slice(2)); // 从下标2提取后面所有元素，['c', 'd']\nconsole.log(arr.slice(-2)); // 提取最后两个元素,['c', 'd']\nconsole.log(arr.slice(1,3)); // 提取[1,3)索引的元素,['b', 'c']\nconsole.log(arr.slice(3,1)); // 范围内无元素，提取为空数组,[]\n```\n\n**`concat()`：**合并多个数组，返回合并后的新数组，**不改变原数组**\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar arr3 = [7, 8, 9];\nconsole.log(arr1.concat(arr2,arr3));// [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(arr1);// 不改变原数组 [1, 2, 3]\n```\n\n**数组合并的另一种方式：**使用扩展运算符`...`\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar a = [0, ...arr1, ...arr2, 7];//[0, 1, 2, 3, 4, 5, 6, 7]\n```\n\n**`fill()`：**用固定的值**填充数组**，返回新数组，**改变原数组**\n\n```js\n// 数组中每一个元素都替换为该值\n新数组 = 数组.fill(固定值);\n//从起始位置开始填充\n新数组 = 数组.fill(固定值, 起始索引);\n//从起始位置到结束位置填充，左闭右开\n新数组 = 数组.fill(固定值, 起始索引, 结束索引);\n```\n\n```js\nvar arr = new Array(6).fill(0)//创建一个元素均为0，长度为6的数组\nconsole.log(arr);// [0, 0, 0, 0, 0, 0]\narr.fill('a',2);//索引2后的所有元素填充为'a'\nconsole.log(arr);// [0, 0, 'a', 'a', 'a', 'a']\narr.fill('b',2,4);//索引[2,4)的元素填充为'b'\nconsole.log(arr);// [0, 0, 'b', 'b', 'a', 'a']\n```\n\n### 数组排序\n\n`reverse()`：反转数组，返回反转后的数组，**改变原数组**\n\n```js\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nconsole.log(arr.reverse());// ['e', 'd', 'c', 'b', 'a']\nconsole.log(arr);// ['e', 'd', 'c', 'b', 'a']\n```\n\n`sort()`：排序，元素默认按照**Unicode编码**（逐个字符比较，非字符串先隐式转换为字符串），从小到大进行排序，返回排序后的新数组，**改变原数组**\n\n```js\nvar arr = ['c', 'e', 'a', 'd', 'b'];// 乱序\nconsole.log(arr.sort());// ['a', 'b', 'c', 'd', 'e']\nconsole.log(arr);// ['a', 'b', 'c', 'd', 'e']\n```\n\n当数组内元素是数字时，不能直接使用sort()排序，因为默认是按逐个字符的Unicode编码进行排序\n\n```js\nvar arr = [7, 3, 11, 4, 1, 5];\n//11排到了3的前面，没有按我们所想的从小到大排\nconsole.log(arr.sort());//[1, 11, 3, 4, 5, 7]\n```\n\n对于非字符串排序（**数字的排序**），需要传入一个比较函数，有两个参数 a 和 b（可以是数组中**任意元素**）\n\n`arr.sort(Fun(a, b))`，a：**第一个**用于比较的元素，b：**第二个**用于比较的元素，数组按照**比较函数的返回值**进行排序，而不是Unicode编码。\n\nJS规定了**Fun(a, b)返回值**的效果：\n\n1. 返回值**小于0**，让a排b**前面**\n2. 返回值**大于0**，让a排b**后面**\n3. 返回值**等于0**，a,b的相对位置**不变**\n\n对于[7, 3, 11, 4, 1, 5]这个数组，比较11和4时，不带比较函数，会按Unicode编码从小到大排序，11会排在4前面，带比较函数后，因为a-b=7大于零，所以会让4排11前面。\n\n```js\n//实现整体升序(小到大)\narr.sort((a, b) => a - b);\n//实现整体降序(大到小)\narr.sort((a, b) => b - a);\n```\n\n```js 实际用用\nvar arr = [7, 3, 11, 4, 1, 5];\narr.sort();//[1, 11, 3, 4, 5, 7]\narr.sort((a, b) => a - b);// [1, 3, 4, 5, 7, 11]\narr.sort((a, b) => b - a);// [11, 7, 5, 4, 3, 1]\n```\n\n**Fun(a, b)**具体比较什么，什么情况返回大于0的数，什么时候返回小于0，需要自己去编写，所以可以实现商品的按价格排序：\n\n```js\n//这个数组中存放了几个商品对象，试着让它们按价格升序排序\nvar commodityList = [\n  {\n    name: 'biscuit',\n    price: 10,\n  },\n  {\n    name: 'Coke',\n    price: 3,\n  },\n  {\n    name: 'toy',\n    price: 8,\n  },\n  {\n    name: 'bread',\n    price: 5,\n  },\n];\n\ncommodityList.sort((a, b) => {\n  // 比较价格，规范起见，都进行parseInt()转换，也可以用parseFloat()，看业务需要\n  return parseInt(a.price) - parseInt(b.price);\n});\n\nconsole.log(JSON.stringify(commodityList));\n\n```\n\n```js 输出如下\n[ \n  {\"name\":\"Coke\",\"price\":3},\n  {\"name\":\"bread\",\"price\":5},\n  {\"name\":\"toy\",\"price\":8},\n  {\"name\":\"biscuit\",\"price\":10}\n]\n```\n\n### 查找数组元素\n**`indexOf()`：** **从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n**`lastIndexOf()`：** **从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n\n找到元素返回其索引，没找到返回**-1**，**严格类型约束**，类似===。\n\n```js\nvar arr = ['1', 2, 1, '2'];\nconsole.log(arr.indexOf(1));// 2\nconsole.log(arr.indexOf('1'));// 0\nconsole.log(arr.indexOf('2'));// 3\nconsole.log(arr.indexOf(2));// 1\nconsole.log(arr.indexOf(3));// -1\n```\n\n可以指定第二个参数，指定查找的起始位置，包括该位置\n\n```js\nvar arr = [1, 2, 3, 4, 3, 2, 1];\n//正着从数组一半开始找\nconsole.log(arr.indexOf(1, parseInt(arr.length/2)));// 6\n//倒着从数组一半开始找\nconsole.log(arr.lastIndexOf(1, parseInt(arr.length/2)));// 0\n```\n\n**`includes()`：**判断数组是否包含一个指定的值，**严格类型约束**，返回**布尔**，可以加上第二个参数规定查找的起始位置。\n\n```js\nvar arr = [1, 2, '3', '4'];\nconsole.log(arr.includes(1)); // true\nconsole.log(arr.includes('1')); // false\nconsole.log(arr.includes(2, 2)); // false\nconsole.log(arr.includes('3', 2)); // true\n```\n\n**`find(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素。\n**`findIndex(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n\n找到符合条件的第一个元素就停止查找，没找到返回**find()返回undefined**，**findIndex()返回-1**\n\n```js 找到大于30的第一个元素\nvar arr = [10, 20, 30, 40, 50, 60];\n//用find\nvar result = arr.find((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 40\n//用findIndex\nvar result = arr.findIndex((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 3\n\n```\n\n`every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**，有一项返回 false 立刻停止遍历。\n`some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**，有一项返回 true 立刻停止遍历。\n\n**every()：**全部真，才为真，**some()：**一个真，就为真，\n\n```js every举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.every((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 0;// 判断数组中元素是否都大于0，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n```js some举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.some((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;// 判断是否有大于0的元素，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n### 遍历数组\n**`for循环`遍历**，大多数语言对于数组通用的遍历方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n//1 2 3 4 5\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]\n```\n\n这不够优雅，JS有更简单便捷遍历数组的方法\n\n**`forEach()`**传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n\n```js\narr.forEach(function (item, index, array) {\n\t//做些事情\n});\n```\n\n**回调函数中传递三个参数：**\n1. **参数1（item）：**当前正在遍历的元素\n2. **参数2（index）：**当前正在遍历的元素的索引\n3. **参数3（array）：**正在遍历的数组\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tconsole.log(`${index}:${item}`);\n});\n//0:1 1:2 2:3 3:4 4:5\n```\n\n在**forEach()**的回调函数中**不能通过参数1（item）直接修改数组中的元素**，但元素是一个对象时，可以访问并修改该对象的属性，这是因为数组中存放的是该对象的引用（地址）\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\titem += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"qx\",\"age\":19}]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem.name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]很显然，这是可以的\n\n```\n\n如果要修改数组中的元素，需**通过参数2（index）和3（array）**，`array[index]`来访问数组元素并修改\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tarray[index] += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[2,3,4,5,6]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index] = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index].name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\n```\n\n纯粹只是遍历数组，可以用forEach()，但同时要修改元素时，最好使用**map()**，避免一些低级错误\n\n**`for of`**，ES6新增循环遍历数组方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor(let item of arr) {\n  //item是元素的拷贝，无法直接修改item来修改元素值\n\tconsole.log(item);\n}\n// 1 2 3 4 5\n```\n\n**`for in`**用于遍历无序的对象的属性，而不是有序的数组\n\n```js\nvar obj = {\n  name: 'chuckle',\n  age: '19'\n};\nfor(let key in obj) {\n  //key是属性名，obj[key]可以修改属性值\n\tconsole.log(`属性名：${key}，值：${obj[key]}`);\n}\n//属性名：name，值：chuckle\n//属性名：age，值：19\n\n```\n\n**`map()`**，遍历数组，并对数组中的每一项进行加工。\n\n对数组中每一项运行回调函数，返回每一项加工后的结果，组成的新数组，**不改变原数组**。\n\n```js 语法\nvar newArr = arr.map((item, index, array) => {\n    // item是元素内容，index是该元素索引，array是该数组\n    return newItem;//返回该项加工后的结果\n});\n```\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar newArr = arr.map((item, index, array) => {\n    return item += 1;//返回每一项加一\n});\nconsole.log(JSON.stringify(newArr));//[2,3,4,5,6]\n```\n\n**常用案例：**将 A 数组(通常存对象)中某个属性的值，存储到 B 数组中。\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n\n//把属性name都提取出来\nvar newArr = arr.map((item) => item.name);//返回每个item的name属性\nconsole.log(JSON.stringify(newArr));//[\"张三\",\"李四\",\"王五\"]\n\n//重新组一个对象，改键名\nnewArr = arr.map((item) => ({\n  myName: item.name,\n  myAge: item.age,\n}));//把属性拿出来重新组一个对象\nconsole.log(JSON.stringify(newArr));\n//[{\"myName\":\"张三\",\"myAge\":19},{\"myName\":\"李四\",\"myAge\":18},{\"myName\":\"王五\",\"myAge\":20}]\n\n```\n\n**`filter()`：**数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n\n```js\nvar arr = [7, 2, 3, 6, 7, 4];\nvar newArr = arr.filter(item => {\n    return item > 4;//item > 4回调函数返回true，filter()就把该元素放进新数组里\n});\nconsole.log(JSON.stringify(newArr));//[7,6,7]\n```\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n//筛选出年龄大于18的同学\nvar newArr = arr.filter((item) => item.age > 18);\nconsole.log(JSON.stringify(newArr));//[{\"name\":\"张三\",\"age\":19},{\"name\":\"王五\",\"age\":20}]\n//再用map()筛选出名字\nvar resultArr = newArr.map((item) => item.name);\nconsole.log(JSON.stringify(resultArr));//[\"张三\",\"王五\"]\n\n```\n\n**`reduce()`：**参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n**reduce() 对于空数组不会执行回调函数**\n\n```js 语法\nvar result = arr.reduce((prev, item, index, array) => {}, initialValue);\n```\n\n**回调函数参数解释：**\n1. **prev**：必填，**上一次**调用回调函数时的**返回值**\n2. **item**：必填，当前正在处理的**数组元素**\n3. **index**：可选，当前正在处理的数组元素**下标**\n4. **array**：可选，**该数组**\n5. **initialValue**：可选，作为第一次调用回调函数时**传给prev**的值，最好手动初始化为0\n\n**举例 1、数组求和：**\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6];\nvar result = arr.reduce((prev, item) => {\n    return prev + item;// 累计求和\n});\nconsole.log(`总和:${result}`); // 总和:21\n```\n\n**举例 2、统计某个元素出现的次数：**\n\n```js\nvar arr = [5, 2, 6, 4, 3, 6];\n\n//统计函数，传入数组arr和要统计的value，返回value出现的次数\nfunction arrCount(arr, value){\n  return arr.reduce((prev, item)=>{\n    //判断当前项item是否等于value，是则让prev计数加一并返回\n    return prev += item === value ? 1 : 0;\n  }, 0);\n}\n\nconsole.log(arrCount(arr, 6)); // 2\nconsole.log(arrCount(arr, 7)); // 0\n\n```\n\n**举例 3、找到最大的元素：**\n\n```js\nvar arr = [5, 2, 6, 7, 3, 6];\n\n//传入数组arr,返回最大元素(首次找到)的下标\nfunction maxValue(arr){\n  return arr.reduce((prev, item, index, arr) => {\n    //prev初始值为0，默认下标0的元素最大，每一项与arr[prev]比较，大于就更新prev为当前下标index\n    return prev = item > arr[prev] ? index : prev;\n  }, 0)\n}\n\nconsole.log(maxValue(arr));// 3\nconsole.log(arr[maxValue(arr)]);// 7\n\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(1)","url":"/article/3f7cd15d.html","content":"\n# 这是JavaScript\nHTML描述页面的结构，CSS展现页面的样式，**JS**在页面中描述行为、控制交互。\n\n~~JavaScript里没有Java，就像老婆饼里没有老婆。~~\n\nJavaScript是解释型语言，既是前端语言，又是后端语言，当它运行在浏览器中时是**前端语言**，**后端语言**运行在服务器中也称为服务端语言，NodeJS可以让JS运行在服务端。\n\nJavaScript基础由三部分组成，ECMAScript是语法，DOM和BOM是浏览器提供的API：\n1. **ECMAScript**: JavaScript的语法标准，至少要学习到**ES6**，它规定了JS最基础的语句、变量、函数、运算等等。\n2. **DOM**: 文档对象模型（Document Object Model），JS**操控网页元素**的API。\n3. **BOM**: 浏览器对象模型（Browser Object Model），JS**操控浏览器**的API。\n\n# 使用JS\n1. **行内**: 写在标签属性中。<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```js\n<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```\n2. **内嵌**: 写在`<script></script>`标签中。\n```html\n<script type=”text/javascript”>\n  alert('你好');\n</script>\n```\n3. **外链**: 在`<script></script>`标签的src属性中写上js文件的链接。\n```html\n<script type=\"text/javascript\" src=\"main.js\"></script>\n```\n\n# 执行顺序\n浏览器默认从**上至下**解析网页，JS的加载默认会阻塞网页的解析，通过JS操控网页元素，需待网页解析完后执行、写在html的最后或写在对应元素后，否则就可能因为DOM树不完整，要操控的对象还未被加载而报出undefined错误。\n\n```html\n<!-- 不等待后续网页的解析，到此就加载JS并执行 -->\n<script src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，但JS在网页解析完后执行 -->\n<script defer src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，JS加载完后立即执行 -->\n<script async src=\"main.js\"></script>\n```\n\n```js\n//待网页解析完、网页中所有资源（图片、css）都加载完毕，执行其中的代码\nwindow.onload  = function () {\n  //js代码\n  alert('你好');\n}\n```\n\n# 输出语句\n1. `console.log()`: 在控制台输出内容\n```js\nconsole.log('日志'); //普通打印\nconsole.warn('警告'); //警告打印\nconsole.error('出错了'); //错误打印\n```\n2. `alert()`: 警告对话框 <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"alert('这是一个警告')\" />\n3. `confirm()`: 确认对话框，返回true或false <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = confirm('确认吗');if(a){alert('你确认了')}else{alert('未确认')}\" />\n```js\nvar a = confirm('确认吗');\nif(a){\n  alert('你确认了')\n}else{\n  alert('未确认')\n}\n```\n4. `prompt()`: 输入对话框，返回输入内容或空字符串，点取消返回NULL <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = prompt('输入内容');if(a){alert('你输入了：'+a)}else if(a==''){alert('你没输入任何东西')}else{alert('取消')}\" />\n```js\nvar a = prompt('输入内容');\nif(a){\n  alert('你输入了：'+ a)\n}else if(a==''){\n  alert('你没输入任何东西')\n}else{\n  alert('取消')\n}\n```\n\n# 常量、变量、标识符\n数字常量、字符串常量、布尔常量\n```js\nconsole.log(123); //123是数字\nconsole.log('123'); //'123'是字符串，''空字符串\nconsole.log('你好'); //''包裹起来的都是字符串\nif(true){ //true、false布尔常量\n  console.log('true'); \n}\n```\n\n自定义常量const\n```js\nconst a = '123'; //定义a为常量\na = '321'; //不允许修改常量\nconst a = '321'; //不允许重新声明\n```\n\n定义变量var、let(ES6)\n```js\nvar a = '123';\nlet b = 321;\n//重新定义\nvar a = '321'; //var允许重新定义\nlet b = 123; //let不允许重新定义\n//不允许var和let之间重新定义\nvar c = 123;\nlet c = 123;\n```\n\nvar可以在声明前使用，值为undefined，而let必须先声明再使用。\n\nvar是**函数作用域**，let是**块作用域**。\n\n**标识符**（一切可自主命名的，如变量名、函数名）命名规则：\n1. 区分大小写\n2. 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成\n3. 不能以数字开头、不允许出现空格\n4. 不能出现中划线 -\n\n# 数据类型\nJavaScript是**弱类型语言**（动态语言），无需声明变量的类型，在程序运行过程中，会根据**等号右边的值**自动确定类型。\n\n```js\nvar a = 123;\nconsole.log(typeof a);//输出number\na = '123'//强制将变量a数据类型转换为字符串\nconsole.log(typeof a);//输出string\na = Number(a);//强制将字符串'123'转换为数字123\nconsole.log(a);//输出123\n```\n\nJS中数据类型分为**基本数据类型**和**引用数据类型**\n1. **基本数据类型**（值类型）: String字符串、Number数值、BigInt(ES6)大型数值、Boolean布尔值、Null空值、Undefined未定义、Symbol(ES6)。\n2. **引用数据类型**（引用类型）：Object 对象(除了基本数据类型之外，都可称之为Object类型)。\n\n基本数据类型**传数值**，引用数据类型**传地址**。\n\n```js\nvar a = 23;\nvar b = a;//将a的值23传给b\na++;\nconsole.log(a); //24\nconsole.log(b); //23，改变a的值不影响b\n```\n\n```js\nvar a = new Object();//a、b都是引用数据类型\nb.name = '123';\nvar b = a;//传的是a的地址，a和b是同一个东西\na.name = '321';\nconsole.log(a.name); //321\nconsole.log(b.name); //321，修改a对象的属性也会修改b\n```\n\nJS中，所有的变量都保存在**栈内存**中的。\n\n基本数据类型直接保存在**栈内存**中。值与值之间独立存在。\n\n对象Object保存在**堆内存**中，创建一个新的对象，在堆内存中开辟一个新的空间，变量在**栈内存**中保存了对象的**内存地址**（对象的引用）。\n\n# String字符串\n字符串是双引号和单引号中的文本，不同类型引号可以嵌套使用。\n\n```js\nvar a = '123';\nconsole.log(a);//123\nvar b = '1\"2\"3';\nconsole.log(b);//1\"2\"3\nvar c = '12    3';\nconsole.log(c);//12    3不忽略连续多个空格\n```\n\n加入字符串进行拼接，可以被同化为字符串\n\n```js\nconsole.log(typeof(123+''));//string\n```\n\n转义字符: `\\`\n* 双引号: `\\\"`，单引号 `\\'`\n* `\\\\` 表示\\\n* `\\r` 回车，`\\n` 换行\n* `\\t` 缩进\n* `\\b` 空格\n\n字符的数量就是**字符串的长度**，获取字符串的长度`.length`：\n\n```js\nvar a = \"abc\";\nconsole.log(a.length);//3\na = \"你好\";\nconsole.log(a.length);//2\n```\n\n使用 **+** 进行**字符串拼接**：\n\n```js\nvar a = \"你好\"+\"世界\";\nconsole.log(a);//你好世界\na = \"你好\"+ 1;\nconsole.log(a);//你好世界1\na = \"你好\"+ null;\nconsole.log(a);//你好null\na = \"你好\"+ true;\nconsole.log(a);//你好true\n```\n\nES6新增**模板字符串**：**``**，可以使用`${变量名}`将其嵌入字符串，使用时需要反引号 **``** 包裹。\n```js\nvar a = 2022;\nvar b = '2023';\nconsole.log(`去年是${a}，今年是${b}`); //去年是2022，今年是2023，注意使用反引号\n```\n\n模板字符串中可以换行，不忽略连续的多个空格，保留原有格式。\n\n可以调用函数：\n\n```js\nfunction getHtml() {\n    return `<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>`;\n}\nconsole.log(`1${getHtml()}2`);\n/*\n1<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>2\n*/\n```\n\n可以嵌套使用，进行运算：\n\n```js\nvar a = 1;\nvar b = 2;\nconsole.log(`${a+`${b}`}`);//12\nconsole.log(`${a+b}`);//3\n```\n\n# Number数值型\nJS中整数和浮点数等所有的数值都是Number类型。\n\n```js\nvar a = 1;\nvar b = 1.2;\nconsole.log(typeof a);//number\nconsole.log(typeof b);//number\n```\n\n数值范围:\n\n```js\nconsole.log(Number.MAX_VALUE);//1.7976931348623157e+308\nconsole.log(Number.MIN_VALUE);//5e-324\n```\n\n数值变量超过了最大值，则会返回**Infinity**，Infinity也是一种数值，代表无穷大。\n\n```js\nvar a = Number.MAX_VALUE;\nvar b = Number.MIN_VALUE;\nconsole.log(a*2);//Infinity\nconsole.log(b/2);//0\nconsole.log(a*(-2));//-Infinity\nconsole.log(typeof Infinity);//number\n```\n\n**NaN**是一个特殊的数字，表示不是数值(Not a Number)，当运算不出数值时就会返回NaN。\n\n```js\nconsole.log(typeof NaN);//number\nconsole.log('abc' / 2);//NaN\nconsole.log('a' * '2');//NaN\n```\n\nUndefined和任何数值计算的结果均为NaN。NaN与任何值都不相等，包括NaN本身。\n\n```js\nconsole.log(undefined + 1);//NaN\nconsole.log(null + 1);//1\nconsole.log(NaN==NaN);//false\n```\n\n**隐式转换**，当有字符串介入的运算，且字符串可被转换为数值，除了+表示字符串连接，其余都会自动将字符串转为数值后进行运算。\n\n```js\nconsole.log('1' + '2');//12\nconsole.log('1' * '2');//2\nconsole.log('1' / 2);//0.5\nconsole.log('1' - 2);//-1\nconsole.log('1' + '2' * '3');//16\n```\n\n浮点数的**运算精度**并不足够准确，当需要进行高精度运算时，最好引入可靠的数学库。\n\n```js\nvar a = 0.1 + 0.2;\nconsole.log(a); //0.30000000000000004\n```\n\n# Null与Undefined\nundefined实际上是由null衍生出来的。\n\n**undefined**表示未定义，应该有值但还未赋值，连null这个值都没有赋予给它。\n**null**代表空值，本身是一个具体的值或空引用。\n\nnull和undefined值上**相等**，但类型不一样。\nnull是引用类型Object，代表空对象，存的地址为空，而undefined的类型是undefined，代表未定义的值。\n\n```js\nconsole.log(null == undefined);//true\nconsole.log(null === undefined);//false\n\nconsole.log(typeof null);//object\nconsole.log(typeof undefined);//undefined\n```\n\nnull转为数值是0，undefined转为数值是NaN。\n任何值和null运算，null可看做0。任何数据类型和undefined运算，结果都是NaN。\n\n```js\nconsole.log(Number(null));//0\nconsole.log(Number(undefined));//NaN\n\nconsole.log(null+1);//1\nconsole.log(undefined+1);//NaN\n```\n\n**出现undefined的情况**：\n1. 变量被声明了，但是没有被赋值\n2. 变量未声明（未定义）时\n3. 调用函数时，未传参\n4. 函数无返回值时\n5. 访问一个对象中没有的属性\n\n```js\nconsole.log(a);//undefined\nvar a;\nconsole.log(a);//undefined\n\nfunction Fun(item) {\n  console.log(item);\n}\nconsole.log(Fun());//undefined\nFun();//undefined\n```\n\n**出现null的情况**：\n1. 访问一个不存在的dom节点\n2. 作为对象原型链的终点出现\n\n# 数据类型转换\n变量的**数据类型转换**：将一种数据类型转换为另外一种数据类型。（通常在基本数据类型中互相转换）\n\n1. **显式类型转换**\n  1. `toString()` 转换为字符串\n  2. `String()` 强制转换为字符串\n  3. `Number()` 转为数值，保留小数\n  4. `parseInt()` 字符串转整数,**直接舍去小数部分**\n  5. `parseFloat()` 在parseInt()的基础上可以获得小数部分\n  6. `Boolean()` \n2. **隐式类型转换**\n  1. `isNaN()` \n  2. 自增/自减\n  3. 正号/负号\n  4. 加号(字符串拼接)\n  5. 其它数值运算符\n  6. 逻辑运算符：会先非布尔值转换为布尔值，再运算\n  7. 关系运算符：运算结果都是布尔值\n\n## 转为字符串\n\n`toString()`:\n\n```js\nvar a = 123;\nconsole.log(a.toString());//\"123\"\na = true;\nconsole.log(a.toString());//\"true\"\na = [1, 2, 3];\nconsole.log(a.toString());//\"1,2,3\"\na = { name: 'qx', age: 18 };\nconsole.log(a.toString());//\"[object Object]\"\n```\n\nnull和undefined这没有toString()方法，调用会报错\n\n```js\nvar a = null; \nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\na = undefined;\nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\n```\n\nNumber类型的变量，在调用toString()时，可以传入一个整数，把数字转换为指定的进制，默认转换为10进制。\n\n```js\nvar a = 8;\na = a.toString(2); //转换为二进制\nconsole.log(a); //\"1000\"\nconsole.log(typeof a);//string\n```\n\n数字不允许直接调用toString()\n```js\n1.toString()//不允许，会把.看成小数点，小数点后面出现非数字是不允许的\n1..toString()//允许\n(1).toString()//允许\n```\n\n使用`String()`强制转换为字符串。\n对于**非**null和undefined的数据类型而言，实际上就是调用toString()。\n对于null和undefined，直接转换为\"null\"和\"undefined\"。\n\n```js\nvar a = 123;\nconsole.log(String(a));//\"123\"\na = null;\nconsole.log(String(a));//\"null\"\na = undefined;\nconsole.log(String(a));//\"undefined\"\n```\n\n字符串拼接，隐式转换：\n\n```js\nvar a = 123;\nconsole.log(a+'');//\"123\"\n```\n\n## 转为数值\n\n`Number()`转为数值类型\n1. **字符串转数字**\n  1. 字符串中是纯数字，直接将其转换为数字\n  2. 空字符串或全是空格，转换为0\n  3. 字符串中包含了非数字的内容，转为NaN\n2. **布尔值转数字**：true --> 1，false --> 0\n3. **null --> 0，undefined --> NaN**\n\n加上**正负号隐式转换**。规则和Number()一样，但是改变正负性，0也会带上负号：\n\n```js\nvar a = '123';\nconsole.log(+a); //123\nconsole.log(-a); //-123\nconsole.log(typeof +a);//number\na = null\nconsole.log(+a); // 0\nconsole.log(-a); // -0\n```\n\n`parseInt()` **字符串转整数**，布尔、null等非字符串、非数值类型都转为NaN，逐个字符转，碰见非数字字符就停止，没有提取到数值，就返回NaN。\n\n```js\nparseInt('123abc'); //123\nparseInt('abc123'); //NaN\nparseInt(''); //NaN\nparseInt('       '); //NaN\nparseInt(null); //NaN\nparseInt(undefined); //NaN\nparseInt(true); //NaN\n```\n\nparseInt()会自动截断、舍弃小数，而Number()不会。\n\n```js\nvar a = parseInt('5.1') + parseInt(5.9);\nconsole.log(a);//10\na = Number('5.1') + Number(5.9);\nconsole.log(a);//11\na = parseInt(5.1 + 5.9);\nconsole.log(a);//11\n```\n\nparseInt()可以多带一个进制参数，把数值**看成对应进制**，再转成10进制返回。无论parseInt()里面的进制参数是多少，最终的转换结果是十进制。\n\n```js\nvar a = parseInt('101', 2);\nconsole.log(a);//5 二进制101就是十进制的5\n\na = parseInt('3', 2);\nconsole.log(a);//二进制中没有3，所以转换失败返回NaN\n```\n\n`parseFloat()` 字符串转小数，与parseInt()相似。\n\n```js\nparseFloat('123.321abc'); //123.321\nparseFloat('12.1a3.321'); //12.1\nparseFloat('12.13.321'); //12.13\n```\n\n## 转为Boolean\n任何数据类型都可以转为 Boolean 布尔型。\n1. **数值型**: 0 和 NaN的转为 false，其它都是 true\n2. **字符串**: 空串转为 false，其它都是 true。全是空格的字符串，转换结果也是 true。\"0\"也是 true。\n3. **null 和 undefined** 都转为 false\n4. **引用数据类型**都转为 true，因为地址永不为空或0。空数组[]和空对象{}，也是 true\n\n```js\nvar a;\nBoolean(a);//false,a未赋值，undefined\na = '';\nBoolean(a);//false\na = [];\nBoolean(a);//true\na = {};\nBoolean(a);//true\n```\n\n使用`!!`或`!`显式转换为 Boolean 类型：\n\n```js\nvar a = 1;\na = !a\nconsole.log(a);//false\na = !!2;\nconsole.log(a);//true\n```\n\n`isNaN()`判断是否是**非数值类型**，任何**不能直接转为数值类型**的数据类型都可以让这个函数返回true\n\n```js\nisNaN('123');//可以转为123，返回false\nisNaN(null);//转为0，false\nisNaN('123abc');//true\nisNaN(undefined);//true\n```\n\n# 运算符和运算\n各种编程语言的运算符功能都大差不差，只介绍JS中比较特殊的运算或特例。\n\n浮点数值的最高精度是 17 位小数，会有丢失精度的风险，**不要直接判断两个浮点数是否相等**\n\n**Boolean + 数字 = 数字**，true按1来算，false按0。\n**null + 数字 = 0 + 数字**\nundefined + 数字 = NaN\n任何值和 NaN 运算的结果都是 NaN\n任何**非数值类型**进行除加法以外的运算`-、*、/、%`时，都会**自动用Number()转成数值类型**再参与运算\n\n```js\ntrue + 1; //2\nnull + 1; //1\nvar a = 2 - '1'; //1\nvar a = '2'/'1'; //2\n```\n\n非布尔值进行与或运算(`&&、||`)时，会先将其转换为布尔值，然后再运算，但返回结果是原值。\n\n**与运算 &&**的返回结果：从左到右依次运行语句，找到第一个为 false 的值，返回原值，不再往后执行。如果所有的值都为 true，则返回最后一个值。\n\n```js\nvar a = '' && 123;\nconsole.log(a);//'',空字符串转为布尔型为false，只执行第一条语句并返回原值\nvar a = [] && 0;\nconsole.log(a);//0，[]转为布尔型为true，直接返回第二个语句的值\nvar a = \"0\" && 0 && 1;\nconsole.log(a);//0\n```\n\n**或运算 ||**的返回结果：从左到右依次运行语句，找到第一个为 true 的值，返回原值，不再往后执行。如果所有的值都为 false，则返回最后一个值。\n\n```js\nvar a = '' || null;\nconsole.log(a);//null\nvar a = 0 || [];\nconsole.log(a);//[]\nvar a = \"0\" || 0 || 1;\nconsole.log(a);//\"0\"\n```\n\n**比较运算符** `>、<、==、!= 等`，得到的结果都是布尔值：要么是 true，要么是 false，非数值进行比较，会将其转换为数值类型。\n\n**特殊情况**：如果参与比较的**都是字符串**，则不会将其转换为数字进行比较，比较的是字符串的Unicode编码。\n比较字符编码时，从**左到右逐位**进行比较，一样大则继续比较下一位，直到比较出大小。\n\n```js\nconsole.log('100' > 9 );//true,将'100'转为数值100进行比较\nconsole.log('100' > '9' );//false,两个字符串逐位比较，9比1大，返回false\n```\n\n`== 、===` ==进行比较时，会做**隐式转换**，将不同的数据类型，转为相同类型进行比较，而全等符号===不会进行转换，不同类型的数据比较一定是false。\n\n```js\nconsole.log('1' == 1); //true\nconsole.log('1' === 1); //false\n\nconsole.log(1 == true); //true\nconsole.log(1 === true); //false\n\nconsole.log(undefined == null); //true\nconsole.log('1a' > 1); // false。'1a'转成NaN\n\n//NaN不和任何值相等，包括它本身\nconsole.log(NaN == NaN); //false\nconsole.log(NaN === NaN); //false\n```\n\nnull与数字进行比较有一个Bug，不必在意，当特性就行：\n\n```js\nconsole.log(null < 0); //false\nconsole.log(null == 0); //false\nconsole.log(null > 0); //false\n\nconsole.log(null <= 0); //true。这是一个bug\nconsole.log(null >= 0); //true。同上\n```\n\n日期大小比较\n\n```js\nvar date1 = new Date(2023, 3, 28)\nconsole.log(date1);//Fri Sep 08 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date2 = '2023-03-27';\nvar date3 = '2023/03/29';\nconsole.log(date1 > date2);//false，date1和date2字符串格式很不相同，比较无意义\nconsole.log(date3 > date2);//true,格式基本相同，分割位置一样，字符串逐位比较大小\n```\n\n# if和switch\n这部分各大语言也大差不差，只记录值得注意的点。\n\ncase的判断逻辑是**===**，不是**==**\n\nswitch中的default无论放到什么位置，都会等到所有case都不匹配再执行，但一般放在最后\n\n当case或default匹配到一个值后，会执行后续所有的case，除非遇到break或执行到switch的末尾。\n\n# 循环\n这部分各大语言也大差不差，只记录值得注意的点。\n\n**break**会立即终止离它最近的**循环语句**，**continue**跳过当次循环，继续下一次循环。\n\n可以为循环语句创建一个**label**，来标识当前的循环。使用break、continue语句时，break label将会结束指定的循环，而不是最近的。\n\n```js\none: for (var i = 0; i < 100; i++) {\n    for (let j = 0; j < 100; j++) {\n        if(i>j) {\n          break one;\n        }\n    }\n}\nconsole.log(i);//1\n```\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"博客添加待办清单页","url":"/article/9875347c.html","content":"\n# 前言\n&emsp;&emsp;要做的事还有很多，想做的事源源不断，那就都记录在博客里吧，[ToDoList](/todolist/)。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/40-1.webp width=\"90%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\page\\todolist.pug`\n\n```pug\n#todolist-box\n    .page-top-card(style='background-image: url(/img/todo.webp);')\n        .content-item-tips 想做清单\n        span.content-item-title ToDoList\n        .content-bottom\n            .tips 要做的事还有很多，想做的事源源不断\n    #todolist-main\n        #todolist-left\n            each i in site.data.todolist\n                if i.seat == 'left'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n        #todolist-right\n            each i in site.data.todolist\n                if i.seat == 'right'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n\n```\n\n&emsp;&emsp;修改`\\layout\\page.pug`\n\n```pug\ncase page.type\n    when 'tags'\n        include includes/page/tags.pug\n        include includes/page/default-page.pug\n    when 'link'\n        include includes/page/flink.pug\n    when 'categories'\n        include includes/page/categories.pug\n        include includes/page/default-page.pug\n    when 'essay'\n        include includes/page/essay.pug\n+    when 'todolist'\n+        include includes/page/todolist.pug\n    default\n        include includes/page/default-page.pug\n\n```\n\n&emsp;&emsp;新建`\\source\\_data\\todolist.yml`\n\n```yml seat控制清单在左栏还是右栏显示，completed控制是否已完成\n- class_name: 想做的项目\n  seat: left\n  todo_list:\n    - content: 个人主页\n      completed: false\n    - content: 公众号\n      completed: false\n\n- class_name: 想看的书\n  seat: left\n  todo_list:\n    - content: 《毛泽东选集》\n      completed: false\n    - content: 《86不存在的战区》\n      completed: false\n\n- class_name: 想买的东西\n  seat: left\n  todo_list:\n    - content: 小米平板5pro\n      completed: true\n    - content: 致态固态硬盘\n      completed: true\n\n- class_name: 想学的技术\n  seat: right\n  todo_list:\n    - content: Vue2/Vue3\n      completed: false\n    - content: Electron\n      completed: false\n\n- class_name: 想去的地方\n  seat: right\n  todo_list:\n    - content: 桂林\n      completed: true\n    - content: 杭州\n      completed: false\n\n```\n\n&emsp;&emsp;添加CSS:\n\n```css\n#todolist-box{\n    margin: 0 10px;\n}\n#todolist-main{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin: 16px 0 10px;\n}\n#todolist-main li{\n    list-style:none;\n    font-size: 17px;\n}\n#todolist-main ul{\n    margin: 0;\n    padding: 0;\n}\n#todolist-left{\n    width: 50%;\n    padding: 0 8px 0 0;\n}\n#todolist-right{\n    width: 50%;\n    padding: 0 0 0 8px;\n}\n.todolist-item{\n    position: relative;\n    background: #fae4df;\n    border-radius: 12px;\n    padding: 10px 1rem 1.2rem;\n    border: 2px dashed #f7a796;\n    margin-bottom: 1rem;\n}\n[data-theme=dark]\n.todolist-item{\n    background: #242424;\n    border: 2px dashed #51908b;\n}\nli.todolist-li i{\n    margin-left: 10px;\n}\nh3.todolist-title{\n    margin: 0!important;\n    border-bottom: var(--todo-border);\n}\nli.todolist-li{\n    border-bottom: var(--todo-border);\n    font-weight: normal;\n}\n.todolist-li span{\n    margin-left: 5px;\n}\n@media screen and (max-width:700px){\n    #todolist-left,#todolist-right{\n        width: 100%;\n        padding: 0;\n    }\n  }\n.page-top-card{\n  background-size: cover;\n  background-position: center;\n  height: 20.5rem;\n  padding: 10px 2.7rem;\n  border-radius: 20px;\n  color: white;\n  position: relative;\n}\n.page-top-card span.content-item-title{\n  font-size: 2.3em;\n  font-weight: bold;\n  line-height: 1.2;\n  font-family: STZhongsong,'Microsoft YaHei';\n}\n.page-top-card .content-bottom{\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: absolute;\n  width: calc(100% - 5.4rem);\n  bottom: 1rem;\n}\n[data-theme='dark'] .page-top-card{\n  opacity: .92;\n}\n\n```\n\n&emsp;&emsp;新建页面\n\n```markdown\n---\ntitle: ToDoList\ndate: 2023-03-18 14:07:13\ncomments: false\naside: false\ntype: todolist\n---\n\n```\n\n# 后记\n&emsp;&emsp;无\n\n\n\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"网站添加点赞、踩功能","url":"/article/5de26c08.html","content":"\n# 前言\n&emsp;&emsp;看[@Shine](https://blog.shineyu.cn/)在博客里整了个点赞功能[Qexo添加点赞功能](https://blog.shineyu.cn/qexo-postlike.html)，心动，那就行动。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/39-2.webp width=\"30%\">\n\n&emsp;&emsp;懒得整一个Qexo系统，那就看看有木有现成的点赞系统拿来改改用。找到力[orlike-vercel](https://github.com/caibingcheng/orlike-vercel)\n\n&emsp;&emsp;最终效果：\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/39-3.webp width=\"70%\">\n\n# 实现\n\n## 部署OrLike\n\n&emsp;&emsp;注册登录[leancloud](https://leancloud.app/)，最好是国际版，创建一个应用，名称随意。在侧栏找到**数据存储->结构化数据**，点击创建Class，名称为**OrLike**，默认ACL权限修改为所有用户。\n\n&emsp;&emsp;接着在侧栏找到**设置->应用凭证**，复制AppID和AppKey，后续用到。\n\n&emsp;&emsp;数据库设置完成，点击下面链接部署后端到Vercel。\n\n{% link Vercel部署OrLike点赞系统,https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fcaibingcheng%2Forlike-vercel%}\n\n&emsp;&emsp;部署完成后，在该Vercel项目的设置中找到环境变量，填入名为APPID（值对应之前复制的AppID）和APPKEY（对应AppKey）的环境变量，然后**重新部署**。\n\n&emsp;&emsp;由于vercel默认域名被墙，最好绑定自己的二级域名，该域名链接即为api。\n\n## 前端部署\n&emsp;&emsp;以Hexo-butterfly主题框架为例：\n\n&emsp;&emsp;修改`layout\\includes\\post\\reward.pug`，在末尾添加以下代码。\n\n```js\n#orlike-box.orlike-box\n  script.\n    (() => {\n      function loadOrLike () {\n        new OrLike({\n          serverUrl: \"你的api\",\n          el: \".orlike-box\",\n          days: 30,\n        });\n      }\n      window.pjax ? loadOrLike() : window.addEventListener('load', loadOrLike)\n    })()\n\n```\n\n&emsp;&emsp;修改`layout\\includes\\header\\post-info.pug`，在末尾添加以下代码，注意缩进在**.meta-firstline**内。\n\n```pug\nspan.post-meta-orlike\n    i.iconfont.icon-aixin.fa-fw.post-meta-icon\n    span.post-meta-label= '点赞数:'\n    a(href=url_for(page.path) + '#orlike-box')\n        span.orlike-count\n```\n\n&emsp;&emsp;在配置文件中全局引入该js和JQ：\n\n```js orlike.js(对OrLike项目源码仓库的orlike.min.js有修改，以适配业务)\nconst version = \"V0.1.33\"; function setCookie(cname, cvalue, exdays) { var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toGMTString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires; }\nfunction getCookie(cname) {\n    var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name) == 0) { return c.substring(name.length, c.length); } }\n    return \"\";\n}\nfunction createLink(url) { let link = $(document.createElement('link')); link.attr('href', url); link.attr('rel', 'stylesheet'); link.attr('type', 'text/css'); $('link').last().after(link); }\nfunction OrLike({ serverUrl = \"\", el = \"\", days = 30, style = \"\", ifont = \"\", icon = { like: \"fa fa-thumbs-up\", dislike: \"fa fa-thumbs-down\" }, } = {}) { this.serverUrl = serverUrl; this.el = el; this.style = style; this.ifont = ifont; this.days = days; this.icon = icon; this.ckid = \"\"; this.prepare(); this.init(); }\nOrLike.prototype.prepare = function () {\n    $(this.el).addClass(\"orlike-loading\"); if (this.style != \"\") { createLink(this.style); }\n    if (this.ifont != \"\") { createLink(this.ifont); }\n}\nOrLike.prototype.init = function () {\n    server_url = this.serverUrl; obj = this; $.ajax({\n        type: 'GET', url: server_url + '/tmp', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: true, crossDomain: true, success: function (data) {\n            let template = $(data.template); let icon_like = template.siblings(\"a.likeit.orlike\").children(\"i\"); let icon_dislike = template.siblings(\"a.dislikeit.orlike\").children(\"i\"); icon_like.attr('class', obj.icon.like); icon_dislike.attr('class', obj.icon.dislike); if (obj.icon.like == false)\n                icon_like.remove(); if (obj.icon.dislike == false)\n                icon_dislike.remove(); $(obj.el).removeClass(\"orlike-loading\"); $(obj.el).html(template); obj.ckusr(obj); $('a.likeit.orlike').click({ obj: obj }, obj.like); $('a.dislikeit.orlike').click({ obj: obj }, obj.dislike);\n        },\n    });\n}\nOrLike.prototype.ckusr = function (obj) {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/ckusr', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: false, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok' && data.uid != \"\") {\n                obj.ckid = data.ckid; if (!getCookie(data.ckid)) { setCookie(data.ckid, data.uid, obj.days); }\n                obj.query();\n            }\n            else { console.error('connect orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.query = function () {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/qry?link=' + window.location.pathname, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok') { \n                $('a.likeit.orlike i span').text(data['like']);\n                $('span.post-meta-orlike a span').text(data['like']);\n                $('a.dislikeit.orlike i span').text(data['dislike']);\n            }\n            else { console.error('query orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.orl = function (obj, method) { server_url = obj.serverUrl; req_url = server_url + '/orl?method=' + method + '&link=' + window.location.pathname + '&' + obj.ckid + '=' + getCookie(obj.ckid); $.ajax({ type: 'GET', url: req_url, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) { obj.query(); }, }); }\nOrLike.prototype.like = function (event) { obj = event.data.obj; obj.orl(obj, 'like'); }\nOrLike.prototype.dislike = function (event) { obj = event.data.obj; obj.orl(obj, 'dislike'); }\n\n```\n\n```yml\ninject:\n  head:\n  bottom:\n    - <script defer=\"true\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\n    - <script defer=\"true\" src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/orlike.js\"></script>\n```\n\n&emsp;&emsp;引入CSS：\n\n```css\n.orlike {\n  color: rgba(255, 255, 255);\n  font-size: 26px!important;\n  line-height: 2;\n  text-shadow: 5px 5px 5px #2ed0d9fc;\n}\n[data-theme=dark]\n.orlike {\n    color: rgba(255, 255, 255, 0.85);\n    text-shadow: 4px 4px 4px #23a8af99;\n}\n.orlike:first-child{\n    margin-right: 36px;\n}\n.orlike span {\n  margin-left: 0.3rem;\n}\n.orlike-box{\n    margin: 15px 0 0 0;\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n    height: 52px;\n}\n.orlike:hover{\n    color: #f07e7e!important;\n}\n[data-theme=dark]\n.orlike:hover{\n    color: #e87373e8!important;\n}\n.orlike-loading {\n    display: block;\n    height: 39px;\n    width: 10px!important;\n    border-radius: 50%;\n    border: 2px solid #acacac;\n    border-bottom-color: transparent;\n    -webkit-animation: orlike-loadingRotate 0.75s linear infinite;\n    animation: orlike-loadingRotate 0.75s linear infinite;\n}\n@-webkit-keyframes orlike-loadingRotate {\n  0% {\n    -webkit-transform: rotate(0deg);\n  }\n  50% {\n    -webkit-transform: rotate(180deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n  }\n}\n@keyframes orlike-loadingRotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n```\n\n\n&emsp;&emsp;完毕。\n\n# 后记\n&emsp;&emsp;无\n\n***\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"体验ChatGPT 不仅是搜索的革命","url":"/article/b19faa1c.html","content":"\n# 前言\n&emsp;&emsp;**本文由ChatGPT辅助编写文案**\n\n&emsp;&emsp;最近ChatGPT热度火爆，见多了小爱同学和siri，但哪见过这种ai，于是我也注册了个账号开始体验。\n\n&emsp;&emsp;ChatGPT的强大不仅在于它搜索答案的能力，而是它背后的模型分析问题的能力，它的回答不一定对，但它对于并不抽象的问题的分析与理解，已经与人无异了。\n\n***\n\n# 什么是ChatGPT\n\n&emsp;&emsp;什么是ChatGPT：ChatGPT是由OpenAI训练的大型语言模型，用于自然语言处理任务，如对话生成、文本摘要、机器翻译等。它是目前最先进的对话生成模型之一，可以根据给定的文本提示生成连贯、有逻辑的回复。\n\n&emsp;&emsp;所用到的技术：ChatGPT是一种基于自然语言处理（NLP）技术的对话生成模型，它使用了深度学习中的变压器（Transformer）网络结构，并通过对大量文本数据的预训练来学习语言模型。下面是一些ChatGPT使用的技术和方法：\n\n1. 变压器网络结构：变压器是一种序列到序列（seq2seq）模型，能够处理变长的输入和输出序列，适用于自然语言处理任务。ChatGPT使用了包含多个编码器和解码器的变压器结构，通过编码用户输入的文本并解码生成回复。\n2. 预训练：ChatGPT使用了大量的文本数据进行预训练，学习了语言模型中的单词嵌入、语法结构、上下文信息等。这些预训练模型可以被微调到特定的对话生成任务中，从而提高模型的表现。\n3. 无监督学习：ChatGPT是一种无监督学习模型，不需要人工标注数据就可以学习对话生成任务。它可以从大量的未标注文本数据中自动学习上下文信息、语言模式和语法结构，从而生成连贯的对话回复。\n4. 控制生成：ChatGPT可以通过添加特定的控制信息来控制对话的生成，例如指定回复的情感、主题或风格。这可以通过在输入中添加相应的标记或特定的控制向量来实现。\n\n&emsp;&emsp;总之，ChatGPT是一种基于深度学习和自然语言处理技术的先进对话生成模型，具有高度的可扩展性和灵活性，可以用于多种对话生成场景。\n\n***\n\n# 搜索答案的能力\n\n&emsp;&emsp;向ChatGPT问21年之前信息的问题，它几乎都能回答，但其回答并不一定对。下面是一些例子。\n\n&emsp;&emsp;先来点医学方面的，连花清瘟对于治疗新冠有效果吗?并列举相关的研究论文。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-2.webp width=\"100%\">\n\n&emsp;&emsp;再来点物理方面的，就问问它宇宙微波背景辐射吧。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-3.webp width=\"100%\">\n\n&emsp;&emsp;最后问几个关于鸿蒙系统的问题。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-4.webp width=\"100%\">\n\n&emsp;&emsp;这些问题可以看出ChatGPT对于搜索内容的整合，语言再组织能力非常强，条理清晰，结合上文回答问题也非常自然，可以理解“它”对于事物的指代，问题没有主语时也能根据前文的主语来回答后文的问题，当有它无法回答的问题时也能给出合理的建议。\n\n***\n\n# 编写程序的能力\n&emsp;&emsp;ChatGPT是一个自然语言处理模型，如果你需要让ChatGPT辅助你编写代码，可以通过以下几种方式：\n1. 与 ChatGPT 进行对话：你可以与 ChatGPT 进行对话，让它为你提供编码建议或解决编程问题的思路。\n2. 利用 ChatGPT 生成代码：你可以向 ChatGPT 提供关于你需要实现的功能或任务的自然语言描述，让 ChatGPT 帮你生成对应的代码。\n3. 利用 ChatGPT 进行代码搜索：你可以向 ChatGPT 提供一些关键字或问题描述，让它搜索互联网上的代码资源，并为你提供相关的代码片段或链接。\n4. 需要注意的是，虽然 ChatGPT 可以提供辅助，但它并不是一个完全的编程工具，它不能替代人类程序员的职责和责任，仍然需要开发人员自己进行实际的编程工作和质量控制。\n\n&emsp;&emsp;让ChatGPT使用js写一个获取网页指定文本并高亮的程序，这看其来是可行的。因为问题的限定较少所以代码也较简单，可以加一些限定，比如需要一层层遍历html结构，比如必要的报错提示，跨标签时分段处理等等。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-12.webp width=\"70%\">\n\n&emsp;&emsp;运行测试\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-13.webp width=\"100%\">\n\n&emsp;&emsp;ChatGPT有vscode插件，这个插件的模型对于编程支持度更好，速度也更快，且当你问其它话题时，还会催你聊编程相关的话题（\n\n&emsp;&emsp;安装插件后，选中任意代码片段，右键即可添加测试、让ChatGPT帮你找BUG、让ChatGPT帮你优化代码等等。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-14.webp width=\"100%\">\n\n&emsp;&emsp;难以想象这是一个免费的服务，以后看不懂的代码就让ChatGPT解释一遍。让机械式、重复性高、通用性强的代码都交给ai做，\n\n***\n\n# 对于情景分析的能力——以俄亥俄化学事故为例\n&emsp;&emsp;此次事故发生在2023年，而ChatGPT只学习到了2021年，通过设立它从来没有接触过的情景可以看到它的强大之处。\n\n&emsp;&emsp;设立和实际相符的大致情景：有一辆运载火车，有10节载有危险的有机物化学物品，其中5节载着液态氯乙烯大约320吨，剩下的车厢载着乙二醇单丁醚、异丁烯、丙烯酸异辛酯、丙烯酸丁酯，且还有适量的含苯或者含酚的阻聚剂，不幸的是这辆火车脱轨了，里面的剧毒化学物质都已发生泄露，而且还着火爆炸了，附近有水源已被火车上化学物质污染，露天的不完全燃烧已经持续了10天，接下来的1年内该地区和全球会发生什么？可能发生化学反应产生哪些物质？\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-5.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT说明可能产生的反应和产出的化学物质。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-6.webp width=\"90%\">\n\n&emsp;&emsp;回答不够详细，让ChatGPT详细地说明这些有机物之间发生相互作用和反应，可能产生的所有的有毒有害的物质。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-7.webp width=\"90%\">\n\n&emsp;&emsp;再让ChatGPT定量地分析，产生的有毒有害物质可能的体积和质量。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-8.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT分析此次事故可能造成的后果\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-9.webp width=\"90%\">\n\n&emsp;&emsp;有些人提出扔氢弹销毁所有的有化学机物，实际上福岛事故俄罗斯好像也提出过扔核弹，于是我向ChatGPT询问解决事故的办法，并尝试诱导它分析扔氢弹是否是可行的方案。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-10.webp width=\"90%\">\n\n&emsp;&emsp;它拒绝使用氢弹，继续尝试诱导。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/38-11.webp width=\"90%\">\n\n&emsp;&emsp;拒绝使用氢弹，且分析得有道理，不知道是这个语言模型是有对于核武等关键词的额外处理，还是ai自己通过学习分析出来的。\n\n&emsp;&emsp;虽然一堆有机物混在一起鬼都不想算，但大多都是准确的，特别是对于反应可能产生的物质分析，不过后面的200吨二噁英过于理想和夸张了，有机反应产率不可能这么高，二噁英会产生，但就算是不完全燃烧也只占产物的一小部分，氯乙烯没长链要生成二噁英得靠自聚形成聚氯乙烯，但是长途运输肯定要添加阻塑剂不然运过去都废一半了。所以氯乙烯自己产生大量二噁英难度有点大，但是阻塑剂本身有大部分带苯环，这就又有了产生二噁英或者别的难降解有毒物质的概率。\n\n\n***\n\n# 总结\n&emsp;&emsp;ChatGPT训练集主要是英文，但它对于中文问题的理解和回答速度不慢，准确性也相当可观，这毫无疑问是搜索引擎的一个革命性技术，一个用钱砸出来的语言模型和ai，通过俄亥俄化学事故的分析，这个语言AI的情景结合能力我认为与人在理性的方面已经无异了。\n\n&emsp;&emsp;NewBing也逐步开始内测，它是bing与ChatGPT的联合产物，与ChatGPT不同的是，它的模型比gpt3.5更加高级，且联网，每时每刻都在学习互联网上的信息，尽管这样可能导致一定危险，比如在水军泛滥的话题充满虚假信息却让ai学习了。\n\n","tags":["瞎折腾","ChatGPT"],"categories":["其它"]},{"title":"页面链接二维码(扫一扫)卡片","url":"/article/59995f0e.html","content":"\n# 前言\n&emsp;&emsp;[@Heo](https://blog.zhheo.com/)博客的侧边栏有个可以hover旋转的公众号二维码卡片，我很想抄过来，冻手！\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/37-2.webp width=\"60%\">\n\n&emsp;&emsp;但Heo是直接放了个ps改好的图，我没有公众号，打算放博客链接的二维码，把图片p个二维码就用不上，自己做个图又嫌麻烦（弱弱的ps技术），还是用div+css去实现吧。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/37-3.webp width=\"60%\">\n\n&emsp;&emsp;**效果：**因为不是图片，所以二维码可以根据页面的链接动态生成。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/37-4.gif width=\"40%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\widget\\card_tuijian.pug`，放入以下内容。\n\n```\n.card-widget#card-tuijian\n    #tj-box\n        #tj-box1\n            #tj-left\n                <p>扫一扫</p>\n                <span>快速打开移动端➤</span>\n            #tj-right\n                #tj-img-box\n                    if is_home()\n                        img(src=qrcode(full_url_for(page.current_url),{margin:4}))\n                    else\n                        img(src=qrcode(full_url_for(page.path),{margin:4}))\n                        \n        #tj-box2\n            #tj-left\n                <p>扫一扫</p>\n                <span>下载移动端APP➤</span>\n            #tj-right\n                #tj-img-box\n                    img(src=qrcode(\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/blog/app/chuckle.apk\",{margin:4}))\n\n```\n\n&emsp;&emsp;安装二维码生成插件。\n\n```\nnpm i -S hexo-helper-qrcode\n```\n\n&emsp;&emsp;修改`\\layout\\includes\\widget\\index.pug`,在合适位置加入。\n\n```\n!=partial('includes/widget/card_tuijian', {}, {cache: false})\n```\n\n&emsp;&emsp;CSS：\n\n```css\n#card-tuijian#card-tuijian#card-tuijian#card-tuijian {\n    background: linear-gradient(to right, #35bb99db, #2dbcc4db) !important;\n    padding: 15px 0;\n    height: 118px;\n    -moz-user-select: none;\n    -khtml-user-select: none;\n    user-select: none;\n}\n\n#card-tuijian #tj-box {\n    width: 100%;\n    height: 100%;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    transition: cubic-bezier(0, 0, 0, 1.29) 0.4s;\n}\n\n#card-tuijian #tj-box2 {\n    transform: rotateY(180deg);\n    -webkit-transform: rotateY(180deg);\n}\n\n#card-tuijian #tj-box1,\n#card-tuijian #tj-box2 {\n    display: flex;\n    justify-content: center;\n    flex-wrap: nowrap;\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n#card-tuijian #tj-img-box {\n    border-radius: 12px;\n    margin-left: 10px;\n    height: 85px;\n}\n\n#card-tuijian #tj-img-box img {\n    height: 85px;\n    border-radius: 12px;\n    filter: brightness(0.95) !important;\n}\n\n#card-tuijian #tj-left {\n    color: #fff;\n    height: 85px;\n}\n\n#card-tuijian #tj-left p {\n    font-family: monospace, Arial;\n    margin: 10px 0 0;\n    font-size: 32px;\n    line-height: normal;\n    font-weight: 800;\n    color: rgba(255, 255, 255, 0.9);\n    text-shadow: -0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px -0.5px 0 rgba(255, 255, 255, 0.9), -0.5px -0.5px 0 rgba(255, 255, 255, 0.9);\n}\n\n#card-tuijian #tj-left span {\n    font-size: 15px;\n    font-weight: 800;\n}\n\n#card-tuijian:hover #tj-box {\n    -webkit-transform: rotateY(180deg);\n    transform: rotateY(180deg);\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n```\n\n# 后记\n&emsp;&emsp;2023-2-22：修改CSS，修复火狐浏览器下未能正确隐藏背面元素的bug\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"给文章添加自定义文本锚点","url":"/article/6f237a88.html","content":"\n# 前言\n&emsp;&emsp;起因是群里有人提出，搜索关键词后只能跳转到对应文章，而不能自动再跳转至关键词处，当然，本文不是实现这个(实际上已经实现了)，这给了我一个想法，为啥不弄个文本锚点呢，把选中的文本都保存起来，点击就滚动页面过去，这是一个不错的主意。\n\n&emsp;&emsp;**功能：**选中页面文字保存锚点，点击锚点，页面滚动到对应文本处并背景高亮，当一个锚点对应多处文本时，多次点击锚点，页面能循环地逐个滚动到对应位置。\n\n&emsp;&emsp;**效果：**\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/36-2.gif width=\"88%\">\n\n# 实现\n&emsp;&emsp;首先是右侧悬浮栏的锚点按钮和容器，修改`\\layout\\includes\\rightside.pug`,对应着原有缩进添加。\n\n```js\nwhen 'anchor'\n    if is_post()\n        button#post-anchor\n            i.fas.fa-book\n            #post-anchor-after\n            #post-anchor-rom\n              #post-anchor-box\n                #no-anchor 没有锚点\n                script.\n                  var anchor_back = '';\n                  var anchor_length = 0;\n                  var anchor_node = '';\n                  function toAnchor(obj) {\n                    var anchor = $(obj).text();\n                    $(\"anchorbox\").parent().each(function(){ \n                      $(this).html($(this).html().replace(/(<\\/?anchorbox.*?>)/g,''));\n                    }) \n                    \n                    if(anchor_back == anchor){\n                      i++;\n                      if(i>=anchor_length){\n                        i = 0;\n                      }\n                    }else{\n                      i = 0;\n                      anchor_back = anchor;\n                      anchor_node = $('#article-container *:contains('+anchor+')').not(\".highlight *,.mini-sandbox *,.tag.link *,.folding-tag *\");\n                      anchor_length = anchor_node.length;\n                    }\n                    if(anchor_length>0){\n                      btf.snackbarShow(\"该锚点对应有 \"+anchor_length+\" 处文本,当前：\"+(i+1));\n                      btf.scrollToDest(anchor_node.eq(i).offset().top-200);\n                    }else{\n                      btf.snackbarShow(\"文章内没有对应文本或出现致命错误，请避免选中跨标签跨行文本。\");\n                    }\n                    let input = anchor;\n                    let textNodes = [];\n                    (function getTextNodes(node) {\n                      if (node.nodeType === Node.TEXT_NODE) {\n                        textNodes.push(node);\n                      } else {\n                        for (let i = 0; i < node.childNodes.length; i++) {\n                          getTextNodes(node.childNodes[i]);\n                        }\n                      }\n                    })(document.getElementById(\"article-container\"));\n                    for (let i = 0; i < textNodes.length; i++) {\n                      let node = textNodes[i];\n                      let text = node.nodeValue;\n                      let index = text.indexOf(input);\n                      if (index !== -1) {\n                        let newNode = document.createElement(\"anchorbox\");\n                        newNode.appendChild(document.createTextNode(text.substring(index, index + input.length)));\n                        node.nodeValue = text.substring(0, index);\n                        node.parentNode.insertBefore(newNode, node.nextSibling);\n                        node.parentNode.insertBefore(document.createTextNode(text.substring(index + input.length)), newNode.nextSibling);\n                      }\n                    }\n                  }\n…………\n\n#rightside\n  - const { enable, hide, show } = theme.rightside_item_order\n  - const hideArray = enable ? hide && hide.split(',') : ['refresh','translate','enlargePage','narrowPage','bg','darkmode','hideAside']\n  //在下面添加个'anchor'\n  - const showArray = enable ? show && show.split(',') : ['toc','anchor','chat','comment', 'share']\n\n```\n\n&emsp;&emsp;然后是右键选中文字添加锚点按钮`rightside.pug`\n\n```js\na.rightMenu-item(href=\"javascript:addAnchor();\")\n    script.\n        function addAnchor () {\n            if($(\"#no-anchor\").length > 0){\n                $(\"#no-anchor\").remove();\n            }\n            var txt = window.getSelection().toString();\n            txt = txt.replace(/<[^>]*>/g, \"\");\n            $(\"#post-anchor-box\").prepend('<a class=\"anchor-item\" href=\"javascript:void(0);\" onclick=\"toAnchor(this)\" data-pjax-state=\"\">'+txt+'</a>');\n            btf.snackbarShow(\"成功添加一个文本锚点\");\n        }\n    i.fa.fa-book\n    span='添加锚点'\n\n```\n\n&emsp;&emsp;当然没有右键就把js拿去，监听下选中文字后弹出个按钮触发一下`addAnchor()`就行。右键教程可看[自定义右键菜单](https://blog.dorakika.cn/p/20220118.html)\n\n&emsp;&emsp;添加CSS：\n\n```css\n#post-anchor{\n    z-index: 10!important;\n}\n#post-anchor-rom{\n    position: fixed;\n    width: auto;\n    overflow: hidden;\n    border-radius: 12px;\n    bottom: 20px;\n    right: -241px;\n    border: var(--anchor-border);\n    transition: all .27s;\n    opacity: 0;\n    max-height: 380px;\n    height: 100%;\n    width: 240px;\n    z-index: 9;\n}\n#post-anchor-box{\n    display:flex;\n    background: #fff;\n    max-height: 380px;\n    height: 100%;\n    flex-wrap: nowrap;\n    flex-direction: column;\n    justify-content: flex-start;\n    border-radius: 12px;\n    overflow: auto;\n}\n#post-anchor-after{\n    display: none;\n    position: fixed;\n    bottom: 20px;\n    right: 0px;\n    background: transparent;\n    max-height: 380px;\n    height: 100%;\n    width: 100px;\n}\n#post-anchor-box a{\n    padding: 5px 10px;\n    width: 100%;\n    border-bottom: 1px solid rgb(8, 148, 235);\n    font-weight: 800;\n}\n#post-anchor:hover #post-anchor-rom{\n    opacity: 1;\n    right: 70px;\n    transition: all .25s;\n}\n#post-anchor:hover #post-anchor-after{\n    display:block;\n}\n#article-container anchorbox{\n    color: black!important;\n    font-weight: 800!important;\n    border-radius: 6px!important;\n    background-color: rgb(253 253 20 / 70%)!important;\n}\na.anchor-item{\n    font-size: 16px;\n    line-height: 17px;\n    text-align: left;\n}\na.anchor-item:hover{\n    background-color: #16b2ef;\n    color: #fff;\n}\n#no-anchor{\n    color: rgb(140, 140, 140);\n    font-size: 30px;\n    line-height: 375px;\n    opacity: 0.8;\n}\n[data-theme=dark]\n#post-anchor-box{\n    background: #000;\n}\n[data-theme=dark]\n#article-container anchor{\n    color: rgb(255, 255, 255);\n}\n@media screen and (max-width:768px){\n    #rightside #post-anchor{\n        display: none!important;\n    }\n}\n\n```\n\n# 后记\n&emsp;&emsp;因为是文章页才用到的JS，不是全局的，量也不多，就直接写在pug里了，还能避免pjax的适配问题。\n\n&emsp;&emsp;已知BUG：选中锚点跨标签的话，可以跳转，但是没法套标签使背景高亮，这就emm有点烦。当选中的文本只包含半个右半边英文括号时，锚点会无法跳转和高亮，原因未知。","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Ventoy多系统移动硬(U)盘","url":"/article/a41cefd.html","content":"\n# 认识Ventoy\n&emsp;&emsp;Ventoy是一个制作可启动U盘的开源工具，可以直接启动iso等镜像、vhd虚拟磁盘等等，支持大部分操作系统，同一个U盘可以同时支持Legacy BIOS、IA32、UEFI等模式。\n{% link Ventoy文档官网,https://www.ventoy.net/cn/,/images/ventoy.webp%}\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-1.webp width=\"70%\">\n\n***\n\n# 安装Ventoy\n&emsp;&emsp;普通U盘只适合运行pe镜像，运行win(vhd)或者linux需要4k性能较好的U盘，推荐使用移动硬盘。\n&emsp;&emsp;我的移动硬盘：致钛5000+itgz(9210b)硬盘盒。\n&emsp;&emsp;下载[Ventoy安装包](https://www.ventoy.net/cn/download.html)，运行**Ventoy2Disk.exe**，选择移动硬盘(U)盘，配置选项中选择分区类型MBR或GPT，默认为MBR，点击安装，等待几分钟即可。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-2.webp width=\"50%\">\n\n&emsp;&emsp;安装完成后，移动硬盘(U)盘会被分成两个区，VENTOY隐藏分区和ventoy分区，ventoy分区可正常存储文件，**接下来的操作无特殊说明都在此分区**。\n&emsp;&emsp;将ventoy分区格式化为**NTFS**格式(默认为exFAT)\n\n***\n\n# 配置Ventoy\n&emsp;&emsp;在根目录新建ventoy文件夹，在该文件夹内新建**images**文件夹、**ventoy.json**，打开ventoy.json填入以下配置。具体介绍在此处查看[Ventoy 全局控制插件](https://www.ventoy.net/cn/plugin_control.html)\n\n```json\n{\n  \"control\":[\n      { \"VTOY_HELP_TXT_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MENU_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MAX_SEARCH_LEVEL\": \"max\" },\n      { \"VTOY_DEFAULT_SEARCH_ROOT\": \"/ventoy/images\" }\n  ]\n}\n\n```\n\n***\n\n# 配置安全启动\n&emsp;&emsp;windows默认开启Secure Boot(安全启动【垄断启动】)，Ventoy1.0.07版本开始支持Secure Boot，但需要手动配置KEY，或者进bios关闭Secure Boot才能使用Ventoy。\n&emsp;&emsp;如已关闭Secure Boot，跳过下面步骤。\n\n&emsp;&emsp;启动电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入一个ERROR界面，按照文档[UEFI模式安全启动操作说明](https://www.ventoy.net/cn/doc_secure.html)，配置Enroll Key或Enroll Hash。\n\n&emsp;&emsp;配置好后会重启电脑，一般无需操作会正常回到电脑主系统。\n\n***\n\n# 运行PE\n&emsp;&emsp;ventoy运行pe非常简单，下载或生成好PE的iso镜像，放入/ventoy/images内即可。\n&emsp;&emsp;重启电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入ventoy界面，选择pe的iso镜像即可进入pe系统\n\n&emsp;&emsp;推荐pe：[微pe](https://www.wepe.com.cn/)、[firpe](http://www.firpe.cn/)、[Hikari PE](https://hikaricalyx.com/)\n\n***\n\n# 运行windows(vhd)\n&emsp;&emsp;准备好一个windows镜像。\n&emsp;&emsp;在ventoy中挂载运行vhd(x)虚拟磁盘可以和正常系统一样升级系统、安装驱动、安装软件等等，能保存对系统的修改和操作。所以推荐使用vhd运行windows。如果使用iso则与pe操作一样。\n\n&emsp;&emsp;下载[Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)，6.1版本即可。运行软件，点击新建(虚拟机)。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-3.webp width=\"75%\">\n\n&emsp;&emsp;进入专家模式，名称任意，文件夹选择**移动硬盘里的**任意一个文件夹(新建)，选择镜像对应的win版本，点击创建。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-4.webp width=\"60%\">\n\n&emsp;&emsp;文件大小50g以上，即系统C盘大小。虚拟硬盘文件类型选vhd，动态大小。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-5.webp width=\"60%\">\n\n&emsp;&emsp;选择虚拟光盘，进入后点击注册，选择windows的iso镜像。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-6.webp width=\"75%\">\n\n&emsp;&emsp;选择好镜像后，点击启动虚拟机。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-7.webp width=\"75%\">\n\n&emsp;&emsp;进入安装引导界面，一直下一步，选择创建好的虚拟硬盘继续下一步。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-8.webp width=\"70%\">\n\n&emsp;&emsp;等待系统安装完成，移除iso镜像，即可正常启动系统，务必在虚拟机中启动一次系统，进入桌面，否则虚拟硬盘无法给ventoy使用。\n\n&emsp;&emsp;关闭虚拟机，在硬盘中找到vhd文件，移动进/ventoy/images文件夹。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-9.webp width=\"40%\">\n\n&emsp;&emsp;重启电脑，在ventoy中选择此vhd即可启动winodws。\n\n***\n\n# 运行Linux\n\n***\n\n# 测试ventoy\n&emsp;&emsp;修改了配置或者镜像，想测试一下，无需每次都重启电脑进入ventoy，可以使用VMware Workstation创建本地磁盘虚拟机。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/35-10.webp width=\"80%\">\n\n***\n\n# 配置主题\n\n\n***\n\n# 注意事项\n1. 虚拟硬盘创建的大小不要超过母盘。\n\n***\n\n\n\n\n\n\n","tags":["教程","Ventoy"],"categories":["教程"]},{"title":"BF添加输入页数跳转","url":"/article/8e0b4c43.html","content":"\n# 前言\n&emsp;&emsp;以后文章多了页数也会多起来，bf没有输入页码跳转实在不方便，现在就加上这个功能好。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/34-2.webp width=\"65%\">\n\n***\n\n# 实现\n&emsp;&emsp;修改`\\layout\\includes\\pagination.pug`替换else后的源码，或者对应着修改。\n\n```js\nelse\n  nav#pagination\n    .pagination\n      if is_home()\n        - options.format = 'page/%d/'\n      !=paginator(options)\n      if is_home()\n        input#textnumer(oninput=\"value=value.replace(/[^0-9]/g,'')\" maxlength=\"3\" onkeyup='this.value=this.value.replace(/[^u4e00-u9fa5w]/g,\"\")')\n        a#textbtn(onclick='textbtn()') 跳转\n    if is_home()\n      .js-css\n        script.\n          function textbtn(){var e=document.querySelectorAll(\".page-number\"),t=e[e.length-1].innerHTML,n=Number(t),a=document.getElementById(\"textnumer\"),o=Number(a.value);if(\"\"!=o&&!isNaN(o)&&o%1==0)if(1==o)document.getElementById(\"textbtn\").href=\"/\";else if(o>n){var d=\"/page/\"+n+\"/\";document.getElementById(\"textbtn\").href=d}else d=\"/page/\"+a.value+\"/\",document.getElementById(\"textbtn\").href=d}\n        style.\n          #pagination .pagination .extend{display: none!important}\n\n```\n\n&emsp;&emsp;css的话，没有通用的，怎么好看怎么改。\n\n***\n\n# 后记\n&emsp;&emsp;暂无\n\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"阳了个🐑","url":"/article/4154609f.html","content":"\n# 没想到咋🐑的\n&emsp;&emsp;2022年12月17号，作为全国高校跑毒的最后一批，我戴上3M有呼吸阀的N95，经过广州南，坐高铁几百公里回家都没有阳，但就在前几天，喉咙发干，头有些发紧，腰有点酸，我意识到可能中招了，但还是嘴硬觉得没阳，并且愉快地**洗了个澡**。\n\n&emsp;&emsp;自我隔离5天后才真正回家，之后出门戴口罩，随身带酒精消毒，这四天千防万防，还是难逃一🐑。\n\n***\n\n# 2022-12-27\n&emsp;&emsp;也许因为昨天洗了个澡，27号凌晨突然39度高烧，还有全身不舒服发冷，头皮发麻脑袋要裂开等等，好在高烧在短短一小时就结束了，但这整晚在身体各种不适下还是难以入眠，退烧后的凌晨2点头特别疼、喉咙干。\n\n&emsp;&emsp;早上7点早早起来，一量38.5度，也听到了我爸的咳嗽声，多半也🐑了。虽然整天都是38.5度，但白天并没感觉发冷，到了晚上，冷到两层被子裹四层睡。并且晚上开始有了咳嗽，一咳整个脑袋要裂开。显然，这一晚又没睡好。\n\n***\n\n# 2022-12-28\n&emsp;&emsp;整天体温37.5，第两天半也该降温了，但各种新症状也来了，一咳嗽肚子到胸口处就酸痛，导致咳到一半总无力，开始有了黄绿色浓痰、鼻涕。味觉倒还在，就是没啥食欲，耳朵感觉被堵住一样，听力和低频声音分别有明显下降。\n\n&emsp;&emsp;这天，我妈也阳了，症状都差不多，第一天38.5度。\n\n***\n\n# 2022-12-29\n&emsp;&emsp;整天37.3，降温聊胜于无，在前几天症状的叠加延续下，这天也是感觉特别地累，腰酸背痛，精神不振。下午测了下抗原，果然两道扛。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;家里其他人也阳了。我好了一些，下楼去买些食物和药品，跑了四家规模还算大的药店，体温计、小柴胡、抗病毒口服液啥都没有。去超市提了9.8一斤的雪梨润润喉，30块钱四个真滴贵。\n\n***\n\n# 2022-12-30\n&emsp;&emsp;凌晨睡觉出现了明显的耳鸣，感觉远处有上万只苍蝇在飞。\n\n&emsp;&emsp;白天精神好了些，体温在36.9度，低频听力回来了一些，不多，但有用，咳嗽稍微没这么频繁了，但一咳还是头疼难受，鼻涕流得更多了。\n\n***\n\n# 2022-12-31\n&emsp;&emsp;往后就是漫长的后遗症了，咳嗽和感觉乏力，注意力下降，精神状态不好。\n\n***\n\n# 2023-01-11\n&emsp;&emsp;总算不咳嗽了，算是阳康了，至于累嘛，也许是干家务加熬夜的锅。\n\n***\n# 后记\n&emsp;&emsp;比受冻感冒、季节性流感难受多了。没咋吃西药，含完了一盒金嗓子，没买到喉风散只好喷西瓜霜，泡了柠檬红枣水喝，还有一些老人家的秘方汤。\n\n&emsp;&emsp;**一个链接：**[上海新冠疫情大样本数据研究](https://mbd.baidu.com/newspage/data/landingsuper?isBdboxFrom=1&pageType=1&urlext=%7B%22cuid%22%3A%22YiHGuguCSu_6aB8RjavRigaC2i0Nu2fQ_u2lflu2vu_Iav8C_aHC8lf51O5FiHPy9M1mA%22%7D&context=%7B%22nid%22%3A%22news_9139130449349147433%22%7D)\n\n\n&emsp;&emsp;**一些图片：**\n\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-2.webp)\n![](https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-3.webp)\n![](https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-4.webp)\n![](https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-5.webp)\n![](https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/33-6.webp)\n{% endgallery %}\n\n***\n","tags":["新冠"],"categories":["其它"]},{"title":"前后端交互初步概念","url":"/article/709b5ecb.html","content":"\n# 前言\n&emsp;&emsp;前后端交互本来是一个简单明了的概念，发请求与响应以及所用到的技术，但如百度等搜索结果大部分都抛出一堆菜鸟如我看不懂的概念与操作，上来就是用vue，或者新建一个MVC项目，实在不友好。\n&emsp;&emsp;本文旨在建立一个初步的、以前端为视角的前后端交互概念。\n\n***\n\n# 为什么要前后端交互\n&emsp;&emsp;以前的网页，用户在浏览器输入链接访问后，服务器一顿操作，渲染出页面扔给浏览器显示。而当页面内某段话，某个数字需要变，服务器又得重新渲染整个网页。\n&emsp;&emsp;这很麻烦，像PHP、JSP，代码写在HTML中,也就是前后端不分离的表现。下面就是一个JSP的表格。\n```jsp\n<tbody class=\"book-body\">\n\t<c:forEach items=\"${bookList}\" var=\"book\">\n\t\t<tr class=\"book-tr\">\n\t\t\t<td>${book.bId}</td>\n\t\t\t<td>${book.bName}</td>\n\t\t\t<td>${book.auName}</td>\n\t\t\t<td>${book.bType}</td>\n\t\t\t<td>${book.bPress}</td>\n\t\t</tr>\n\t</c:forEach>\n</tbody>\n\n```\n\n***\n\n## 表单\n&emsp;&emsp;在这个前后端不分离的时代，所谓前端实现单纯的登录操作JS都不用写。弄个表单，点击表单内`type=\"submit\"`的按钮，就能对`action=\"doLogin\"`发起登录的`get`/`post`请求，然后再由服务器去处理，登录失败就渲染`${errorMsg}`。\n```html\n<form action=\"doLogin\" method=\"get\">\n    <p>用户名</p>\n    <input name=\"userName\" type=\"text\" placeholder=\"输入用户名/邮箱\" />\n    <p>密码</p>\n    <input name=\"password\" type=\"password\" placeholder=\"输入密码\" />\n    <button type=\"submit\" class=\"btn1\">登录</button>\n\t<span>${errorMsg}</span>\n</form>\n\n```\n\n&emsp;&emsp;有时候需要触发事件而提交表单，比如删除操作，可以使用JQ伪造表单提交\n```js\nbtn.bind(\"click\", function () {\n\tvar id = btn2.parent().parent().children(\"td\").get(0).innerHTML;\n\tvar form = $(\"<form method='get'></form>\");\n\tform.attr({ \"action\": \"/myBatisDemo/deleteBooksById\" });\n\tform.append($(\"<input type='hidden'>\").attr(\"name\", \"bId\").val(id));\n\t$(\"body\").append($(form));\n\tform.submit();\n});\n\n```\n\n&emsp;&emsp;面对越来越复杂的网页页面，以及无刷更新内容提升体验的需求，后端提供数据前端去使用成了主流，这也大大减轻了服务器的压力，随着Ajax的出现，JS可以使用json来与服务器进行数据交互，真正的前后端分离出现了。\n\n***\n\n# 前端如何与后端交互\n&emsp;&emsp;和以前一样，后端会提供一个接口，就像是表单属性`action=\"/myBatisDemo/deleteBooksById\"`里的一样。JS本身没有网络通信能力，但使用浏览器提供的对象和方法，遵循一定的规范协议(**http**)，就可以通过这些接口与后端交互，也就是发请求和处理响应。\n&emsp;&emsp;后端响应后，拿到后端返回的内容(JSON)，我们可以判断密码是否正确，或者通过DOM操作改变网页内容等等。\n\n***\n\n## Ajax\n&emsp;&emsp;**Ajax**是最早出现的向后端发送请求的技术，其核心是浏览器提供的**XMLHttpRequest(xhr)**对象。我们可以直接原生地使用它。\n```js\n//既然xhr是个对象，当然要先new再使用里面的方法\nlet xhr = new XMLHttpRequest();\n//定义我们的请求，与一个url建立连接，true代表异步请求\nxhr.open('GET', '/url', true);\n//readyStated，它一共有五个值，当等于4时代表请求已完成\n//readyStated的变化会触发onreadystatechange事件\nxhr.onreadystatechange = function(){\n    //当readyState为4以及http状态码为200代表请求成功，响应已就绪\n    if(this.readyState === 4 && this.status==200){\n        //对DOM的操作，比如替换个P标签的内容\n        console.log(this.responseText);//打印响应返回的文本\n    }\n}\n//把请求发送一下\n//因为没有请求体的所以为null\nxhr.send(null);\n\n```\n\n&emsp;&emsp;利用Ajax进行前后端交互看起来非常简单，拿到响应后进行DOM操作即可，当然，在实际的开发中，很少写原生的Ajax，而是使用封装好的第三方库和框架，比如**jQuery**、**axios**\n```js 使用jQuery封装好的Ajax\n $.ajax({\n    //获取数据url地址\n    url: \"/url\",\n    //获取数据的方式\n    type: \"GET\",\n    //获取数据类型\n    dataType: \"JSON\",\n    //接口所需参数\n    data:{\"id\":1},\n    beforeSend: function () {\n        console.log(\"发起请求之前在控制台打印\");\n    },\n    //请求数据成功调用的方法\n    //传参data代表请求成功的数据\n    success:function(data){\n        console.log(data);\n    },\n    //请求失败\n    error: function(err) {\n\t\tconsole.log(err);\n\t},\n    complete: function () {\n        console.log(\"请求完成时在控制台打印\");\n    }\n})\n\n```\n\n&emsp;&emsp;可以看到，使用已经封装好的Ajax更加方便、简单。\n\n>一个非常好的Ajax基础教程：[Ajax基础](https://zhuanlan.zhihu.com/p/474914790)\n\n***\n\n## Fetch\n&emsp;&emsp;在**ES6**中，新增了一种HTTP数据请求的方式：**Fetch**。\n&emsp;&emsp;不同于Ajax是一种技术，使用**XMLHttpRequest**去实现，Fetch从定义上本身就是一个真实存在的API，它使用了ES6提出的**promise**对象(链式处理解决回调地狱)。关于Ajax、Fetch区别，说法五花八门，还是以后再深入了解吧。也可先看此知乎问题的第二个回答[fetch底层也是基于XMLHttpRequest吗](https://www.zhihu.com/question/335786718)\n\n&emsp;&emsp;如何使用Fetch发请求，以登录为例：\n```js\nfetch('/login', {\n\tmethod: \"POST\",\n    //请求的主体，转换为json对象\n\tbody: JSON.stringify({ username: account.value, password: password.value }),\n    //http头部的内容类型\n\theaders: {\n\t\t\"Content-Type\": \"application/json\"\n\t},\n})\n.then(response => {\n    //判断响应是否成功\n\tif (response.ok) {\n        //转换成js可操作的json数据并返回对象\n\t    return response.json();\n\t} else {\n\t    return Promise.reject('QAQ出错啦');\n\t}\n})\n.then(data => {\n    //拿到json对象后进行处理\n\tconsole.log(data);\n    //这里的data是服务器返回的json\n});\n\n```\n\n***\n\n## axios\n&emsp;&emsp;[axios官方文档](https://www.axios-http.cn/)\n&emsp;&emsp;Ajax只是一种技术，最开始单纯通过xhr去实现，而当**promise**出现后，出现了**axios**，它通过promise实现对ajax技术的一种封装，底层仍然是xhr，但支持了promise等一系列新功能与API。\n&emsp;&emsp;与Ajax(xhr版)、Fetch不同的是，axios是第三方库，所以需要npm安装或者cdn引入后才可使用。\n\n&emsp;&emsp;简单的get：\n```js\naxios.get('/url', {\n    params: {\n        username: 'chuckle'\n    }\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;简单的post:\n```js\naxios.post('/url', {\n    username: 'chuckle',\n    password: '123456'\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;相较于Ajax的老旧，Fetch的稚嫩，axios是目前最流行的网络请求库，vue、react都使用它，但如果简单发个请求获取个一言啥的，还是用fetch方便，毕竟能少引用一个库。\n\n***\n\n# 实战一下\n\n<div id=\"get-example\"></div>\n\n***\n\n# 后记\n&emsp;&emsp;本文只简单概述了下前后端交互(前端发请求)的概念与实现方式，让有可能需要的人建立一个初步的、以前端为视角的前后端交互概念，也就是Ajax、Fetch和axios的初步认识。具体的HTTP、ES6、JSON、Promise等等，再说，在学（。\n\n>参考文章：\n>[Ajax(XMLHTTPRequest)和Fetch的认识以及利用promise和ts实现一个Ajax](https://zhuanlan.zhihu.com/p/366458405)\n>[简单通俗来讲ajax与axios的区别](https://www.cnblogs.com/bingcola/p/16499188.html)\n>[fetch底层也是基于XMLHttpRequest吗？](https://www.zhihu.com/question/335786718)\n>[XMLHttpRequest—必知必会](https://www.jianshu.com/p/918c63045bc3)\n>[AJAX基础](https://zhuanlan.zhihu.com/p/474914790)\n>[你知道Ajax、Fetch、Axios三者的区别吗](https://juejin.cn/post/7086325194934976519)\n\n***\n\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/32.js?1\"></script>\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"使用MiniSandbox前端代码可视化","url":"/article/b827db53.html","content":"\n# 前言\n&emsp;&emsp;官方文档:[Mini Sandbox](https://buuing.github.io/mini-sandbox/#/),Github仓库:[mini-sandbox](https://github.com/buuing/mini-sandbox)\n\n&emsp;&emsp;这也算是一篇安利文，markdown本身的代码框直接显示代码，对于前端的代码来说，样式效果全靠截图，动不起来，也没交互，虽然可以复制到我另一个单页[HTML/CSS/JS 在线工具](/hjc/)，但切换页面和复制终究不直观，影响阅读体验。\n\n&emsp;&emsp;前段时间看到这个新的前端代码、组件可视化方案，兼容任意js环境，就计划弄到Hexo上试试，其纯前端部署,不依赖服务器,静态页即可实现编辑和预览功能也十分契合Hexo静态站，手动适配了下Hexo的夜间模式以及pjax，效果非常不错。\n\n***\n\n# 安装\n>首先推荐先看[官方文档](https://buuing.github.io/mini-sandbox/#/)。\n\n&emsp;&emsp;我将其保存在本地引入，并且稍微根据需要对`mini-sandbox.js`作了一点修改，由于这个js压缩后还有450kb，我建议是在有使用需要的单页通过cdn引入。\n```html \n<script src=\"https://unpkg.com/mini-sandbox@0.3.11\"></script>\n```\n\n***\n\n# 使用\n&emsp;&emsp;在Hexo中使用也很方便\n```html 在markdown中需要的地方插入div,并在文末引入一个js\n<div id=\"my-sandbox\"></div>\n···\n<script src=\"index.js\"></script>\n```\n\n```js index.js中按文档这样写\nnew MiniSandbox({\n    el: '#my-sandbox',//注意id和上面的一致\n    files: {//要几个页面就仿照写法加几个\n        'index.html': {//html\n            title: 'HTML',//tab上实际显示的名字\n            defaultValue: `<button>点击</button>`,//HTML的内容/代码\n            cssLibs: ['index.css'],//html引入的css\n            jsLibs: ['index.js'],//html引入的js\n        },\n        'index.css': {\n            title: 'CSS',\n            //CSS的内容/代码,写起来排版有点怪，但熟悉了也还好\n            defaultValue: `button {\n  width: 100%;\n  color: red;\n}\n        `},\n        'index.js': {\n            title: 'JS',\n            //JS的内容/代码\n            defaultValue: `const btn = document.querySelector('button')\nbtn.addEventListener('click', () => {  \n    alert('这是一个按钮')\n})\n        `}\n    },\n    //用来设置一些Sandbox的默认配置\n    defaultConfig: {\n        height: '330px',//Sandbox的高度,默认为 '300px'\n        autoRun: true,//每次修改后是否自动运行, 默认等于 true\n        autoRunInterval: 1000,//每次自动运行的时间间隔,单位为毫秒,默认等于300\n        editorRange: '55%',//编辑区域默认占比,默认情况下编辑区域占50%\n        draggable: true,//是否可以左右拖动布局, 默认为true\n        direction: 'row',//控制上下/左右布局,默认为'row','row' | 'row-reverse' | 'column' | 'column-reverse'\n      }\n})\n\n```\n\n&emsp;&emsp;效果如下:\n<div id=\"my-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox不仅让我能方便展示前端的代码、组件，同时也允许读者直接修改代码框中的内容并运行（自动的，实时的），试着改改下面的代码，看看效果吧。\n<div id=\"myAuthorBox-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox还对CSS有补全和提示，F12可以直接用浏览器的。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/30-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;当然，如果单纯展示,不希望读者修改，也可以将css、js写在resource中:\n```js\nnew MiniSandbox({\n  el: '#exhibition-sandbox',\n  files: {\n    'index.html': {\n      title: 'HTML',\n      defaultValue: `<input type=\"text\" value=\"0\"><br><br>\n<input type=\"submit\" value=\"加一\">\n<input type=\"submit\" value=\"清除\">  \n    `}\n  },\n  resource: {\n    cssLibs: [],\n    jsLibs: [],\n    css: `\n      input {\n        color: blue;\n      }\n    `,\n    js: `\n      var text = document.getElementsByTagName('input')[0];\n      var add = document.getElementsByTagName('input')[1];\n      var clear = document.getElementsByTagName('input')[2];\n      add.onclick = function numberadd(){\n        text.value++;  \n      }\n      clear.onclick = function clearnumber(){\n        text.value = 0; \n      }\n    `,\n  }\n})\n```\n\n&emsp;&emsp;效果:\n<div id=\"exhibition-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox左上角按钮点击后有一些可自定义的功能\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/30-2.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;除了上述的一些基本功能,Mini Sandbox还有很多功能，如直接放置CDN链接展示组件库，如Sandbox事件的触发回调函数，如支持vue、react等，并且在持续更新。\n\n***\n\n# 更多示例\n官方文档提供了一些示例：[Examples & 示例](https://buuing.github.io/mini-sandbox/#/docs/html)\n\n***\n\n# Hexo夜间适配\n```css\n  .mini-sandbox{\n    box-shadow: none!important;\n    border-radius: 7px;\n  }\n  [data-theme=dark]\n  .mini-sandbox{\n    background-color: #151515!important;\n  }\n  [data-theme=dark]\n  .cm-activeLine{\n     background-color: #252525!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head{\n    background: #202020!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .cm-gutters{\n    background: #202020!important;\n  }\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    box-shadow: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .cm-activeLineGutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .sandbox-body .sandbox-gutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-gutter{\n    border-left: 1px solid #404040!important;\n    border-right: 1px solid #404040!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::after{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::before{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-render{\n    background: #E1E1E1!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼd{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼc{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼb{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼf{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼh{\n    color: #ff5370!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼa{\n    color: #FF00FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼi{\n    color:#5F9EA0!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼl{\n    color:#969896!important;\n  }\n  .mini-sandbox{\n    margin-bottom: 10px;\n  }\n\n```\n\n***\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/mini-sandbox.min.js?3\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/30.js?3\"></script>","tags":["教程","瞎折腾"],"categories":["教程"]},{"title":"HTML基础笔记","url":"/article/1475187a.html","content":"\n# HTML\n&emsp;&emsp;一个最基本的H5骨架长这样：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <meta name=\"Author\" content=\"\">\n    <meta name=\"Keywords\" content=\"123\" />\n    <meta name=\"Description\" content=\"123456\" />\n    <title>Document</title>\n</head>\n<body>\n  \n</body>\n</html>\n\n```\n\n>标准的div+css页面，只会用到种类很少的标签：div、p、h1、span、a、img、ul、ol、dl、input、i等\n\n***\n\n## 头标签head\n&emsp;&emsp;head标签表示的是页面的配置，有字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等\n\n1. **文档声明头：**`<!DOCTYPE html>`，DocType Declaration，简称DTD,DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n2. **页面语言lang：**`<html lang=\"en\">`，指定页面的语言类型，en、zh-CN。\n3. **meta标签：**提供相关页面的元信息（meta-information）\n\n```html\n<!--必要，网页标题-->\n<title>轻笑Chuckle</title>\n<!--必要，网页的编码方式,文件格式要与其声明相符-->\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n<!--视口viewport，适配移动端-->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<!--网页关键词，SEO用-->\n<meta name=\"Keywords\" content=\"轻笑,Chuckle\" />\n<!--网页描述-->\n<meta name=\"Description\" content=\"漫天倾尘,风中轻笑\" />\n<!--网页作者-->\n<meta name=\"Author\" content=\"轻笑Chuckle\">\n<!--3s后跳转百度-->\n<meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\">\n<!--指定基础的路径，a链接以此为基准-->\n<base href=\"/\">\n\n```\n\n***\n\n## body标签\n* div、section、article、aside、header、footer\n* p\n* span、em、strong\n* 表格元素：table、thead、tbody、tr、td\n* 列表元素：ul、ol、dl、dt、dd\n* a\n* 表单元素：form、input、select、textarea、button\n\n&emsp;&emsp;**HTML标签分为两种：**\n1. 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input）\n2. 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。\n\n***\n\n## 排版标签\n1. `<h1>`标题使用`<h1>`至`<h6>`标签定义,有align属性(对齐方式)：left、center、right。\n2. `<p>`段落标签，单独成段，分割网页。有align属性。\n3. `<hr/>`水平分割线线标签。\n4. `<br/>`\n5. `<div>`可以把标签中的内容分割为独立的区块。必须单独占据一行,DIV+CSS来实现各种样式,**div标签负责布局、结构、分块，css负责样式**\n6. `<span>`和div的作用一致，但不换行\n7. `<center>`让元素居中，H5中不使用\n8. `<pre>`预格式化，让文本不空格和空行，几乎用不着\n9. `<!-- 我是 html 注释  -->`\n\n***\n\n## 字体标签\n1. 特殊字符（转义字符），需要时百度，`&nbsp;`空格,`&lt;`小于号<,`&gt;`大于号>，等\n2. `<u>`下划线,`<s>`或`<del>`中划线,`<i>`或`<em>`斜体\n3. **弃用:**`<b>` `<strong>`粗体，`<font>`字体标签\n4. `<sup>`上标，`<sub>`下标\n\n***\n\n## 超链接a\n&emsp;一个文本级标签\n1. 外部链接:`<a href=\"02页面.html\">点击进入另外一个文件</a>`**href**超文本地址\n2. 锚链接:\n\n```html\n<!--设置锚点，必须是a标签-->\n<!--name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的-->\n<a name=\"a1\" id=\"a1\">a1点</a>\n<!--触发锚点-->\n<a href=\"#a1\">去a1点</a>\n<!--跳转到a.html页面的a1锚点中去-->\n<a href=\"a.html#a1\">去a1</a>\n\n```\n\n&emsp;通常p包裹a  \n{% folding cyan, 超链接的属性 %}\n**href**：目标URL  \n**title**：悬停文本。  \n**name**：主要用于设置一个锚点的名称。  \n**target**：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值：  \n&emsp;**_self**：在同一个网页中显示（默认值）  \n&emsp;**_blank**：在新的窗口中打开。  \n&emsp;**_top**：在顶级窗口中显示  \n{% endfolding %}\n\n***\n\n## 图片标签\n&emsp;`<img src=\"图片的URL\" />`src中写图片路径\n\n&emsp;标签属性：\n1. **width**、**height**\n在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比\n可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行**等比缩放**\n2. **alt**：当图片无法显示时，代替图片的文本\n3. **title**：鼠标悬停时出现的文本\n4. align属性，默认bottom\n\n***\n\n### 相对路径\n&emsp;`.`当前目录,`..`上一层目录\n```html\n<!-- 当前目录中的图片 -->\n<img src=\"img.jpg\">\n<img src=\"./img.jpg\">\n<!-- 上一级目录中的图片 -->\n<img src=\"../img.jpg\">\n<!-- ../要么不写，要么就写在开头 -->\n\n```\n\n***\n\n### 绝对路径\n&emsp;`<img src=\"C:\\img.jpg\">`C盘图片\n&emsp;`<img src=\"http://img.baidu.com/head.png\">`网络路径\n\n***\n\n## 列表标签\n\n1. 无序列表`<ul>`,type=\"属性值\";disc(实心原点，默认)，square(实心方点)，circle(空心圆)\n2. 有序列表`<ol>`,type=\"属性值\";1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始\n`<ul>`、`<ol>`里放`<li>`,li是容器级\n3. 定义列表`<al>`,没有属性,子元素`<dt>`、`<dd>`\n\n<div id=\"list-example\"></div>\n\n&emsp;&emsp;从语义上来说，dt表示名称，dd表示对其的描述，dt、dd都是容器级标签，想放什么都可以。用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。\n\n***\n\n## 表格标签table\n\n&emsp;&emsp;网页中表格由每行`<tr>`组成，每一行由一个个单元格`<td>`组成\n&emsp;&emsp;`<th>`加粗的单元格。相当于`<td>` + `<b>`\n```html 一个表格\n<table>\n\t<tr>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t</tr>\n</table>\n\n```\n\n{% folding cyan, table的属性 %}\n* **border** 边框\n* **style=\"border-collapse:collapse;\"**单元格的线和表格的边框线合并（表格的两边框合并为一条）\n* **width**、**height**\n* **bordercolor** 表格的边框颜色\n* **align** 表格的水平对齐方式left right center，注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签`<td>`进行设置）\n* **cellpadding** 单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\n* **bgcolor** 背景颜色，**background** 背景图片。背景图片的优先级大于背景颜色。\n* **bordercolorlight** 表格的上、左边框，以及单元格的右、下边框的颜色,**bordercolordark** 表格的右、下边框，以及单元格的上、左的边框的颜色 这两个属性的目的是为了设置3D的效果\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n* **bgcolor** 设置这一行的单元格的背景色\n* **height**\n* **align** 一行的内容水平居中显示，取值：left、center、right\n* **valign** 一行的内容垂直居中，取值：top、middle、bottom\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **bgcolor** 单元格的背景色，**background** 设置这个单元格的背景（图片）\n* **height** 单元格的高度\n* **width** 绝对值或者相对值(%)\n* **align** 内容的横向对齐方式，取值：left right center\n* **valign** 内容的纵向对齐方式。取值：top middle bottom\n{% endfolding %}\n\n***\n\n### 单元格的合并\n1. **colspan**：横向往右合并\n2. **rowspan**：纵向往下合并\n\n<div id=\"table1-example\"></div>\n\n***\n\n### thead、tbody、tfoot\n&emsp;&emsp;表格优先按照thead、tbody、tfoot的顺序依次来显示内容（三个标签无需同时存在），如果不写，表格按代码从上到下的顺序来显示\n&emsp;&emsp;当表格非常大内容非常多的时候，用thead、tbody、tfoot标签，数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。\n&emsp;&emsp;tr和tbody同级，按代码从上到下的顺序来显示\n\n<div id=\"table2-example\"></div>\n\n***\n\n## *框架标签\n&emsp;&emsp;框架标签用于在一个网页中显示多个页面（html）\n>1. `<frameset>`和`<body>`只能二选一。框架标签不能放在`<body>`标签里面，因为`<body>`标签代表的只是一个页面，而框架标签代表的是多个页面\n>2. 框架的集合用`<frameset>`表示，然后在`<frameset>`集合里放入一个一个的框架`<frame>`\n>3. **frameset和frame已经从 Web标准中删除，使用iframe代替**\n\n***\n\n### *frameset\n&emsp;&emsp;`<frameset>` 框架的集合,一个框架的集合可以包含**多个框架**或**框架的集合**\n\n{% folding cyan, frameset的属性 %}\n* **rows** 水平分割，将框架分为上下部分\n* **cols** 垂直分割，将框架分为左右部分。\n写法有两种：\n1. 绝对值写法：`rows/cols=\"200,*\"` *代表剩余的。包含了两个框架：一个占200个像素，另一个占剩下的部分。\n2. 相对值写法：`rows/cols=\"30%,*\"` *代表剩余的。包含了两个框架：一个占30%，另一个占70%。\n\n&emsp;如果想将框架分成很多个，在属性值里用多个逗号隔开。\n{% endfolding %}\n\n```html\n<frameset rows=\"20%,*\">\n    <frame src=\"1.html\"></frame> \n    <frameset cols=\"30%,*\">\n        <frame src=\"1.html\"></frame> \n        <frame src=\"1.html\"></frame> \n    </frameset>      \n</frameset>\n\n```\n\n***\n\n### *frame\n&emsp;&emsp;`<frame>`是`<frameset>`的子标签，一个框架显示一个页面。\n\n{% folding cyan, frame的属性 %}\n* **scrolling=\"no\"** 是否要滚动条,默认值是true。\n* **noresize** 不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的,用了这个属性值，框架大小将固定。\n* **bordercolor** 框架边框颜色,仅IE生效\n* **frameborder=\"0\"**或**\"1\"** 隐藏或显示边框（框架线）。\n* **name** 框架名字，用于框架内的超链\n{% endfolding %}\n\n***\n\n## 内嵌框架\n&emsp;&emsp;内嵌框架用`<iframe>`表示。`<iframe>`写在`<body>`中，在其中嵌入html页面\n\n{% folding cyan, iframe的属性 %}\n* **src=\"\"** 嵌入html页面的路径\n* **height**,**width**\n* **scrolling=\"no\"** 是否需要滚动条。默认值是true。\n* **name** 名称\n{% endfolding %}\n\n<div id=\"iframe-example\"></div>\n\n***\n\n## 表单标签\n&emsp;&emsp;表单标签用`<form>`表示，收集用户信息，用于与服务器的交互。\n{% folding cyan, form的属性 %}\n* **name**，**id** 表单的名称，JS来操作或控制表单时使用\n* **action** 指定表单数据的处理程序\n* **method** 表单数据的提交方式，一般取值：get(默认)和post\n{% endfolding %}\n\n***\n\n### input输入标签\n&emsp;&emsp;`<input>`是一个输入标签，用于接收用户输入或选择\n\n{% folding cyan, input的属性 %}\n* **type=\"属性值\"** 文本类型\n***text*** 文本框，默认\n***password*** 密码框\n***radio*** 单选按钮\n***checkbox*** 多选按钮，name属性值相同的按钮作为一组进行选择，但id必须唯一。\n***hidden*** 隐藏框，在表单中包含不希望用户看见的信息\n***button*** 普通按钮，结合js代码进行使用。\n***submit*** 提交按钮，提交当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字，点击按钮后，整个表单就会被提交到form标签的action属性中指定的那个页面中去\n***reset*** 重置按钮，清空当前表单的内容，并设置为最初的默认值\n***image*** 图片按钮，和submit提交按钮的功能完全一致，图片按钮可以显示图片。\n***file*** 文件选择框，配合JS对文件进行限制和检查\n* **checked** 将单选按钮或多选按钮默认处于选中状态。当`<input>`标签设置为**type=\"radio\"**或者**type=checkbox**时，可用此属性\n* **value=\"内容\"** 文本框里的默认内容（已经被填好了的）\n* **size=\"50\"** 表示文本框内可以显示**五十个字符**。一个英文或一个中文都算一个字符\n* **readonly** 文本框只读\n* **disabled** 文本框只读\n{% endfolding %}\n\n<div id=\"input1-example\"></div>\n\n***\n\n### select下拉列表\n&emsp;&emsp;`<select>`列表中每一选项为`<option>`\n\n{% folding cyan, select、option的属性 %}\n`<select>`的属性:\n* **multiple** 多选(ctrl加左键点击)\n* **size=\"3\"** 属性值大于1，则列表为滚动视图，默认属性值为1，即下拉视图。\n\n`<option>`的属性:\n* **selected** 预选中\n{% endfolding %}\n\n<div id=\"select1-example\"></div>\n\n***\n\n### textarea多行文本框\n&emsp;&emsp;`<textarea>`不会省略空格和换行\n{% folding cyan, textarea的属性 %}\n* **rows=\"4\"** 文本框行数\n* **cols=\"20\"** 文本框列数\n* **readonly** 文本框只读\n{% endfolding %}\n\n<div id=\"textarea1-example\"></div>\n\n***\n\n### fieldset表单分组\n&emsp;&emsp;`<fieldset>`子标签`<legend>`定义组的标题\n{% folding cyan, fieldset的属性 %}\n* **disabled** 表单仍然显示，但是禁用\n* **form=\"另一个表单的id\"** 让此fieldset也属于该表单一部分\n* **name** fieldset的名称\n{% endfolding %}\n\n<div id=\"fieldset1-example\"></div>\n\n***\n\n### label\n&emsp;&emsp;`label`使其中文字内容与`<input>`绑定，点击文字也能选择选项等\n{% folding cyan, fieldset的属性 %}\n* **for=\"[id]\"** label要绑定的input的id\n{% endfolding %}\n\n<div id=\"label1-example\"></div>\n\n***\n\n# HTML5\n&emsp;&emsp;HTML5是新一代开发Web富客户端应用程序整体解决方案。包括：HTML5,CSS3，Javascript API在内的一套**技术组合**。富客户端具有很强的**交互性**和体验。\n\n***\n\n## 新增的语义标签\n&emsp;&emsp;相较于使用`class=\"header\"`给网页做语义化处理，HTML5本身提供了一些语义化的标签。强调了HTML的职责是描述一块内容是什么（或其意义）。\n\n&emsp;&emsp;常见的HTML结构：\n```html\n<!-- 头部 -->\n<div class=\"header\">\n    <ul class=\"nav\"></ul>\n</div>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <div class=\"article\"></div>\n    <!-- 侧边栏 -->\n    <div class=\"aside\"></div>\n</div>\n\n<!-- 底部 -->\n<div class=\"footer\">\n\n</div>\n\n```\n\n&emsp;&emsp;HTML5中这样写\n```html\n<!-- 头部 -->\n<header>\n    <ul class=\"nav\"></ul>\n</header>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <article></article>\n    <!-- 侧边栏 -->\n    <aside></aside>\n</div>\n\n<!-- 底部 -->\n<footer>\n\n</footer>\n\n```\n\n{% folding cyan, HTML5语义标签 %}\n* **section** 区块\n* **article** 表示主体内容，如文章\n* **header** 页眉\n* **footer** 页脚\n* **nav** 导航栏\n* **aside** 侧边栏\n* **figure** 媒介内容分组\n* **mark** 标记\n* **progress** 进度\n* **time** 日期\n{% endfolding %}\n\n***\n\n## H5中的表单\n{% folding cyan, HTML5表单中input新增的类型 %}\n* **email** 只能输入email格式，自带格式验证\n* **tel** 手机号码\n* **url** 只能输入url格式\n* **number** 只能输入数字。\n* **search** 搜索框\n* **range** 滑动条\n* **color** 拾色器\n* **time** 时间\n* **date** 日期\n* **datetime** 时间日期\n* **month** 月份\n* **week** 星期\n{% endfolding %}\n\n<div id=\"h5-input-example\"></div>\n\n***\n\n## 新表单标签\n* `<datalist>` 数据列表,用于数据自动提示\n\n<div id=\"datalist-example\"></div>\n\n* `<keygen>` 用于验证用户，本质是密钥对生成器，当提交表单时，会生成两个键：一个公钥，一个私钥，私钥存储于客户端，公钥则被发送到服务器。公钥可用于之后验证用户的客户端证书。\n\n***\n\n## 新表单属性\n{% folding cyan, 新表单属性 %}\n* **placeholder** 占位符（提示文字）\n* **autofocus** 自动获取焦点\n* **multiple** 文件上传多选或多个邮箱地址\n* **autocomplete** 自动完成（填充的）on开启（默认）off取消。效果是会记住之前的提交，可以快速选择\n* **form** 指定表单项属于哪个form，处理复杂表单时会需要\n* **novalidate** 关闭默认的验证功能（只能加给form）\n* **required** 表示必填项\n* **pattern** 自定义正则，验证表单。\n{% endfolding %}\n\n<div id=\"new-form-example\"></div>\n\n***\n\n## 表单事件\n1. `oninput()` 用户输入内容时触发，可用于输入字数统计。\n2. `oninvalid()` 验证不通过时触发\n\n***\n\n## audio音频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n{% endfolding %}\n\n<div id=\"audio-example\"></div>\n\n***\n\n## video视频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n* **width**、**height**\n{% endfolding %}\n\n```html\n<video src=\"video/movie.mp4\" controls  autoplay ></video>\n<video controls autoplay>\n  <source src=\"video/movie.mp4\"/>\n  <source src=\"video/movie.ogg\"/>\n  <source src=\"video/movie.webm\"/>\n  抱歉，不支持此视频\n</video>\n\n```\n\n***\n\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/31.js?3\"></script>","tags":["前端"],"categories":["学习笔记"]},{"title":"老旧浏览器弹窗提醒","url":"/article/e61f6567.html","content":"\n# 前言\n&emsp;&emsp;在今年IE终于从半身入土到彻底寄寄，谷歌也做了个违背祖宗的决定，版本号破百。\n&emsp;&emsp;但像夸克、UC、百分等浏览器，仍然用着老旧的谷歌内核，也有不少人还用着老版本的谷歌浏览器、Edge。像我学校的机房，仍用着老旧的44版Edge。\n\n&emsp;&emsp;老旧的浏览器不仅让兼容性较低的网站样式爆炸（没错，说的就是我站（bushi）），更不是大势所趋。样式爆炸也会给访客留下不好的印象，为了避免这种情况，合理甩锅（嗯对没错）给浏览器非常双赢。可以每天检测一次浏览器版本号然后弹窗。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/29-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;把这JS找个地方塞进去，弹窗调用butterfly自带的，用其它的替换即可。\n```JS 老旧浏览器弹窗提醒\nfunction browserTC() {\n    btf.snackbarShow(\"\");\n    Snackbar.show({\n        text: '浏览器版本较低，网站样式可能错乱',\n        actionText: '关闭',\n        duration: '6000',\n        pos: 'bottom-right'\n    });\n}\nfunction browserVersion() {\n    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串\n    var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1; //判断是否IE<11浏览器\n    var isIE11 = userAgent.indexOf('Trident') > -1 && userAgent.indexOf(\"rv:11.0\") > -1;\n    var isEdge = userAgent.indexOf(\"Edge\") > -1 && !isIE; //Edge浏览器\n    var isFirefox = userAgent.indexOf(\"Firefox\") > -1; //Firefox浏览器\n    var isOpera = userAgent.indexOf(\"Opera\")>-1 || userAgent.indexOf(\"OPR\")>-1 ; //Opera浏览器\n    var isChrome = userAgent.indexOf(\"Chrome\")>-1 && userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Chrome浏览器\n    var isSafari = userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Chrome\")==-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Safari浏览器\n    if(isEdge) {\n        if(userAgent.split('Edge/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isFirefox) {\n        if(userAgent.split('Firefox/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isOpera) {\n        if(userAgent.split('OPR/')[1].split('.')[0]<80){\n            browserTC()\n        }\n    } else if(isChrome) {\n        if(userAgent.split('Chrome/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isSafari) {\n        //不知道Safari哪个版本是该淘汰的老旧版本\n    }\n}\n//2022-10-29修正了一个错误：过期时间应使用toGMTString()，而不是toUTCString()，否则实际过期时间在中国差了8小时\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\nif(getCookie('browsertc')!=1){\n    setCookies({\n        browsertc: 1,\n    }, 1);\n    browserVersion();\n}\n\n```\n\n***\n\n# 后记\n&emsp;&emsp;样式爆炸首先甩锅（\n\n","tags":["教程","Butterfly"],"categories":["教程"]},{"title":"CodeFA×Hexo体验","url":"/article/cf571182.html","content":"\n# 前言\n&emsp;&emsp;Hexo是一个无后端的静态博客框架，但不妨碍各路大佬基于Github Action自动化部署实现假后端，为的就是随时随地可以通过假后端来写or修改文章，当然也可以改源码和配置。\n\n&emsp;&emsp;流行的假后端有Qexo、Wexa等，博主尝试过Wexa，但还是习惯于Vscode上的体验，假后端就凉一旁吃灰了，也关掉了Github Action自动化部署，本地Bat双击实现推送也很快。\n```bat\n@echo off\ncd C:\\chuckle\\blog\nhexo clean&&hexo g&&gulp&&hexo d\n```\n\n&emsp;&emsp;不过，随时修改文章，或者在外闲着无事给博客写个单页的需求也还是客观存在的，于是我又尝试了github.dev，这个github提供的在线vscode，启动很方便，仓库地址在把com改成dev后跳转即可，但它不能装插件、没有终端，浏览器打开需要等上一会，并且这是一个在线服务离不开网络。\n\n&emsp;&emsp;我将目光转向了早些年捣鼓过的Termux，可以配合CodeServer实现一个本地Vscode，但还是得配合VNC或者浏览器，依旧麻烦笨重。\n\n&emsp;&emsp;最终，我找到了它[CodeFA](https://www.coolapk.com/apk/com.nightmare.code)，[github地址：vscode_for_android](https://github.com/nightmare-space/vscode_for_android)，使用LinuxArm64启动一个code-server，ubuntu版本22.04，然后使用WebView进行加载，WebView加载的内容完全来自本地，并非套壳在线的网站。安装在平板上再合适不过（生产力MAX？）\n\n# 上手体验\n&emsp;&emsp;因为其本质就是一个ubuntu，且贴心地集成好了不少东西，上手非常轻松。第一件事当然是安装好环境跑几个代码玩玩（啊，不对，是先美化），`apt install gcc`、`apt install g++`、`apt install openjdk-17-jdk`等，没空去配置调试环境，也用不上，装上Coderunner插件，C、JAVA都可以运行了。和win端一样，支持智能提示和补全，java也支持psvm、sout等快捷方式。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;当然，我们的重点不是跑代码，而是部署Hexo。\n\n## 部署Hexo\n>并不是完整教程，只是记录，实际上和ubuntu下部署hexo没啥大区别。\n\n&emsp;&emsp;首先，安装NodeJs、git、npm、vim，`pkg install nodejs`，`pkg install git`，`pkg install vim`，`apt install npm`。\n&emsp;&emsp;然后安装Hexo和gulp，`npm install hexo-cli -g`，`npm install --global gulp-cli`，`npm install gulp --save`。\n&emsp;&emsp;配置一下git，然后`git clone`博客源码，cd进去运行`npm install`，让它慢慢安装完依赖和我用到的插件。\n\n&emsp;&emsp;现在hexo三连，nodejs会报错：**System limit for number of file watchers reached**，问题不大，在`/etc/sysctl.conf/`中加上`fs.inotify.max_user_watches=524288`，然后运行`sysctl -p`。\n\n&emsp;&emsp;再次三连，不出意外的话，浏览器访问`http://localhost:4000/`就可以看到自己的hexo网站啦~。四连也可以推送网站到github和服务器端（当然前提是配置好了git，这就不赘述了，openssh自带无需安装）。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-4.webp width=\"60%\" height=\"60%\">\n\n## 多端协作\n&emsp;&emsp;得益于vscode便利的git管理，一个文件或者文章，电脑端写完，推送push上github，平板端pull下来，就能继续写。得益于hexo的高性能，即使在虚拟环境下跑，hexo g也能在几秒内完成。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-2.webp width=\"60%\" height=\"60%\"><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;配合小米平板的pc模式，还不错。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-5.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;完全体。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/27-6.webp width=\"60%\" height=\"60%\">\n\n# 后记\n\n暂无\n","tags":["Hexo","VScode"],"categories":["Hexo"]},{"title":"CSS/JS备忘录","url":"/article/2ec41fd7.html","content":"\n# CSS备忘录\n\n## 元素水平和垂直居中\n```css 水平居中\n.example{/* 父元素的宽度是确定的 */\n    margin: 0 auto;\n}\n.example{/* 文本水平居中 */\n    text-align: center;\n}\n\n```\n\n```css 垂直居中(元素父级添加flex)\n.example{\n    display: flex;\n    -webkit-box-align: center;\n    align-items: center;\n}\n\n```\n\n## 文本自动换行\n```css \n.example{\n    white-space: normal;\n    word-break: break-all;\n    word-wrap: break-word;\n    text-overflow: ellipsis;\n}\n\n```\n\n## 隐藏浏览器滚动条\n```css \n.example::-webkit-scrollbar{\n    display:none\n    /* or */\n    width:0;\n}\n\n```\n\n## 水平镜像旋转元素\n```css \n.example{\n    -moz-transform:scaleX(-1);\n    -webkit-transform:scaleX(-1);\n    -o-transform:scaleX(-1);\n    transform:scaleX(-1);\n}\n\n```\n\n## 媒体自适应css\n```css \n@media screen and (min-width: 1000px) and (max-width: 1300px){\n    .example{\n    }\n}\n\n```\n\n***\n\n# JS备忘录\n\n## Cookie操作\n```js 设置Cookie\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nsetCookies({\n    browsertc: 1,\n}, 1);\n\n```\n\n```js 读取Cookie\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\ngetCookie('browsertc');\n\n```\n\n\n***","tags":["前端","JS","CSS"],"categories":["学习笔记"]},{"title":"给网站增加悬浮伸缩侧边栏","url":"/article/fab5c3df.html","content":"\n# 前言\n&emsp;&emsp;看到了不！看到了不！[@Heo](https://blog.zhheo.com/)的网站又双叒变好看了，还增加了个音乐灵动球！\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/25-2.webp width=\"80%\" height=\"80%\">\n\n&emsp;&emsp;开抄开抄~我也有了思路，魔改原来的悬浮aplayer，但一问，噢《新写了一个》，尝试抄了下却不能播放。但问题不大，按之前思路结合一下刚弄好的侧边栏，非常好。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/25-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;很快成品完工~（但是还是好馋那个灵动乐球~）\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/25-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;aplayer怎么开启看butterfly的文档。\n&emsp;&emsp;在`layout.pug`里加上：\n```pug 记得修改网易云歌单id\ninclude ./rightside.pug\n!=partial('includes/third-party/search/index', {}, {cache: true})\n!=partial('includes/dorakika/rightmenu',{}, {cache:true})\ninclude ./additional-js.pug\n//- 上面的是本来就有的，对齐上面的缩进，加上下面的内容\n.contact-info\n  .option\n    i.fas.fa-rocket\n    .bloktop\n    .text 还不造有啥用滴悬浮模块\n      .strip\n  .option\n    i.fas.fa-cube\n    .blok\n    .text\n      .strip\n      <div class=\"post-reward\"><button class=\"tip-button reward-button\"><span class=\"tip-button__text\">投 喂</span><div class=\"reward-main\"><ul class=\"reward-all\"><li class=\"reward-item\"><a class=\"about-reward\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/weixin.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/weixin.webp\" alt=\"微信\"></a><div class=\"post-qr-code-desc\">微信</div></li><li class=\"reward-item\"><a class=\"about-reward\" href=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/alipay.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/alipay.webp\" alt=\"支付宝\"></a><div class=\"post-qr-code-desc\">支付宝</div></li></ul></div></button></div>\n  .option\n    i.fas.fa-music\n    .blokbottom\n    .text.aplayertext\n      .strip\n      .aplayer.no-destroy(mutex='true', listfolded='true', data-id='你的网易云歌单id', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n&emsp;&emsp;引入css：\n```css 不生效就在对应属性加上!important\n.contact-info{\n    position: fixed;\n    top: 22%;\n    z-index: 200;\n    left: -51px;\n    transition: 0.4s;\n  }\n  .contact-info:hover{\n    left: 0px;\n  }\n  .contact-info .option{\n    cursor: pointer;\n    position: relative;\n  }\n  \n  .contact-info .option i{\n    display: block;\n    width: 50px;\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n    background: rgb(255, 255, 255);\n    color: #b9b9b9;\n    font-size: 20px;\n    transition: 0.4s;\n    border-radius: 0 10px 10px 0;\n  }\n  \n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n  .contact-info .text{\n    border-radius: 15px;\n    position: absolute;\n    height: 60px;\n    width: 200px;\n    background: rgba(255,255,255,.85);\n    top: 0;\n    z-index: -1;\n    left: -136px;\n    color: rgb(0, 0, 0);\n    line-height: 60px;\n    text-align: center;\n    transition: 0.4s;\n  }\n  .contact-info .aplayertext{\n    transition: none!important;\n  }\n  .aplayer{\n    position: absolute!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-body{\n    left: -60px;\n    position: absolute!important;\n    width: 370px!important;\n    transition: none!important;\n    border-radius: 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    left: -300px;\n  }\n  .contact-info .option:hover .aplayer.aplayer-fixed .aplayer-body,.contact-info .option:hover .aplayer.aplayer-fixed{\n    left: 0px;\n  }\n  .contact-info .option:hover .text{\n    left: 60px;\n  }\n  .contact-info .blok{\n    position: absolute;\n    height: 60px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .bloktop{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    bottom: 0px;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .blokbottom{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .option:hover .blok,.contact-info .option:hover .bloktop,.contact-info .option:hover .blokbottom{\n    left: 0px;\n  }\n  .contact-info .option:hover .aplayertext{\n    left: 60px!important;\n    width: 370px!important;\n    background: transparent!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-miniswitcher{\n    border-radius: 0 10px 10px 0!important;\n  }\n  .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{\n    transition: 0.28s!important;\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    height: 60px!important;\n  }\n  .aplayer .aplayer-info{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px;\n  }\n  .aplayer .aplayer-list.aplayer-list-hide{\n    margin-bottom: 59px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    margin-bottom: 62px!important;\n    max-height: 240px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-info{\n    transition: none!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic{\n    border-radius:  10px 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    border-radius:  0 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    border-radius: 10px 10px 0 0!important;\n  }\n  [data-theme=dark]\n  .contact-info .option i{\n    background: rgb(22, 22, 22);\n    color: #b9b9b9;\n  }\n  [data-theme=dark]\n  .contact-info .text{\n    background: rgba(23, 23, 23, 0.85);\n    color: rgba(255, 255, 255, 0.92);\n  }\n  @media screen and (max-width:1300px){\n    .contact-info{\n        display: none!important;\n      }\n  }\n  .aplayer{\n    opacity: .93!important;\n  }\n  [data-theme=dark]\n  .aplayer{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer.aplayer-fixed .aplayer-body{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li:hover{\n    background: #3b3b3b;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li.aplayer-list-light{\n    background: #686868;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-index{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-author{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{\n    fill: #d4d4d4;\n  }\n\n.contact-info .text .strip{\n    border-radius: 5px;\n    position: absolute;\n    height: 36px;\n    width: 5px;\n    background: rgba(20, 163, 230, 0.8);\n    top: 12px;\n    z-index: -1;\n    right: 4px;\n    transition: 0.4s;\n  }\n  .aplayertext .strip{\n    transition: none!important;\n  }\n  .contact-info .option:hover .aplayertext .strip{\n    background: transparent;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-miniswitcher{\n    background: rgba(23, 23, 23, 0.85);\n  }\n  .aplayer .aplayer-miniswitcher .aplayer-icon:hover path{\n    fill: #3498db;\n  }\n  [data-theme=dark]\n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n.contact-info .option .text .post-reward .tip-button__text{\n  margin: 25px!important;\n}\n.post-reward .reward-button .reward-main .reward-all{\n  border-radius: 12px!important;\n}\n.contact-info .option .text .post-reward .reward-button .reward-main .reward-all{\n  z-index: 999!important;\n}\n[data-theme=\"dark\"]\n.contact-info .option .text .post-reward .tip-button{\n  border: solid 2px rgba(236, 233, 233, 0.8);\n  background: #043749d0;\n}\n```\n\n> 还缺着两个空位不知道该放些啥\n\n***\n\n# 后记\n&emsp;&emsp;2022年9月26日，Meting挂了，原因是ssl证书到期。\n&emsp;&emsp;为了aplayer的稳定，还是播放本地音乐吧。\n```pug #aplayer后加上js,并在配置文件关闭meting\n#aplayer.aplayer.no-destroy(mutex='true', listfolded='true', data-id='6609736315', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n  script.\n    const ap = new APlayer({\n      container: document.getElementById('aplayer'),\n      fixed: true,\n      order: 'random',\n      preload: 'none',\n      volume: 0.25,\n      audio: [\n        {\n        name: '越权访问-崩坏：星穹铁道',\n        artist: 'Hanser',\n        url: '/music/songs/1.mp3',\n        lrc: '/music/lrc/1.lrc',\n        cover: '/music/images/songs/1.webp'\n        }\n      ]\n    });\n    \n```\n\n&emsp;&emsp;10月18日，侧边栏增加打赏，好耶，又利用了一个模块，已更新上方的代码。\n\n&emsp;&emsp;2023年1月24日，Meting又挂了，原因是api过期，可以用vercel自建api，或者播放本地音乐。\n&emsp;&emsp;自建api地址：[vercel-meting](https://github.com/ladjeek-actions/vercel-meting)\n\n```pug\n.option\n  i.fas.fa-music\n  .blokbottom\n  .text.aplayertext\n+    script.\n+      var meting_api='<你的api>';\n    .strip\n    .aplayer.no-destroy(mutex='true', listfolded='true', data-id='11111111', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"添加音乐页面","url":"/article/3322c8a8.html","content":"\n# 前言\n&emsp;&emsp;没有音乐页面怎么行，花里胡哨的都安排上，本来想摆烂直接上aplayer，但考虑到网站速度以及aplayer的稳定性（和卜算子日常歇菜），还是弄个音乐播放器放自己本地的音乐好，又快又稳定。\n&emsp;&emsp;在网上找了个能用的h5播放器源码(找不到原作者)，适配下pjax和hexo，再改改样式就完成啦：[查看音乐页面](/music/)\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/24-1.webp width=\"50%\" height=\"50%\">\n\n***\n\n# 实现\n&emsp;&emsp;让指定单页的背景透明可以看此教程：[控制指定单页的背景样式](/article/eb3a4679.html)\n&emsp;&emsp;新建music单页，cv以下内容覆盖原内容：\n```html\n---\ncomments: false\naside: false\n---\n{% raw %}\n<!-- 播放器 -->\n<div class=\"music-player\">\n\t<!-- audio标签 -->\n\t<audio class=\"music-player__audio\" ></audio>\n\t<!-- 播放器主体 -->\n\t<div class=\"music-player__main\">\n\t\t<!-- 模糊背景 -->\n\t\t<div class=\"music-player__blur\"></div>\n\t\t<!-- 唱片 -->\n\t\t<div class=\"music-player__disc\">\n\t\t\t<!-- 唱片图片 -->\n\t\t\t<div class=\"music-player__image\">\n\t\t\t\t<img width=\"100%\" src=\"\" alt=\"\">\n\t\t\t</div>\n\t\t\t<!-- 指针 -->\n\t\t\t<div class=\"music-player__pointer\"><img width=\"100%\" src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/img/cd_tou.png\" alt=\"\"></div>\n\t\t</div>\n\t\t<!-- 控件主体 -->\n\t\t<div class=\"music-player__controls\">\n\t\t\t<!-- 歌曲信息 -->\n\t\t\t<div class=\"music__info\">\n\t\t\t\t<h3 class=\"music__info--title\">...</h3>\n\t\t\t</div>\n\t\t\t<!-- 控件... -->\n\t\t\t<div class=\"player-control\">\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player-control__btns\">\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--prev\"><i class=\"iconfont icon-prev\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--play\"><i class=\"iconfont icon-play\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--next\"><i class=\"iconfont icon-next\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--mode\"><i class=\"iconfont icon-random\"></i></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"player-control__volume\">\n\t\t\t\t\t\t<div class=\"control__volume--icon player-control__btn\"><i class=\"iconfont icon-volume\"></i></div>\n\t\t\t\t\t\t<div class=\"control__volume--progress progress\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player__song--progress progress\"></div>\n\t\t\t\t\t<div class=\"player__song--timeProgess nowTime\">00:00</div>\n\t\t\t\t\t<div class=\"player__song--timeProgess totalTime\">00:00</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<!-- 歌曲列表 -->\n\t<div class=\"music-player__list\">\n\t\t<ul class=\"music__list_content\">\n\t\t</ul>\n\t</div>\n</div>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/utill.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/js/player.js?10\"></script>\n<div style=\"text-align:center;margin:-100px 0; font:normal 14px/24px 'MicroSoft YaHei';color:#ffffff\"></div>\n\n{% endraw %}\n\n```\n\n&emsp;&emsp;在`blog\\source\\music`下新建`songs`和`images`文件夹，`songs`内直接放入歌曲。再在`images`文件夹内新建`songs`文件夹，里面放歌曲封面。\n&emsp;&emsp;在`blog\\source\\img`内放入这两张图片[cd.png](https://blog.chuckle.top/img/cd.png)，[cd_tou.png](https://blog.chuckle.top/img/cd_tou.png)。\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`player.js`。\n```js\n//创建一个音乐播放器的类 单例模式\nclass Player {\n    constructor() { //类的构造函数\n        //如果没有实例化，就去构造一个实例\n        return this.getInstance(...arguments);\n    }\n\n    //构建实例\n    getInstance() {\n        let instance = new PlayerCreator(...arguments);\n        //让实例可以使用到Player的原型的属性方法\n        // instance.__proto__=Player.prototype;\n        // instance.constructor=Player;\n        //把构建好的实例挂在Player类上\n        Player.instance = instance;\n        return instance;\n    }\n}\n\n//歌曲信息\nclass Musics {\n    //歌曲\n    constructor() {\n        this.songs = [{\n                id: 1,\n                title: '越权访问-崩坏：星穹铁道 - Hanser',\n                singer: '越权访问-崩坏：星穹铁道 - Hanser',\n                songUrl: './songs/1.mp3',\n                imageUrl: './images/songs/1.webp'\n            },\n            {\n                id: 2,\n                title: '妄想Reality（翻自 洛天依） - 炎祾',\n                singer: '妄想Reality（翻自 洛天依） - 炎祾',\n                songUrl: './songs/2.mp3',\n                imageUrl: './images/songs/2.webp'\n            },\n\t\t\t{\n                id: 3,\n                title: '人间失宠 - 昔诺',\n                singer: '人间失宠 - 昔诺',\n                songUrl: './songs/3.mp3',\n                imageUrl: './images/songs/3.webp'\n            },\n            {\n                id: 4,\n                title: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                singer: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                songUrl: './songs/4.mp3',\n                imageUrl: './images/songs/4.webp'\n            },\n\t\t\t{\n                id: 5,\n                title: '玛德琳娜电塔 - 花玲',\n                singer: '玛德琳娜电塔 - 花玲',\n                songUrl: './songs/5.mp3',\n                imageUrl: './images/songs/5.webp'\n            },\n        ]\n    }\n    //根据索引获取歌曲的方法\n    getSongByNum(index) {\n        return this.songs[index];\n    }\n}\n\n//真正的构建播放器的类\nclass PlayerCreator {\n    constructor() {\n        this.audio = document.querySelector('.music-player__audio') // Audio dom元素, 因为很多api都是需要原生audio调用的，所以不用jq获取\n        // this.audio.muted = true; // 控制静音\n        this.audio.volume = 0.2;\n\n        //工具\n        this.util = new Util();\n        this.musics = new Musics(); //歌曲信息\n        this.song_index = 0; // 当前播放的歌曲索引\n        this.loop_mode = 1; // 1 2\n        // 下方歌曲列表容器\n        this.song_list = $('.music__list_content');\n\n        this.render_doms = { //切换歌曲时需要渲染的dom组\n            title: $('.music__info--title'),\n            singer: $('.music__info--singer'),\n            image: $('.music-player__image img'),\n            blur: $('.music-player__blur')\n        }\n        this.ban_dom = { //禁音时需要渲染的dom组\n            control__btn: $('.control__volume--icon')\n        }\n\n        // 时间显示容器\n        this.render_time = {\n            now: $('.nowTime'),\n            total: $('.totalTime')\n        }\n\n        // 唱片\n        this.disc = {\n            image: $('.music-player__image'),\n            pointer: $('.music-player__pointer')\n        };\n        //播放器初始化\n        this.init();\n    }\n    //初始化函数\n    init() {\n        this.renderSongList();\n        this.renderSongStyle();\n        this.bindEventListener();\n    }\n    //生成播放列表\n    renderSongList() {\n        let _str = '';\n        this.musics.songs.forEach((song, i) => {\n            _str += `<li class=\"music__list__item\">${song.title}</li>`\n        });\n        this.song_list.html(_str);\n    }\n\n    //根据歌曲去渲染视图\n    renderSongStyle() {\n        let {\n            title,\n            singer,\n            songUrl,\n            imageUrl\n        } = this.musics.getSongByNum(this.song_index);\n        this.audio.src = songUrl;\n        this.render_doms.title.html(title);\n        this.render_doms.singer.html(singer);\n        this.render_doms.image.prop('src', imageUrl);\n        this.render_doms.blur.css('background-image', 'url(\"' + imageUrl + '\")');\n\n        //切换列表中的item的类名 play\n        this.song_list.find('.music__list__item').eq(this.song_index).addClass('play').siblings().removeClass('play');\n    }\n    //绑定各种事件\n    bindEventListener() {\n        //播放按钮\n        this.$play = new Btns('.player-control__btn--play', {\n            click: this.handlePlayAndPause.bind(this)\n        });\n        //上一首\n        this.$prev = new Btns('.player-control__btn--prev', {\n            click: this.changeSong.bind(this, 'prev')\n        });\n        //下一首\n        this.$next = new Btns('.player-control__btn--next', {\n            click: this.changeSong.bind(this, 'next')\n        });\n        //循环模式\n        this.$mode = new Btns('.player-control__btn--mode', {\n            click: this.changePlayMode.bind(this)\n        });\n        //禁音\n        this.$ban = new Btns('.control__volume--icon', {\n            click: this.banNotes.bind(this)\n        })\n        //列表点击\n        this.song_list.on('click', 'li', (e) => {\n            let index = $(e.target).index();\n            this.changeSong(index);\n        })\n\n        //音量控制 audio标签音量 vlouem 属性控制0-1\n\n        new Progress('.control__volume--progress', {\n            min: 0,\n            max: 1,\n            value: this.audio.volume,\n            handler: (value) => { //更改进度时\n                this.audio.volume = value;\n            }\n        })\n        //歌曲进度 this.audio.duration\n        //可以播放的时候触发（歌曲的基本信息都已经获取到了）\n        this.audio.oncanplay = () => {\n            //避免重复实例化\n            if (this.progress) {\n                this.progress.max = this.audio.duration; //切换歌曲后更新时长\n                this.render_time.total.html(this.util.formatTime(this.audio.duration));\n                return false;\n            };\n            this.progress = new Progress('.player__song--progress', {\n                min: 0,\n                max: this.audio.duration,\n                value: 0,\n                handler: (value) => {\n                    this.audio.currentTime = value;\n                }\n            })\n            //调整总时长\n            this.render_time.total.html(this.util.formatTime(this.audio.duration));\n        }\n\n        //会在播放的时候持续触发\n        this.audio.ontimeupdate = () => {\n            this.progress.setValue(this.audio.currentTime);\n            //调整当前时长\n            this.render_time.now.html(this.util.formatTime(this.audio.currentTime));\n        }\n\n        //当歌曲播放完成的时候\n        this.audio.onended = () => {\n            this.changeSong('next');\n            //播放完，换歌后，重新播放\n            this.audio.play();\n        }\n\n    }\n\n    //播放暂停控制\n    handlePlayAndPause() {\n        let _o_i = this.$play.$el.find('i');\n        //this.audio.pauseed值为true 说明目前是不播放\n        if (this.audio.paused) { //现在是暂停的 要播放\n            this.audio.play();\n            _o_i.removeClass('icon-play').addClass('icon-pause');\n            this.disc.image.addClass('play');\n            this.disc.pointer.addClass('play')\n        } else {\n            this.audio.pause();\n            _o_i.addClass('icon-play').removeClass('icon-pause');\n            this.disc.image.removeClass('play');\n            this.disc.pointer.removeClass('play');\n        }\n    }\n\n    //更改循环模式\n    changePlayMode() {\n        this.loop_mode++;\n        if (this.loop_mode > 2) this.loop_mode = 0;\n        this.renderPlayMode();\n    }\n    //更改按钮样式\n    renderPlayMode() {\n        let _classess = ['loop', 'random', 'single'];\n        let _o_i = this.$mode.$el.find('i');\n        //prop 改一些标签的自有属性 attr改一些标签的自定义属性\n        _o_i.prop('class', 'iconfont icon-' + _classess[this.loop_mode])\n    }\n    //更改歌曲索引\n    changeSongIndex(type) {\n        if (typeof type === 'number') {\n            this.song_index = type;\n        } else {\n            if (this.loop_mode === 0) {\n                //列表循环\n                this.song_index += type === 'next' ? 1 : -1;\n                if (this.song_index > this.musics.songs.length - 1) this.song_index = 0;\n                if (this.song_index < 0) this.song_index = this.musics.songs.length - 1;\n            } else if (this.loop_mode === 1) {\n                //随机播放\n                let _length = this.musics.songs.length;\n                let _random = Math.floor(Math.random() * _length);\n                for (let i = 0; i < 10000; i++) { //随机的数为本身则继续随机\n                    if (this.song_index == _random) {\n                        _random = Math.floor(Math.random() * _length);\n                    } else {\n                        this.song_index = _random;\n                        break;\n                    }\n                }\n            } else if (this.loop_mode === 2) {\n                this.song_index = this.song_index;\n            }\n        }\n    }\n    //歌曲时长\n    songTime() {\n        let totalMinute = parseInt(this.audio.duration / 60) < 10 ? \"0\" + parseInt(this.audio.duration / 60) : parseInt(this.audio.duration / 60);\n        let totalSecond = parseInt(this.audio.duration % 60) < 10 ? \"0\" + parseInt(this.audio.duration % 60) : parseInt(this.audio.duration % 60);\n        $('.totalTime').text(totalMinute + ':' + totalSecond);\n    }\n    //切换歌曲\n    changeSong(type) {\n        //更改索引\n        this.changeSongIndex(type);\n        //记录切歌前的状态\n        let _is_pause = this.audio.paused;\n        //切歌后更改视图显示\n        this.renderSongStyle();\n        //如果切歌前是在播放，就继续播放\n        if (!_is_pause) this.audio.play();\n    }\n    //禁音\n    banNotes() {\n        let _o_i = this.$ban.$el.find(\"i\");\n        if (this.audio.muted == true) { //如果禁音则开启\n            this.audio.muted = false;\n            _o_i.removeClass('icon-muted').addClass('icon-volume');\n        } else {\n            this.audio.muted = true;\n            _o_i.removeClass('icon-volume').addClass('icon-muted');\n        }\n    }\n}\n\n//进度条\nclass Progress {\n    constructor(selector, options) {\n        $.extend(this, options);\n        ///给this挂载传入的参数\n        this.$el = $(selector);\n        this.width = this.$el.width();\n        this.init();\n    }\n\n    //进度条初始化\n    init() {\n        this.renderBackAndPointer();\n        this.bindEvents();\n        this.drag();\n        this.value;\n        this.changeDOMStyle(this.width * this.value);\n    }\n    //为进度条渲染back和pointer\n    renderBackAndPointer() {\n        this.$back = $('<div class=\"back\">');\n        this.$pointer = $('<div class=\"pointer\">');\n\n        this.$el.append(this.$back);\n        this.$el.append(this.$pointer);\n    }\n\n    setValue(value) { //主动调用，传入value值，设置进度条样式\n        let _distance = this.width * value / (this.max - this.min);\n        this.changeDOMStyle(_distance);\n    }\n\n    drag() {\n        let ele = this.$pointer;\n        let father = this.$el;\n        let flag = false; //鼠标是否点击\n        ele.mousedown((e) => {\n            flag = true;\n            let mousePos = {\n                x: e.offsetX\n            }\n            $(document).mousemove((e) => {\n                if (flag === true) {\n                    let _left = e.clientX - father.offset().left - mousePos.x;\n                    let _distance = Math.max(0, Math.min(_left, father.outerWidth(false) - ele.outerWidth(false)))\n                    let _ratio = _distance / father.outerWidth(false);\n                    let _value = _ratio * (this.max - this.min); //当前的音量值\n                    this.changeDOMStyle(_distance);\n                    this.handler(_value); //更改进度之后，执行回调\n                }\n            })\n        })\n        $(document).mouseup(() => {\n            flag = false;\n        })\n\n    }\n\n    bindEvents() { //鼠标点击时更改\n        this.$el.click((e) => {\n            let _x = e.offsetX; //鼠标距离元素左边的距离\n            let _ratio = _x / this.width;\n            let _value = _ratio * (this.max - this.min); //当前的音量值\n            this.changeDOMStyle(_x);\n            this.handler(_value); //更改进度之后，执行回调\n        })\n    }\n    //更改pointer和back\n    changeDOMStyle(distance) {\n        this.$back.width(distance + 7 == 7 ? 0 : distance + 7);//进度为0时将进度条背景改为0否则加上进度按钮的长度\n        this.$pointer.css('left', distance + 'px');\n    }\n}\n\n\n//按钮类 \nclass Btns {\n    constructor(selector, handlers) {\n        this.$el = $(selector); //元素\n        this.bindEvents(handlers);\n    }\n    bindEvents(handlers) { //绑定事件\n        for (const event in handlers) {\n            //使用值的时候保证键值对在对象中是存在的\n            if (handlers.hasOwnProperty(event)) {\n                this.$el.on(event, handlers[event]);\n            }\n        }\n    }\n}\nnew Player();\ndocument.addEventListener('pjax:complete', (e) => {\n    new Player();\n})\n\n```\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`utill.js`。\n```js\nclass Util {\n    constructor() {\n        if (Util.instance) return Util.instance;\n        return this.getInstance(...arguments);\n    }\n\n    getInstance() {\n        var instance = {\n            /*\n             *   formatTime 格式化时间（s）为 hour:minutes:seconds\n             *   @params  time  required number (s)\n             *   \n             *   return hour:minutes:seconds string\n             */\n\n            formatTime(time) {\n                //没有传time的时候\n                if (time === undefined) {\n                    this.handlerError(123, {\n                        method: 'formate',\n                        param: 'time'\n                    });\n                    return false;\n                }\n                let _time = Math.floor(time);\n                let _minutes = Math.floor(_time / 60);\n                let _hours = Math.floor(_minutes / 60);\n                let _seconds = _time - (_minutes * 60);\n\n                return (_hours ? this.fillZero(_hours) + ':' : '') + this.fillZero(_minutes - (_hours * 60)) + ':' + this.fillZero(_seconds);\n            },\n            /*\n             *   fillZero 为小于10的数字补0\n             *   @params  num  required number\n             *   return '01'.. string\n             */\n            fillZero(num) {\n                //当没有传time的时候\n                if (num === undefined) {\n                    this.handlerError(123, {\n                        method: 'fillZero',\n                        param: 'num'\n                    });\n                    return false;\n                }\n                //这个函数只是让我们在渲染/显示的时候有一个不同的效果，不要操作原数据\n                return num > 9 ? num : '0' + num;\n            },\n            errors: {\n                123: ({\n                    method,\n                    param\n                }) => {\n                    return method + 'function need a param ' + param;\n                }\n            },\n            handlerError(code, options) { //处理报错\n                console.error('[until error] message' + this.errors[code](options));\n            }\n        }\n        Util.instance = instance;\n        return instance;\n    }\n}\n\n//为了这个工具以后在模块化环境中依然可以使用，需要判断一下，如果是在模块化环境，就将其暴露出去\n//commonJs\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = Util;\n}\n\n//AMD\nif (typeof define === 'function' && define.amd) {\n    define('util', [], function () {\n        return Util;\n    });\n}\n\n```\n\n&emsp;&emsp;引入css（一些高度和细节按需自行调整）：\n```css\n/* 播放器大小 */\n.music-player {\n  width: 570px;\n  height: 500px;\n}\n.music-player h3{\n  margin: 0px 0 1px!important;\n}\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1537976418058'); /* IE9*/\n  src: url('iconfont.eot?t=1537976418058#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAmcAAsAAAAADgwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY8lGHxY21hcAAAAYAAAACUAAACBGvSDaxnbHlmAAACFAAABUMAAAbwatoOAWhlYWQAAAdYAAAALwAAADYSwtboaGhlYQAAB4gAAAAcAAAAJAfeA4tobXR4AAAHpAAAAA8AAAAoKAAAAGxvY2EAAAe0AAAAFgAAABYIpgZ4bWF4cAAAB8wAAAAdAAAAIAEYAGNuYW1lAAAH7AAAAUUAAAJtPlT+fXBvc3QAAAk0AAAAZQAAAJSspZ5ZeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeyf3/z9zwv4EhhrmBoQEozAiSAwD0fA0ZeJztkcENwjAQBMdxCAQhQgU88qYeesBKGoh48aLSS7oIa1+QKIKzxtKedWdpF9gBUdxEDeFNINdL3VD6kWPp19ylzxyoaOxqvSUb57RM6wqbHr76p4Jm/Fx0oNGfUVtabdzrueFfp3I/N9VmPx25hfVOzsqSkzOzwZGX2Ojk2Tk5Oc9lcuR0x6OQE+lIBag+4Pgp1HicbVVrjBNVFJ5z796Zvu482plOH0tLZ9rp7hba0m5bZLuUhwZNQEB2F7airBDlERd5/IX4b+MPE3/wUhMTEkLEQAwkhpAIgcCaGI3xpyQqwb/orgsmGs129Ex3UWJoJufec+43PfN955wZgQjC37/SL6giGEKvIESgHjWNHBpNhnzOQAPOILCaH2psI9xP9BNQ4gNACqb7kBRi7lKVbnEvuU2YhhG4ADuUUOn0bUUpdl4e0JU7J9HAuFYEZ3bWveNOz8wI+PtfTj+ITr7G0GirwWQ1NBDVIWf4wcjRz9ylsQJxH5oFAgNxUEh/Au6r85cx3bTbdC/BdvdjRR84eQcNOV9UlNunSyHFvRAuut/PzEAThmdnMWcP5nxA99F9giZkhKIwJAhmEbyMjYoJKdBFCUQqg6mJUbPegLqDxCOWU29BPQWiAqL0pHO3UAGoFJZaRE2l0+nOo2w6IQPICS1K5CxYnTmj45Noj48FRMKknq8854Ou835PFJoVcrbSBN29rJXqpbB7RacbSJ/cmVD6CIRgs1HWYWuw82UwSBmlgQBl5DjuJyj1oyWLGn5Na7QhKEJaEMCWwdD0qFlFQqh3Dn1JS8Fjn/zeStp2spWwAWy3vDrprcmFhTZw2wl3jxJkduHoSd+rGcV8f9Cb1C/khPXCGGbEBHjZljNYb3hZ8Krm0amksXooER60wHQsUU+DjVI7MkTNFAyBJOrRCio5mIcqPmHUrKDYCMBH1qPkkfPuuolPnx+KxGKRofJHG9sfDq9s8oQtT4VCU7KV5E0i2wneXNn70nLZjgNf/3oJAUnLA8x/PmTvHOBqJA5y662a9yekxI6v3fUejediwN7ZOP42XcUzidAUz/KpUCLLV//EE1l5GNYUOCSzvPXsKm4lOB6HYC9dlw9Bb5YPbQCI5eKLOqDZT34RkqjEWk95SxIlz3j6D0Eam6mKa72hOdQpga1VReynRn3QsRRUoavHogRmtIIqEE44v+HfG+FKIrK/NhGLAeckLkmWOvrasWNkxyFg45KsSuNtSeViuy1yVWqPS6oskZ/95wIhVXUfRBKlrRHD39NLTvd2dskvjEAv2bzbnW6LGpfGxyWueTf+u+/Ow4/0IrVxHvqFljCKTLCeBSzrEvB4VKJpwKoUACuDI4mBegPfC0hSzDfEIvLDghc9CM5rCgxdNBejtf+iJs5E5x5HDcLxeLiq2fzenz7DX82VcXrsqt/wAZUjEfmKTwtSKdsH0JeTIKhJy1as0LuxTaMwuqkbGnkV4BVy91owBHHtejjGg9feZz4oZ6/bFZ/4XdAfnp8L+4M/MKJobMnW4rIXU6ImEzG7q/7M7m9wtjWxeXH3zvMtjAJ77uobb95YnKNb9BZdIzjCJkHIZbAfZawpVq4ILWRR7XJTIIN0a9jd0SUoEWTyDopS9URKgYIR7HA8bUEGZwLxljOM95KrLi8rQAzFp7LJAAlNMtWn6D7WD3NjB4mW0ugp14K5sroI8ZPggccQV912eAEysDwQUTQfmwj0BvYwBroicZanh0bGFE1TxiZPkE+eimBHxtpyOCxvP3qmO783uzzzwubu/Fqix0TKeBUbdPKW91rr0qlipZH+AmGHVeoelUYGu8PQvWHF0e2qY1uihL28wDjKNFsyGxo9q2jk4Jir9jOf3uUUhECXtoFfjjL8duQU1eavIOjwNph7DDoQJP5FkFp2VQ8D35a3qMNwDgmOHKJ5xiVFB8b2IMMJ5tOUSGA5PTGJCmwJy+2xI+ypCHLm6HY5fBTWrOrvd//Ccv8D5gQugwB4nGNgZGBgAOJ0oeli8fw2Xxm4WRhA4PrFk0kI+v9+FgbmDCCXg4EJJAoAItUKtAB4nGNgZGBgbvjfwBDDwgACQJKRARVwAQBHEAJzeJxjYWBgYCECAwADmAApAAAAAAAAOgB0ANwBFAGYAfwCgAL0A3gAAHicY2BkYGDgYghnYGEAASYwjwtI/gfzGQASMwF8AAAAeJxlj01OwzAQhV/6B6QSqqhgh+QFYgEo/RGrblhUavdddN+mTpsqiSPHrdQDcB6OwAk4AtyAO/BIJ5s2lsffvHljTwDc4Acejt8t95E9XDI7cg0XuBeuU38QbpBfhJto41W4Rf1N2MczpsJtdGF5g9e4YvaEd2EPHXwI13CNT+E69S/hBvlbuIk7/Aq30PHqwj7mXle4jUcv9sdWL5xeqeVBxaHJIpM5v4KZXu+Sha3S6pxrW8QmU4OgX0lTnWlb3VPs10PnIhVZk6oJqzpJjMqt2erQBRvn8lGvF4kehCblWGP+tsYCjnEFhSUOjDFCGGSIyujoO1Vm9K+xQ8Jee1Y9zed0WxTU/3OFAQL0z1xTurLSeTpPgT1fG1J1dCtuy56UNJFezUkSskJe1rZUQuoBNmVXjhF6XNGJPyhnSP8ACVpuyAAAAHicbcrBCoNADATQjLau3dWPjBTdaInINqD9+gb06MBc3gxVdCbSfSIq1HjgiQYBLV6ISJRKZp0OKXm1sBjLLNoM6+gYfqxf0SkVc73MZ39r6/2IQ7+bZmM95+7NutlFRH+UdSMxAAAA') format('woff'),\n  url('iconfont.ttf?t=1537976418058') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1537976418058#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.icon-prev:before { content: \"\\f0069\"; }\n\n.icon-next:before { content: \"\\f006a\"; }\n\n.icon-play:before { content: \"\\e66a\"; }\n\n.icon-pause:before { content: \"\\e76a\"; }\n\n.icon-random:before { content: \"\\e622\"; }\n\n.icon-muted:before { content: \"\\e61e\"; }\n\n.icon-volume:before { content: \"\\e87a\"; }\n\n.icon-loop:before { content: \"\\e66c\"; }\n\n.icon-single:before { content: \"\\e66d\"; }\n\n\n/* 播放器位置 */\n.music-player {\n  position: relative;\n  margin: 0px auto;\n}\n\n/* 歌曲列表 */\n\n.music-player__list {\n  width: 100%;\n  padding: 10px;\n  margin-top: 30px;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 5px;\n  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n}\n\n.music__list__item {\n  padding-left: 25px;\n  color: #ccc;\n  position: relative;\n  margin-bottom: 10px;\n  font-size: 14px;\n  cursor: pointer;\n}\n\n.music__list__item:last-of-type {\n  margin: 0;\n}\n\n.music__list__item.play {\n  color: #fff;\n}\n\n.music__list__item.play:before {\n  font-family: 'iconfont';\n  content: \"\\e87a\";\n  position: absolute;\n  left: 0px;\n  top: 4px;\n}\n/* 播放器主体 */\n.music-player__main {\n  height: 180px;\n  padding: 25px;\n  box-shadow: 0 0 10px rgb(0 0 0 / 20%);\n  border-radius: 10px;\n  position: relative;\n  overflow: hidden;\n}\n\n/* 播放器主体模糊背景 */\n.music-player__blur {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-size: 100%;\n  left: 0;\n  top: 0;\n  z-index: -1;\n  -webkit-filter: blur(20px);\n  filter: blur(20px);\n}\n/* 播放器唱片效果 */\n.music-player__disc {\n  float: left;\n  width: 130px;\n  height: 130px;\n  background: url(/img/cd.png) no-repeat center;\n  background-size: 100%;\n  position: relative;\n}\n\n/* 唱片指针 */\n.music-player__pointer {\n  width: 25px;\n  position: absolute;\n  right: -10px;\n  top: 0;\n  -webkit-transform-origin: right top;\n  -ms-transform-origin: right top;\n  transform-origin: right top;\n  -webkit-transform: rotate(-15deg);\n  -ms-transform: rotate(-15deg);\n  transform: rotate(-15deg);\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n}\n\n/* 唱片指针播放状态 加play类名 */\n.music-player__pointer.play {\n  -webkit-transform: rotate(0deg);\n  -ms-transform: rotate(0deg);\n  transform: rotate(0deg);\n}\n\n/* 唱片歌曲图片 */\n.music-player__image {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n/* 播放器控件 */\n.music-player__controls {\n  width: 330px;\n  height: 130px;\n  float: right;\n}\n\n/* 歌曲信息 */\n.music__info {\n  width: 100%;\n  height: 50px;\n  margin-bottom: 15px;\n}\n\n.music__info .music__info--title {\n  color: #fff;\n}\n\n.music__info .music__info--title {\n  font-size: 16px;\n}\n/* 控件 */\n\n.player-control {\n  width: 100%;\n}\n\n.player-control__content {\n  overflow: hidden;\n}\n\n/* 播放暂停按钮 */\n.player-control__btns {\n  float: left;\n  overflow: hidden;\n}\n\n.player-control__btn {\n  float: left;\n  margin: 0 5px;\n  font-weight: bolder;\n  color: #fff;\n  cursor: pointer;\n}\n\n.player-control__volume {\n  float: right;\n  overflow: hidden;\n}\n\n.control__volume--progress {\n  float: left;\n  width: 100px;\n  position: relative;\n  top: 8px;\n}\n\n.player__song--timeProgess{\n  font-size: 12px;\n  color: #fff;\n  padding: 0px 3px;\n  background: rgba(0, 0, 0, 0.3);\n  border-radius: 5px;\n}\n\n.player-control__content .nowTime{\n  float: left;\n}\n.player-control__content .totalTime{\n  float: right;\n}\n\n.music-player .progress {\n  background: rgba(0, 0, 0, 0.3);\n  height: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  overflow: hidden;\n  margin: 0.5rem 0!important;\n  border-radius: 2px;\n  position: relative;\n  cursor: pointer;\n}\n\n.music-player .progress .back {\n  width: 0px;\n  height: 100%;\n  border-radius: 2px;\n  background: rgb(12, 182, 212);\n}\n\n.music-player .progress .pointer {\n  width: 7px;\n  height: 7px;\n  background: #fff;\n  border-radius: 50%;\n  opacity: 0;\n  -webkit-transition: opacity 0.3s;\n  -o-transition: opacity 0.3s;\n  transition: opacity 0.3s;\n  position: absolute;\n  top: -1px;\n  left: 0;\n}\n\n.music-player .progress:hover .pointer {\n  opacity: 1;\n}\n\n\n/* 播放 画片 动画 */\n\n@-webkit-keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n\n@keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n.music-player__image.play {\n  -webkit-animation: disc 5s linear 0s infinite;\n  animation: disc 5s linear 0s infinite;\n}\n/*  播放进度  */\n.player__song--progress {\n  width: 100%;\n  margin-top: 15px;\n}\n.music-player h1, .music-player h2, .music-player h3,.music-player h4, .music-player h5, .music-player h6, .music-player p {\n  margin: 0; padding: 0;\n}\n.music-player li { list-style: none; }\n\n```\n\n&emsp;&emsp;修改`player.js`里`this.songs`的歌曲信息，把音乐换成自己的，接着三连即可。\n>本地浏览可能音乐的进度条无法拖动或者一拖动音乐就回到最开头，问题不大，推送上去就正常了。\n\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"归档、分类、标签页文章卡片加上所属分类和标签","url":"/article/a19bb7fb.html","content":"\n# 前言\n&emsp;&emsp;如图，上面修改前，下面修改后。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/23-2.webp width=\"90%\" height=\"90%\">\n\n# 实现\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug`\n```\n.article-sort-item-info\n    .article-sort-item-time\n        time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n        a.article-sort-item-title(href=url_for(article.path) title=title)= title\n+    .article-meta-wrap\n+        if (theme.post_meta.page.categories && article.categories.data.length > 0)\n+            span.article-sort-item-categories\n+                i.iconfont.icon-fenlei//- 记得改成自己的图标\n+                each item, index in article.categories.data\n+                    a(href=url_for(item.path)).article-meta__categories #[=item.name]\n+                    if (index < article.categories.data.length - 1)\n+                       i.fas.fa-angle-right\n+        if (theme.post_meta.page.tags && article.tags.data.length > 0)\n+            span.article-sort-item-tags\n+                i.iconfont.icon-biaoqian//- 记得改成自己的图标\n+                each item, index in article.tags.data\n+                    a(href=url_for(item.path)).article-meta__tags #[=item.name]\n+                    if (index < article.tags.data.length - 1)\n+                        span.article-meta__link #[='•']\n+        .article-sort-item-time\n+            time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n\n```\n\n&emsp;&emsp;增加css：根据自己的实际样式情况进行微调，没有通用css。\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"控制指定单页的背景样式","url":"/article/eb3a4679.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客单页，无论是哔哔，友链，还是关于页，page的背景都是透明的，一开始我以为是在单页的index.md里单独引入css，后来才知道，是直接`#page{background:transparent;}`,这只会让所有非文章、归档、分类、标签的单页背景透明。\n\n&emsp;&emsp;这好啊，果断抄走，然后不出意外，有些单页变得很难看，因为没关侧边栏（侧边栏没透明，page透明了），或因为背景透明后字看不清（友链页），反正，我需要能单独控制单页page的背景样式，说干就干，让不同单页加上不同class，css控制这些class即可。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/22-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n# 实现\n## 方案一\n&emsp;**让指定单页背景样式相同(如透明)**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制哪些单页的背景就加上is_current('<单页路径>')\nblock content\n+  - let transparent = (is_current('/bb/') || is_current('/charts/')) ? true : false\n-  #page\n+  #page(class= (transparent === true) ? 'transparentpage' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug 这里是让指定单页的背景都透明\n.transparentpage{\n    background:transparent!important;\n}\n\n```\n\n## 方案二\n&emsp;**控制不同单页有不同背景样式**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制更多单页就仿照格式写\nblock content\n+  - let bb = is_current('/bb/') ? true : false\n+  - let charts = is_current('/charts/') ? true : false\n-  #page\n+  #page(class= (bb === true) ? 'bb-transparent' : '')(class= (charts === true) ? 'charts-transparent' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug\n.bb-transparent{\n    background:transparent!important;\n}\n.charts-transparent{\n    background:blue!important;\n}\n\n```\n\n&emsp;&emsp;此方法存在一个问题：\n&emsp;&emsp;hexo g和hexo s时，会提示:You should not have pug tags with multiple attributes.（您不应该使用具有多个属性的pug标记）\n&emsp;&emsp;这是因为我尝试多次class=()，但实际上，因为路径是唯一的，这不会导致出问题，对hexo渲染没有影响。\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Butterfly给首页首个文章卡片加个class","url":"/article/dbde845d.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客首页，他的第一个文章卡片是其余卡片宽度的两倍，F12可知是首页的首个文章卡片多了一个class，虽然我的文章卡片暂时没这需求，但刚好有人问怎么才能控制首页第一个文章卡片的样式，也刚好我有思路，就实现一下吧\n&emsp;&emsp;关键就是怎么给首个文章卡片加一个class，我想到了和之前[给文章卡片加上最新文章标志](/article/2ed7d622.html)差不多的操作\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/21-2.webp width=\"100%\" height=\"100%\">\n***\n\n# 实现\n&emsp;&emsp;先看原来post-ui的结构:``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    .recent-post-item//要在这里加个calss\n    //后面就是文章卡片的具体的内容\n\n```\n\n&emsp;&emsp;可以改成这样，就能将首页第一个文章卡片和其余卡片分开渲染成html，自然，加个class就轻而易举了\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    if (firstpost !== 1 && is_current('/'))\n      - var firstpost = 1\n      .recent-post-item.firstpost-item\n      //首页首个文章卡片的具体的内容（cv原来的就行）\n    else\n      .recent-post-item\n      //其余文章卡片的具体的内容（cv原来的就行）\n\n```\n\n&emsp;&emsp;这样，首页第一个文章卡片就会多一个``firstpost-item``class，控制这个class就能控制样式了\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/21-1.webp width=\"40%\" height=\"40%\">\n\n&emsp;&emsp;而且这样改完pug，首页第一个文章卡片有更多的操作空间，可以完全和其余卡片长得不一样，修改具体内容里的源码即可\n***\n\n# 优化\n&emsp;&emsp;[@heo](https://blog.zhheo.com/)的代码结构优化版本（适合无需对首页第一个卡片进行定制化）\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    - let lastPost = firstpost !== 1 && is_current('/') ? true : false\n    - var firstpost = 1\n    .recent-post-item(class= (lastPost === true) ? 'firstpost-item' : '')\n    \n```\n\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"Butterfly文章卡片加上最新文章标志","url":"/article/2ed7d622.html","content":"\n# 前言\n&emsp;&emsp;昨天[@Leonus](https://blog.leonus.cn/)大佬用js给首页最新的文章卡片加上了``最新``标志:[几行代码实现最新文章标志 | Leonus](https://blog.leonus.cn/2022/newpost.html)\n&emsp;&emsp;不过每次切换到首页都要执行这个js，不然最新标志就不显示，开启了pjax之后,怎么让这js每次切换到首页都执行是个问题，而且每次都执行也会多吃一些性能\n\n&emsp;&emsp;因为butterfly是按创建时间顺序排序的，最上面的卡片就是最新文章，直接修改文章卡片源码，给第一个卡片加上``最新``标志就行了（当然还要排除手动置顶的文章）\n&emsp;&emsp;这样pug渲染成html时，``最新``标志就写死在那了\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/20-1.webp width=\"30%\" height=\"30%\">\n***\n\n# 实现\n>我这实现看起来挺笨，有大佬有更好的实现方式不\n\n1. 修改``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``&emsp;加上三行：\n```pug\n.recent-post-info\n+    if (numberone !== 1 && is_current('/') && (!article.top || (article.new && article.top)))\n+        span.newPost 最新\n+        - var numberone = 1\n```\n\n2. 在你的自定义css文件中，添加如下代码：\n```css\n/* 最新文章图标 */\n.newPost {\n    position: absolute;\n    top: 0;\n    color: rgba(255, 255, 255, 0.92);\n    padding: 0 15px;\n    background-color: #49b0f5b9;\n    border-radius: 0 0 10px 10px;\n    right: 40px;\n}\n@media screen and (max-width:600px){\n  .newPost {\n    right: 0px;\n    padding: 0 12px;\n    border-radius: 0 10px 0px 10px;\n}\n}\n```\n\n***\n\n# 使用\n&emsp;&emsp;当首页没有置顶时，会给第一个卡片加上最新标志\n&emsp;&emsp;当首页有置顶时，会给非置顶的第一个卡片加上最新标志\n\n&emsp;&emsp;显然，这里有bug，如果置顶里的文章就是最新的咋办？\n&emsp;&emsp;只需要在文章头部加上``new: true``就行了\n\n&emsp;&emsp;稍微有点麻烦，所以，建议最新的文章就没必要置顶了，反正不置顶也在第一个\n```\n---\ntitle: aaaaaaaaaa\ntop: 1\n+ new: true\n---\n```\n\n***\n\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"小米妙享--MIUI的生态互联","url":"/article/eb38f645.html","content":"\n# 引言\n&emsp;&emsp;不少人去年就听说了这个功能，作为小米产品生态构建的重要一环（全局设备互联互通），这个功能我却迟迟没去更新使用，因为它与miui+的割裂导致使用起来比较繁琐，也因为它把平板排除于外，当然最主要是我实在没有这么多设备需要去``流转``。\n&emsp;&emsp;但在最近的更新中，``小米妙享``不仅将miui+给整合进了`妙享中心`，还带上了小米平板5系列，为平板与电脑的互联互通增加了几个重要的功能。\n\n# 如何安装\n&emsp;&emsp;我喜欢小米的一点，就是它将系统功能都作为一个个软件的形式打包，不同批次的软件之间兼容性也不错，除非跨安卓版本才能实现的功能（例如米版的全局手写，这个基于安卓12，自然安卓11用不了），都可以通过安装或更新软件来使用新功能，正好，小米妙享就是这样一个安装即用的系统功能。  \n\n## 平板/手机端\n&emsp;&emsp;我的平板还在13.0.6这个稳定版养老，下载安装最新的`miui+`、`投屏`、`小米互联通信`,手机端就搞定了(没有资格就刷个`Miui解锁小米妙享模块`)。\n\n## 电脑端\n&emsp;&emsp;目前电脑端软件有限制，只有小米电脑上才能使用，但这难不倒酷友们，跟着此帖即可在电脑端安装好妙享中心：[最新miui+（小米妙享）PC版安装及配置教程](https://www.coolapk.com/feed/38357299?shareKey=MzdiMWMzNjNmMTgwNjJmYTcyYmI~&shareUid=4137393&shareFrom=com.coolapk.market_12.0.2)。\n\n# 使用体验\n\n## 互联\n&emsp;&emsp;电脑打开蓝牙，平板打开蓝牙、wifi、小米互传，让设备处于同一网络下，电脑端点击连接，等待`1-2秒`，很快即可连接上。且蓝牙wifi我一般保持常开，平板使用时也是手机或电脑给平板开热点，基本能做到需要就点击连接。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-1.webp width=\"60%\" height=\"60%\"><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-3.webp width=\"60%\" height=\"60%\">\n\n## 平板作为电脑副屏\n&emsp;&emsp;这个功能是这次妙享更新后给米版上的新功能，在连接成功后可以看到两种副屏方式，作为镜像屏，或者扩展屏。选择任意一种副屏方式，同样等待2秒，就可完成副屏的启动。\n&emsp;&emsp;作为一个`无线可触摸`的副屏，使用起来非常舒适。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-2.webp width=\"60%\" height=\"60%\">&emsp;&emsp;侧边栏有一些快捷键：“返回桌面”“多任务”“保存”“返回/撤销上一步操作”“保存截图”“屏幕键盘”“退出”。\n\n### 作为镜像屏\n&emsp;&emsp;利用秒表测试有0.04s延迟（屏幕一半播视频，一半秒表计时，拍照算时差，确保符合正常使用的延迟），实际体验下延迟确实可忽略不计，分辨率1920*1080（等同电脑屏幕分辨率），但帧率在40到60之间波动，习惯了120帧确实有点不舒服，不过也远胜我之前用的spacedesk。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-4.webp width=\"60%\" height=\"60%\">&emsp;&emsp;小米妙享实际上是一个软件，那当然可以上滑挂在后台，或者挂个小窗在前台。  \n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-5.webp width=\"60%\" height=\"60%\">&emsp;&emsp;在电脑端还可以设置侧边栏的位置、使用米板作为电脑的音频输出等。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-6.webp width=\"60%\" height=\"60%\">\n\n### 作为扩展屏\n&emsp;&emsp;作为扩展屏时与镜像屏时差不多，同样有低延迟、高分辨率（作为扩展屏时分辨率1920*1200），同样可以挂后台挂小窗，设置侧边栏的位置、使用米板作为电脑的音频输出等。\n&emsp;&emsp;但此时帧率在30到50之间波动，可以感觉到鼠标拖动的略微不顺畅的卡顿，且窗口在平板与电脑直接拖动时，大小变化还有待优化，经常拖到平板还得再手动调小窗口大小。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-7.webp width=\"60%\" height=\"60%\">\n&emsp;&emsp;无论是作为镜像还是扩展屏，吃电脑资源都不多。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-10.webp width=\"70%\" height=\"70%\">\n\n## 平板投屏到电脑\n&emsp;&emsp;应用流转仅限于小米的设备，自然投屏也需要小米笔记本才行，不过酷友[@迷璐](https://www.coolapk.com/u/1189245)的模块可以让其它品牌的电脑也出现在妙享界面，只需要将平板画面拖到电脑的气泡上，1-2秒后，电脑上就有平板的投屏窗口了，投屏后平板可关闭屏幕。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-11.webp width=\"60%\" height=\"60%\">&emsp;&emsp;投屏窗口可最大化可最小化，利用秒表测试有0.07s延迟（主界面播视频，小窗秒表计时，拍照算时差，确保符合正常使用的延迟），分辨率至少有1080p以上，帧数稳稳50-60帧。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-12.webp width=\"60%\" height=\"60%\">&emsp;&emsp;值得注意的点是，这不是简单的投屏，投屏后，不仅平板的画面会在电脑上出现个窗口，平板上的所有音频也会用电脑的喇叭输出，而且可以直接使用电脑的键盘、鼠标去控制、操作平板。\n\n## 互通\n&emsp;&emsp;平板端截图，电脑会弹出有图和保存按键的小悬浮窗。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-8.webp width=\"40%\" height=\"40%\">&emsp;&emsp;平板端或电脑端复制文字内容，另一个设备会同步这个内容到剪切板，并弹窗提示，且电脑端的弹窗会显示复制的文字内容。当任意一设备复制的是网址时，悬浮窗还会有直接打开网站的按键。\n\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-9.webp width=\"60%\" height=\"60%\">\n\n### 电脑与平板互传文件\n&emsp;&emsp;平板长按文件点分享，选择电脑即可；电脑端使用用小米互传向平板传文件，两种操作都非常方便且快速。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/19-13.webp width=\"70%\" height=\"70%\">\n\n# 使用感受\n&emsp;&emsp;在简单上手平板与电脑之间的妙享后，可以确定，我以后将经常用到它的功能，实际上我还体验了平板-手机-电脑的三方互联互通，不过任意两个设备互联后，另一个设备就会断开连接（虽然重连很快，但还是很影响体验），所以三方互联的体验并不好，但平板-手机、手机-电脑之间的妙享体验也不错。\n&emsp;&emsp;可以看得出来MIUI还是有认真去做互联互通生态的，未来可期。\n\n# 不足之处\n1. 多设备同时互联体验差。\n2. 作为扩展屏与电脑之间拖动软件窗口，窗口大小自适应效果不好。\n3. 虽然博主安装起来较轻松，但不少酷友倒在了电脑硬件或其它配置上。\n4. 依赖核显（考虑考虑没核显或核显弱的笔记本？）。\n5. 平板投屏到电脑不能像手机与电脑的互联那样，直接拖文件传输。\n6. 手机应用流转到平板居然开倒车！直接全屏，而不是像之前那样在平板上弹出小窗。","tags":["小米妙享","MIUI"],"categories":["其它"]},{"title":"FakeLocation模拟校园跑教程","url":"/article/c5d354fd.html","content":"\n# 前言\n**本文未在任何平台出售，本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用，如有发现倒卖行为欢迎向博主反馈**\n\n我们学校用的是运动世界校园，所以就用这个软件为例，其他软件差不多  \n博主测试设备：红米k40安卓11、红米6pro安卓9  \n>吐槽：这软件，什么都往里塞，天天更新加广告（一指禅干掉）  \n\n**2023-03-17**这学期校园跑软件换成小步点了，软件使用手册里明确指出root和xp框架:\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-5.webp width=\"45%\">\n\n问题不大，照样。\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-6.webp width=\"30%\">\n\n# 准备工作\n1、首先是有面具**Root**，而非小米官方等残废root  \n2、下载万恶之源：运动世界校园  \n3、下载安装[FakeLocation1.3.0.2版本](https://wwm.lanzoul.com/iMHUo057ibyb)  \n4、下载安装[隐藏应用列表xp模块](https://wwm.lanzoul.com/iQ6lq057irkd)我使用的版本1.6较老，但能稳定用我也没去升级  \n5、安装lsp/xp框架  \n6、下载安装[Godvip](https://wwm.lanzoul.com/i8RYM057ibzc)  \n\n***\n\n# 隐藏防检测\n\n## 运动世界校园权限设置\n确保权限设置与图一致，关闭miui的模糊定位  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-1.webp width=\"75%\"></div>\n\n## 隐藏root\n面具本身随机包名安装  \n面具hide对运动世界校园全勾选（如果是24版本的面具，自行去酷安找shamiko模块隐藏root教程，我还没升到24，因为我用hide就能很好地隐藏root）  \n\n## 隐藏应用列表设置\n推荐先看酷安详细图文：[隐藏应用列表使用教程 Pro](https://www.coolapk.com/feed/34458057?shareKey=YjBlYzcxNDgwMzYwNjI4OGIzZmM~)  \n\n简单速通：  \n1、lsp/edxp启用**隐藏应用列表**  \n2、也许需要重启手机  \n3、点击模板管理，启用所有隐藏方式  \n4、选择要隐藏的应用，将FakeLocation、面具、lsp等搞机应用勾选  \n5、对运动校园应用模板  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-2.webp width=\"100%\" height=\"100%\"></div>\n\n## 破解FakeLocation\nlsp启用Godvip，模块对FakeLocation起作用  \n\n## FakeLocation设置\n给FakeLocation软件Root权限  \nFakeLocation设置页只打开**模拟GPS信号**  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-3.webp width=\"50%\" height=\"50%\"></div>\n\n## 如何模拟跑\n首先到一个较空旷，能接收到gps信号的地方（宿舍阳台、宿舍走廊），拿个椅子坐下，手机关闭wifi（可以开启蓝牙和数据）  \nFakeLocation选择**要模拟的位置**到跑道，当然具体在哪无所谓  \n打开运动软件，**待运动软件接收到gps信号**提示可以开始跑，返回FakeLocation软件，点击**启动模拟**（第一次打开需要等待一会，建议在模拟跑前先开关一次预热），并**打开摇杆**  \n\n摇杆设置：  \n摇杆里的**模拟gps信号**和**步频模拟**都得关掉，不能打开！不能打开！不能打开！   \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/11-4.webp width=\"100%\" height=\"100%\"></div>\n\n接着返回运动软件，你会发现显示的位置瞬移到了之前选择的模拟位置处，然后开始运动，要去哪就**用摇杆摇**到哪，步频可以使用其它软件模拟，但**建议抖手**  \n跑完后先结束运动，关闭运动软件，再停止位置模拟  \n\n***\n\n# 可能出现的问题\n1、当摇杆回到中间时（速度为0），运动软件会提示gps信号弱，这是正常现象  \n2、启动模拟后，运动软件上显示的位置没变：杀掉运动软件和FakeLocation，重新操作一次  \n3、启动模拟后，运动软件上显示的位置变了，但一开始运动位置就变回原来位置：杀掉运动软件和FakeLocation，重新操作一次  \n4、被检测到环境异常4：FakeLocation没隐藏好、运动软件检测到gps信号长期未变。请自查有无和教程操作不同的地方  \n\n# 温馨提示\n\n>如有问题可在评论区回复或在酷安找我\n>本教程虽然目前还可行，博主自用了两个学期也没被检测到一次，但安卓设备众多，系统繁杂，不确保教程的通用性\n>Root手机导致手机变砖、假跑被检测到影响体育成绩等后果，博主不承担任何责任\n\n***\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(3)","url":"/article/8636f786.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)\n\n# Swing\n**Swing**是一个为Java设计的GUI工具包，是java的基础类（import javax.swing.*;）  \n在Swing中，所有我们在界面中看到的东西都是**部件**（组件）  \n\n其中容器是一种特殊的部件\n部件可以被放进容器中，当然容器也能放进容器中  \n\nSwing提供了一个底层容器类JFrame，即整个窗口    \n```java JFrame中常用的方法\n//创建一个无标题的窗口\nJFrame()\n//创建标题为s的窗口\nJFrame(String s)\n//设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\npublic void setBounds(int a,int b,int width,int height)\n//设置窗口的大小。\npublic void setSize(int width,int height)\n//设置窗口的位置，默认位置是(0,0)。\npublic void setLocation(int x,int y)\n//设置窗口是否可见，窗口默认是不可见的。\npublic void setVisible(boolean b)\n//设置窗口是否可调整大小，默认可调整大小。public voiddispose()撤销当前窗口，并释放当前窗口所使用的资源。\npublic void setResizable(boolean b)\n//撤销当前窗口，并释放当前窗口所使用的全部资源\npublic void dispose()\n//设置窗口的扩展状态\npublic void setExtendedState(int state)\n//其中参数state取JFrame类中的下列类常量:\nMAXIMIZED_HORIZ (水平方向最大化)，\nMAXIMIZED_VERT (垂直方向最大化)，\nMAXIMIZED_BOTH (水平、垂直方向都最大化)。\n//该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，\npublic void setDefaultCloseOperation(int operation)\n//其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\nDO_NOTHING_ON_CLOSE(什么也不做)，\nHIDE_ON_CLOSE (隐藏当前窗口)，\nDISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\nEXIT_ON_CLOSE (结束窗口所在的应用程序)\n```\n\n## add\n通过add把一个部件加到一个容器中  \n部件被加到容器后，就受这个容器所管理  \n容器管理部件的方式叫**布局管理器**  \nJFrame默认采用的布局管理器叫**BorderLayout**,默认把部件放到CENTER  \n```java\ntheView = new View(theField);//theView是一个容器\nJFrame frame = new JFrame();//创建一个底层容器\nframe.add(theView);//把theView容器加到底层容器中。默认为中间\nJButton btnstep =new JButton(\"单步\");//btnstep是一个按钮部件\nframe.add(btnstep, BorderLayout.SOUTH);//把btnstep部件加到底层容器中，且放到南边（窗口最下面）\n```\n\n## BorderLayout\nBorderLayout把整个容器划分为五个部分  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-13.webp width=\"60%\" height=\"60%\"></div>\n\n后面放进去的部件会替换掉相同位置的部件（这就是为什么之前界面中只剩下一个按钮了）  \n当有部分没有部件时，其他部分会膨胀，将那个位置所占据  \n\nBorderLayout会根据部件里面的东西来帮我们计算，这个部件需要占据多大的空间 \n\n## 消息机制\n现在我们有了一个按下去没反应的按钮  \n如何让按钮按下去有反应？程序如何知道按钮被按下去了？  \n用户在图形界面做了一些操作，通过一些路径让程序知道，这个路径叫做**消息机制**  \n\nJava的Swing类实现了一个有意思的消息机制  \n```java\nJButton btnstep =new JButton(\"单步\");\nframe.add(btnstep, BorderLayout.SOUTH);\nbtnstep.addActionListener(new ActionListener(){\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(\"成功按下!\");\n\t}\n});\n```\n运行一下，当我们点击一次按钮，控制台都会输出一次“成功按下!”\n\n现在程序已经知道按钮被按下，且在上面的古怪代码中能成功做一些我们期望程序做的事（输出点东西）  \n我们可以把输出点东西换成其它事情，在狐狸和兔子中，step()函数控制单步  \n我们只需要做下面一些动作，就能让按钮控制单步  \n```java\nprivate JFrame frame;//把frame从FoxAndRabbit()中拿出来，让它变为FoxAndRabbit类中的成员变量\n···\n//JFrame frame = new JFrame();\nframe = new JFrame();\n···\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n···\n//fab.start(500);把main里的这句去掉，不让程序主动地开始\n``` \n现在每按一次按钮，程序就会运行一步  \n\n按钮自己有代码，知道自己被按下去了，但按钮作为一个早已经定好的类不可能有代码去调用step()\n但实际效果就是，每按一次按钮，step()就会被调用一次，这是怎么做到的？  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-14.webp width=\"90%\" height=\"90%\"></div>\n\nJButton类提供了一个接口，只要实现了这个接口的类的对象，都可以通过**addActionListener()**方法**注册**给JButton，当按钮发现自己被按下去了，就会检查有没有东西注册在按钮那，接着找到重写的**actionPerformed()**，这样JButton就知道step()了  \n注册进去的东西，是运行时候一个动态的对象  \n\n这就是**反转控制**（Swing的消息机制）：\n·由按钮公布一个守听者接口和一对注册/注销函数  \n·你的代码实现那个接口，将守听者对象注册在按钮上  \n·一旦按钮被按下，就会反过来调用你的守听者对象的某个函数   \n\n## 内部类、匿名类\n刚刚实现接口的代码看起来十分奇怪\n```java\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n```\n可以换种写法\n```java\n//在类中新增这个类\nprivate class stepListener implements ActionListener {\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n\t\tframe.repaint();\t\t\t\n\t}\n}\n···\n//原来的代码替换为这句\nbtnstep.addActionListener(new stepListener());\n```\n在一个类的内部，再定义一个类，这个类就叫**内部类**  \n内部类可以**直接访问**其所处类的**所有**成员  \njava的内部类也是类的成员  \n外部是函数时，只能访问那个函数里**final**的变量   \n\n用匿名类实现接口\n```java\nnew ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n}\n```\n在**new对象**的时候给出的**类的定义**形成了匿名类  \n匿名类可以**继承某类**，也可以**实现某接口**  \nSwingl的消息机制广泛使用匿名类  \n外部是函数时，只能访问那个函数里**final**的变量  \n\n为什么需要匿名类？\nSwing的消息机制决定了，每个部件发出的消息，都需要新的类去实现接口，然后去接收消息，当部件很多时，给每个类起名字非常麻烦   \n\n***\n\n# 一个课程表\n做一个课程表程序，它有8行7列，有表头表示7天，每个格子用户能自己编辑内容  \n效果是这样：  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-15.webp width=\"60%\" height=\"60%\"></div>\n\n有前面Swing的基础，我们知道想要有一个窗口，需要用到JFrame类，来创建一个底层窗口  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n现在运行，只有一个空空的窗口，一个空空的容器，我们需要往里面放部件  \n想要一个表格，那就放一个表格进去  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n\t\tJTable table = new JTable());//声明一个表格\n        frame.add(table);//把表格放进去\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n运行一下，还是啥都没有，因为我们还没初始化表格，还没给表格它要的数据  \n\n用JTable类可以以表格的形式显示和编辑数据。  \nJTable类的对象并不存储数据，它只是数据的表现。  \nJTable实现了数据与表现的分离  \n\n新建一个KCBData类，作为表格的数据  \n让这个类实现一个叫TableModel的接口  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    @Override\n    public int getRowCount() {\n        return 0;\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 0;\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return false;\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n\n    }\n}\n```\nTableModel接口是由JTable提供给我们的  \nTableModel告诉我们，只要实现了它，就能作为数据交给JTable  \n\n完善一下KCBData  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    private String[] title = {\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"};//表格标题\n    private String[][] data = new String[8][7];//真正放7天8节课的数据结构\n    //这个data数组里面都是String类型的管理者，所以需要初始化每个管理者去管理一个String类型的空数据\n    public KCBData() {\n        //构造方法,初始化数据,每一行的数据都是空的,即没有数据,这样才能显示表格,否则会报错\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                data[i][j] = \"\";//让每一个单元格都是空的\n            }\n        }\n    }\n    @Override\n    public int getRowCount() {\n        return 8;//表格有8行\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 7;//表格有7列\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return title[columnIndex];//返回一个表头\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return String.class;//告诉表格每列的数据类型,每一个都是String类型\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return true;//每个单元格都可以编辑\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return data[rowIndex][columnIndex];//将每一个单元格的数据返回，让表格拿到\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        data[rowIndex][columnIndex] = (String) aValue;//将每一个单元格的数据设置为aValue,即用户输入的数据\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n        //添加监听器\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n        //移除监听器\n    }\n}\n\n```\n现在表格能拿到数据了，它知道该怎么画一个表格  \n但运行一下，还是没有表头  \n\n这是因为JTable组件显示数据时，如果直接将其放置在Frame的contentPane中则表头一行会显示不出来，如果将其放置在JScrollPane中显示数据的话，表头会自动显示出来。  \n暂时无需关心为什么  \n\n再完善下KCB类，一个课程表就完成了  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        JTable table = new JTable(new KCBData());//声明一个表格\n        JScrollPane pane = new JScrollPane(table);//声明一个滚动面板\n        frame.add(pane);//将滚动面板添加到窗口\n        frame.pack();//自动调整窗口大小\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭方式\n        frame.setVisible(true);//显示窗口\n    }\n\n}\n```\n\n## MVC设计模式\n刚刚的课程表结构是这样的  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-16.webp width=\"85%\" height=\"85%\"></div>\n\n当JTable决定显示多少列时会调用getColumnCount，当它要显示表头时会调用getColumnName  \n程序运行过程中JTable反过来调用我们自己的KCBData里的方法  \n\n数据由我们自己实现了TableModel的对象来维护，JTable只管表现不管数据  \n\n**MVC**:数据、表现和控制三者分离，各负其责  \n·M=Model（模型)  \n·V=View(表现)  \n·C=Control(控制)  \n\n模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新  \n表现：从模型获得数据，根据数据画出表现  \n控制：从用户得到输入，根据输入调整数据  \n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-17.webp width=\"85%\" height=\"85%\"></div>\n\n不是由接收到用户输入的代码去修改界面上的显示，而是去修改内部的数据，内部的数据去触发界面的更新  \n\n这样做的好处：每一部分都很单纯，尤其是View表现，只管拿到想要的数据去表现，至于数据是怎么更新，怎么生成的，它统统不管  \n\n在代码实现中，View和Control通常在同个表达界面的类中实现，因为表现和用户控制都是在界面中完成的，这和MVC并不矛盾，只是在具体实现MVC模式时的技巧  \n\n***\n\n# Exception异常\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。  \n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。  \n\n写出下面的程序，idea的编辑器不会指出数组越界的错误，但运行程序控制台会抛出异常  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n}\n```\n\n```java 异常\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat ArrayIndex.main(ArrayIndex.java:4)\n```\n在main里面有Exception异常，问题出在在ArrayIndex的第四行，问题叫做ArrayIndexOutOfBoundsException，即数组越界  \n\n## 两种类型的异常与错误\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。  \n运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。  \n错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  \n\n异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  \n\n## 捕获异常\n当代码某一处可能出现问题、可能出现异常，就可以将这块代码放在一个用于捕捉异常的代码块中  \n```java\ntry\n{\n   // 可能出现异常的程序代码\n}catch(ExceptionName e1)//可以多个catch\n{\n   //处理异常的代码\n}catch(ExceptionName e2)\n{\n   //处理异常的代码\n}finally{\n  //无论是否发生异常，finally 代码块中的代码总会被执行。\n  // 程序代码\n}\n```\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码  \n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。  \n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样.  \n\n将刚刚数组越界的代码用捕捉异常处理  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n        a[10] = 10;\n        System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n运行一下\n```java\nerror\n```\n\n异常是程序运行过程中可能出现的问题，现在这个代码是一定会出错的，我们改造一下  \n```java\nimport java.util.Scanner;\n\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        int idx = 0;\n        Scanner in = new Scanner(System.in);\n        idx = in.nextInt();\n        try{\n            a[idx] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n\n```java 输出\n输入：2\nhello\n输入：12\nerror\n```\n\n## 异常处理机制\n把可能发出异常的代码放到try里，在try后面用catch去匹配可能出现的异常类型。  \n当try里的代码没有异常，catch里的代码不会被运行，当try里的代码出现异常，try里后续的代码都不会被执行，会直接调到catch里，在catch里处理完异常，会继续往下运行整个程序，而不会回到try。   \n当匹配到一个catch之后，异常就已经被处理完了，不会再去匹配另一个异常。  \n\n运行下面的代码  \n```java\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n    public static void main(String[] args) {\n        try{\n            f();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n当给数组赋值出现异常后，f方法后面的代码都不会被执行，然后回到调用f方法的地方，try会捕捉到f方法的异常，然后传递给catch  \n\n当有异常被抛出时，可以遵循下面的图来判断该在哪个地方处理这个异常  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-18.webp width=\"92%\" height=\"92%\"></div>\n\n```java 示例\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;//抛出ArrayIndexOutOfBoundsException异常\n        System.out.println(\"hello\");//异常后面的代码不会被执行\n    }\n\n    public static void g(){\n        f();//f方法抛出异常，异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void h(){\n        int i = 10;\n        if(i < 100){\n            g();//所处不是函数，跳出一层\n        }//异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void k(){\n        try{\n            h();//有try捕捉异常\n        }catch(NullPointerException e){//没有对应catch匹配，退出到外层\n            System.out.println(\"k error\");\n        }//所处是函数\n        //返回调用者\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();//有try捕捉异常\n        }catch(ArrayIndexOutOfBoundsException e){//有对应catch匹配\n            System.out.println(\"error\");//处理异常\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n\n## Java 内置异常类\n\n| 异常  | 描述    |\n| -----    | ------ |\n| ArithmeticException  |当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例|\n|ArrayIndexOutOfBoundsException|用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引|\n|ArrayStoreException|试图将错误类型的对象存储到一个对象数组时抛出的异常|\n|ClassCastException|当试图将对象强制转换为不是实例的子类时，抛出该异常|\n|IllegalArgumentException|抛出的异常表明向方法传递了一个不合法或不正确的参数|\n|IllegalMonitorStateException|抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程|\n|IllegalStateException|在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下|\n|IllegalThreadStateException|线程没有处于请求操作所要求的适当状态时抛出的异常|\n|IndexOutOfBoundsException|指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出|\n|NegativeArraySizeException|如果应用程序试图创建大小为负的数组，则抛出该异常|\n|NullPointerException|当应用程序试图在需要对象的地方使用 null 时，抛出该异常|\n|NumberFormatException\t|当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常|\n|SecurityException|由安全管理器抛出的异常，指示存在安全侵犯|\n|StringIndexOutOfBoundsException|此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小|\n|UnsupportedOperationException|当不支持请求的操作时，抛出该异常|\n|下面是Java 定义在 java.lang 包中的检查性异常类：||\n|ClassNotFoundException|应用程序试图加载类时，找不到相应的类，抛出该异常|\n|CloneNotSupportedException|当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常|\n|IllegalAccessException|拒绝访问一个类的时候，抛出该异常|\n|InstantiationException|当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常|\n|InterruptedException|一个线程被另一个线程中断，抛出该异常|\n|NoSuchFieldException|请求的变量不存在|\n|NoSuchMethodException|\t请求的方法不存在|\n\n## 异常方法\n当catch匹配到了异常，实际上是拿到了一个异常类型的对象，我们可以让对象做事情  \n```java\npublic class a {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n            a[10] = 20;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n            System.out.println(e.getMessage());\n            System.out.println();\n            System.out.println(e);\n            System.out.println();\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nerror\nIndex 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat a.main(a.java:5)\n\n```\n\n| 异常方法  | 描述    |\n| -----    | ------ |\n|String getMessage()|返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了|\n|Throwable getCause()|返回一个 Throwable 对象代表异常原因|\n|String toString()|返回此 Throwable 的简短描述|\n|void printStackTrace()|将此 Throwable 及其回溯打印到标准错误流|\n|StackTraceElement [] getStackTrace()|返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底|\n|Throwable fillInStackTrace()|用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中|\n\n## throw再度抛出\n当一个异常已经被处理了，将不会再次被捕捉  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){//k中已经处理了异常\n            System.out.println(\"k error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){//不会再次处理\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nmain\n```\n但可以通过throw主动地再次抛出这个异常  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"k error\");\n            throw e;//捕捉到后在此抛出该异常\n        }\n    }\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nerror\nmain\n```\n\n## 为什么要异常机制\n我们希望程序能够根据运行过程中可能出现的各种情况进行处理  \n早期，函数都有特定的返回值，通过函数内很多的if-else来判断返回什么，以返回值来做相应处理  \n\n函数内出现很多与功能无关的if-else，会导致函数可读性很差，而且不利于增加新的功能  \n异常机制将业务逻辑与异常处理在代码上分开  \n```java\ntry{\n    //业务逻辑都放在一起\n    open the file;\n    determine its size;\n    allocate that much memory;\n    read the file into memory;\n    close the file;\n    //如果上面的业务逻辑出了问题，就用下面的catch去处理对应的问题\n}catch(fileOpenFailed){\n    doSomething;\n}catch(sizeDeterminationFailed){\n    doSomething;\n}catch(memoryAllocationFailed ){\n    doSomething;\n}catch(readFailed ){\n    doSomething;\n}catch(fileCloseFailed ){\n    doSomething;\n}\n```\n异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码  \n\n## 异常的抛出和声明\n在Java中可以自定义异常。  \n1、所有异常都必须是 Throwable 的子类。  \n2、如果希望写一个检查性异常类，则需要继承 Exception 类。  \n3、如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。  \nRuntimeException继承自Exception  \n\n```java 声明一个异常类型\nclass MyException extends Exception{\n}\n```\n```java 声明一个可能会抛出异常的方法\npublic void f() throws MyException{\n    throw new MyException();//抛出一个MyException异常\n}\n```\n所有调用这个方法的地方都必须套上try-catch，来处理可能发生的异常  \n```java\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"error\");\n    }\n}\n```\n\n可以声明并不会真的抛出的异常,但调用该方法的地方必须处理全部可能抛出的异常  \n```java\npublic void f() throws MyException,YouException{\n    throw new MyException();//抛出一个MyException异常\n}\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"MyError\");\n    }catch(YouException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"YouError\");\n    }\n}\n```\n\n任何继承了Throwable类的对象都可以被throw  \nException类继承了Throwable，我们通常让自定义的异常类从Exception类得到继承  \n\n```java Exception类的两种构造\n//我们在自定义异常类时也通常会有这两种构造\nthrow new Exception();  \nthrow new Exception(\"HELP\");//可以用这个字符串来表达一些东西  \n```\n\n## catch的匹配机制\n抛出子类的异常会被捕捉父类异常的catch给捉到  \n```java\n//声明两个异常类，YouException继承自MyException\nclass MyException extends Exception{}\nclass YouException extends MyException{}\n\npublic class Test{\n\n    public static void f() throws MyException, YouException {\n        throw new YouException();//抛出一个YouException异常\n    }\n\n    public static void main(String[] args) {\n        try{\n            throw new YouException();\n        }catch(MyException e){//MyException匹配到了它的子类YouException\n            System.out.println(\"YouException\");\n        }\n    }\n}\n```\n如果同时捕捉父类子类两个异常，子类catch要写在父类前面，否则会报错  \n```java\ntry{\n    throw new YouException();\n}catch(YouException e){\n    System.out.println(\"YouException\");\n}catch(MyException e){\n    System.out.println(\"YouException\");\n}\n```\n\n捕捉任何异常\n```java\ncatch(Exception e){\n}\n```\n\n### 运行时刻异常\n像ArrayIndexOutOfBoundsException这样java本身提供的异常是不需要声明的，如果需要去声明这些异常，那么每个方法都将带上一长串的声明    \n但是如果没有适当的机制来捕捉，就会最终导致程序终止  \n\n## 异常遇到继承\n当覆盖一个方法的时候，子类不能声明抛出比父类的版本更多的异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public static void f() throws MyException {}\n    public static void main(String[] args) {}\n}\nclass NewClass extends Test{\n    //NewClass'中的f()'与' Test'中的'f()'冲突；重写的方法未抛出NewException'\n    public void f() throws NewException {}\n    //正确的\n    public void f() throws YouException {}\n    public void f() throws MyException {} \n    public void f() {} \n}\n```\n\n在子类的构造方法中，必须声明父类可能抛出的全部异常，可以抛出更多异常,可以是父类抛出异常的父类异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public Test() throws YouException{}\n    public static void main(String[] args) {}\n}\n\nclass NewClass extends Test {\n    //允许\n    public NewClass() throws YouException{}\n    public NewClass() throws MyException{}\n    public NewClass() throws MyException,NewException{}\n    //不允许\n    public NewClass(){}\n    public NewClass() throws NewException{}\n}\n```\n\n***\n\n# Stream流\n任何程序都有输入输出，会向用户那读点东西，也会向用户那输出点东西  \n所以，任何一个编程语言都给程序员提供了输入输出的方式，让这个程序可以和外界打交道  \n\n对于java语言，以及之后的新语言，处理输入输出的手段叫做**流**  \n\n流是一个抽象、动态的概念，是一连串连续动态的数据集合。  \n流给数据源和程序之间提供了数据信息传输的通道，编程语言提供了多种流用于数据传输  \n\n## Hallo World\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n这个程序就用到了输出流，把Hallo World输出给用户看  \n**System**是一个类，**out**是这个类的一个静态成员，**println**是这个成员能做的事情  \n实际上，**out**这个成员就是用于做输出的流  \n\n## 流的基础\n在java的基础类库中，所有的输出都基于**OutputStream**类，所有的输入都基于**InputStream**类，这两个类构成了输入和输出的基础  \n\n但这两个类是抽象的，具体使用时应该用它们的子类  \n在这里可以看到java系统类库中所有的包[Java®平台、标准版和Java开发工具包第18版API规范](https://docs.oracle.com/en/java/javase/18/docs/api/index.html)  \n在其中的java.base中有[java.io](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)，这里面有java输入输出所有相关的东西  \n在里面可以找到**InputStream**和**OutputStream**类，当然这里面还有很多的类，以及其它的东西  \n\n点击InputStream，可以看到这个类的描述，以及它所有的方法  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-19.webp width=\"100%\" height=\"100%\"></div>\n\n**InputStream**把外界的输入当做**字节**的流来看待，**OutputStream**也同理，当我们使用这两个类，只能做字节层面上的读和写  \n\n尝试一下：  \n```java\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        byte[] buffer = new byte[1024];//一个1k字节的butter\n        int len = 0;//让系统读取输入流，并将读取到的内容存储到buffer中，返回读取到的字节数\n        try {//所有io的操作都存在风险，所以要捕获异常\n            len = System.in.read(buffer);\n            String s = new String(buffer, 0, len);//将buffer中从0开始到len的这么多个字节构造一个字符串\n            System.out.println(\"读到了：\"+len+\"字节\");//输出读取到的字节数\n            System.out.println(s);//输出字符串\n            System.out.println(\"s的长度：\"+s.length());//输出字符串有多少个字符\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nHello World!\n输入:123abc\n读到了：7字节\n123abc\n\ns的长度：7\n\n```\n123abc是6个字节，但后面还有个回车，所以读到7个字节，且输出s时，把回车也输出了  \n\n换个输入：\n```java 输出\nHello World!\n输入：123汉字abc\n读到了：13字节\n123汉字abc\n\ns的长度：9\n\n```\n在UTF-8编码中,一个中文字符等于三个字节，所以一共读到13个字节  \n\n## 文件流\n**System.in**和**System.in**是标准输入和标准输出的流  \n如果想要直接写文件，就需要使用到**文件流**：**FileInputStream**、**FileOutputStream**  \n\n实际工程中已经较少直接对文件进行读写（除了在造轮子）  \n更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信  \n具体的文件读写往往有更专业的类，比如配置文件和日志文件  \n\n尝试一下**FileOutputStream**：  \n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            FileOutputStream out = new FileOutputStream(\"a.dat\");//如果文件不存在，则创建，存在则覆盖\n            out.write(buf);//将buf中的数据写入文件\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n用**Hexdump**打开这个16进制文件  \n```\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: 00 01 02 03 04 05 06 07 08 09                      ..........\n\n```\n1到9都已经被写入  \n\n## 流过滤器\n无论是System.in和out还是文件流，都只能处理单个字节，一个个字节地读，一个个字节地写  \n如果要把一个10进制地整数写入到一个文件中，就要同时读写4个字节，显然前面介绍的流无法做到  \n\n**流过滤器**可以在已存在的流的基础上，去增加一层层的过滤器，每一层的过滤器都可以做点事情，其中一些过滤器就可以做int、double这些基础类型数据的读和写  \n\n尝试一下：  \n```java\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            DataOutputStream out = new DataOutputStream(\n                    new BufferedOutputStream(//缓冲输出流\n                            new FileOutputStream(\"a.dat\")));\n            //打开这个文件之后，在上面接了一个缓冲流，缓冲流外面还有一个流，最终得到的是一个DataOutputStream的对象\n            //我们可以往DataOutputStream这个流里面写入数据，数据会被缓冲到缓冲流里面，缓冲流里面的数据会被写入到文件里面\n            int i = 0xcafebabe;\n            out.writeInt(i);//写入一个int类型的数据,DataOutputStream流的writeInt方法可以写入一个int类型的数据\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: CA FE BA BE                                        J~:>\n```\n0xcafebabe这个16进制数已经被写入  \n```java 输出\nHello World!\n-889275714\n```\n0xcafebabe这个16进制的数对应的10进制数是-889275714  \n\n每一层过滤器都可以起到一定的作用，在上面的程序中，BufferedOutputStream起到了缓冲垫作用，DataOutputStream起到了读写基本数据类型的作用  \n\n## 文本的输入和输出\n加上了DataOutputStream也只能以二进制处理基本数据类型，如何处理文本？  \n\n二进制数据采用InputStream/OutputStream  \n文本数据采用Reader/Writer  \n\n但Reader/Writer本身是处理Unicode编码的字符的，如果文件是Unicode编码，可以直接用Reader/Writer处理文件，但一般情况下，文件本身并不是Unicode编码，它可能是GBK，可能是UTF-8  \n在这种情况下，我们需要借助Stream，用字节形式打开文件，再在Stream流的基础上，用过滤器的方式去建立Reader/Writer ，来做文本的输入和输出，**StreamReader**可以将字节流转换为字符流，然后交给Reader/Writer，当然中间可以加上Buffered实现缓冲  \n\n尝试一下：  \n```java\nimport java.io.*;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            PrintWriter out = new PrintWriter(//创建一个输出流,PrintWriter可以通过连接BufferedWriter实现的缓冲功能\n                    new BufferedWriter(//创建一个缓冲流\n                            new OutputStreamWriter(//将字节流转换为字符流\n                                new FileOutputStream(\"a.txt\"))));//创建一个文件输出流\n            //我们做了一个文件流，但它只能处理字节\n            // 在此基础上再做一个桥梁：OutputStreamWriter\n            // 它构建起了Stream和Writer的桥梁，它的输入是OutputStream，输出是Writer\n            int i = 123456;\n            out.println(i);//在PrintWriter的基础上，我们可以用println方法来输出数据\n            out.close();\n            //和上面输出一样，如果要读取一个文件，我们需要做一个桥梁：InputStreamReader\n            //它构建起了Stream和Reader的桥梁，它的输入是InputStream，输出是Reader\n            BufferedReader in = new BufferedReader(// BufferedReader类从字符输入流中读取文本并缓冲字符\n                    new InputStreamReader(//将字节流转换为字符流\n                        new FileInputStream(\"src/test.java\")));//创建一个文件输入流，打开这个程序的源码文件\n            //readLine()方法从字符输入流中读取一行，并返回该行。\n            String line;\n            while ((line = in.readLine()) != null){//当读取到的行不为空时，执行循环，就可以读取整个文件\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n运行：在a.tet文件中有123456字符,控制台也将这整个源码输出了出来  \n\n除了BufferedReader，还有LineNumberReader，里面的getLineNumber()可以读取指定的行  \n\n**FileReader**是InputStreamReader类的子类，所有方法都从父类中继承而来，它可以直接读取一个二进制文件，建立起一个流，然后形成一个Reader    \nFileReader(File file)在给定从中读取数据的Fe的情况下创建一个新FileReader  \nFileReader(String fileName)在给定从中读取数据的文件名的情况下创建一个新FileReader  \nFileReader不能指定编码转换方式  \n\n## 汉字编码问题\nFileOutputStream(\"a.txt\")可以以二进制形式打开一个文件  \nOutputStreamWriter(FileOutputStream(\"a.txt\"))将字节流转换为字符流,如果不指定编码，那么它优先使用程序源码文件的编码去转换这个字节流为字符流，这就很容易导致汉字乱码  \n\n我们可以指定编码进行转换OutputStreamWriter(FileOutputStream(\"a.txt\"),\"utf8\")  \n用utf8去将这个字节流转换成字符流 \n\n当然还有其它方法，这里不展开讲\n\n## 格式化输入输出\n格式化输出：使用printf(\"格式\", );用法和C语言的基本一样，这里不展开讲，博主同样有篇C语言学习笔记  \n\n格式化输入：如果想从一个文本中读取出一些数字，可以在流上构建一个Scanner，然后用next系列的方法去读取数字、单词等等  \n\n## Stream/Reader/Scanner的选择\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-20.webp width=\"92%\" height=\"92%\"></div>\n\n## 流的应用\n现在已经很少有程序需要用流的方式去打开一个文件，裸地去进行文件读和写的操作，更多地是从某个地方得到了一个流  \n\n### 服务器通信\n下面这个程序将从本地服务器得到一个流，并向这个流写入东西  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n当然，直接运行这个程序一定报错，因为本地没有任何服务器程序在12345端口上听着，连接建立不起来  \n\n使用netcat可以实现监听  \n从[netcat](https://eternallybored.org/misc/netcat/)下载netcat1.12  \n解压后把nc.exe移动到C:\\Windows\\System32目录，压缩包内其它东西用不上  \n然后打开cmd，运行nc -l -p -12345\n\n现在再运行程序，cmd窗口就会输出Hello, world!  \n\n还可以接收服务端的数据  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.flush();//刷新缓冲区，将缓冲区中的数据立即发送出去\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(\n                            //getInputStream()方法获取Socket对象的输入流，并构造一个BufferedReader对象\n                            socket.getInputStream()));//创建一个BufferedReader对象，用于接收服务器端的信息\n            String line = in.readLine();//读取服务器端的一行文本\n            System.out.println(line);//输出读取的文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在cmd窗口输入任意文本，idea的控制台也会输出这个文本  \n\n### 对象串行化\n写入和读取一个对象，使用ObjectOutputStream和ObjectInputStream，被读写的类要实现Serializable接口  \n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.Serializable;\nimport java.io.*;\n\nclass Student implements Serializable {//可以串行化的类\n    private String name;\n    private int age;\n    private int grade;\n\n    public Student(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n\n    public String toString() {\n        return \"Student: \" + name + \" \" + age+ \" \" + grade;\n    }\n}\n\npublic class chh {\n    public static void main(String[] args) {\n        try {\n            Student s1 = new Student(\"zhangsan\", 20, 1);\n            ObjectOutputStream out = new ObjectOutputStream(\n                    new FileOutputStream(\"obj.dat\"));\n            out.writeObject(s1);\n            out.close();\n            ObjectInputStream in = new ObjectInputStream(\n                    new FileInputStream(\"obj.dat\"));\n            Student s2 = (Student) in.readObject();\n            System.out.println(s2);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java obj.bat\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: AC ED 00 05 73 72 00 07 53 74 75 64 65 6E 74 98    ,m..sr..Student.\n00000010: 61 28 66 C5 BE 55 BC 02 00 03 49 00 03 61 67 65    a(fE>U<...I..age\n00000020: 49 00 05 67 72 61 64 65 4C 00 04 6E 61 6D 65 74    I..gradeL..namet\n00000030: 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72    ..Ljava/lang/Str\n00000040: 69 6E 67 3B 78 70 00 00 00 14 00 00 00 01 74 00    ing;xp........t.\n00000050: 08 7A 68 61 6E 67 73 61 6E                         .zhangsan\n\n```\n```java 输出\nStudent: zhangsan 20 1\n```\n\n***\n\n>完结撒花！\n>javase的学习暂且告一段落，但学习的步伐永不停歇\n>翁恺老师讲的课循序渐进，简洁明了，好评，但课程上只学到流，刚步入javase的高级部分\n>后面还有一个重要部分：线程\n>过段时间实操一个java的管理系统（万物起源管理系统），暂且咕咕咕吧\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"给Butterfly加上顶部加载条","url":"/article/13d6481a.html","content":"\n>效果已在本站实装，切换页面顶部有加载进度条\n>参考文章[为Hexo博客添加顶部加载条](https://cloud.tencent.com/developer/article/1960734)\n\n# 旧版顶部长条\n\n## 引入css\n```css\n.pace {\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n.pace-inactive {\n  display: none;\n}\n\n.pace .pace-progress {\n  background: #e90f92;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n\n.pace .pace-progress-inner {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;\n  opacity: 1.0;\n  -webkit-transform: rotate(3deg) translate(0px, -4px);\n  -moz-transform: rotate(3deg) translate(0px, -4px);\n  -ms-transform: rotate(3deg) translate(0px, -4px);\n  -o-transform: rotate(3deg) translate(0px, -4px);\n  transform: rotate(3deg) translate(0px, -4px);\n}\n\n.pace .pace-activity {\n  display: block;\n  position: fixed;\n  z-index: 2000;\n  top: 15px;\n  right: 15px;\n  width: 14px;\n  height: 14px;\n  border: solid 2px transparent;\n  border-top-color: #e90f92;\n  border-left-color: #e90f92;\n  border-radius: 10px;\n  -webkit-animation: pace-spinner 400ms linear infinite;\n  -moz-animation: pace-spinner 400ms linear infinite;\n  -ms-animation: pace-spinner 400ms linear infinite;\n  -o-animation: pace-spinner 400ms linear infinite;\n  animation: pace-spinner 400ms linear infinite;\n}\n\n@-webkit-keyframes pace-spinner {\n  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-moz-keyframes pace-spinner {\n  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-o-keyframes pace-spinner {\n  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-ms-keyframes pace-spinner {\n  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@keyframes pace-spinner {\n  0% { transform: rotate(0deg); transform: rotate(0deg); }\n  100% { transform: rotate(360deg); transform: rotate(360deg); }\n}\n/* 在下面修改进度条外观 */\n.pace .pace-progress {\n  background: #1ef4fbec; /*进度条颜色*/\n  height: 3px;/* 进度条厚度 */\n}\n.pace .pace-progress-inner {\n  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/\n}\n.pace .pace-activity {\n  border-top-color: #1edafbe5;\t/*上边框颜色*/\n  border-left-color: #1ef4fbec;\t/*左边框颜色*/\n}\n```\n\n## 引入js\n\n```js\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n```\n\n**然后三连即可**\n\n***\n\n# 新版胶囊\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/10-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;看这个文章即可，虽然实现过程不太一样，但效果差不多：[为你的Butterfly添加顶部加载进度条](https://xlenco.eu.org/posts/769f.html)\n\n***\n\n\n\n","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"基于UptimeRobot的监控面板","url":"/article/8f1fedc5.html","content":"\n>演示：[轻笑的网站监控面板](https://status.chuckle.top/)\n\n# 注册UptimeRobot\n\n填写邮箱以完成注册  \n>[跳转至注册](https://uptimerobot.com/signUp?ref=website-header)\n\n\n# 新建监视器\n点击左上角Add New Monitor  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-1.webp width=\"70%\" height=\"70%\"></div>\n\n在弹出窗口填写需要需要监控的站点的相关信息  \n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-2.webp width=\"70%\" height=\"70%\"></div>\n\n点击Create Monitor完成创建   \n\n\n# 创建API密钥\n\n点击My Settings\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-3.webp width=\"70%\" height=\"70%\"></div>\n为监视器创建一个api密钥（也可选择第三个，为所有监视器创建一个密钥）  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-4.webp width=\"70%\" height=\"70%\"></div>\n\n# fork监控面板仓库\n选择其中一个fork  \n[yb/uptime-status](https://github.com/yb/uptime-status)  \n[Ice-Hazymoon/status](https://github.com/Ice-Hazymoon/status)  \n\n# 修改config.js\n\n进入刚fork的仓库，打开/public/config.js  \n添加监视器的api密钥  \n>需要监控的站点较多，也可为所有监控器创建一个api密钥填入\n\n```\n ApiKeys: [\n    '在这里粘贴api密钥',\n  ],\n```\n>还可以选择在ApiDomain修改自定义反代域名，详见https://github.com/yb/uptime-status/\n\n# vercel部署\n\n新建一个项目  \nimport监控面板仓库  \n等待几分钟创建完成，点击vist，一个监控面板就完成了  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-5.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/9-6.webp width=\"70%\" height=\"70%\"></div>\n\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(2)","url":"/article/9f2dc6c7.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(1)](/article/bfb663c6.html)\n\n# 城堡游戏（可扩展性）\n整体思路：用Room先初始化5个房间，Room类中有房间名称、四个方向所连接的房间，currentRoom = outside;设置出生点  \n进入goRoom方法，匹配用户输入的方向，让nextroom指向下一个房间，然后让currentRoom = outside;并输出房间信息。  \n大致以此循环  \n \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    public String description;\n    //房间四个方向连接的房间\n    public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = null;//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n```java 输出\n欢迎来到城堡!\n这是一个超级无聊的游戏。\n如果需要帮助，请输入'help'\n\n你在城堡外\n出口有：\neast\nsouth\nwest\n\ngo south\n你在书房\n出口有：\nnorth\neast\n\ngo east\n你在卧室\n出口有：\nwest\n\nhelp\n迷路了吗？你可以做的命令有：go bye help\n如：\tgo east\nbye\n感谢您的光临。再见！\n```\n\n## 消除代码复制\n在printWelcome和goRoom方法中都有一段相同的输出出口方向的代码  \n将这段代码提取出来，做成一个方法，在需要输出房间信息的地方调用即可  \n```java\npublic void showPrompt()\n{\n    // 输出当前房间的描述\n    System.out.println(\"你在\"+ currentRoom);\n    System.out.println(\"出口有：\");\n    if(currentRoom.northExit != null)\n        System.out.println(\"north\");\n    if(currentRoom.eastExit != null)\n        System.out.println(\"east\");\n    if(currentRoom.southExit != null)\n        System.out.println(\"south\");\n    if(currentRoom.westExit != null)\n        System.out.println(\"west\");\n    System.out.println();\n}\n\n```\n\n## 封装\n这个程序没有bug，能正常运行，但不见得是一个好的代码  \n评价一个代码质量的好坏是多元的，尤其是这个代码是否能适应将来的需要  \n\n**可扩展性**：代码是否易于将来增加新的东西\n\n我们想在这个游戏里给每个房间增加两个方向down和up  \n我们需要改的地方很多  \nRoom.java里需要增加两个房间对象public Room downExit;和public Room upExit; setExits方法需要增加两个参数并进行判断  \nGame.java里很多方法也要增加if判断，还要改每个房间的初始化  \n\n总之，想增加一个方向，代码几乎每个地方都要改变  \n\n要想增加可扩展性，首先要降低类和类之间的耦合  \n\n### 用封装来降低耦合\nRoom类和Game类都有大量的代码和出口相关  \n尤其是Game类中大量使用了Room类的成员变量  \n类和类之间的关系称作**耦合**  \n耦合**越低越好**，保持距离是形成良好代码的关键  \n\n我们可以让Room自己告诉Game有哪些出口，出口连接的房间  \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    private String description;\n    //public String description;\n    //房间四个方向连接的房间\n    private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;\n    /*public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;*/\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        /*String returnString = \"Exits:\";\n        if (northExit != null)\n            returnString += \"north \";\n        if (eastExit != null)\n            returnString += \"east \";\n        if (southExit != null)\n            returnString += \"south \";\n        if (westExit != null)\n            returnString += \"west \";\n        return returnString;*/\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n        /*System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();*/\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        /*if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }*/\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n            /*System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();*/\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n        /*System.out.println(\"出口有：\");\n        if(currentRoom.northExit != null)\n            System.out.println(\"north\");\n        if(currentRoom.eastExit != null)\n            System.out.println(\"east\");\n        if(currentRoom.southExit != null)\n            System.out.println(\"south\");\n        if(currentRoom.westExit != null)\n            System.out.println(\"west\");\n        System.out.println();*/\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n\n### 用接口来实现聚合\n原本Room有什么出口，连接着什么房间，Game是能直接获取使用的  \n现在我们在Room中实现了两个接口getExitDesc和getExit,把方向的细节彻底隐藏在Room类内部  \n今后方向如何实现就和外部无关了  \n\n### 用容器来实现灵活性\n在Room当中，有四个Room对象，用于保存这个房间连接着的四个房间（null，或者房间名）  \n这种一一对应的关系，可以使用HashMap去实现  \n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n    /*private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;*/\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    /*public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }*/\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        /*if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");*/\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n        /*if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;*/\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        /*outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);*/\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n//现在当我们想增加出口方向，很简单  \nlobby.setExits(\"up\", pub);  \npub.setExits(\"down\", lobby);  \n\n这里发生了什么？  \n将lobby的出口方向和对应房间传给它的setExits的方法后  \nlobby里面的容器就会多一对出口和房间的对应关系  \nlobby里面的getExitDesc、getExit方法以及未来可能加入的新方法，都遍历这个容器  \n所以，增加出口和连接的房间，只需要调用setExits方法，去往lobby里的容器写入东西即可  \n\n现在，对于增加出口来说，已经具有了可扩展性\n\n### 以框架+数据来提高可扩展性\n我们原来用硬编码去保存room的出口  \n现在我们用容器，HashMap和对应的方法（接口方法）组成了一个框架，数据就是放在HashMap里的东西  \n在这个框架中要增加出口很容易  \n\n启发：  \n命令的解析是否可以脱离if-else  \n定义一个Handler来处理命令  \n用Hash表来保存命令和Handler之间的关系  \n\n现在我们可以用相同的思路去解决用户命令（help，go，bye）的硬编码问题  \n一个字符串对应调用一个方法，这显然也是一一对应的关系  \n但容器**只能放对象**，一个方法不能放进容器中  \n\n### 如何把方法放进容器中\n创建一个Handler类，然后把每个命令创建为Handler的子类  \n将命令字符串和Handler子类的对象一一对应放入HashMap中  \n将功能在Handler的子类的doCmd方法中实现  \n在game中通过父类对象管理者去管理子类对象（从HashMap中获取子类对象），管理者调用doCmd方法即可  \n\n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n    //创建一个HashMap对象，用于保存所有的命令处理器\n    private HashMap<String, Handler> handlers = new HashMap<String, Handler>();\n\n    public Game()//构造函数\n    {\n        //将字符串和命令处理器对应\n        handlers.put(\"go\",new HandlerGo(this));//把game对象作为参数传入HandlerGo类，让HandlerGo能管理game\n        handlers.put(\"help\",new HandlerHelp(this));\n        handlers.put(\"bye\",new HandlerBye(this));\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    /*private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }*/\n\n    public void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public void play(){//游戏开始\n        Scanner in = new Scanner(System.in);\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            Handler handler = handlers.get(words[0]);//获取用户输入的命令,从HashMap中获取对应的子类对象,让handler管理这个对象\n            String value = \"\";//保存命令的字符串\n            if(words.length > 1)//判断是不是bye命令\n            {\n                value = words[1];//获取参数\n            }\n            if(handler != null){//如果命令存在\n                handler.doCmd(value);//调用命令处理器\n                if ( handler.isBye() ) {//如果命令处理器返回true，则退出游戏\n                    System.out.println(\"感谢您的光临。再见！\");\n                    break;\n                }\n            }\n        }\n        in.close();//关闭Scanner\n    }\n\n    public static void main(String[] args) {\n        /*Scanner in = new Scanner(System.in);*/\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n        game.play();\n        /*while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }*/\n        //System.out.println(\"感谢您的光临。再见！\");\n        //in.close();//关闭Scanner\n    }\n}\n```\n```java Handler.java\npackage castle;\n\npublic class Handler {\n    protected Game game;//创建一个Game对象的管理者，为了方便设为protected\n    public Handler(Game game) {\n        this.game = game;//两个game管理者管理同一个Game对象\n    }\n\n    public void doCmd(String word) {}//一个接口，用于运行命令\n    public boolean isBye() { return false; }\n}\n```\n```java HandlerBye.java\npackage castle;\n\npublic class HandlerBye  extends Handler {\n    //必要的构造器\n    public HandlerBye(Game game) {\n        super(game);\n    }\n    @Override\n    public boolean isBye() {\n        return true;\n    }\n}\n```\n```java HandlerHelp.java\npackage castle;\n\npublic class HandlerHelp extends Handler {\n    //必要的构造器\n    public HandlerHelp(Game game) {\n        super(game);\n    }\n    @Override\n    public void doCmd(String word) {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n}\n```\n```java HandlerGo.java\npackage castle;\n\npublic class HandlerGo extends Handler {\n    public HandlerGo(Game game) {\n        super(game);//现在HandlerGo能管理game对象了\n    }\n    //help和bye都与game无关，但go需要调用goRoom方法，所以需要拿到game对象的管理者\n    public void doCmd(String word) {\n        game.goRoom(word);//调用game的goRoom方法\n    }\n\n}\n```\n>HandlerGo在未来有更好的方法去实现，现在还是用管理者吧\n\n如果要加入新的命令，也非常简单  \n创建一个新的Handler子类，在里面实现命令的功能  \n在Game的构造器中将命令字符串和Handler的子类对象放进去  \n\n现在这个城堡游戏已经有极高的可扩展性了  \n>这个城堡游戏例子非常全面，偶尔回来看看这个例子，是个不错的选择\n\n***\n\n# 抽象abstract\n关键字：**abstract**\n```java\npublic abstract class Shape {//抽象类\n    public abstract void draw(Graphics g);//抽象方法不带{}，即不带方法体\n}\n```\n抽象方法：表达概念，但无法实现具体功能（代码）的方法  \n抽象类：表达概念而无法构造出实体（对象）的类  \n\n有抽象方法的类**一定**是抽象类  \n抽象类不能**制造**对象，但是可以**定义**类变量（任何继承了抽象类的非抽象类的对象可以使用赋给这个类变量，即任何抽象类的子类的对象都可以由这个类变量来管理）  \n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  \n\n继承自抽象类的子类必须覆盖父类中的抽象方法，否则自己成为抽象类（即子类必须实现抽象父类的抽象方法）\n\n## 两种抽象\n与具体相对  \n·表示一种概念而非实体  \n与细节相对  \n·表示在一定程度上忽略细节而着眼大局  \n\n*** \n\n# 细胞自动机\n\n死亡：如果活着的邻居的数量小于2或大于3，则死亡  \n新生：如果正好有3个邻居活着，则新生其他情况则保持原状  \n\n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n \npublic class Cell {\n\tprivate boolean alive = false;//默认为死亡状态\n\t\n\tpublic void die() { alive = false; }//让细胞死亡\n\tpublic void reborn() { alive = true; }//让细胞重生\n\tpublic boolean isAlive() { return alive; }//返回细胞状态,判断细胞是否存活\n\t//绘制细胞\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tg.drawRect(x, y, size, size);//画个空心矩形\n\t\tif ( alive ) {//如果细胞存活\n\t\t\tg.fillRect(x, y, size, size);//画个实心矩形\n\t\t}\n\t}\n}\n\n```\n\n```java CellMachine.java\npackage cellmachine;\n\nimport javax.swing.JFrame;\n\nimport cell.Cell;\nimport field.Field;\nimport field.View;\n\npublic class CellMachine {\n\n\tpublic static void main(String[] args) {\n\t\t//数据准备阶段,画出一个细胞网格\n\t\tField field = new Field(30,30);//一个30*30的网格\n\t\t//遍历网格，每个网格都有一个细胞\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tfield.place(row, col, new Cell());//每个细胞都有一个状态，初始状态为死亡\n\t\t\t}\n\t\t}\n\n\t\t//遍历每个细胞，设置初始细胞的生存状态\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t//利用随机数让整个网格的五分之一的细胞生存\n\t\t\t\tif ( Math.random() < 0.2 ) { //Math.random()返回0~1之间的随机数\n\t\t\t\t\tcell.reborn();//reborn()方法设置细胞的生存状态为true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //在窗口中显示细胞网格\n\t\tView view = new View(field);//将网格传入View类中\n\t\tJFrame frame = new JFrame();//创建一个JFrame对象,是java当中的窗口,用来显示细胞网格\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭时的操作\n\t\tframe.setResizable(false);//设置窗口不可改变大小\n\t\tframe.setTitle(\"Cells\");//设置窗口的标题\n\t\tframe.add(view);//将网格添加到窗口中\n\t\tframe.pack();//设置窗口的大小\n\t\tframe.setVisible(true);//设置窗口可见,即显示出来\n\n\t\t//模拟细胞网格的运行\n\t\t//遍历整个网格,取出每个细胞\n\t\tfor ( int i=0; i<1000; i++ ) {//进行1000次模拟\n\t\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t\tCell[] neighbour = field.getNeighbour(row, col);//获取(row,col)位置上的细胞的邻居\n\t\t\t\t\tint numOfLive = 0;//计数器，记录邻居中活细胞的个数\n\t\t\t\t\t//遍历邻居，计算邻居中有多少个细胞是活的\n\t\t\t\t\tfor ( Cell c : neighbour ) {\n\t\t\t\t\t\tif ( c.isAlive() ) {//如果邻居中有一个细胞是活的\n\t\t\t\t\t\t\tnumOfLive++;//让计数器加一\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//控制台输出当前细胞的状态\n\t\t\t\t\tSystem.out.print(\"[\"+row+\"][\"+col+\"]:\");//打印细胞的位置\n\t\t\t\t\tSystem.out.print(cell.isAlive()?\"live\":\"dead\");//打印细胞的状态\n\t\t\t\t\tSystem.out.print(\":\"+numOfLive+\"-->\");//打印细胞的邻居中有多少个细胞是活的\n\t\t\t\t\t//写入下一次的细胞状态\n\t\t\t\t\tif ( cell.isAlive() ) {//如果当前细胞是活的\n\t\t\t\t\t\tif ( numOfLive <2 || numOfLive >3 ) {//判断是否满足让细胞死的条件条件\n\t\t\t\t\t\t\tcell.die();//让细胞死\n\t\t\t\t\t\t\tSystem.out.print(\"die\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( numOfLive == 3 ) {//如果当前细胞是死的，判断是否满足让细胞活的条件条件\n\t\t\t\t\t\tcell.reborn();//让细胞活\n\t\t\t\t\t\tSystem.out.print(\"reborn\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"UPDATE\");\n\t\t\tframe.repaint();//整个Field都更新好后，画出棋盘\n\t\t\t//延时\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Field {\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;//一个二维数组field，存放每个格子（细胞）\n\t//构造器，初始化棋盘\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\tpublic int getWidth() { return width; }\n\tpublic int getHeight() { return height; }\n\t//添加细胞\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\t//获取某个格子\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\t//获取周围细胞\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor ( int i=-1; i<2; i++ ) {\n\t\t\tfor ( int j=-1; j<2; j++ ) {\n\t\t\t\tint r = row+i;\n\t\t\t\tint c = col+j;\n\t\t\t\tif ( r >-1 && r<height && c>-1 && c<width && !(r== row && c == col) ) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        //toArray会自动把一个Cell[]数组装好，让返回这个数组\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\t//清空所有格子\n\tpublic void clear() {\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfor ( int j=0; j<width; j++ ) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -5258995676212660595L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\n\t//构造器\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t//每次当窗口被重绘时调用，被调用时会得到一个Graphics对象，即当前要画的对象\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);//调用父类的paint方法\n\t\t//绘制网格\n\t\tfor ( int row = 0; row<theField.getHeight(); row++ ) {//行\n\t\t\tfor ( int col = 0; col<theField.getWidth(); col++ ) {//列\n\t\t\t\tCell cell = theField.get(row, col);//得到每个格子的对象\n\t\t\t\tif ( cell != null ) {//如果该格子有对象\n\t\t\t\t\tcell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);//绘制该格子\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth()*GRID_SIZE+1, theField.getHeight()*GRID_SIZE+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tField field = new Field(10,10);\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {\n\t\t\t\tfield.place(row, col, new Cell());\n\t\t\t}\n\t\t}\n\t\tView view = new View(field);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(view);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n}\n\n```\n\n## Cell、Field、View的关系\nField只需要管好数据以及提供数据  \nView只管拿到数据之后按数据把整个网格都重新画一遍  \n而Cell只管自己应该画空心还是实心，Field要就提供给它  \n\n不去精心设计哪个局部需要更新，需要更新就整个重画   \n这样简化了程序逻辑，是在计算机运算速度提高的基础上实现的  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-8.webp width=\"80%\" height=\"80%\"></div>\n\n## 数据与表现分离\n程序的业务逻辑与表现无关  \n-表现可以是图形的也可以是文本的  \n-表现可以是当地的也可以是远程的  \n\n需要不同表现，那就用不同表现的代码去取数据，然后表现出来  \n\n## 责任驱动的设计\n将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环  \n\n将功能拆分成很多个部分，每个部分只做自己擅长做的、简单的事  \n\n## 网格化\n图形界面本身有更高的解析度，但是将画面网格化以后，数据就更容易处理了  \n\n无需关心x、y轴坐标，只需知道要操作的对象在第几行第几列\n\n***\n\n# 狐狸和兔子\n细胞自动机是细胞在一个网格上，每个细胞都有两种状态  \n\n现在要模拟一个有狐狸和兔子的农场：   \n·狐狸和兔子都有年龄，且有规律增加  \n·当年龄到了一定的上限就会自然死亡  \n·狐狸可以随机决定在周围的兔子中吃一个，吃了后年龄上限会提高  \n·狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里  \n·如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步  \n\n这比只有细胞，细胞只有两种状态要复杂得多  \n\n## 源码\n这个没注释，原理和细胞自动机差不多  \n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\n\n```java Animal.java\npackage animal;\n\nimport java.util.ArrayList;\nimport field.Location;\n\npublic abstract class Animal {\n\n\tprivate int ageLimit;\n\tprivate int breedableAge;\n\tprivate int age;\n\tprivate boolean isAlive = true;\n\n\tpublic Animal(int ageLimit, int breedableAge) {\n\t\tthis.ageLimit = ageLimit;\n\t\tthis.breedableAge = breedableAge;\n\t}\n\n\tprotected int getAge() {\n\t\treturn age;\n\t}\n\n\tprotected double getAgePercent() {\n\t\treturn (double) age / ageLimit;\n\t}\n\n\tpublic abstract Animal breed();\n\n\tpublic void grow() {\n\t\tage++;\n\t\tif (age >= ageLimit) {\n\t\t\tdie();\n\t\t}\n\t}\n\n\tpublic void die() {\n\t\tisAlive = false;\n\t}\n\n\tpublic boolean isAlive() {\n\t\treturn isAlive;\n\t}\n\n\tpublic boolean isBreedable() {\n\t\treturn age >= breedableAge;\n\t}\n\n\tpublic Location move(Location[] freeAdj) {\n\t\tLocation ret = null;\n\t\tif (freeAdj.length > 0 && Math.random() < 0.02) {\n\t\t\tret = freeAdj[(int) (Math.random() * freeAdj.length)];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\" + age + \":\" + (isAlive ? \"live\" : \"dead\");\n\t}\n\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\treturn null;\n\t}\n\n\tprotected void longerLife(int inc) {\n\t\tageLimit += inc;\n\t}\n}\n\n```\n\n```java Fox.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Fox extends Animal implements Cell {\n\n\tpublic Fox() {\n\t\tsuper(20, 4);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));// (int)((20-getAge())/20.0*255)));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.05) {\n\t\t\tret = new Fox();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Fox:\" + super.toString();\n\t}\n\n\t@Override\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\tAnimal ret = null;\n\t\tif (Math.random() < 0.2) {\n\t\t\tret = neighbour.get((int) (Math.random() * neighbour.size()));\n\t\t\tlongerLife(2);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n```\n\n```java Rabbit.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport cell.Cell;\n\npublic class Rabbit extends Animal implements Cell {\n\n\tpublic Rabbit() {\n\t\tsuper(10, 2);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(255, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.12) {\n\t\t\tret = new Rabbit();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Rabbit:\" + super.toString();\n\t}\n}\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\nimport cell.Cell;\n\npublic class Field {\n\n\tprivate static final Location[] adjacent = {\n\t\t\tnew Location(-1, -1), new Location(-1, 0), new Location(-1, 1),\n\t\t\tnew Location(0, -1), new Location(0, 0), new Location(0, 1),\n\t\t\tnew Location(1, -1), new Location(1, 0), new Location(1, 1)\n\t};\n\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;\n\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tint r = row + i;\n\t\t\t\tint c = col + j;\n\t\t\t\tif (r > -1 && r < height && c > -1 && c < width && !(r == row && c == col)) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\n\tpublic Location[] getFreeNeighbour(int row, int col) {\n\t\tArrayList<Location> list = new ArrayList<Location>();\n\t\tfor (Location loc : adjacent) {\n\t\t\tint r = row + loc.getRow();\n\t\t\tint c = col + loc.getCol();\n\t\t\tif (r > -1 && r < height && c > -1 && c < width && field[r][c] == null) {\n\t\t\t\tlist.add(new Location(r, c));\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Location[list.size()]);\n\t}\n\n\tpublic boolean placeRandomAdj(int row, int col, Cell cell) {\n\t\tboolean ret = false;\n\t\tLocation[] freeAdj = getFreeNeighbour(row, col);\n\t\tif (freeAdj.length > 0) {\n\t\t\tint idx = (int) (Math.random() * freeAdj.length);\n\t\t\tfield[freeAdj[idx].getRow()][freeAdj[idx].getCol()] = cell;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Cell remove(int row, int col) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = null;\n\t\treturn ret;\n\t}\n\n\tpublic void remove(Cell cell) {\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tfor (int col = 0; col < width; col++) {\n\t\t\t\tif (field[row][col] == cell) {\n\t\t\t\t\tfield[row][col] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tfor (int j = 0; j < width; j++) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void move(int row, int col, Location loc) {\n\t\tfield[loc.getRow()][loc.getCol()] = field[row][col];\n\t\tremove(row, col);\n\t}\n}\n```\n\n```java Location.java\npackage field;\n\npublic class Location {\n\n\tprivate int row;\n\tprivate int col;\n\n\tpublic Location(int row, int col) {\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t}\n\n\tpublic int getRow() {\n\t\treturn row;\n\t}\n\n\tpublic int getCol() {\n\t\treturn col;\n\t}\n}\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JPanel;\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -2417015700213488315L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\t\tg.setColor(Color.GRAY);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tg.drawLine(0, row * GRID_SIZE, theField.getWidth() * GRID_SIZE, row * GRID_SIZE);\n\t\t}\n\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\tg.drawLine(col * GRID_SIZE, 0, col * GRID_SIZE, theField.getHeight() * GRID_SIZE);\n\t\t}\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tcell.draw(g, col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth() * GRID_SIZE + 1, theField.getHeight() * GRID_SIZE + 1);\n\t}\n}\n```\n\n```java FoxAndRabbit.java\npackage foxnrabbit;\n\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport animal.Animal;\nimport animal.Fox;\nimport animal.Rabbit;\nimport cell.Cell;\nimport field.Field;\nimport field.Location;\nimport field.View;\n\npublic class FoxAndRabbit {\n\n\tprivate Field theField;\n\tprivate View theView;\n\n\tpublic FoxAndRabbit(int size) {\n\t\ttheField = new Field(size, size);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tdouble probability = Math.random();\n\t\t\t\tif (probability < 0.05) {\n\t\t\t\t\ttheField.place(row, col, new Fox());\n\t\t\t\t} else if (probability < 0.15) {\n\t\t\t\t\ttheField.place(row, col, new Rabbit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheView = new View(theField);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(theView);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n\tpublic void start(int steps) {\n\t\tfor (int i = 0; i < steps; i++) {\n\t\t\tstep();\n\t\t\ttheView.repaint();\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void step() {\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tAnimal animal = (Animal) cell;\n\t\t\t\t\tanimal.grow();\n\t\t\t\t\tif (animal.isAlive()) {\n\t\t\t\t\t\tLocation loc = animal.move(theField.getFreeNeighbour(row, col));\n\t\t\t\t\t\tif (loc != null) {\n\t\t\t\t\t\t\ttheField.move(row, col, loc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// eat\n\t\t\t\t\t\t// animal.eat(theField);\n\t\t\t\t\t\tCell[] neighbour = theField.getNeighbour(row, col);\n\t\t\t\t\t\tArrayList<Animal> listRabbit = new ArrayList<Animal>();\n\t\t\t\t\t\tfor (Cell an : neighbour) {\n\t\t\t\t\t\t\tif (an instanceof Rabbit) {\n\t\t\t\t\t\t\t\tlistRabbit.add((Rabbit) an);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!listRabbit.isEmpty()) {\n\t\t\t\t\t\t\tAnimal fed = animal.feed(listRabbit);\n\t\t\t\t\t\t\tif (fed != null) {\n\t\t\t\t\t\t\t\ttheField.remove((Cell) fed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// breed\n\t\t\t\t\t\tAnimal baby = animal.breed();\n\t\t\t\t\t\tif (baby != null) {\n\t\t\t\t\t\t\ttheField.placeRandomAdj(row, col, (Cell) baby);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttheField.remove(row, col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFoxAndRabbit fab = new FoxAndRabbit(50);\n\t\tfab.start(500);\n\t}\n}\n\n```\n\n## 项目结构及分析\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-9.webp width=\"40%\" height=\"40%\"></div>\n\n在英文中Cell有两种意思，格子、细胞  \n在刚刚到细胞自动机中，Cell类表达细胞，或者没有细胞的空格子，这很合理  \n\n狐狸和兔子类有很多相似的属性和动作，所以它们应该有一个父类  \n但这个父类不应该是Cell，Cell在这个程序中应该表达有东西或没东西的格子才合理  \n所以这个父类应该是Animal  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-10.webp width=\"100%\" height=\"100%\"></div>\n\n在细胞自动机中我们通过place(r,c,cell)将Cell放进网格中  \n但现在Fox、Rabbit和Cell没有联系，无法将它们放进网格中  \n如果按照之前的思路，Fox、Rabbit应该也是Cell的子类，但多继承是不被允许的（除了C++）  \n\n如果让Animal从Cell继承，这在语意上是模糊的，动物不应该是一种格子（虽然这样做能实现）  \n\n## 接口\n接口是纯抽象类  \n·所有的成员函数都是抽象函数  \n·所有的成员变量都是public static final  \n\n类表达一个具体的东西，而接口表达一种概念、一种规范  \n接口规定了长什么样，但是不管里面有什么  \n\n我们可以将Cell类改造成接口： \n```java Cell\nimport java.awt.Graphics;\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\nCell现在的作用：所有实现了Cell这个接口的类，都应该有draw这个方法  \n在这个程序中，只要实现了这个方法的类的对象，都可以直接放到Field中  \n\n为什么Cell接口只要求实现draw方法？  \n因为将来View只需要拿Cell去draw，所以只需要要求放到Field里的类的对象实现draw方法  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-11.webp width=\"100%\" height=\"100%\"></div>\n\n现在Fox、Rabbit的对象都可以放进Field里（Field需要一个Cell，而Fox、Rabbit都实现了Cell）  \n\n### implements\n用关键字implements让类实现接口  \n```java\npublic class Fox extends Animal implements Cell{\n    //Fox是一种Animal，它实现了Cell\n}\n```\n在Field的place方法中,place需要一个Cell类的对象  \nCell本身是一个接口，它本身是抽象的，不可能有对象  \n但**所有实现了Cell接口**的对象都可以交给Cell对象的管理者  \n```java\npublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n```\n当Fox实现Cell后，就必须重写Cell中的方法  \n把draw方法实际地做出来  \n```java\n@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n```\n类用extends,接口用implements  \n类可以实现很多接口  \n接口可以继承接口，但不能继承类  \n接口不能实现接口  \n\n### interface\n声明一个接口  \n```java\npublic interface Cell{//接口\n}\npublic class Cell{//类\n}\n```\ninterface是一种特殊的class，它替代掉了class  \n\n### 面向接口的编程方式\n在上面的程序中，Field需要一个能draw的类的对象，然后Field提供了一个Cell接口，所有实现了这个接口的东西都可以交给Field，而它不关心这个东西是什么，只需要符合接口即可  \n\n设计程序时先定义接口，再实现类  \n任何需要在函数间传入传出的一定是接口而不是具体的类  \n是Java成功的关键之一，因为极适合多人同时写一个大程序：每个人只需要用接口去提出要求，其他人根据借口实现具体的类   \n也是Java被批评的要点之一，因为代码量膨胀起来很快，显得程序十分臃肿  \n\n## 增加一个按钮\n\n在狐狸与兔子程序的图形界面中增加一个按钮，按一下执行一步   \n\n在FoxAndRabbit.java中，这么一段代码生成了一个窗口  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\nframe.pack();\nframe.setVisible(true);\n```\n首先要在窗口中增加一个按钮  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\n//有一个类叫JButton，做一个叫btnstep的对象\nJButton btnstep =new JButton(\"单步\");\n//把这个按钮加到窗口中\nframe.add(btnstep);\nframe.pack();\nframe.setVisible(true);\n```\n运行一下\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-12.webp width=\"30%\" height=\"30%\"></div>\n\n整个窗口只剩下了我们加进去的这个按钮,解决这个问题我们需要了解Swing  \n\n***\n\n>下接[JAVA/面向对象学习笔记(3)](/article/8636f786.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"Butterfly魔改","url":"/article/ab2d75d5.html","content":"\n# 最新文章标志\n\n{% link 给首页文章卡片加上最新文章标志,/article/2ed7d622.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/20-1.webp width=\"30%\" height=\"30%\">\n\n# 首页第一个卡片加个class\n\n{% link 首页第一个卡片加个class,/article/dbde845d.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/21-1.webp width=\"40%\" height=\"40%\">\n\n# 加载进度条\n\n{% link 一个加载进度条,/article/13d6481a.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/10-1.webp width=\"40%\" height=\"40%\">\n\n# 控制单页背景样式\n\n{% link 给指定单页加个class以控制其背景样式,/article/eb3a4679.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/22-1.webp width=\"40%\" height=\"40%\">\n\n# 归档、分类、标签页文章卡片加上所属分类和标签\n\n{% link 给归档、分类、标签页文章卡片的标题下方加上所属分类和标签,/article/a19bb7fb.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/23-2.webp width=\"80%\" height=\"80%\">\n\n# 添加音乐页面\n\n{% link 添加音乐页面,/article/3322c8a8.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/24-1.webp width=\"40%\" height=\"40%\">\n\n# 给网站增加悬浮伸缩侧边栏\n\n{% link 给网站增加悬浮伸缩侧边栏,/article/fab5c3df.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/25-1.webp width=\"40%\" height=\"40%\">\n\n# 老旧浏览器弹窗提醒\n\n{% link 老旧浏览器弹窗提醒,/article/e61f6567.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/29-1.webp width=\"50%\" height=\"50%\">\n\n# 使用MiniSandbox前端代码可视化\n\n{% link 使用MiniSandbox前端代码可视化,/article/b827db53.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/30-3.webp width=\"50%\">\n\n# BF添加输入页数跳转\n\n{% link BF添加输入页数跳转,/article/8e0b4c43.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/34-2.webp width=\"50%\" height=\"50%\">\n\n# 给文章添加自定义文本锚点\n\n{% link 给文章添加自定义文本锚点,/article/6f237a88.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/36-2.gif width=\"70%\">\n\n# 页面链接二维码(扫一扫)卡片\n\n{% link 页面链接二维码(扫一扫)卡片,/article/59995f0e.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/37-4.gif width=\"40%\">\n\n# 网站添加点赞、踩功能\n\n{% link 网站添加点赞、踩功能,/article/5de26c08.html,%}\n<img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/39-3.webp width=\"70%\">\n\n# 博客添加待办清单页\n\n{% link 博客添加待办清单页,/article/9875347c.html,%}\n<img src=/images/40-1.webp width=\"60%\">\n\n# 文章添加预设或实时生成的AI简介\n\n{% link 文章添加预设或实时生成的AI简介,/article/17d3383a.html,%}\n\n***\n\n>咕咕咕~~\n\n***","tags":["Hexo","Butterfly"],"categories":["Hexo"]},{"title":"JAVA/面向对象学习笔记(1)","url":"/article/bfb663c6.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n\n# 面向对象\n\n## 什么是面向对象\n面向对象是把**一组数据结构**和**处理他们的方法**组成对象。  \n把具有**相同行为**的对象归纳成**类**  \n通过**封装**隐藏类的内部细节  \n通过**继承**使类得到泛化  \n通过**多态**实现基于对象类型的动态分派 \n\n## 只能操作对象\n一切事物都是调用加封装的结果  \n程序实现的一切功能都是**调用**加**封装**的结果  \n程序调用一个个对象  \n封装的也是一个个对象\n\n## 基于对象编程\n同一个事物，构成它的对象能有多种划分方式  \n机器语言、汇编语言将电路上的开关，由1和0组成的指令作为对象  \n\nc语音将对象界定为一个个**数据**和一个个**算法**  \njava将**数据和算法的结合**作为一个对象    \n\n数据和算法分开的编程：面向过程编程  \n数据和算法结合的编程：面向对象编程  \n\n## 面向过程与面向对象\n面向过程关注如何实现，关注如何做，将一个要实现的、复杂的功能，用一个或多个大函数去实现，再抽丝剥茧，用更多的函数去实现这些函数。  \n面向对象关注数据，方法就在这，处理什么数据（对象）  \n\n面向对象中也有面向过程的代码，只是重点不在如何做，而是对对象的**抽象**与**扩展**  \n对于实现功能的核心算法，面向对象与面向过程并无区别，c语言也可通过结构体与函数指针实现面向对象    \n\n面向对象的**封装**、**继承**和**多态**，使得代码、功能的扩展、复用变得非常容易  \n\n这两种编程思想都是为了解决实际的问题  \n\n{% folding, 如何烧水  %}\n**转自互联网**  \n面向过程的烧水：  \n读取热水壶内水的水温，缓存  \n电热装置将发热量缓存  \n损耗算法读取发热量，并将将水的提升温度缓存  \n与水温相加  \n将这个数值重新赋给水温  \n直到温度达到沸点，完成烧水    \n\n面向对象的烧水：  \n定义热水壶类，继承自盛水容器，温度改变装置，温度计，水温控制接口  \n实例化一个热水壶类对象，命名为「我的热水壶」  \n为终止温度赋值：水.沸点  \n我的热水壶.温度处理(终止温度);  \n\n另：个人实现的烧水方法，仅图一乐：  \n为热水壶类实装烧水接口：实装水温监视事件  \n为热水壶类实装烧水接口：定义一个水温枚举器  \n为热水壶类实装烧水接口：实装温度处理方法  \n执行流程：  \n1.执行继承自盛水容器类的盛水方法  \n2.注册继承自温度改变装置类的温度监视事件  \n3.遍历水温枚举器：如果水温提升，则返回当前水温  \n4.如果返回值接近终止温度，跳出枚举过程，完成烧水。  \n5.否则，继续遍历枚举器。  \n\n你肯定会问这哪里优雅了，确实，看起来是复杂了不少，但再仔细想一想，这一整套流程只要稍加修改，稍加改变接口实现，你就可以直接用这个「热水壶类」实现一个热水器，甚至还可以是一个冰箱。  \n毕竟烧的又不一定是水，又不一定要烧水，又不一定要用壶烧水，又不一样要是个烧水壶  \n{% endfolding %}\n\n***\n\n# 对象与类\n对象是实体，需要被创建，可以为我们做事情    \n类是规范，根据类的定义来创建对象    \n\n一个类可以有多个对象  \n\n动物是一个类，每个对象，猫，狗，都是动物类的实体    \n我们用类制造出对象，再给对象所需要的数据，对象可以利用这些数据去做事情，我们大可无需知道对象是如何利用这些数据的，因为我们只要求，这个对象能实现一些功能  \n\n## 面向对象的思维\n我们看到一个事物  \n它有什么东西？  \n能干什么？  \n\n## 第一个程序：自动售货机\n售货机（VendingMachine）有什么？  \n商品的价格：price  \n显示的余额：balance  \n卖了多少钱：total  \n\n售货机能干什么？  \n输出一些提示：showPromot  \n取得一些钱：insertMomey  \n告诉用户余额：showBalance\n给我们商品（食物）：getFood  \n告诉商家总收入：showTotal\n\n我们需要设计VendingMachine这个类，这个类有3个属性，有5个动作（方法）  \n```java\nimport java.util.Scanner;\n//创建一个类\npublic class VendingMachine {\n    int price = 80;//商品价格(假设就只有一个商品，且价格固定)\n    int balance = 0;//当前余额\n    int total = 0;//总收入\n    int amount = 0;//钱\n    Scanner s=new Scanner(System.in);\n\n    void showPromot() {\n        //输出提示\n        System.out.println(\"欢迎！\");\n    }\n\n    void insertMomey(){\n        // 投入钱，更新余额\n        System.out.print(\"请充值余额：\");\n        amount = s.nextInt();\n        balance = balance + amount;\n    }\n\n    void showBalance(){\n        //输出余额\n        System.out.println(\"现在余额： \"+ balance);\n    }\n\n    void getFood(){\n        //给食物\n        if (balance >= price) {\n            System.out.println(\"给你。\");\n            balance = balance - price;\n            total = total + price;\n        }\n        else{\n            System.out.println(\"没有足够的余额！\");\n        }\n    }\n\n    void showTotal(){\n        System.out.println(\"目前总收入：\"+total);\n    }\n}\n```\n有了这个类，就可以通过类去制造一个对象,并让对象去实现一些功能\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //制作一个对象\n        VendingMachine vm = new VendingMachine();\n        boolean t = true;\n        vm.showPromot();\n        vm.showBalance();\n        while (t) {\n            vm.insertMomey();\n            vm.getFood();\n            vm.showBalance();\n            vm.showTotal();\n        }\n    }\n}\n```\n运行结果：  \n```\n欢迎！\n现在余额： 0\n请充值余额：100\n给你。\n现在余额： 20\n目前总收入：80\n请充值余额：20\n没有足够的余额！\n现在余额： 40\n目前总收入：80\n请充值余额：40\n给你。\n现在余额： 0\n目前总收入：160\n请充值余额：\n```\n\n## 创建对象\n使用new运算符，来创建这个类的一个对象  \n然后将这个对象交给这个类型的一个变量  \nVendingMachine vm = new VendingMachine();  \n\n**对象变量是对象的管理者**  \n\n## 让对象做事情\n使用 . 运算符  \nvm.insertMomey();  \nvm.getFood();  \n通过.运算符调用某个对象的方法  \n\n## 成员变量、成员方法\n类定义了**对象中**所具有的变量，这些变量称作成员变量  \n每个对象有自己的变量，和同一个类的其他对象是分开的  \n在方法中可以直接写成员变量（方法）的名字来访问成员变量（方法）（省去了this关键字）  \n\njava会给成员变量默认0值\n\n成员变量（方法）分为实例变量（方法）和类变量（方法）  \n加了static的就是类变量（方法）  \n\n### 类变量\n声明类变量： **static** <类型> <变量名>  \n\n访问类变量：  \n通过对象访问：<对象名>.<类变量名>  \n通过类访问：<类名>.<类变量名>  \n\n类变量不属于任何一个对象，属于这个类，但任何一个对象都拥有这个变量  \n\n修改类变量的值，所有对象中的该变量的值都会改变  \n\n类变量的初始化只会进行一次（在类的装载时）  \n\n### 类方法\n声明类方法： **static** <返回类型> <方法名>() {  }  \n\nstatic方法只能调用static方法，只能访问static变量   \n\n类方法可以通过类的名字去访问，也可以通过对象去访问  \n\n\n## 本地（局部）变量\n定义在**方法内部**的变量是本地变量  \n本地变量的生存期和作用域都是方法内部  \n\n本地变量没被赋值，会被禁止使用  \n\n成员变量的生存期是对象的生存期，作用域是类内部的成员方法 \n\n### var局部变量\n使用var时必须指出初始值(不可以是null)  \nvar <变量名> = <值>;  \n编译器可以推断出该变量的类型，且之后该变量的类型都是确定的，不可以给该变量赋其它类型的值\n\n## 对象初始化\n可以在定义成员变量的地方直接赋值  \nint price = 80;  \n\n在创建一个对象的过程中，会首先去做各种初始化的动作\n\n### 构造方法\n与类同名的函数，没有返回值  \n在创建一个对象时会自动调用的方法\n应该是public\n```java  \nVendingMachine(){\n    total = 10;\n}\n\nVendingMachine(int price ){\n    this.price = price;\n}\n```\n### 方法重载\n一个类里可以有多个**不同参数**的构造方法  \n创建对象的时候给出不同的参数值，就会自动调用不同的构造方法  \n通过this()还可以在构造方法中调用其他构造方法，写在第一行，且只能使用一次    \n一个类里的同名但参数表不同的方法构成了重载关系  \n\n## 对象的识别\n通过巧妙的思想，识别不同出对象的特点，让类更通用  \n例如，要实现一个时钟  \n可以设计一个类，通过这个类可以制造出时、分、秒三个对象  \n\n## 对象的交互\n时、分、秒三个对象可以共同组成一个时钟对象  \n控制时、分、秒之间的交互在时钟对象的方法中完成  \n```java Display.java\npublic class Display {\n    private int value = 0;\n    private int limit = 0;\n\n    public Display(int limit){\n        this.limit = limit;\n    }\n\n    public void increase(){\n        value++;\n        if(value == limit){\n            value = 0;\n        }\n    }\n\n    public int getValue(){\n        return value;\n    }\n\n}\n```\n\n```java Clock.java\npublic class Clock {\n    Display hour = new Display(24);\n    Display minute = new Display(60);\n    Display second = new Display(60);\n\n    public void start() {\n        while (true) {\n            second.increase();\n            if (second.getValue() == 0) {\n                minute.increase();\n                if (minute.getValue() == 0) {\n                    hour.increase();\n                }\n            }\n            System.out.printf(\"%02d:%02d:%02d\\n\", hour.getValue(), minute.getValue(), second.getValue());\n        }\n    }\n}\n```\n\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Clock clock = new Clock();\n        clock.start();\n    }\n}\n```\n\n***\n\n# 访问属性\n**private**：这个成员是私有的，只有在类的内部（成员方法和定义初始化 ）才能访问  \n一般来说，成员变量都该是private   \n**这个限制是对类的而不是对对象的**：同一个类的不同对象可以互相访问对方的成员变量  \n\n**public**：任何人都可以访问  \n任何人指的是在任何类的方法或定义初始化中可以使用  \n使用指的是调用、访问或定义变量  \n很多的成员方法都是public \npublic的类，类名和文件名要一致，一个编译单元只能有一个public的类  \n\n**protected**：受保护的成员  \n\n**friendly**：默认属性，友好的成员  \n\n| 访问属性  | 本类    | 同包       | 子类      |   其它  |\n| -----    | ------ | --------- | ------   |   ---  |\n| private  |   √    |           |          |        |\n| friendly |     √  |   √       |          |        |\n| protected|   √    |     √     |     √    |        |\n| public   |     √  |     √     |      √   |   √    |\n\n***\n\n# 包package\n包是java管理类的一个机制  \n源文件中同名类要在**不同**包内  \n\n声明该类的指定包名  \npackage <包名>;  \n\n包名中的.代表文件夹的层次  \n\n没有package语句的源程序都将视为在同一个无名包内  \n\n## import\n使用import语句引入包中的类和接口  \n\nimport test.Hallo  \ntest包中的Hallo类  \n\n只要用到的类和本类不在同一个包内，就要import它  \n\n如果不使用import，当要用到类时要给出全名：<包名>.<类名>  \n\n引入一个包内的所有东西：import <包名>.*;（注意同名类的冲突） \n\n***\n# NoteBook例子\n记事本可以做什么？  \n1、能存储记录  \n2、不限制能存储的记录的数量  \n3、能知道已经存储的记录的数量  \n4、能查看存进去的每一条记录  \n5、能删除一条记录  \n6、能列出所有的记录  \n\n确定需求后，进行接口设计  \n```java 接口设计\npublic class NoteBook {\n\n    public void add(String s) {\n        //添加内容\n    }\n\n    public int getSize() {\n        //放了多少个\n        return 0;\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return \" \";\n    }\n\n    public boolean removeNote(int index) {\n        //删除\n        return true;\n    }\n\n    public String[] list() {\n        //返回全部内容\n    }\n\n}\n\n```\n接口设计完，考虑实际功能的实现，首先是数据的存放  \n\n## 顺序容器\n```java\nprivate ArrayList<String> notes = new ArrayList<String>();  \n```\n用来存放String的一个ArrayList  \nArrayList内的东西是有顺序的，是加入数据的顺序，形成对应下标的索引（从0开始）  \n\n这种类型叫做范型类：泛型类封装不特定于特定数据类型的操作  \n这种范型类是一种容器  \n\n容器类有两个类型：容器的类型、元素的类型  \n\n利用容器类的方法可以实现需要的功能  \nnotes.add(s);  //向容器添加数据\nnotes.size();  //容器存了多少个东西\nnotes.get(1); //得到1位置处的数据\n\n完成全部功能接口\n```java NoteBook.java\nimport java.util.ArrayList;\n\npublic class NoteBook {\n    private ArrayList<String> notes = new ArrayList<String>();//容器类\n\n    public void add(String s) {\n        //添加内容\n        notes.add(s);\n    }\n\n    public void add(String s, int location) {\n        //加到指定位置前，后面的内容下标后推\n        notes.add(location, s);\n    }\n\n    public int getSize() {\n        //放了多少个\n        return notes.size();\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return notes.get(index);\n    }\n\n    public void removeNote(int index) {\n        //删除，后面下标前移，因为remove方法自会抛异常，所以无需返回boolean\n        notes.remove(index);\n    }\n\n    public String[] list() {\n        //返回全部内容\n        String[] a = new String[notes.size()];\n\n        //for (int i=0; i< notes.size(); i++){\n        //    a[i] = notes.get(i);\n        //}\n        notes.toArray(a);//会自己把数组按顺序填好\n        //要熟悉系统类库里有的方法，无需重复造轮子\n        return a;\n    }\n\n}\n```\n写出上层程序\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        NoteBook nb = new NoteBook();\n\n        nb.add(\"first\");\n        nb.add(\"second\");\n        System.out.println(nb.getSize());\n        System.out.println(nb.getNote(1));\n\n        nb.add(\"third\", 1);\n        System.out.println(nb.getNote(1));\n        System.out.println(nb.getNote(2));\n        System.out.println(nb.getSize());\n\n        nb.removeNote(1);\n        String[] b = nb.list();\n        for (String s : b) {\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n输出：\n```\n2\nsecond\nthird\nsecond\n3\nfirst\nsecond\n```\n\n## 对象数组\n```java\nString[] a = new String[notes.size()];  \n```\n对象数组中的每个元素都是对象的管理者而非对象本身  \n当创建了一个对象数组，只是管理者们被创建了，但对象还没有，得想办法把每个对象创建出来  \n\n### for-each循环\n对于普通数组：  \n```java\nint[] a = new int[10];\nfor (int i = 0; i < a.length; i++) {\n    a[i] = i;//赋值\n}\nfor ( int k : a ) {\n    System.out.println(k);\n    k++;//每个k都是a中元素的复制品，不会起作用\n}\n```\n对于对象数组：  \n```java\nValue[] a = new Value[10]; \nfor (int i=0; i< 10; i++){\n    a[i] = new Value[];\n    a[i].set(i);\n}\nfor ( Value v : a ){\n    System.out.println(v.get());\n    v.set(0);//起作用，因为对象数组存的是对象管理者，v=a[i]，v也会成为对象管理者\n}\n```\n\n\n## 集合容器\n集合容器内所有元素都不相同  \n而且里面的元素不排序  \n```java\nHashSet<String> s = new HashSet<String>();\ns.add(\"first\");\ns.add(\"second\");\ns.add(\"first\");\nSystem.out.println(s);//容器都可以这样输出\n```\n输出：\n```java\n[second, first]\n```\n\n## public String toString\n在java中只要类中实现了这样一个方法  \n就可以直接用对象名输出这个对象  \n容器当中都有这样一个方法 \n```java\npublic String toString(){  \n    return \"\";  \n}  \n```\n\n## Hash表\n例子：数字与美元硬币名字对应，查找硬币名称  \n1=penny  \n5=nickel  \n10=dime  \n25=quarter  \n50=half-dollar\n\n定义接口：\n```java\npublic class Coin {\n    public String getName(int amount){\n            return  \"\";\n    }\n}\n```\n为什么不用switch-case？  \n体现在代码中的硬编码越少越好  \n\n使用Hash表（一种数据结构）  \n在这个表中，所有东西是以一对值放入的，一个叫做key（键），一个叫做值  \n一个key对应一个值，可以用key取值  \nHash表中的元素没有顺序  \n```java Coin.java\nimport java.util.HashMap;\n\npublic class Coin {\n    //不能使用int，容器当中所有的类型都得是对象,而不能是基本类型\n    //Integer是int的包裹类型\n    private HashMap<Integer, String> coinnames = new HashMap<Integer, String>();\n\n    public Coin(){\n        coinnames.put(1, \"penny\");//1对应penny\n        coinnames.put(10, \"dime\");\n        coinnames.put(25, \"quarter\");\n        coinnames.put(50, \"half-dolar\");\n        \n        System.out.println(coinnames.keySet().size());//keySet()，把所有key做为一个HashSet的集合给你，在这个集合可以得到size\n        System.out.println(coinnames);//也可以直接输出\n        coinnames.put(50, \"五十\");//会替换掉前面的\n        System.out.println(coinnames);\n        for (Integer k : coinnames.keySet()){//遍历Hash表\n            String s = coinnames.get(k);\n            System.out.println(s);\n        }\n    }\n\n    public String getName(int amount){\n        if (coinnames.containsKey(amount))\n            return coinnames.get(amount);\n        else\n            return  \"NOT FOUND\";//不判断的话，不存在会返回null\n    }\n\n\n}\n```\n```java Main.java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int amount = in.nextInt();\n        Coin coin = new Coin();\n        String name = coin.getName(amount);\n        System.out.println(name);\n    }\n}\n```\n输出：\n```java\n10\n4\n{1=penny, 50=half-dolar, 25=quarter, 10=dime}\n{1=penny, 50=五十, 25=quarter, 10=dime}\npenny\n五十\nquarter\ndime\ndime\n```\n\n***\n\n# 继承与子类\n\n## 媒体资料库设计\n和NoteBook一样，需要设计一个类,用类去表达一种媒体（CD,DVD）  \n然后用一个媒体类的容器去装媒体对象，一个资料库就完成了  \n\nCD有什么？  \n名称：title  \n艺术家：artist  \n多少首歌：numofTracks  \n持续时间：playingTime  \n是否被借出：gotIt  \n描述：comment  \n\n能做什么？\n输出一些信息：print\n\n```java CD.java\npublic class CD{\n    private String title;\n    private String artist;\n    private int numofTracks;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        System.out.print(title+\":\");\n        System.out.println(artist);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.list();\n    }\n}\n```\n现在资料库中已经可以存各种CD媒体了  \n但我们还想在资料库中存DVD媒体或者其它媒体类型  \n\n当然，我们可以再创建一个类表示DVD\n```java DVD.java\npublic class DVD{\n    private String title;\n    private String director;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        this.director = director;\n        this.title = title;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        System.out.print(title+\":\");\n        System.out.println(director);\n    }\n}\n```\n设计好类后在Database.java里创建一个放DVD的容器,以及配套的方法    \n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n    //+\n    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n    //+\n    public void add(DVD dvd){\n        listCD.add(dvd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n        //+\n        for(DVD dvd : listDVD){\n            dvd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        //+\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n现在资料库中能存放两种媒体  \n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \n我们创建了一个资料库类  \n资料库类里有两个容器，用来存放两种不同类型的媒体的对象管理者  \n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-1.webp width=\"70%\" height=\"70%\"></div>\n\n这样的结构虽然能实现我们需要的功能，但DVD和CD类几乎一模一样   \n出现了很多代码复制，这是代码质量不良的表现  \n当我们需要修改print，add等方法，就得逐个去改  \n当我们需要新增一种媒体，就得为它做很多的工作  \n\n## 继承\nCD和DVD类很相似，我们可以从中提取一些它们共有的东西封装成一个类Item  \nItem可以表达CD或者DVD  \n而Database只需管Item  \n\n```java Item.java\npublic class Item {\n    private String title;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public Item(String title, int playingTime, boolean gotIt, String comment) {\n        this.title = title;\n        this.playingTime = playingTime;\n        this.gotIt = gotIt;\n        this.comment = comment;\n    }\n\n    public Item(){\n\n    }\n\n    public void print() {\n        System.out.print(title+\":\");\n    }\n\n}\n```\n```java CD.java\npublic class CD extends Item{\n//    private String title;\n    private String artist;\n    private int numofTracks;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n//        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        super.print();\n        System.out.println(artist);\n    }\n}\n```\n```java DVD.java\npublic class DVD extends Item{\n//    private String title;\n    private String director;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n        this.director = director;\n//        this.title = title;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        super.print();\n        System.out.println(director);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n//    private ArrayList<CD> listCD = new ArrayList<CD>();\n//    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n    private ArrayList<Item> listItem = new ArrayList<Item>();\n\n//    public void add(CD cd){\n//        listCD.add(cd);\n//    }\n//\n//    public void add(DVD dvd){\n//        listCD.add(dvd);\n//    }\n    public void add(Item item){\n        listItem.add(item);\n    }\n\n    public void list(){\n//        for (CD cd : listCD){\n//            cd.print();\n//        }\n//        for(DVD dvd : listDVD){\n//            dvd.print();\n//        }\n        for (Item item : listItem){\n            item.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \nCD extends Item：CD扩展了Item  \n即CD变成了Item的子类  \n这就是**继承**  \nCD得到了Item里所有的东西  \n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-2.webp width=\"70%\" height=\"70%\"></div>\n\n## 子类与父类\n当父类里的东西是private时  \nprivate String title;  \n子类得到了这个东西，但不能用（可以通过父类的方法去用）  \n解决办法：将private改成protect  \n但这样不好，有很多时候父类和子类不在同一个包内  \n\ntitle本来就是父类的东西  \n可以让title在父类中初始化完，再让子类得到title  \n```java\npublic Item(String title) {\n    this.title = title;\n}\n```\n在子类构造器中使用super()来得到父类的title  \n```java\n public CD(String title) {\n    super(title);\n}\n```\n\n### super()\n当程序初始化对象时，会先运行super()  \n然后去运行父类的构造器，再回来继续运行自己的构造器  \n\nsuper():去父类调用一个没有参数的构造器  \nsuper(<参数>):去父类调用一个有对应参数的构造器  \n\n当子类没有super(),会默认去调用父类没有参数的构造器  \n\n通过super关键字来实现对父类成员的访问，用来引用当前对象的父类  \nsuper.<父类成员>  \n\n通过this来区分子类父类中的同名成员  \nthis.aaa();   // this 调用自己的方法  \nsuper.aaa();  // super 调用父类方法  \n\n## 子类和子类型\n类定义了类型  \n子类定义了子类型  \n\n子类的对象可以被当作父类的对象来使用  \n-赋值给父类的变量（父类的对象管理者可以管理子类的对象）  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-3.webp width=\"70%\" height=\"70%\"></div>\n\n-传递给需要父类对象的方法  \n\n\n-放进存放父类对象的容器里  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-4.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-5.webp width=\"35%\" height=\"35%\"></div>\n\n***\n\n# 多态\n## 多态变量\n所有的**对象变量**都是**多态**的（它们能保存不止一种类型的对象，不同时刻可以放不同类型的对象（例如父类的对象变量放子类的对象））  \n它们可以保存的是声明类型的对象，或声明类型的子类的对象  \n\n当把**子类的对象**赋给**父类的变量**的时候，就发生了**向上造型**  \n\n每一个java的对象变量，都具有两个类型  \n一个是**声明类型**  \n一个是**动态类型**  \n有时候两者是一致的，有时候又不一样  \n\n这就是变量的多态（在运行过程中，它所管理的对象类型是会变化的）  \n\n## 造型\n造型：把一个类型的**对象**，赋给另一个类型的**变量**\n\n对象变量的赋值并不是把一个对象赋给另一个对象（注在c++中可以做两个对象之间的赋值）  \n而是让这两个对象的管理者去**管理同一个对象**  \n```java\nString s = \"hello\";\n//原本这个String类型的对象变量s管理着一个对象\n//这个对象里面有个\"hello\"\ns = \"bye\";\n//后来s去管理另一个对象，里面有\"bye\"\n```\n并不是将bye替换掉hello，java不能做这种事  \n\njava中”=“的赋值运算，实际上是在改变指向  \n```java\nString s = \"hello\";\nString t = \"bye\";\ns = t;\n//原本s和t各管理一个对象，现在s和t管理同一个对象，里面有”hello“\n```\n当给一个**对象变量**管理着与它声明（静态）类型**不符**的对象时，就发生了**造型**  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\n//把子类的对象赋给父类的变量，让父类的对象变量去管理子类的对象\n```\n父类对象是不能直接赋给子类对象变量的\n但可以强制把父类对象当成子类的对象，然后去造型  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\nCD cc = item;//不行。父类对象不能直接交给子类对象变量去管理\nCD cc = (CD)item;//行，因为item已经管理着一个CD的对象了\n//强制把item的类型当做CD\n```\n如果没有Item item = cd;\n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\n//Item item = cd;\nCD cc = (CD)item;//编译可以通过，但运行会出错\n```\n将一个变量强制造型成另一个类型，然后赋给另一个变量  \nCD cc = (CD)item;  \n只有当item这个变量**实际管理**着CD类型的对象才不会出错  \n\n在C语言中，有类似写法，但是是类型转换（对于基本类型int、double，java也能强制类型转换）  \nint i = (int)10.2;//强制类型转换\n这与造型是不同的  \n类型转换是将10.2变成了10  \n但造型只是把item当做CD类型来看待  \nitem本身还是Item类型  \n\n(类型名)对象名：将一个对象当做这个类型来看待  \n\n### 向上造型\n向上造型是特殊的造型，无需写(父类类型)  \n拿一个子类的对象，当作父类的对象来用  \n向上造型总是安全的  \n\n## 方法调用的绑定\n```java\npublic void list(){\n    for (Item item : listItem){\n        item.print();\n    }\n}\n```\nitem每次循环管理的对象不一样，甚至管理的对象的类型也不一样，可以是CD或是DVD  \n当item管理CD(DVD)类型的对象时，去调用print方法，调用的是CD(DVD)类型里的print  \n\n\n当通过对象变量调用方法的时候，调用哪个方法这件事情叫做绑定  \n-静态绑定：根据变量的声明类型来决定  \n-动态绑定：根据变量的动态类型来决定  \n在成员函数中调用其他成员函数也是通过this这个对象变量来调用的  \n\njava默认所有的绑定都是动态绑定  \n\n### 覆盖\n子类和父类中存在**名称和参数表**完全相同的函数，这一对函数构成**覆盖**关系  \n通过父类的变量调用存在覆盖关系的函数时，调用变量当时所**管理的对象**所属的类的函数  \n这是一种动态绑定  \n\n## 多态总结\n多态性是对象多种表现形式的体现  \n\n通过一个变量去调用一个函数，我们不去判断变量运行中实际类型是什么，我们只想它能print  \n多态是**同一个行为**具有多个**不同表现形式或形态**的能力  \nitem是CD类型时它这样print，是DVD类型时那样print，但都是print行为  \n\n***\n\n# 类型系统\n\n## Object类\njava中所有类都是Object类型的子类  \n这是一种单根结构  \n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-6.webp width=\"70%\" height=\"70%\"></div>\n\n发生继承时，父类所有public的东西子类都会得到  \n所以java中所有的类，都从Object类中得到了两个函数  \n-toString()  \n-equals()  \n\n## toString()\ntoString()会返回一个字符串，用来表达对象  \n\n当一个类中没有toString()方法时，会调用继承自Object类的toString()  \n```java\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd.toString());\nSystem.out.println(cd);//和上面的效果一个月，编译器会知道这个地方需要调用toString()\n\nString s = \"aa\"+cd;//编译器知道这个地方需要调用toString()\nSystem.out.println(s);\n```\n```java 输出\nCD@3d075dc0\n//类型名+一个类似地址、编号的东西\nCD@3d075dc0\naaCD@3d075dc0\n```\n显然，默认的表达这个对象的toString(),是返回一个类型名+一个类似地址、编号的东西  \n\n我们可以在类中自定义一个toString()  \n即设计一个表达对象的toString()  \n```java\n@Override\npublic String toString() {\n    return \"CD{\" +\n            \"artist='\" + artist + '\\'' +\n            \", numofTracks=\" + numofTracks +\n            '}';\n    }\n```\n```java 输出\nCD{artist='aaa', numofTracks=4}\n```\n\n## equals()\n\n==**无法**比较两个对象的内容是否相同，只能比较这两个对象变量是否管理着同一个对象    \n我们需要使用equals()去比较内容  \n\n当类中没有equals()，会调用继承自Object类的equals()  \n```java\nCD cd1 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nCD cd2 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd1.equals(cd2));\n```\n```java 输出\nfalse\n```\nObject这个公共父类的equals()无法知道它的子类长什么样子，所以也无法比较这两个对象内容是否相等  \nObject的equals()实际上也是在比较两个对象变量是否管理着同一个对象\n\n我们需要使用自定义的equals()去比较内容  \n```java\n@Override\npublic boolean equals(Object o) {\n    CD cc = (CD) o;//将Object o看作是CD类型的\n    return numofTracks == cc.numofTracks && artist.equals(cc.artist);\n}\n```\n```java 输出\ntrue\n```\n\n## @Override\n作用：告诉编译器，这个函数覆盖了父类的同属性、同名、同参方法  \n也可能会在代码界面报错，如果这个函数没有和父类的同名方法有相同属性、参数\n\n不带@Override，如果自定义的equals()和父类的同属性、同名、同参  \n那么也会覆盖掉父类的，@Override只是起帮助检查作用  \n\n***\n\n# 可扩展性\n现在要往Database这个资料库里增加新的媒体类型，是一件非常容易的事情    \n```java VideoGame.java\npublic class VideoGame extends Item {\n    private int numberofPlayers;\n\n    public VideoGame(String title, int playingTime, boolean gotIt, String comment, int numberofPlayers) {\n        super(title, playingTime, gotIt, comment);\n        this.numberofPlayers = numberofPlayers;\n    }\n\n    public void print() {\n        System.out.print(\"VideoGame:\");\n        super.print();\n        System.out.println(numberofPlayers);\n    }\n}\n```\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/7-7.webp width=\"70%\" height=\"70%\"></div>\n\n只需要增加一个子类，然后构造一下，覆盖下方法，父类完全不需要去动  \n这种特性叫**可扩展性**：代码无需修改即可扩展去适应新的数据、新的内容  \n\n如果需要修改去适应新的数据、新的内容，则叫**可维护性**  \n\n***\n\n>下接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"C语言单链表菜品管理系统","url":"/article/a696e8fe.html","content":"\n# 简介\n我的大一上学期期末项目，也是C语言的期末大作业。  \n\n使用单链表进行菜品信息的存储，系统有菜品的增删改查、排序、安全输入、统计、随机输出和文件输入输出等功能。 \n\n现在回去看代码想给自己一锤子（误）\n\n***\n\n# 包含文件\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-8.webp width=\"70%\" height=\"70%\"></div>\n\n***\n\n# 函数说明\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-9.webp width=\"70%\" height=\"70%\"></div>\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-10.webp width=\"70%\" height=\"70%\"></div>\n\n***\n# 代码\n```c 900行有点长\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\n#define SIZE1 100 //名称，价格等字数\n#define SIZE2 200 //限制评价字数\n\ntypedef struct _node\n{\t\t\t\t\t\t\t//链表的节点结构体\n\tchar name[SIZE1];\t\t//菜品名称\n\tchar restaurant[SIZE1]; //饭店名字\n\tfloat price;\t\t\t//菜的价格\n\tint fraction;\t\t\t//菜的评分\n\tchar comment[SIZE2];\t//菜品评价\n\tstruct _node *next;\n} Node;\ntypedef struct _list //方便对链表操作\n{\n\tNode *head;\n\tNode *pa;\n\tNode *pb;\n\tNode *pc;\n} List;\n//菜单\nvoid menu(void);\t\t\t   //一级菜单\nvoid menu_inquire(List *list); //二级菜单_查询菜单\nvoid help(void);\t\t\t   //二级菜单_帮助菜单\nint menu_sort(List *list);\t   //三级菜单_排序方法\n//对节点操作\nvoid add(List *list);\t  //添加节点\nvoid delete (List *list); //删除节点\nvoid revise(List *list);  //修改节点\n//安全输入\nchar *s_gets(char *st, int n); //安全输入字符\nint get_int(void);\t\t\t   //安全输入int型\nfloat get_float(void);\t\t   //安全输入float型\n//链表的输出和操作\nvoid inquire_all(List *list);\t\t\t//输出链表全部节点\nvoid inquire_one(List *list);\t\t\t//输出链表指定菜名节点\nvoid inquire_restaurant(List *list);\t//输出链表指定饭店节点\nvoid inquire_part_price(List *list);\t//输出一定价格以下的菜品(这功能。。贫穷)\nvoid inquire_part_fraction(List *list); //输出一定评分以上的菜品\nvoid average_percentage(List *list);\t//查询某饭店或食堂的平均价格和评分\nvoid output(Node *p);\t\t\t\t\t//方便输出\nvoid random_menu(List *list);\t\t\t//随机输出一道菜\nvoid empty(List *list);\t\t\t\t\t//清空链表\n//文件操作\nvoid save(List *list);\t   //保存\nvoid read_txt(List *list); //读取文件_初始链表\n//单链表的排序\nvoid sort_ascending(List *list);\t\t //菜品按价格从低到高排序\nvoid sort_descending(List *list);\t\t //菜品按价格从高到低排序\nvoid sort_score(List *list);\t\t\t //菜品按评分从高到低排序\nint calculate(List *list);\t\t\t\t //计算出单链表的节点个数\nvoid swap1(List *list, List *list_swap); //单链表冒泡排序的算法块1\nvoid swap2(List *list, List *list_swap); //单链表冒泡排序的算法块2\n//其他\nint random_number(List *list); //随机生成不大于节点数的整数\nvoid color(int a);\t\t\t   //控制台文本颜色\n//______________________________________________________\n//------------------------------------------------------\nint main() //主函数\n{\n\t//system(\"chcp 65001\");//GB2313\n\t//system(\"chcp 936\");//UTF8\n\t//system(\"cls\");\n\tmenu(); //输出功能菜单\n\t//佛祖开光无bug\n\treturn 0;\n}\n//菜单\nvoid menu() //一级菜单\n{\n\tint options, z = 1;\n\tList list;\n\tlist.head = NULL;\t\t\t\t   //head指向空，链表不存在\n\tFILE *fp = fopen(\"Menu.txt\", \"a\"); //若无Menu.txt文件，则创建一个\n\tfclose(fp);\n\tread_txt(&list); //读入txt中的数据，初始化链表\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(14);\n\t\tprintf(\"|                    菜品信息系统             \\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"|********************系统功能菜单*********************\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|1、使用帮助|                       \\n\");\n\t\tprintf(\"|*******************|2、添加菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|3、删除菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|4、查询菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|5、修改菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|6、今天吃什么|                     \\n\");\n\t\tprintf(\"|*******************|7、清空所有数据|                     \\n\");\n\t\tprintf(\"|*******************|8、保存|\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|0、退出系统|                       \\n\");\n\t\tcolor(12);\n\t\tprintf(\"|!!!前请先保存再退出系统,否则数据会丢失!!!\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0; //跳出循环\n\t\t\tprintf(\"即将退出系统。\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd(&list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdelete (&list);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmenu_inquire(&list);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevise(&list);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trandom_menu(&list);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tempty(&list);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsave(&list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n\tsystem(\"pause\");\n}\nvoid help() //二级菜单_帮助菜单\n{\n\tsystem(\"cls\");\n\tprintf(\"\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tcolor(15);\n\tprintf(\"|使用帮助：\\n\");\n\tprintf(\"|1、本菜品信息系统可供用户自行修改内容\\n\");\n\tprintf(\"|2、因为考虑到不同饭店有同样名称的菜品，本系统允许菜品名称有重复\\n\");\n\tprintf(\"|3、请勿输入错误信息，以免造成程序出错\\n\");\n\tprintf(\"|4、关闭系统前记得保存！否则数据会丢失\\n\");\n\tprintf(\"|5、有bug联系1934009145@qq.com\\n\");\n\tprintf(\"|6、github地址:github.com/qxchuckle/Dishes-Management-System\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tprintf(\"\\n\");\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid menu_inquire(List *list) //二级菜单_查询菜单\n{\n\tint options, z = 1;\n\tList *p = list;\t\t\t//方便传结构体指针\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！无法查询！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn; //为空结束函数\n\t}\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、查询全部菜品信息\\n\");\n\t\tprintf(\"|2、按菜名查询菜品信息\\n\");\n\t\tprintf(\"|3、查询饭店或食堂的全部菜品信息\\n\");\n\t\tprintf(\"|4、查询某价格以下的全部菜品\\n\");\n\t\tprintf(\"|5、查询某评分以上的全部菜品\\n\");\n\t\tprintf(\"|6、查询某饭店或食堂的平均价格、评分和价格区间占比\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_all(p);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tinquire_one(p);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_restaurant(p);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_price(p);\n\t\t\treturn;\n\t\tcase 5:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_fraction(p);\n\t\t\treturn;\n\t\tcase 6:\n\t\t\taverage_percentage(p);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n}\nint menu_sort(List *list) //三级菜单_排序方法\n{\n\tint options, z = 1, n = 1;\n\tList *p = list;\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、按价格从低到高排序\\n\");\n\t\tprintf(\"|2、按价格从高到低排序\\n\");\n\t\tprintf(\"|3、按评分从高到低排序\\n\");\n\t\tprintf(\"|4、不排序\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\treturn z;\n\t\tcase 1:\n\t\t\tsort_ascending(p);\n\t\t\treturn n;\n\t\tcase 2:\n\t\t\tsort_descending(p);\n\t\t\treturn n;\n\t\tcase 3:\n\t\t\tsort_score(p);\n\t\t\treturn n;\n\t\tcase 4:\n\t\t\treturn n;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n}\n//对节点操作\nvoid add(List *list) //添加节点\n{\n\tfloat k = 1;\n\tint n = 0, i = 0;\n\tNode *last = list->head;\n\tNode *p1 = (Node *)malloc(sizeof(Node)), *p; //给节点分配空间\n\tp1->next = NULL;\n\tsystem(\"cls\");\n\tputs(\"开始录入菜品：\\n----------------\\n\");\n\tputs(\"请输入菜品名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->name, SIZE1);\n\t} while (strlen(p1->name) == 0);\n\tputs(\"请输入菜品所属饭店or食堂名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->restaurant, SIZE1);\n\t} while (strlen(p1->restaurant) == 0);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(p1->name, p->name) || strcmp(p1->restaurant, p->restaurant)))\n\t\t{\n\t\t\tcolor(12);\n\t\t\tprintf(\"该饭店/食堂内已存在同名菜品！\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"请输入菜品的价格：\");\n\tp1->price = get_float();\n\tputs(\"请输入0-10的整数对菜品进行评分：\");\n\tdo\n\t{\n\t\tn = get_int();\n\t\tif (n >= 0 && n <= 10) //判断评分是否是0-10\n\t\t{\n\t\t\tp1->fraction = n;\n\t\t\ti = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor(12);\n\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (!i);\n\tputs(\"请对菜品进行评价：\");\n\tdo\n\t{\n\t\ts_gets(p1->comment, SIZE2);\n\t} while (strlen(p1->comment) == 0);\n\tif (last) //如果last有值，则说明head已指向链表第一个节点\n\t{\n\t\twhile (last->next)\n\t\t{\n\t\t\tlast = last->next; //last始终指向最后一个节点\n\t\t}\n\t\tlast->next = p1; //在最后一个节点后面再加一个节点\n\t}\n\telse\n\t{\n\t\tlist->head = p1; //如果last为NULL，则要将head指向第一个节点\n\t}\n\tcolor(11);\n\tputs(\"录入成功！\");\n\tsystem(\"pause\");\n}\nvoid delete (List *list) //删除节点\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL)\n\t{ //判断链表是否为空\n\t\tprintf(\"还未存入任何菜品！删除失败！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入你要删除的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //遍历链表\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要修改的节点\n\t\t{\n\t\t\tn++;   //记录找到了\n\t\t\tif (q) //判断找到的是不是第一个节点\n\t\t\t{\n\t\t\t\tq->next = p->next; //让该节点的前一个节点都next指向后一个节点\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist->head = p->next; //让head的next指向后一个节点\n\t\t\t}\n\t\t}\n\t}\n\tif (!n)\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n删除成功%d道菜。\\n\", n);\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid revise(List *list) //修改节点\n{\n\tfloat k = 1;\n\tint n = 0, m = 0, i = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tprintf(\"还未存入任何菜品！无法修改！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入要修改的菜品的名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要删除的节点\n\t\t{\n\t\t\tn++; //记录找到\n\t\t\tprintf(\"\\n原来的菜品信息:\\n\");\n\t\t\tprintf(\"|菜名:%s\\n\", p->name);\n\t\t\tprintf(\"|所属:%s\\n\", p->restaurant);\n\t\t\tprintf(\"|价格:%.2f\\n\", p->price);\n\t\t\tprintf(\"|评分:%d\\n\", p->fraction);\n\t\t\tprintf(\"|评价:%s\\n\", p->comment);\n\t\t\tprintf(\"\\n\");\n\t\t\tputs(\"请修改菜品的价格：\");\n\t\t\tp->price = get_float();\n\t\t\tputs(\"请输入0-10的整数以修改菜品的评分：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm = get_int();\n\t\t\t\tif (m >= 0 && m <= 10)\n\t\t\t\t{\n\t\t\t\t\tp->fraction = m;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor(12);\n\t\t\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\t\t\tcolor(15);\n\t\t\t\t}\n\t\t\t} while (!i);\n\t\t\tputs(\"请修改对菜品的评价：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts_gets(p->comment, SIZE2);\n\t\t\t} while (strlen(p->comment) == 0);\n\t\t}\n\t}\n\tif (n)\n\t{\n\t\tprintf(\"\\n修改完成。\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\n//安全输入\nchar *s_gets(char *m, int n) //安全输入字符\n{\n\tchar *p;\n\tchar *find;\n\tp = fgets(m, n, stdin);\n\tif (p)\n\t{\n\t\tfind = strchr(m, '\\n'); //查找换行符\n\t\tif (find)\t\t\t\t//如果地址不是NULL\n\t\t\t*find = '\\0';\t\t//在此处放一个空字符\n\t\telse\n\t\t\twhile (getchar() != '\\n')\n\t\t\t\tcontinue;\n\t}\n\treturn p;\n}\nint get_int() //安全输入int型\n{\n\tint n;\n\tchar ch;\n\twhile (scanf(\"%d%*c\", &n) != 1)\n\t{\n\t\twhile ((ch = getchar()) != '\\n')\n\t\t\tputchar(ch);\n\t\tcolor(4);\n\t\tprintf(\" 不是一个正整数！\\n请您重新输入：\\n\");\n\t\tcolor(15);\n\t}\n\treturn n;\n}\nfloat get_float() //安全输入float型\n{\n\tfloat n = 1;\n\tchar ch;\n\tdo\n\t{\n\t\tif (n <= 0)\n\t\t{ //用户输入不是正数输出提示\n\t\t\tcolor(12);\n\t\t\tputs(\"请重新输入一个正数！\");\n\t\t\tcolor(15);\n\t\t}\n\t\twhile (scanf(\"%f%*c\", &n) != 1)\n\t\t{\n\t\t\twhile ((ch = getchar()) != '\\n')\n\t\t\t\tputchar(ch);\n\t\t\tcolor(12);\n\t\t\tprintf(\" 不是一个正数！\\n请您重新输入：\\n\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (n <= 0);\n\treturn n;\n}\n//链表的输出和操作\nvoid inquire_all(List *list) //输出链表全部节点\n{\n\tNode *p;\n\tint n = 1;\n\tsystem(\"cls\");\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tprintf(\"\\n第%d道菜:\", n);\n\t\toutput(p);\n\t\tn++;\n\t}\n\tcolor(11);\n\tprintf(\"\\n所有菜品查询完毕\\n\");\n\tsystem(\"pause\");\n}\nvoid inquire_one(List *list) //输出指定菜名\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->name)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_restaurant(List *list) //输出指定饭店所有菜品\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_price(List *list) //输出一定价格以下的菜品(这功能。。贫穷)\n{\n\tint n = 0;\n\tfloat money, k = 1;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入封顶价格：\");\n\tmoney = get_float();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->price <= money) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_fraction(List *list) //输出一定评分以上的菜品\n{\n\tint n = 0;\n\tint score;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入最低评分：\");\n\tscore = get_int();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->fraction >= score) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid average_percentage(List *list) //查询某饭店或食堂的平均价格和评分\n{\n\tint n = 0;\n\tfloat sum1 = 0, sum2 = 0, b[5] = {0};\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要查的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\tsum1 += p->price;\t //累加价格\n\t\t\tsum2 += p->fraction; //累加评分\n\t\t\tif (p->price <= 5)\n\t\t\t{\n\t\t\t\tb[0]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (p->price <= 10)\n\t\t\t\t{\n\t\t\t\t\tb[1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p->price <= 15)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[2]++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p->price < 20)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[3]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[4]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++; //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tif (n)\n\t{\n\t\tprintf(\"该饭店/食堂的一共有%d道菜\\n平均价格是：%.2f\\t平均评分是：%.2f\\n\", n, sum1 / n, sum2 / n);\n\t\tprintf(\"其中：\\n0~5元占:%.1f%%\\n5~10元占:%.1f%%\\n10~15元占:%.1f%%\\n\", b[0] / n * 100, b[1] / n * 100, b[2] / n * 100);\n\t\tprintf(\"15~20元占:%.1f%%\\n20元以上占:%.1f%%\\n\\n\", b[3] / n * 100, b[4] / n * 100);\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"无该饭店或食堂！\\n\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid output(Node *p) //方便输出\n{\n\tprintf(\"\\n|菜名:%s\\n\", p->name);\n\tprintf(\"|所属:%s\\n\", p->restaurant);\n\tprintf(\"|价格:%.2f\\n\", p->price);\n\tprintf(\"|评分:%d\\n\", p->fraction);\n\tprintf(\"|评价:%s\\n\", p->comment);\n}\nvoid random_menu(List *list) //随机输出一道菜\n{\n\tsystem(\"cls\");\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tList *q = list;\n\tNode *p = list->head;\n\tint n = random_number(q), i = 1; //将随机出来的数赋予n，并初始i等于第一道菜，判断数字是否相等，即可找到那个随机出来的菜\n\twhile (p != NULL)\n\t{\n\n\t\tif (i == n) //借助随机数来随机输出菜\n\t\t{\n\t\t\toutput(p);\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tp = p->next;\n\t}\n}\nvoid empty(List *list) //清空链表\n{\n\tNode *p, *q;\n\tint n;\n\tsystem(\"cls\");\n\tcolor(12);\n\tprintf(\"此操作将清空所有数据！\\n输入 1 继续，输入 0 取消：\\n\");\n\tdo\n\t{\n\t\tn = get_int();\n\t} while (!(n == 0 || n == 1));\n\tif (n == 1)\n\t{\n\t\tfor (p = list->head; p; p = q) //遍历链表\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t}\n\t\tlist->head = NULL;\n\t\tprintf(\"清除完成！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n}\n//文件操作\nvoid save(List *list) //保存\n{\n\tif (list->head == NULL)\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！保存为空！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tNode *p = list->head;\n\tFILE *fp = fopen(\"Menu.txt\", \"w\");\n\tif (fp)\n\t{\n\t\twhile (p)\n\t\t{\n\t\t\tfprintf(fp, \"\\n%s %s %0.2f %d %s\", p->name, p->restaurant, p->price, p->fraction, p->comment);\n\t\t\tp = p->next;\n\t\t}\n\t\tfclose(fp);\n\t\tcolor(11);\n\t\tprintf(\"\\n保存成功\\n\");\n\t\tsystem(\"pause\");\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"保存失败，请自查或联系作者\");\n\t}\n}\nvoid read_txt(List *list) //读取文件_初始链表\n{\n\tint i = 1;\n\tNode *last;\n\tNode *p1;\n\tint a = 1;\n\tchar f[5];\n\tFILE *fp = fopen(\"Menu.txt\", \"r\");\n\tfgets(f, 10, fp); //读取第一行，并进入下一行，防止bug\n\twhile (!feof(fp)) //当读取到文件结束符跳出循环结束读取\n\t{\n\t\tlast = list->head;\n\t\tp1 = (Node *)malloc(sizeof(Node));\n\t\tp1->next = NULL;\n\t\tfscanf(fp, \"%s%s%f%d%s\", p1->name, p1->restaurant, &p1->price, &p1->fraction, p1->comment);\n\t\tif (last)\n\t\t{\n\t\t\twhile (last->next)\n\t\t\t{\n\t\t\t\tlast = last->next;\n\t\t\t}\n\t\t\tlast->next = p1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlist->head = p1;\n\t\t}\n\t}\n\tfclose(fp);\n}\n//单链表的冒泡排序，这指来指去，作者一口气写完到断气的，不想加注释了，应该会有更好的算法，咕咕咕，以后优化\nvoid sort_ascending(List *list) //菜品按价格从低到高排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price > list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_descending(List *list) //菜品按价格从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price < list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_score(List *list) //菜品按评分从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->fraction < list_swap.pc->fraction)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nint calculate(List *list) //计算出单链表的节点个数\n{\n\tint n = 0;\n\tNode *p = list->head;\n\twhile (p->next != NULL)\n\t{\n\t\tn++;\n\t\tp = p->next;\n\t}\n\treturn n + 1;\n}\nvoid swap1(List *list, List *list_swap) //单链表冒泡排序的算法块1\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pb->next = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\telse\n\t{\n\t\tlist->head = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\tlist_swap->pb = list_swap->pc;\n\tlist_swap->pc = list_swap->pa->next;\n}\nvoid swap2(List *list, List *list_swap) //单链表冒泡排序的算法块2\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list_swap->pb->next;\n\t}\n\telse\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list->head;\n\t}\n}\n//其他\nint random_number(List *list) //随机生成不大于节点数的整数\n{\n\tint n = 0, m = 0, sum = 1, i = 0;\n\tList *q = list;\n\tsrand((unsigned)time(NULL) * 12);\n\tm = calculate(q);\n\ti = m;\n\twhile (m > 0)\n\t{\n\t\tsum = sum * 10;\n\t\tm = m / 10;\n\t}\n\twhile (1)\n\t{\n\t\tn = rand() % sum;\n\t\tif (n <= i && n > 0)\n\t\t{\n\t\t\ti = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid color(int a) //控制台文本颜色\n{\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), a); //更改控制台文字颜色\n}\n\n```\n***\n\n# 部分功能截图\n**主菜单**\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-1.webp width=\"50%\" height=\"50%\"></div>\n\n**查找功能**\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-2.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-5.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-6.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-7.webp width=\"50%\" height=\"50%\"></div>\n\n**排序**\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-3.webp width=\"50%\" height=\"50%\"></div>\n\n**修改功能**\n<div><img src=https://cdn.jsdelivr.net/gh/qxchuckle/qxchuckle.github.io/images/6-4.webp width=\"45%\" height=\"45%\"></div>\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["项目"]},{"title":"C语言学习笔记","url":"/article/13675369.html","content":"\n# 整数运算\n两个整数运算结果也只能是整数  \na+=5等价于a=a+5  \na*=b+5等价于a=a*(b+5)  \na++等a+=1等a=a+1  \na++是a加1以前的值，++a是a加1后的值  \n运算符优先级：算数>关系>赋值，判断是否相等的优先级比大于小于低\n***\n# 所表达的数的范围\nchar< short<int< float<double\n***\n# sizeof()\nsizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数  \nsizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的\n***\n# unsigned\nunsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)  \nunsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位\n***\n# 整数的输入输出\n只有两种形式:int或 long long  \n%d: int  \n%u: unsigned  \n%ld: longlong  \n%lu: unsigned long long\n***\n# 选搔整数类型\n为什么整数要有那么多种?为了准确表达内存,做底层程序的需要  \n没有特殊需要,就选int  \n现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢  \n现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)\n***\nunsigned与否只是输出的不同,内部计算是一样的  \nprintf输出inf表示超过范围的浮点数:±∞  \nprint输出nan表示不存在的浮点数  \n带小数点的字面量是 double而非 float  \nfloat需要用或F后綴来表明身份  \n1.234f\n***\n判断两个浮点数是否相等可能失败  \nfabs(fl-2)< le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等\n***\n# 选浮点类型\n如果没有特殊需要,只使用 double  \n现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢\n***\n# 自动类型转换\n当运算符的两边出现不一致的类型时,会自动转换成較大的类型  \n大的意思是能表达的数的范围更大  \nchar——> short——>int——>long——>long long  \nint——> float——> double  \n对于 printf,任何小于int的类型会被转换成int，float会被转换成 double  \n但是scanf不会,要输入short,需要%hd\n***\n# 强制类型转换\n要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值  \n比如：  \n(int)10.2  \n(short)32  \n注意这时候的安全性,小的变量不总能表达大的量  \n(short)32768  \n只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变  \n强制类型转换的优先级高于四则运算\n***\n# 逻辑运算符优先级:\n!>&&>||\n***\n# 短路\n逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算  \na==6&&b==1  \na==6&&b+=1  \n对于&&,左边是 false时就不做右边了  \n对于‖,左边是true时就不做右边了  \n***\n# tip1\n不要把赋值,包括复合赋值组合进表达式!  \n一个代码内有重复相似段是程序质量不良的表现  \n函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值\n***\n# 数组的大小\nsizeof给出整个数组所占据的内容的大小,单位是字节  \nsizeof(a)/sizeof(a[0])  \nsizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数  \n这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗\n***\n# 数组的操作\n遍历数组：通常都是使用for循环,让循环变量i从0到<数组的长度,这样循环体内最大的正好是数组最大的有效下标  \n数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!  \n数组作为函数参数时,往往必再用另一个参数来传入数组的大小\n# 作为参数的指针\nvoid f(int * p)  \n在被调用的时候得到了某个变量的地址  \nint i=O; f(&i)  \n在函数里面可以通过这个指针访问外面的这个  \n函数参数表中的数组实际上是指针  \nsizeof(a)==sizeof(int *)  \n但是可以用数组的运算符进行运算\n***\n# 指针是const\n表示一旦得到了某个变量的地址,不能再指向其他变量  \nint *const q=&i;//q是 const  \n*q=26;//OK  \nq++; //ERROR\n***\n# 所指是 const\n表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)  \nconst int *p=&i  \n*p= 26; //ERROR!  \ni=26;//OK  \nP=&i;//OK\n***\n# const\nlnt i  \nconst int* p1 =&i  \nint const* p2=&i  \nint *const p3=&i  \n判断哪个被const了的标志是const在*的前面还是后面  \n*const p指针不许动  \nconst *p指针不许动变量\n***\n## 转换\n总是可以把一个非 const的值转換成 const的  \nvoid f(const int* x)  \nint a =15:  \nf(&a);//ok  \nconst int b = a  \nf(&b);//ok  \nb =a+1: // Error  \n当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改\n***\n## const数组\nconst int a[]={1,2,3,4,5,6};  \n数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值\n***\n## 保护数组值\n因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值  \n为了保护数组不被函数破坏,可以设置参数为 const  \nint sum(const int a[], int length);\n***\n# 指针\nint *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元  \nint *p=a[];  \n*p -->a[0]  \n*(p+1)-->a[1]  \n*(p++)可以遍历数组\n***\n给一个指针加|表示要让指针指向下一个变量  \nint a[l0]  \nint *p= a  \n*(p+1)-->a[1]  \n如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义  \n*(p+n)<-->a[n]  \n*p*q两个指针相减p-q，等于q加多少个单元等于p\n***\n*p++  \n取出p所指的那个数据来,完事之后顺便把移到下一个位置去  \n*的优先级然高,但是没有++高  \n常用于数组类的连续空间操作  \n在某些CPU上,这可以直接被翻译成一条汇编指令\n\n指针乘除无意义\n***\n## 指针遍历数组方法 \n```\n*p a[10]\np=a\nfor(i=0;i<sizeof(a)/sizeof(a[0]); i++ ){\nprintf(\"%d\\n\", acri[i]);\n}  \na[9]=-1//在数组末尾放入一个特殊的东西\nwhile(*p!=-1){\nprintf(\"%d\\n\",*p++);\n}\n```\n***\n## 指针比較\n<,<=,==,>,>=,!=都可以对指针做  \n比较它们在内存中的地址  \n数组中的单元的地址肯定是线性从小到大递增的\n***\n## 0地址\n当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址  \n所以你的指针不应该具有0值  \n\n因此可以用0地址来表示特殊的事情:  \n1返回的指针是无效的  \n2指针没有被真正初始化(先初始化为0)  \n\nNULL（必须是大写）是一个预定定义的符号,表示0地址  \n有的编译器不愿意你用0来表示0地址\n***\n## 指针的类型\n无论指向什么类型,所有的指针的大小都是一样的,因为都是地址  \n但是指向不同类型的指针是不能直接互相赋值的  \n这是为了避免用错指针\n## 指针的类型转换\nvoid*表示不知道指向什么东西的指针  \n计算时与char*相同(但不相通)\n\n指针也可以转换类型  \nint*p =&i  \nvoid*p<-->(void *)p  \n这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量  \n我不再当你是int,我认为你就是个void!\n***\n## 用指针来做什么\n需要传入較大的数据时用作参数  \n传入数组后对数组做操作  \n函数返回不止一个结果是  \n需要用函数来修改不止一个变量  \n动态申请的内存\n***\n# 内存操作\n## malloc(跟系统要一块内存)\n```\n#include <stdlib. h>\nvoid*malloc(size_t size)\n//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型\n(int *)malloc(n*sizeof(int))\n```\n如果申请失敗则返回0,或者叫做NULL\n***\n## free()\n把申请得来的空间还给“系统”  \n申请过的空间,最终都应该要还  \n只能还申请来的空间的首地址\n## free常见问题\n申请了没free—>长时间运行内存逐漸下降  \n新手:忘了  \n老手:找不到合的free的时机  \nfree过了再free  \n地址变过了,直接去free\n***\n# 字符串\nchar a[]={'h','a','l','l','o','!'}//字符数组  \nchar a[]={'h','a','l','l','o','!','\\0'}//字符串\n***\n以0(整数0)结尾的一串字符  \n0或'\\0'是一样的,但是和0不同  \n0标志字符串的结束,但它不是字符串的一部分  \n计算字符串长度的时候不包含这个0  \n字符串以数组的形式存在,以数组或指针的形式访问  \n更多的是以指针的形式  \nstring.h里有很多处理字符串的函数\n***\n```\nchar*str=\"Hello\"\nchar word[]=\"Hello\"\nchar linel[10]=\"Hello\"\n```\n***\n## 字符串常量\nChar* s=\"Hello, world\"  \n●s是一个指针,初始化为指向一个字符串常量 \n●由于这个常量所在的地方,所以实际上s是 const  \nchar*s,但是由于历史的原因,编译器接受不带const的写法  \n●但是试图对s所指的字符串做写入会导致严重的后果\n***\nchar S[]=\"Hello, world\"//这个字符串就在我这里  \nChar* s=\"Hello, world\"//指向某个地方的字符串  \n数组:这个字符串在这里(作为本地变量,空间自动被回收)  \n指针:这个字符串不知道在哪里(处理参数,动态分配空间)  \n如果要构造一个字符串一>数组  \n如果要处理一个字符串一>指针\n***\n## 字符串输入输出\n```\nchar string[8];\nscanf(\"%s\", string);\nprintf(\"%s\", string);\n//scanf读入一个単词(到空格、tab或回车为止)\n//scanf是不安全的,因为不知道要该入的内容的长度\nscanf(\"%7s\", string)\n//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小\n```\n***\n## 空字符串\n```\nchar buffer[100]=\"\";\n//这是一个空的字符串, buffer[O]==\"\\0\";\nchar buffer[]=\"\";\n//这个数组的长度只有1\n```\n***\n## 复制一个字符串\n```\nchar*dst=(char*)malloc(strlen(src)+1)\nstrcpy(dst, src)\n```\n***\n# 枚挙\n枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明  \nenum枚挙类型名字{名字0,……,名字n};  \n\n枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：  \nenum colors {red, yellow, green};  \n就创建了三个常量,red的值是0, yellow是1,而 green是2。  \n当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。\n>声明枚挙量的时候可以指定值\n>enum COLOR {RED=1, YELLOW, GREEN =5};\n\n***\n\n# 结构\n## 声明结构的形式\n```\nstruct point{\nint X;\nInt y;\n};\nstruct point p1, p2\n//pl和p2都是 point里面有x和y的值\n\nstruct {\nInt x;\nint y;\n}pl, p2;\n//pl和p2都是一种无名结构,里面有x和y\n\nstruct point {\nInt x;\nint y;\n}pl, p2;\n//pI和p2都是point, 里面有x和y的值t\n```\n>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用  \n>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了\n\n***\n## 结构指针\n和数组不同,结构变量的名字并不是结构变量的地址,必须使用&运算符\n```\nstruct date*pdate= &today;\n```\n***\n## 结构作为函数参数\n```\nint numberofdays(struct date d)\n```\n整个结构可以作为参数的值传入函数  \n这时候是在函数内新建一个结构变量,并复制调用者的结构的值  \n也可以返回一个结构  \n这与数组完全不同\n***\n## 指向结构的指针\n```\nstruct date {\nint month;\nint day;\nint yeari;\n}myday;\nstruct date *p =&myday;\n(*p).month 12;\np->zmonth 12;\n//用->表示指针所指的结构变量中的成员\n```\n***\n# 全局变量初始化\n没有做初始化的全局变量会得到0值  \n指针会得到NULL值  \n只能用编译时刻已知的值来初始化全局变量  \n它们的初始化发生在main函数之前  \n全局变量不应该和另一个全局变量有联系  \n同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量\n***\n# 静态本地变量（全局生存期，本地作用域）\n在本地变量定义时加上 static修饰符就成为静态本地变量  \n当函数离开的时候,静态本地变量会銖存在并保持其值  \n静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值  \n静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域  \n静态本地变量具有全局的生存期,函数内的局部作用域  \nstatic在这里的意思是局部作用域(本地可访问)\n>不要使用全局变量来在函数间传递参数和结果  \n>尽量避免使用全局变量  \n>丰田汽车的案子  \n>使用全局变量和静态本地变量的函数是线程不安全的  \n\n***\n# 返回指针的函数\n返回本地变量的地址是危险的  \n返回全局变量或静态本地变量的地址是安全的  \n返回在函数内 malloc的内存是安全的,但是容易造成问题  \n最好的做法是返回传入的指针\n***\n# 编译预处理指令\n#开头的是编译预处理指令  \n它们不是C语言的成分,但是C语言程序离不开它们\n***\n## #define(纯文本替换)\n#define用来定义一个宏  \n#define<名字><值>  \n注意没有结尾的分号,因为不是C的语句  \n名字必颁是一个单词,值可以是各种东西  \n在C语言的编译器开始编译之前,编译预处理程序  \n(cpp)会把程序中的名字换成值  \n完全的文本替换  \nacc-save-temps\n***\n## 宏\n如果一个宏的值中有其他的宏的名字,也是会被替换的  \n如果一个宏的值超过一行,最后一行之前的行末需要加  \\   \n宏的值后面出现的注释不会被当作宏的值的一部分\n***\n### 预定义的宏\n```\n_LINE_\n_FILE_\n_DATE_\n_TIME_\n_STDC_\n```\n### 带参数的宏\n```\n#define cube(x) ((x)*(x)*(x))\n```\n在大型程序的代吗中使用非常普遍  \n可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下  \n存在中西方文化差异  \n部分宏会被inline函数替代\n***\n# 变量的声明\nint i;是变量的定义  \nextern int i;是变量的声明\n***\n# 声明和定义\n声明是不产生代码的东西  \n函数原型  \n变量声明  \n结构声明  \n宏声明  \n枚挙声明  \n类型声明  \ninline函数  \n定义是产生代码的东西  \n头文件放声明是规则\n***\n# 重复声明\n同一个编译单元里,同名的结构不能被重复声明  \n如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要\"标准头文件结构\"\n***\n# 标准头文件结构(宏的if)\n```\n#ifndef _LIST_HEAD_\n#define _LIST_HEAD_\n#include \"node.h\"\ntypedef struct _list{\n    Node* head\n    Node* tail\n}List\n#endif\n//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次\n#pragma once//也能起到相同的作用,但是不是所有的编译器都支持\n```\n\n# 链表\n>0建一个node结构  \n>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）  \n>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点  \n>3要有一个node结构last，每次要让last从head开始，直到last->next是空的，然后让next等于新的p结构（这样就链起来了）  \n>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last->next是空的，然后然后让next等于新的p结构  \n\n**要在函数内改变指针的指向，就要传指针的指针进去**\n***\n## 遍历链表\n```\nfor(p=list.head; p; p=p->next){}\n//单用一个指针p可以遍历链表\n```\n\n但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点  \n当p找到了要删除的节点，就让q->next等于p->next，然后free(p)  \nfor(q=null，p=list.head; p; q=p，p=p->next){}  \n当然还要判断链表的第一个元素是不是我们要删除的  \n如果是，就不能让q->next等于p->next，因为q一开始是NULL  \n我们应该让head->next等于p->next，然后free(p)  \n>\".\"一般情况下读作\"的”。  \n>\"->\"一般读作\"指向的结构体的\"。  \n\n***\n## 清除整个链表\n```\nfor(p=head;p;p=q){\n     q=p->next;\n     free(p)\n}\n//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点\n```\n\n***\n# main()\nmain(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)  \n操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数  \n在不同操作系统，入口函数可能不是main()\n***","tags":["C语言"],"categories":["学习笔记"]}]